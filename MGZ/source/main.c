#include <assert.h>
#include <dirent.h>
#include <fcntl.h>
#include <malloc.h>
#include <math.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <getopt.h>

#include <sys/file.h>
#include <sys/memory.h>
#include <sys/thread.h>
#include <sys/process.h>
#include <sys/systime.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <lv2/sysfs.h>
#include <lv2/process.h>
#include <ppu-lv2.h>
#include <ppu-types.h>
#include <io/pad.h>
#include <tiny3d.h>
#include <ft2build.h>
#include <freetype/freetype.h> 
#include <freetype/ftglyph.h>
#include <pngdec/pngdec.h>
#include <jpgdec/jpgdec.h>
#include <sysmodule/sysmodule.h>
#include <sysutil/osk.h>
#include <sysutil/msg.h>
#include <sysutil/sysutil.h>
#include <sysutil/game.h>
#include <arpa/inet.h>

#include <zip.h>

#include <net/net.h>
#include <http/http.h>
#include <http/https.h>
#include <ssl/ssl.h>

#include "types.h"
#include "config.h"
#include "aes.h"
#include "util.h"
#include "keys.h"
#include "sce.h"
#include "np.h"
#include "self.h"
#include "rvk.h"
#include "frontend.h"

#include <MagickWand/MagickWand.h>

#include <webp/decode.h>
#include <tiffio.h>

#include "ntfs.h"
#include "ff.h"
#include "fflib.h"
#include "exFAT.h"
#include "mgz_io.h"

#include "tga_reader.h"
#include "dds_reader.h"
#include "makepng.h"

#include "cobra.h"
#include "ps3mapi.h"

#include "syscall8.h"
#include "fw.h"
#include "fw_unk.h"
#include "ps2vers.h"
#include "pad.h"
#include "zlib.h"
#include "ttf_render.h"
#include "libfont2.h"
#include "iso.h"
#include "osk_input.h"

#include "gtf.h"
#include "gim.h"
#include "gim2png.h"
#include "vag2wav.h"
#include "jsx.h"
#include "cxml.h"

#include "unrar.h"
#include "7zExtractor.h"
#include "minitar.h"

#include "md5.h"
#include "sha1.h"
#include "ird_iso.h"
#include "trpex.h"
#include "ciso.h"

#include "RCO/rco.h"

#include "ps2gen.h"

#include "xreg.h"

#include "bd/bd.h"
#include "erk/dumper.h"

#include "paged_file.h"

#include "npdata_make.h"

#include "dynarec.h"

// might be used later in write_htab instead of sc10
#include "erk/hvcall.h" 

#define NO_UID		-1
#define SYSTEM_UID	0
#define NO_GID		-1

#define OK 			1
#define NOK 		0
#define YES			1
#define NO 			0
#define TRUE 		1
#define FALSE 		0
#define SUCCESS 	1
#define FAILED	 	0
#define ON			1
#define OFF			0
#define FOUND		1
#define NOT_FOUND	0
#define VERTICAL	0
#define HORIZONTAL	1
#define STATIC		0
#define DYNAMIC		1
#define SCROLL		0
#define PAGE		1
#define FULL		0
#define SPLIT		1

#define NET_ERROR	2

#define CONTINUE	0
#define BREAK		1

#define REACTPSN	0
#define SNAKE		0 // cobra else mamba
#define IRIS		1
#define MM			2
#define NO_PAYLOAD	3

#define _NOT_EXIST		0
#define	_EXIST			1
#define _FILE			1
#define _DIRECTORY		2

#define UNK				0
#define JB_PS3			1
#define JB_PS2			2
#define	JB_PS1			3
#define	JB_PSP			4				
#define	ISO_PS3			5
#define	ISO_PS2			6
#define	ISO_PS1			7
#define	ISO_PSP			8
#define BDVD			9
#define ISO_BD_VIDEO	10
#define ISO_DVD_VIDEO	11

#define _SDIR			".mgz_sdir"	 // simple directory
#define _SFILE			".mgz_sfile" // simple file (without extension)
#define _JB_PS3			".mgz_jbps3"
#define _JB_PS2			".mgz_jbps2"
#define	_JB_PS1			".mgz_jbps1"
#define	_JB_PSP			".mgz_jbps2"
#define	_ISO			".mgz_iso"
#define	_ISO_PS3		".mgz_isops3"
#define	_ISO_PS2		".mgz_isops2"
#define	_ISO_PS1		".mgz_isops1"
#define	_ISO_PSP		".mgz_isopsp"
#define _ISO_BD_VIDEO	".mgz_bd_video"
#define _ISO_DVD_VIDEO	".mgz_dvd_video"
#define _BDVD			".mgz_bdvd"

#define	_EBOOT_BIN		"eboot.bin"
#define	_EBOOT_ELF		"eboot.elf"
#define	_XREG			"xRegistry.sys"

#define IRD_SERVER "http://ps3ird.free.fr"
#define IRD_SCRIPT IRD_SERVER "/script.php"

// #define IRD_WEB				"https://irdinfostorage.azurewebsites.net"
// #define IRD_WEB_API			IRD_WEB 	"/api/irdinfo/"
// #define IRD_WEB_API_TRUST	IRD_WEB_API "incrementTrustLevel"
// #define IRD_WEB_API_NEW		IRD_WEB_API "saveird"

#define IRD_WEB				IRD_SERVER "/script.php?json"
#define IRD_WEB_API			IRD_WEB
#define IRD_WEB_API_TRUST	IRD_WEB_API
#define IRD_WEB_API_NEW		IRD_WEB_API
 

char *TXTViewerSupport[] = {".txt", ".xml", ".js", ".md5", ".sha1", ".log", ".ini", ".nfo", ".json"};

char *PictureViewerSupport[] = {
								".jpg", ".jpeg", ".jpe", ".jif", ".jfif", ".jfi",
								".png",
								".gif",
								".dds", ".gtf", ".gim",
								".bmp", ".dib",
								".webp",
								".tif", ".tiff",
								"tga",
								".raw", ".arw", ".cr2", ".nrw", ".k25",
								//".jp2", "jpc", ".j2k", ".jpf", ".jpx", ".jpm", ".mj2",
								//".svg", ".svgz",
								".psd",
								//".pspimage", ".psp"
								//".ico", ".cur",
								//".lbm", ".eps",
								//".ttf",
								//".pam",
								".rgba", ".rgb",
								".pcx", ".pgm", ".pbm", ".pnm", ".dcm", ".icon", ".ppm", ".xpm"
};

#define ArrayCount(x) (sizeof(x)/sizeof(x[0]))

#define NONE		0
#define BDMIRROR	1
#define BDEMU		2

#define BLACK		0x000000FF
#define WHITE		0xFFFFFFFF
#define ORANGE 		0xFFA000FF
#define BLUE		0x0070FFFF
#define DARKBLUE	0x0040A0FF
#define GREEN		0x00A000FF
#define RED			0xFF0000FF
#define PURPLE		0x7D00FFFF
#define YELLOW		0xFFFF00FF
#define GREY		0x808080FF
#define PINK		0xFF00FFFF

#define COLOR_ISO	RED
#define COLOR_PS3	0x00A0FFFF
#define COLOR_PS2	0x0303C0FF
#define COLOR_PS1	BLACK
#define COLOR_PSP	0x909090FF

#define MD5_HASH	0
#define SHA1_HASH	1

#define LIST		0
#define GRID		1
#define XMB			2
#define	FLOW		3

#define MGZ 0
#define P3T 1
#define THM 2

#define X_MAX		848.0f
#define Y_MAX		512.0f

#define FS_S_IFMT 0170000
#define FS_S_IFDIR 0040000

#define MAX_SECTIONS	((0x10000-sizeof(rawseciso_args))/8)

#define SCENE_FILEMANAGER			0
#define SCENE_PS3_MENU				1
#define SCENE_PS2_MENU				2
#define SCENE_PS1_MENU				3
#define SCENE_PSP_MENU				4
#define SCENE_PS2_CONFIG_EDITOR		5
#define SCENE_SETTINGS				6
#define SCENE_MAIN					7

#define PI 3.14159265f
#define DEG(x) PI/180*x

#define INPUT_SIZE		16
#define INPUT_X			10
#define INPUT_Y			491-INPUT_SIZE/2

#define GAMEPIC_COVER_UNK		16
#define GAMEPIC_ICON0_DEFAULT	8
#define GAMEPIC_COVER3D			4
#define GAMEPIC_COVER2D			2
#define GAMEPIC_ICON0			1
#define GAMEPIC_NONE			0

// GAMEOS ID

#define FLASH_NAND			0x100000000000001ULL
#define FLAS_NAND_EXT		0x100000500000001ULL
#define FLASH_NOR			0x100000000000004ULL
#define FLASH_NOR_EXT		0x100000200000004ULL

#define ATA_HDD					0x101000000000007ULL
#define BDVD_DRIVE				0x101000000000006ULL
#define PATA0_HDD_DRIVE			0x101000000000008ULL
#define PATA0_BDVD_DRIVE		BDVD_DRIVE
#define PATA1_HDD_DRIVE			ATA_HDD
#define PATA1_BDVD_DRIVE		0x101000000000009ULL
#define CARDCTRL				0x101000000000010ULL  // ?
#define BUILTIN_FLASH			0x100000000000001ULL
#define MEMORY_STICK			0x103000000000010ULL
#define SD_CARD					0x103000100000010ULL
#define COMPACT_FLASH			0x103000200000010ULL

#define USB_MASS_STORAGE_1(n)	(0x10300000000000AULL+(n)) // For 0-5 
#define USB_MASS_STORAGE_2(n)	(0x10300000000001FULL+((n)-6)) // For 6-127
#define USB_MASS_STORAGE(n)		(((n) < 6) ? USB_MASS_STORAGE_1(n) : USB_MASS_STORAGE_2(n))

#define	HDD_PARTITION(n)	(ATA_HDD | ((uint64_t)n<<32))
#define FLASH_PARTITION(n)	(BUILTIN_FLASH | ((uint64_t)n<<32))

#define DEVICE_TYPE_PS3_DVD	0xFF70
#define DEVICE_TYPE_PS3_BD	0xFF71
#define DEVICE_TYPE_PS2_CD	0xFF60
#define DEVICE_TYPE_PS2_DVD	0xFF61
#define DEVICE_TYPE_PSX_CD	0xFF50
#define DEVICE_TYPE_BDROM	0x40
#define DEVICE_TYPE_BDMR_SR	0x41 /* Sequential record */
#define DEVICE_TYPE_BDMR_RR 0x42 /* Random record */
#define DEVICE_TYPE_BDMRE	0x43
#define DEVICE_TYPE_DVD		0x10 /* DVD-ROM, DVD+-R, DVD+-RW etc, they are differenced by booktype field in some scsi command */
#define DEVICE_TYPE_CD		0x08 /* CD-ROM, CD-DA, CD-R, CD-RW, etc, they are differenced somehow with scsi commands */
#define DEVICE_TYPE_USB		0x00

u8 scene=SCENE_MAIN;
typedef struct
{
	uint64_t device;
	uint32_t emu_mode;
	uint32_t num_sections;
	uint32_t num_tracks;
} __attribute__((packed)) rawseciso_args;

SYS_PROCESS_PARAM(1200, 0x100000);

//************ SCETOOL ****************

#define ARG_NULL no_argument
#define ARG_NONE no_argument
#define ARG_REQ required_argument
#define ARG_OPT optional_argument

BOOL _verbose = FALSE;
BOOL _raw = FALSE;
static BOOL _decrypt_file = FALSE;
static BOOL _encrypt_file = FALSE;
char *_template = NULL;
char *_file_type = NULL;
char *_compress_data = NULL;
char *_skip_sections = NULL;
char *_key_rev = NULL;
char *_meta_info = NULL;
char *_keyset = NULL;
char *_auth_id = NULL;
char *_vendor_id = NULL;
char *_self_type = NULL;
char *_app_version = NULL;
char *_fw_version = NULL;
char *_add_shdrs = NULL;
char *_ctrl_flags = NULL;
char *_cap_flags = NULL;
char *_license_type = NULL;
char *_app_type = NULL;
char *_content_id = NULL;
char *_klicensee = NULL;
char *_real_fname = NULL;
char *_add_sig = NULL;

//************ FIRMWARE	***************

u8 eid_root_key[EID_ROOT_KEY_SIZE];

u64 TOC;
int firmware = 0;
u64 SYSCALL_TABLE;
u64 HV_START_OFFSET;
u64 HTAB_OFFSET;
u64 HTAB_PATCH1;
u64 HTAB_PATCH2;
u64 HTAB_PATCH3;
u64 MMAP_OFFSET1;
u64 MMAP_OFFSET2;
u64 SPE_OFFSET;
u64 OFFSET_FIX;
u64 OFFSET_2_FIX;
u64 OFFSET_FIX_3C;
u64 OFFSET_FIX_2B17;
u64 OFFSET_FIX_LIC;
u64 OPEN_HOOK;
u64 BASE_ADDR;
u64 UMOUNT_SYSCALL_OFFSET;
u64 LV2MOUNTADDR;
u64 LV2MOUNTADDR_ESIZE;
u64 LV2MOUNTADDR_CSIZE;
u64 NEW_POKE_SYSCALL_ADDR;
u64 PAYLOAD_SKY;
size_t PAYLOAD_SKY_SIZE;
u64 UMOUNT;
size_t UMOUNT_SIZE;
u64 MAMBA;
size_t MAMBA_SIZE;
u64 *MAMBA_LOADER;
size_t MAMBA_LOADER_SIZE;
u64 *ERK_DUMPER;
size_t ERK_DUMPER_SIZE;
u64 OFFSET_1_IDPS;
u64 OFFSET_2_IDPS;
u64 UFS_SB_ADDR=0;

//*********** IRIS ****************

#define PAYLOAD_OFFSET						0x3d90
#define PERMS_OFFSET						0x8000000000003560ULL
#define PAYLOAD_UMOUNT_OFFSET				(0x3d90+0x400)
#define PATCH_JUMP(add_orig, add_dest)		lv2poke32(add_orig, 0x48000000 | ((add_dest-(add_orig-0x8000000000000000ULL)) & 0x3fffffc))
#define PATCH_CALL(add_orig, add_dest)		lv2poke32(add_orig, 0x48000000 | ((add_dest-(add_orig-0x8000000000000000ULL)) & 0x3fffffc) | 1)

static char temp_buffer[8192];
//static u64 restore_syscall8[2] = {0,0};
static char *table_compare[19];
static char *table_replace[19];
static int ntable = 0;

//*********** MultiMAN ***************
typedef struct
{
	char src[384];
	char dst[384];
} redir_files_struct;
static redir_files_struct file_to_map[8];
static u8 max_mapped=0;

//****** Thread Loading *************

static s8 loading = NO;
static char loading_log[20][255];
static char head_title[128];
int64_t prog_bar1_value=-1;
int64_t prog_bar2_value=-1;
u8 cancel = NO;
uint8_t ERR = FALSE;
uint8_t WAR = FALSE;
static u32 LoadIconRot=0;

//******* Notification **********

static u32 time_not = 0;
static char not_msg[255];

//****** Devices **************

static char list_device[32][32]={{0}};
static int8_t device_number=-1;

//****** Thread LoadGAMEPIC **************

//static int64_t Load_GAMEPIC_progbar = -1;
static u8 Load_GAMEPIC_flag=NO;
static u8 Load_GAMEPIC_busy=NO;
static u8 Load_GAMEPIC_init=NO;

//****** Thread LoadTMP ******************
static u8 Load_CURPIC_flag=NO;

//********** Backup LIST *****************


#define MAX_GAME 		512*64

static s64 game_number=-1;
static char **list_game_path=NULL;
static char **list_game_title=NULL;
static char **list_game_ID=NULL;
static u8 *list_game_platform=NULL;
static u8 *list_game_havepic=NULL;

//********** Backup FAV ******************

#define MAX_FAV 		32

static char list_FAV_game_path[MAX_FAV][128] = {{0}};
static char list_FAV_game_title[MAX_FAV][128]= {{0}};
static int8_t FAV_game_number = -1;

//*************** Current Informations *************

static char GamPath[512]={0};
static char GamID[20]={0};
static u8 Game_stuff = YES;
static u8 PEEKnPOKE;
static u8 cobra = NO;
static u8 iso = NO;
static u8 HEN = NO;
static u8 mamba = NO;
static u8 usb = NO;
static int position=0;
char ManaGunZ_id[10];

static int position_CURPIC=-1;

//********** Scan DIR ****************

#define MAX_SCANDIR 	10
static char scan_dir[MAX_SCANDIR][128];
static int8_t scan_dir_number=0;

//********** THEME ******************

#define MAX_THEME		16
static char Themes_Names_list[4][MAX_THEME][128];
static char Themes_Paths_list[4][MAX_THEME][255];
static char Themes[4][128] = {"Default", "Default", "Default", "Default"};
static u8 Themes_position[4] = {0}; 
static int8_t Themes_number[4] = {-1,-1,-1,-1}; // ou {[0 ... 3] = -1}

//********* FONT *******************

static char Font[0x40]="/dev_flash/data/font/SCE-PS3-SR-R-LATIN2.TTF";
static char **FontName=NULL;
static char **FontPath=NULL;
static s8 FontNumber=0;

//**************** ManaGunZ UI **************

#define POINT(X,Y,Z) \
		tiny3d_VertexPos(X, Y, Z);\
		tiny3d_Normal(X, Y, Z);

static float ITEM_moveX[MAX_GAME] = {0.0};
static float ITEM_moveY[MAX_GAME] = {0.0};
static float ITEM_moveZ[MAX_GAME] = {0.0};
static float ITEM_angleX[MAX_GAME] = {0.0};
static float ITEM_angleY[MAX_GAME] = {0.0};
static float ITEM_angleZ[MAX_GAME] = {0.0};

static u8 MOVE_animated=NO;

MATRIX matrix;

//*************** GAME SETTINGS *******************

static u8 direct_boot = NO;
static u8 clean_syscall = NO;
static u8 change_IDPS = NO;
static u8 IDPS[0x10]={0};
static u8 ext_game_data= NO;
static u8 payload = MM;
static u8 prim_USB = NO;
static u8 emu = NONE;
static u8 libfs_from = MM;
static u8 mount_app_home = NO;
static u8 use_ex_plug = NO;
static u8 bt_audio = NO;

//*************** GLOBAL SETTINGS *******************
#ifdef FILEMANAGER
static char *UI[4] = {"0", "0", "Win", "0"};
#else
static char *UI[4] = {"List", "Grid", "XMB", "Flow"};
#endif //FILEMANAGER

static u8 UI_position = XMB;
static u8 XMB_priority = NO;
static u8 Show_Help = YES;
static u8 Use_SideMenu = NO;
static u8 Show_COVER = NO;
static u8 Show_PIC1 = NO;
static u8 Show_GameCase = NO;
static int8_t videoscale_x = 0;
static int8_t videoscale_y = 0;
static u32 COLOR_1 = WHITE;
static u32 COLOR_2 = GREEN;
static u32 COLOR_3 = ORANGE;
static u32 COLOR_4 = RED;
static u8 Display_PIC1 = NO;
static u8 Show_Waves = YES;
static u32 WAVES_COLOR = WHITE-0xFF+0x20;
#define FILTER_X_DEFAULT 700.0
#define FILTER_Y_DEFAULT 300.0
static float filter_x = FILTER_X_DEFAULT;
static float filter_y = FILTER_Y_DEFAULT;
static u8 LOG = NO;
u8 DEBUG = NO;
u8 IGNORE_ERR = NO;
u8 with_3k3y_header = NO;
char UPLOADER[0x40]={0};
u8 BOX3D_ALIGN = YES;
u8 BOX3D_GAP = 1;
u8 SHOW_LOG = NO;
u8 DUMPER_MAX_TRY = 30;

#define OVERWRITE_ALWAYS	0
#define OVERWRITE_NEVER		1
#define OVERWRITE_ASK		2
#define OVERWRITE_DUPLICATE 3
u8 OVERWRITE = OVERWRITE_NEVER;

#define STYLE_CUSTOM	0
#define STYLE1			1
#define STYLE2			2
#define STYLE3			3	
#define STYLE4			4
#define STYLE5			5
#define STYLE6			6
static u8 root_display = STYLE1;
#define MAX_STYLE 6

#define SMALL	0
#define BIG		1

u8 fm_LineSize;
u8 fm_RowNumber;
u8 fm_FontRowSize[3];
char fm_Format[6][0x80]={{0}};
float fm_CapacityBarWidth;
u8 fm_CustomIcons;

//*************** LIST SETTINGS *******************

#define LIST_SizeFont		20
static u8 Show_ICON0 = NO;
static int first_line=0;
static int nb_line=0;
static int last_line=0;

//*************** GRID SETTINGS *******************

static s16 GRID_FIRST_ICON = 0, GRID_LAST_ICON=-1;
static u8 GRID_NB_LINES = 5;
static u8 GRID_NB_COLUMNS = 5;
static u8 GRID_TYPE = SCROLL;
static u8 GRID_DIRECTION = VERTICAL;
static u8 GRID_ANIMATED = YES;
static u8 GRID_KEEP_PROP = YES;
#define GRID_e 10
#define GRID_X 20
#define GRID_Y 25
#define GRID_W X_MAX-GRID_X*2
#define GRID_H Y_MAX-GRID_Y*2
#define GRID_W_ICON0	(GRID_W - (GRID_NB_COLUMNS-1) * GRID_e) / GRID_NB_COLUMNS 
#define GRID_H_ICON0    ((GRID_H - (GRID_NB_LINES-1) * GRID_e) / GRID_NB_LINES)*(1-GRID_KEEP_PROP) + GRID_KEEP_PROP*GRID_W_ICON0/1.86
#define GRID_NB_ICON0 	GRID_NB_LINES*GRID_NB_COLUMNS

//*************** XMB SETTINGS *******************

#define XMB_W 72.0f
#define XMB_H 40.0f

#define XMB_COLUMN_SETTINGS		0
#define XMB_COLUMN_FAVORITES	1
#define XMB_COLUMN_PS3			2
#define XMB_COLUMN_PS2			3
#define XMB_COLUMN_PS1			4
#define XMB_COLUMN_PSP			5

#define XMB_COLUMN_NUMBER		6


static u8 XMB_H_position = XMB_COLUMN_PS3;
static s16 XMB_nb_line = -1;
static u16 XMB_value_line[MAX_GAME] = {0};
static u16 XMB_V_position[XMB_COLUMN_NUMBER] = {0};

static char *XMB_COLUMN_NAME[XMB_COLUMN_NUMBER]={"SETTINGS", "FAVORITES", "PS3", "PS2", "PS1", "PSP"};
static float XMB_columnX[XMB_COLUMN_NUMBER]={0.0};
static float XMB_columnY[XMB_COLUMN_NUMBER]={0.0};
static float XMB_columnZ[XMB_COLUMN_NUMBER]={0.0};

//*************** FLOW SETTINGS *******************

#define FLOW_W  	80.0f
#define FLOW_H		44.0f

static u8 FLOW_3D = YES;
static u8 FLOW_Zoom = NO;
static u8 FLOW_ShowBack = NO;
static u8 FLOW_inverse_button=YES;

//*************** FILTER SETTINGS *******************

static u8 Show_PS3 = YES;
static u8 Show_PS2 = YES;
static u8 Show_PS1 = YES;
static u8 Show_PSP = YES;
static u8 Only_FAV = NO;

//*************** AutoMount *******************

static u8 AutoM = NO;
static u8 gui_called = NO;

//************** PICTURE ******************************

imgData COVER;
static u32 COVER_offset;

imgData TMP_PIC;
static u32 TMP_PIC_offset;
char TMP_PIC_path[255];

// *************** PICTURE ***************************

enum 
{
	ALL,
	UP,
	LEFT,
	DOWN,
	RIGHT,
	SELECT,
	START,
	SQUARE,
	CROSS,
	CIRCLE,
	TRIANGLE,
	NOT,
	L1,
	L2,
	L3,
	L,
	R1,
	R2,
	R3,
	R,
	DEFAULT,
	DEFAULT_ISO,
	DEFAULT_JB,
	TAG,
	PS1_CASE,
	PS2_CASE,
	PS3_CASE,
	PSP_CASE,
	FOLDER,
	FILES,
	GAME,
	DISC,
	DISC_PS1,
	DISC_PS2,
	DISC_PS3,
	DISC_PSP,
	DISC_VIDEO,
	DISC_DATA,
	CF,
	FLASH,
	HDD,
	MS,
	SD,
	USB,
	VIRTUAL,
	LOCK,
	BR_LOGO,
	PS_LOGO,
	TOGGLE_ON,
	TOGGLE_OFF,
	CHECKBOX_FALSE,
	CHECKBOX_TRUE,
	RESET,
	RESET_HOVER,
	MAXIMIZE,
	MAXIMIZE_HOVER,
	CLOSE,
	CLOSE_HOVER,
	DOCK_R,
	DOCK_R_HOVER,
	DOCK_L,
	DOCK_L_HOVER,
	FRAME,
	HEADER,
	COLUMN_HEADER,
	CONTENT,
	CURSOR,
	CURSOR_D1,
	CURSOR_D2,
	CURSOR_H,
	CURSOR_V,
	APP_HOME,
	HOST_ROOT,

// with color filter
	NOTIF,
	BOXHEAD,
	BOXBODY,
	SIDEBAR,
	BGS,
	BGF,

	PICTURE_NUMBER,
};

#define _BG_			255

char *PICTURE_NAME[PICTURE_NUMBER] = {
	"ALL",
	"UP",
	"LEFT",
	"DOWN",
	"RIGHT",
	"SELECT",
	"START",
	"SQUARE",
	"CROSS",
	"CIRCLE",
	"TRIANGLE",
	"NOT",
	"L1",
	"L2",
	"L3",
	"L",
	"R1",
	"R2",
	"R3",
	"R",
	"DEFAULT",
	"DEFAULT_ISO",
	"DEFAULT_JB",
	"TAG",
	"PS1_CASE",
	"PS2_CASE",
	"PS3_CASE",
	"PSP_CASE",
	"FOLDER",
	"FILES",
	"GAME",
	"DISC",
	"DISC_PS1",
	"DISC_PS2",
	"DISC_PS3",
	"DISC_PSP",
	"DISC_VIDEO",
	"DISC_DATA",
	"CF",
	"FLASH",
	"HDD",
	"MS",
	"SD",
	"USB",
	"VIRTUAL",
	"LOCK",
	"BR_LOGO",
	"PS_LOGO",
	"TOGGLE_ON",
	"TOGGLE_OFF",
	"CHECKBOX_FALSE",
	"CHECKBOX_TRUE",
	"RESET",
	"RESET_HOVER",
	"MAXIMIZE",
	"MAXIMIZE_HOVER",
	"CLOSE",
	"CLOSE_HOVER",
	"DOCK_R",
	"DOCK_R_HOVER",
	"DOCK_L",
	"DOCK_L_HOVER",
	"FRAME",
	"HEADER",
	"COLUMN_HEADER",
	"CONTENT",
	"CURSOR",
	"CURSOR_D1",
	"CURSOR_D2",
	"CURSOR_H",
	"CURSOR_V",
	"APP_HOME",
	"HOST_ROOT",

// with color filter
	"NOTIF",
	"BOXHEAD",
	"BOXBODY",
	"SIDEBAR",
	"BGS",
	"BGF",
};

imgData PICTURE[PICTURE_NUMBER];
static u32 PICTURE_offset[PICTURE_NUMBER];

#define _Go(x)						((size_t)(x) >> 30)	
#define Go(x)						((size_t)(x) << 30)
#define _Mo(x)						((size_t)(x) >> 20)	
#define Mo(x)						((size_t)(x) << 20)
#define _Ko(x)						((size_t)(x) >> 10)	
#define Ko(x)						((size_t)(x) << 10)

#define simple(t, x) 	if((t) > Go(1)) x = (float)_Go((t)); \
						if((t) > Mo(1)) x = (float)_Mo((t)); \
						if((t) > Ko(1)) x = (float)_Ko((t)); \
						x = (float) (t);

// ****************************************
// Color Filters
// ****************************************
#define DISABLED	0
#define ENABLED 	1

u8 FILTER_NOTIF=DISABLED;
u8 FILTER_BOXHEAD=DISABLED;
u8 FILTER_BOXBODY=DISABLED;
u8 FILTER_SIDEBAR=DISABLED;
u8 FILTER_BGS=DISABLED;
u8 FILTER_BG=DISABLED;

#define COLOR_NOTIF_DEFAULT			0x555555FF
#define COLOR_BOXHEAD_DEFAULT		0xC0C0C0FF
#define COLOR_BOXBODY_DEFAULT		0x505050FF
#define COLOR_SIDEBAR_DEFAULT		0xFFFFFF60
#define COLOR_BGS_DEFAULT			0xAA40AAFF
#define COLOR_BG_DEFAULT			0x306090FF

u32 COLOR_NOTIF=COLOR_NOTIF_DEFAULT;
u32 COLOR_BOXHEAD=COLOR_BOXHEAD_DEFAULT;
u32 COLOR_BOXBODY=COLOR_BOXBODY_DEFAULT;
u32 COLOR_SIDEBAR=COLOR_SIDEBAR_DEFAULT;
u32 COLOR_BGS=COLOR_BGS_DEFAULT;
u32 COLOR_BG=COLOR_BG_DEFAULT;


// ****************************************
//  RAM  232 Mo (256)					  *
// ****************************************
//
// ****************************************
//  VRAM   
// ****************************************
//  _____________________________________
// | TexturePointer  -> TextureOffset    |
// |   0 Mo          ->   ~13 Mo	     |   0xD523100
// |   1 Mo          ->   ~17 Mo	     |
// |   X Mo          ->   ~13 + (X*4) Mo |
// |   55 Mo         ->   ~233 Mo        |
// ****************************************
//
// Texture are stored in BMP, size = w*h*p
// ICON0            320*176*4     = 0x37000
// COVER PS1		250*250*4     = 0x3D090
// COVER PS2		250*350*4     = 0x55730
// COVER PS3		260*300*4     = 0x4C2C0
// COVER PSP		200*340*4     = 0x42680
//
// COVER3D PS1      450*450*4 + 450*600*4  = 0x1CD6D0
// COVER3D PS2		850*570*4              = 0x1D9250
// COVER3D PS3      950*525*4              = 0x1E70F8
// COVER3D PSP		800*640*4		       = 0x1F4000
//
// ****************************************
// | TexturePointer   | TextureOffset    |
//     2  Mo = 0->2   |  8 Mo = 13->21		    FONT
//     16 Mo = 2->18  |  64 Mo = 21->85         THEME
//	   30 Mo = 18->48 |  120 Mo = 85->205		GAMEPIC
//     1 Mo = 48->49  |  4 Mo = 205->209        COVER
//     6 Mo = 49->55  |  24 Mo = 209->233       TEMP	
//

#define TEXTURE_SIZE_MAX 				Mo(55)

#define TEXTURE_FONT_SIZE_MAX			Mo(2)
#define TEXTURE_THEME_SIZE_MAX			Mo(16)
#define TEXTURE_GAMEPIC_SIZE_2D			Ko(512)
#define TEXTURE_GAMEPIC_SIZE_3D			Mo(2)
#define TEXTURE_GAMEPIC_TOT_SIZE_MAX	Mo(30)
#define TEXTURE_COVER_SIZE_MAX			Mo(1)

char GAMEPIC_LOG[128];
int GAMEPIC_POSITION = 0;
int GAMEPIC_SLOT_FIRST=0;
int GAMEPIC_SLOT_LAST=0;

#define GAMEPIC_NUMBER					TEXTURE_GAMEPIC_TOT_SIZE_MAX / TEXTURE_GAMEPIC_SIZE_2D
imgData GAMEPIC[GAMEPIC_NUMBER];
static u32 GAMEPIC_offset[GAMEPIC_NUMBER];
int GAMEPIC_SLOT_POS[GAMEPIC_NUMBER] = { [0 ... GAMEPIC_NUMBER-1] = -1 };

u32 TEXTURE_FONT_SIZE = 0;
u32 TEXTURE_THEME_SIZE = 0;
#define TEXTURE_GAMEPIC_SIZE(u)         (((GAMEPIC[u].pitch * GAMEPIC[u].height + 15) & ~15) / 4)
#define TEXTURE_COVER_SIZE				(((COVER.pitch * COVER.height + 15) & ~15) / 4)
#define TEXTURE_TMP_SIZE				(((TMP_PIC.pitch * TMP_PIC.height + 15) & ~15) / 4)

imgData PS1BACK[GAMEPIC_NUMBER];
u32 PS1BACK_offset[GAMEPIC_NUMBER];

// FONT
#define TEXTURE_POINTER_FONT		0

// THEME
#define TEXTURE_POINTER_THEME		(TEXTURE_POINTER_FONT + TEXTURE_FONT_SIZE_MAX)

u64 TEXTURE_GAMEPIC_SIZE_MAX = 0;
#define GAMEPIC_MAX						(TEXTURE_GAMEPIC_TOT_SIZE_MAX / TEXTURE_GAMEPIC_SIZE_MAX)
#define TEXTURE_POINTER_GAMEPIC(x)		((TEXTURE_POINTER_THEME+TEXTURE_THEME_SIZE_MAX) + x * TEXTURE_GAMEPIC_SIZE_MAX)
#define TEXTURE_POINTER_COVER			(TEXTURE_POINTER_GAMEPIC(0) + TEXTURE_GAMEPIC_TOT_SIZE_MAX)

#ifdef FILAMANAGER
#define TEXTURE_POINTER_TMP				(TEXTURE_POINTER_GAMEPIC(0))
#else
#define TEXTURE_POINTER_TMP				(TEXTURE_POINTER_COVER + TEXTURE_COVER_SIZE_MAX)
#endif
#define TEXTURE_TMP_SIZE_MAX			(TEXTURE_SIZE_MAX - (TEXTURE_FONT_SIZE_MAX + TEXTURE_THEME_SIZE_MAX + TEXTURE_GAMEPIC_TOT_SIZE_MAX + TEXTURE_COVER_SIZE_MAX))

// Update Texture after tiny3d_Flip !

static u32 *texture_pointer;
static u32 *texture_mem;

#define MAX_FRAME		64
static u32 BG_offset[MAX_FRAME];
imgData BG[MAX_FRAME];

// ***************** PICTURE : XMB ***************************

imgData XMB_Col[6];
static u32 XMB_Col_offset[6];

imgData XMB_MMTHM_XMB;
static u32 XMB_MMTHM_XMB_offset;

imgData XMB_MMTHM_XMB2;
static u32 XMB_MMTHM_XMB2_offset;

// ****************** FILE MANAGER ***************

#define FM_FORMAT_INIT						0
#define FM_FORMAT_EMPTY						1
#define FM_FORMAT_LABEL						2
#define FM_FORMAT_DEVICE					3
#define FM_FORMAT_FILESYSTEM				4	
#define FM_FORMAT_MEMORY					5
#define FM_FORMAT_MOUNTPOINT				6
#define FM_FORMAT_DEVICE_MOUNTPOINT			7
#define FM_FORMAT_LABEL_MOUNTPOINT			8
#define FM_FORMAT_LABEL_DEVICE_MOUNTPOINT	9
#define FM_FORMAT_CAPACITY					10
#define FM_FORMAT_CAPACITY_MEMINSIDE		11
#define FM_FORMAT_CAPACITY_MEMOUTSIDE		12

#define ROW(x)			x
#define LEFTROW(x) 		x*2
#define RIGHTROW(x) 	x*2+1

#define ASC 0
#define DSC 1

#define LINE_H1 					16.0
float LINE_H=LINE_H1;
#define COL_H1						20.0
float COL_H=COL_H1;
#define COL_W_MIN 					90
#define BORDER						5
#define TOP_H_FONT					LINE_H1
#define TOP_H						(BORDER+TOP_H_FONT+TOP_H_FONT/4)
#define SCROLL_W1					10
float SCROLL_W=SCROLL_W1;
#define SCROLL_H_MIN				10
#define CONTROLBOX_W				20.0
#define CONTROLBOX_H				TOP_H_FONT
#define CONTROLBOX_GAP				BORDER
#define WINDOW_MIN					(COL_W_MIN*2+BORDER*2)
#define WINDOW_MAX					4
#define WINDOW_MAX_ITEMS			4096
#define WINDOW_MAX_PATH_LENGTH		512
#define WINDOW_MAX_NAME_LENGTH		128
#define WINDOW_MAX_DEVICES			32

#define OVERLAY_COLOR				0xC0E0F0FF

static float *window_x=NULL;
static float *window_y=NULL;
static float *window_z=NULL;
static float *window_h=NULL;
static float *window_w=NULL;
static char **window_path=NULL;
static char **window_lastpath=NULL;
static char ***window_content_Name=NULL;
static u64 **window_content_Size=NULL;
static char ***window_content_Type=NULL;
static u8 **window_content_Selected=NULL;
static u8 *window_sort=NULL;
static float *window_w_col_size=NULL;
static int *window_content_N=NULL;
static u8 *window_open=NULL;

static s8 window_activ=-1;

static s8 *window_item_N=NULL; // nb of item displayed

static u32 *window_scroll_N=NULL; //	nb of increment
static u32 *window_scroll_P=NULL; // 	increment position
static float *window_scroll_size=NULL;
static float *window_scroll_y=NULL;

#define OPTION_MAX 32

static char **option_sel=NULL;
static char **option_item=NULL;
static char **option_copy=NULL;
static int option_item_N;
static int option_sel_N;
static int option_copy_N=-1;
static u8 option_cut = NO;
static u8 option_activ = NO;
static float option_x;
static float option_y;
static float option_h;
static float option_w;

static float curs_x = 848/2;
static float curs_y = 512/2;
static float curs_move_x;
static float curs_move_y;
static u8 curs_push=NO;
static float curs_move_scroll=0;

static u8 window_resize_H = NO;
static u8 window_resize_V = NO;
static u8 window_resize_D1 = NO;
static u8 window_resize_D2 = NO;
static u8 window_move = NO;

typedef struct
{
	char Label[32]; 
	char MountPoint[32];
	char FileSystem[32];
	char Name[32];
	u8 ReadOnly;
	u64 TotalSpace;
	u64 FreeSpace;
} DeviceInfo_t;

static DeviceInfo_t *DevicesInfo=NULL;
static s8 DevicesInfo_N=-1;

// ****************** FILE MANAGER : Properties ***************

static u8 prop_activ;

char **PROP_ITEM=NULL;
char **PROP_ITEM_VALUE=NULL;
s8 PROP_ITEM_NUMBER;

#define PROP_FONT		20.0f
#define PROP_W			800.0f
#define PROP_H			(PROP_ITEM_NUMBER+1)*PROP_FONT
#define PROP_X			X_MAX/2.0f-PROP_W/2.0f
#define PROP_Y			Y_MAX/2.0f-PROP_H/2.0f
#define PROP_COL_W		100.0f
#define PROP_MAX_ITEMS	10

// ****************** FILE MANAGER : SFO Viewer ***************

#define SFO_MAGIC				0x00505346
#define SFO_DATA_TYPE_UTF8S		0x004
#define SFO_DATA_TYPE_UTF8		0x204
#define SFO_DATA_TYPE_INT32		0x404

#define ES16(x)		(((x) & 0xFF) << 8 | ((x) & 0xFF00) >> 8)
#define ES32(x)		(((x) & 0xFF) << 24 | ((x) & 0xFF00) << 8 | ((x) & 0xFF0000) >> 8 | ((x) & 0xFF000000) >> 24)
#define ES(x)		(sizeof(x) == 2 ? ES16(x) : ES32(x))

char SFO_KEY[64][64];
char SFO_DATA[64][255];
u8 SFO_viewer_activ;
u8 SFO_NB;

#define SFO_FONT	20		
#define SFO_W		800
#define SFO_COL2_W	SFO_W-SFO_COL1_W
#define SFO_X		848/2-SFO_W/2

// ****************** FILE MANAGER : TXT Viewer ***************

#define TXT_FONT 15
#define TXT_LINE_MAX 24
#define TXT_H 375
#define TXT_W 711
#define TXT_X 68.5
#define TXT_Y 68.5

u64 txt_line;
int txt_scroll;
u8 txt_viewer_activ = NO;
char *txt_viewer_content=NULL;
char *txt_viewer_path=NULL;

//************************ COPY ************************

char copy_file[128];
char copy_src[128];
char copy_dst[128];

u64 copy_current_size;
u64 copy_file_prog_bar;
u8 copy_flag=NO;
u8 copy_cancel=NO;

u8 gathering=NO;
s64 gathering_nb_file = 0;
s64 gathering_nb_directory = 0;
u8 gathering_cancel=NO;
u64 gathering_total_size;


//************************** PAD ************************

#define n_s(x)		(x*1000000000ULL)
#define n_ms(x)		(x*1000000ULL)
#define n_us(x)		(x*1000ULL)

#define MAX_HOLD		(u64)40
#define MAX_HOLD_S		(u64)n_s(4)



u64 hold_value[18]={0};
u64 slow_value[18]={0};
static int R2speed=6;
static int x_L = 0;
static int y_L = 0;
static u64 hold_CIRCLE=0;

// ************** filter ************************************

u8 filter=NO;
u8 filter_position=0;

// ************** FILE MANAGER : Picture Viewer ***************

//char picture_viewer_info[2048];
static u8 picture_viewer_activ = NO;

//***************** MENU *************************************

#define MENU_MAX_ITEMS				64
#define MENU_MAX_ITEMS_VALUE		128

#define ITEM_TEXTBOX				0
#define ITEM_CHECKBOX				1
#define ITEM_COLORBOX				2
#define ITEM_COMMAND				3
#define ITEM_TOGGLE					4
#define ITEM_LOCKED					5

static u8 MENU=NO;

static char **ITEMS=NULL;
static s8 ITEMS_NUMBER;
static char ***ITEMS_VALUE=NULL;
static s8 *ITEMS_VALUE_NUMBER=NULL;

static u8 ITEMS_POSITION;
static u8 *ITEMS_VALUE_POSITION=NULL;
static u8 *ITEMS_VALUE_SHOW=NULL;
static u8 *ITEMS_TYPE=NULL;

#define LVL_TITLE	2
#define LVL_ITEMS	1
#define LVL_VALUE	0
static s8 MENU_LVL=LVL_ITEMS;

static float MENU_ITEMS_X;
static float MENU_ITEMS_VALUE_X;
static int MENU_SCROLL;
static int MENU_SCROLL_START;

static int MENU_COLUMN_ITEMS_NUMBER;
static float MENU_COLUMN_ITEMS_W;
static s8 MENU_TABLE_START;
static s8 MENU_TABLE_END;

static char **TITLES=NULL;

u8 USE_TITLE_MENU=NO;
s32 TITLE_MENU_FIRST_ITEM=-1;
s32 TITLE_MENU_LAST_ITEM=-1;

static u8 MENU_SIDE;

static float current_x;
static float current_y;

// ***************** PS2 GAME MENU *************************************

#define LIMG_SIZE 0x4000
static u8 has_LIMG=NO;
static char *PS2ELF_mem = NULL;
static int PS2ELF_mem_size = 0;
static u32 PS2CRC=0;
static u32 PS2ORICRC=0;
static char PS2_ID[12];
static char pnach[128];
static char WS[128];

static u8 PS2PATCH_480P = NO;
static u8 PS2PATCH_YFIX = NO;
static u8 PS2PATCH_FMVSKIP = NO;

u32 PS2PATCH_480P_offset;
u32 PS2PATCH_YFIX_offset;
u32 PS2PATCH_FMVSKIP_offset;

static u8 PS2PATCH_480P_FLAG_DISABLE[] = { 
									0x00, 0x2C, 0x05, 0x00, 0x20, 0x00, 0xB2, 0xFF, 
									0x00, 0x34, 0x06, 0x00, 0x10, 0x00, 0xB1, 0xFF, 
									0x00, 0x3C, 0x07, 0x00
								  };

static u8 PS2PATCH_480P_FLAG_ENABLE[] = { 
								   0x00, 0x00, 0x05, 0x3C, 0x20, 0x00, 0xB2, 0xFF,
								   0x50, 0x00, 0x06, 0x3C, 0x10, 0x00, 0xB1, 0xFF,
								   0x01, 0x00, 0x07, 0x3C
								 };

static u8 PS2PATCH_YFIX_FLAG_DISABLE[] = { 
									0x70, 0xFF, 0xBD, 0x27, 0x00, 0x2C, 0x05, 0x00,
									0x70, 0x00, 0xB6, 0xFF, 0x00, 0x34, 0x06, 0x00,
									0x60, 0x00, 0xB5, 0xFF, 0x00, 0x3C, 0x07, 0x00,
									0x50, 0x00, 0xB4, 0xFF, 0x00, 0x44, 0x08, 0x00,
									0x40, 0x00, 0xB3, 0xFF, 0x00, 0x4C, 0x09, 0x00
								  };

static u8 PS2PATCH_YFIX_FLAG_ENABLE[] = { 
								   0x70, 0xFF, 0xBD, 0x27, 0x00, 0x2C, 0x05, 0x00,
								   0x70, 0x00, 0xB6, 0xFF, 0x00, 0x34, 0x06, 0x00, 
								   0x60, 0x00, 0xB5, 0xFF, 0x00, 0x3C, 0x07, 0x00, 
								   0x50, 0x00, 0xB4, 0xFF, 0x00, 0x44, 0x08, 0x00, 
								   0x40, 0x00, 0xB3, 0xFF, 0x10, 0x00, 0x09, 0x3C
								 };

static u8 PS2PATCH_FMVSKIP_FLAG_DISABLE[] = {
									   0x40, 0x00, 0x83, 0x8C, 0x08, 0x00, 0xE0, 0x03,
									   0x00, 0x00, 0x62, 0x8C, 0x00, 0x00, 0x00, 0x00
									 };

static u8 PS2PATCH_FMVSKIP_FLAG_ENABLE[] = {
									  0x40, 0x00, 0x83, 0x8C, 0x08, 0x00, 0xE0, 0x03,
									  0x01, 0x00, 0x02, 0x24, 0x00, 0x00, 0x00, 0x00
									};

// todo Skip video 2 : replacing "ChoosePlayMovie" by "AAAAePlayMovie"

//***********************************************************
// Language
//***********************************************************
// http://www.psdevwiki.com/ps3/XRegistry.sys
// 0x0=German
// 0x1=English (US)
// 0x2=Spanish
// 0x3=French
// 0x4=Italian
// 0x5=Dutch
// 0x6=Portuguese (Por)
// 0x7=Russian
// 0x8=Japanese
// 0x9=Korean
// 0xA=Chinese (traditional)
// 0xB=Chinese (simplified)
// 0xC=Finnish
// 0xD=Swedish
// 0xE=Danish
// 0xF=Norwegian
// 0x10=Polish
// 0x11=Portuguese (Bra)
// 0x12=English (UK)
// ...
// CUSTOM
// 0x20=Hungarian
// 0x21=Turkish
//***********************************************************

#define MAX_LANG 32
#define LANG_DEFAULT		0xFF
#define LANG_UNDEFINED		0xEE
#define LANG_NONE			0xDD

uint8_t lang=0;
uint8_t lang_N;
uint8_t lang_code = LANG_UNDEFINED;
uint8_t lang_code_loaded = LANG_NONE;

static char *STR_LANGUAGE[MAX_LANG]; // "English"
static u8 LANGCODE[MAX_LANG];
static char *lang_path[MAX_LANG];

#define MGZ_PREFIX			"[MGZ] "
static char *STR_MGZ_CUSTOM = NULL;

#include "str.h"

//***********************************************************
// Functions
//***********************************************************

u8 Copy(char *src, char *dst);
void Delete(char* path);
void print_head(char *format2, ...);
void print_load(char *format, ...);
u8 Show_it(int pos);
char *LoadFile(char *path, int *file_size);
char *LoadFileProg(char *path, int *file_size);
u8 GetParamSFO(const char *name, char *value, char *path);
u8 Get_ID(char *isopath, u8 platform, char *game_ID);
u8 is_apng(char *file);
u8 Load_APNG(char* filename);
float DrawStringFromCenterX(float x, float y, char *txt);
void start_loading();
void end_loading();
void open_picture_viewer(char *pict_path);
void open_txt_viewer(char *txt_path);
void open_SFO_viewer(char *path);
void Draw_FileExplorer();
void show_msg(char *str);
char *LoadFileFromISO(u8 prog, char *path, char *filename, int *size);
char *get_ext(char *file);
u8 get_platform(char *file);
void read_fav();
int Draw_Progress_Bar(float x, float y, u8 size, float value, u32 color);
u32 Get_PS2CRC();
u32 Get_Original_PS2CRC();
void Draw_scene();
void Draw_title(float x, float y, char *str);
void peek_IDPS();
void start_load_CURPIC();
void end_load_CURPIC();
int SaveFile(char *path, char *mem, int file_size);
void read_setting();
void write_setting();
void Draw_input();
void cursor_input();
u8 is_iso(char *file_name);
u8 is_splitted_iso(char *file_name);
u8 is_66600(char *file_name);
u8 is_666XX(char *file_name);
u8 is_usb(char *file_name);
u8 is_FAT32(char *file_name);
u64 get_size(char *path);
void poke_IDPS();
u8 WS_exist();
u8 Pnach_exist();
void CONFIG_check(char *IsoPath);
float DrawTXTInBox(float x, float y, float z, float w, float h, char *txt, u32 bg_color, u32 font_color);
char *get_unit(u64 nb);
char *strcpy_malloc(char *STR_DEFAULT);
void Draw_cursor();
void ScreenShot();
u8 GetALPHA(u32 rgba);
u32 SetALPHA(u8 alpha, u32 rgba);
char *get_str_regex(char *mem, char *format);
void LoadFont();
u8 LoadTexture(char *texture_path, u32 *texture_offset, imgData *texture_data, u32 *texture_size, u8 gray);
int sys_fs_chown(char *path, s32 uid, s32 gid);
u8 SetFilePerms(char *path);
void open_SETTINGS();
void close_SETTINGS();
void TranslateTo(float *value, float target);
void remove_GAMELIST(s64 pos);
void Draw_MemMonitor();
void DrawLoadingIcon();
void Draw_filter();
void ReloadTheme(u8 i);
int NTFS_Test_Device(char *name);
char *FM_GetContent(char *str_format, char *MountPoint, DeviceInfo_t DeviceInfo);
u8 FM_GetFormat(char *str);
char *FM_SetFormat(u8 format_id);
u8 OldPad(u32 button);
u8 NewPad(u32 button);
u8 R2pad(u32 button);
u8 ComboNewPad(u32 button1, u32 button2);
u8 GetRED(u32 rgba);
u8 GetGREEN(u32 rgba);
u8 GetBLUE(u32 rgba);
u8 GetALPHA(u32 rgba);
u8 is_float_window();
int move_bdemubackup_to_origin(char *device_path);
s8 bmpLoadFromBuffer(const void *buffer, int file_size, imgData *data);
s8 MagickLoadFromBuffer(const void *buffer, int file_size, imgData *data);
u8 make_png(char *outfile, imgData data);
char *GetTimeStr(u64 secTime);
char *sprintf_malloc(char *format, ...);
u8 SetPerms(char* path);
u32 crc_file2(char *path, u32 current_crc);
u32 crc_file(char *path);
int upload(char *url, char *src, const char *method);
int http_response(char *url);
void add_GAMELIST(char *path);
void sort_GAMELIST();
void update_RootDisplay();
float DrawTXTinLineBox(float x, float y, float z, float w, char *string, u32 bg_color, u32 font_color);
int Extract_SELF(char *in, char *out, u8 *rif);
void MGZ_exit();
s32 sys_map_path(char *oldpath, char *newpath);
float Get_MgzVersion();
u8 is_splitted_iso_X(char *file_name);

void Draw_MENU();

typedef void (*func)();
void EmptyFunc()
{
	return;
}
func Draw_MENU_input = &EmptyFunc;
func input_MENU = &EmptyFunc;

// TODO
//
// func MENU_TRIANGLE = &EmptyFunc;
// func MENU_CROSS = &EmptyFunc;
// func MENU_CIRCLE = &EmptyFunc;
// func MENU_CROSS = &EmptyFunc;
// func MENU_R1 = &EmptyFunc;


//*******************************************************
// 
//*******************************************************

void cls()
{
	tiny3d_Clear(0xff000000, TINY3D_CLEAR_ALL);
		
	// Enable alpha Test
	tiny3d_AlphaTest(1, 1, TINY3D_ALPHA_FUNC_GEQUAL);

   // Enable alpha blending.
			tiny3d_BlendFunc(1, TINY3D_BLEND_FUNC_SRC_RGB_SRC_ALPHA | TINY3D_BLEND_FUNC_SRC_ALPHA_SRC_ALPHA,
				TINY3D_BLEND_FUNC_DST_RGB_ONE_MINUS_SRC_ALPHA | TINY3D_BLEND_FUNC_DST_ALPHA_ZERO,
				TINY3D_BLEND_RGB_FUNC_ADD | TINY3D_BLEND_ALPHA_FUNC_ADD);
	reset_ttf_frame();
}

void Init_Graph()
{
	tiny3d_Init( TINY3D_Z16 | Mo(2) );

	texture_mem = tiny3d_AllocTexture(Mo(100));
	if(!texture_mem) return;
		
	ResetFont();
	
	double sx = (double) Video_Resolution.width;
	double sy = (double) Video_Resolution.height;
	double psx = (double) (1000 + videoscale_x)/1000.0;
	double psy = (double) (1000 + videoscale_y)/1000.0;
	
	tiny3d_UserViewport(1, 
		(float) ((sx - sx * psx) / 2.0), // 2D position
		(float) ((sy - sy * psy) / 2.0), 
		(float) ((sx * psx) / X_MAX),	// 2D scale
		(float) ((sy * psy) / Y_MAX),
		(float) ((sx * psx) / X_MAX),  // 3D scale
		(float) ((sy * psy) / Y_MAX));
}

void adjust_screen()
{
	double sx = (double) Video_Resolution.width;
	double sy = (double) Video_Resolution.height;
	double psx = (double) (1000 + videoscale_x)/1000.0;
	double psy = (double) (1000 + videoscale_y)/1000.0;
	
	tiny3d_UserViewport(1, 
		(float) ((sx - sx * psx) / 2.0), // 2D position
		(float) ((sy - sy * psy) / 2.0), 
		(float) ((sx * psx) / X_MAX),	// 2D scale
		(float) ((sy * psy) / Y_MAX),
		(float) ((sx * psx) / X_MAX),  // 3D scale
		(float) ((sy * psy) / Y_MAX));
}

//*******************************************************
// FONT
//*******************************************************

void FreeFont()
{
	int i;
	for(i=0; i<MENU_MAX_ITEMS_VALUE; i++) FREE(FontName[i]);
	FREE(FontName);
	
	for(i=0; i<MENU_MAX_ITEMS_VALUE; i++) FREE(FontPath[i]);
	FREE(FontPath);
	
	FontNumber=-1;
}

char *get_ttf_name(char *ttf)
{
	char strFullName[255];
	char strVersion[255];
	u32 strFullNameLen=0;
	u32 strVersionLen=0;
	int i,j;
	FILE *f;
	
	f = fopen(ttf, "rb");
	if(f==NULL) return NULL;
	
	u32 entrynumber;
	
	fseek(f, 2, SEEK_SET);
	fread(&entrynumber, sizeof(u32), 1, f);
	
	char entryname[5];
	
	u32 NameTable_offset=0;
	for(i=0; i<entrynumber; i++) {
		fseek(f, 0xC + i*0x10, SEEK_SET);
		fread(&entryname, 4, 1, f);
		entryname[4]=0;
		
		if( strcmp(entryname, "name") == 0) {
			fseek(f, 4, SEEK_CUR);
			fread(&NameTable_offset, sizeof(u32), 1, f);
			break;
		}
	}
	if(NameTable_offset == 0) {
		fclose(f);
		return NULL;
	} 

	u16 strtaboff=0;
	u16 number=0;

	fseek(f, NameTable_offset+2, SEEK_SET);
	fread(&number, sizeof(u16), 1, f);
	fread(&strtaboff, sizeof(u16), 1, f);
	
	u16 lang, name;
	for(i=0; i<number; i++) {
		fseek(f,  NameTable_offset+0xA+i*0xC, SEEK_SET);
		fread(&lang, sizeof(u16), 1, f);
		fread(&name, sizeof(u16), 1, f);
		
		//if(lang==0 && name==4) { //fullname english
		if(name==4) {
			u16 strlen;
			u16 stroff;
			fread(&strlen, sizeof(u16), 1, f);
			fread(&stroff, sizeof(u16), 1, f);
			
			fseek(f, NameTable_offset+strtaboff+stroff, SEEK_SET);
			
			char c;
			for(j=0; j<strlen; j++) {
				fread(&c, 1, 1, f);
				if(c==0) continue;
				strFullName[strFullNameLen]=c;
				strFullNameLen++;
			}
			strFullName[strFullNameLen]=0;
		}
		
		//if(lang==0 && name==5) { //version english
		if(name==5) {
			u16 strlen;
			u16 stroff;
			fread(&strlen, sizeof(u16), 1, f);
			fread(&stroff, sizeof(u16), 1, f);
			
			fseek(f, NameTable_offset+strtaboff+stroff, SEEK_SET);
			
			char c;
			for(j=0; j<strlen; j++) {
				fread(&c, 1, 1, f);
				if(c==0) continue;
				strVersion[strVersionLen]=c;
				strVersionLen++;
			}
			strVersion[strVersionLen]=0;
		}
		
		if(strVersionLen && strFullNameLen) break;
	}
	fclose(f);
	
	if(strFullNameLen==0) return NULL;

	char *ret = (char *) malloc(strFullNameLen+strVersionLen+3);
	if(ret==NULL) return NULL;
	
	if(strVersionLen) {
		sprintf(ret, "%s [%s]", strFullName,  strVersion);
	} else {
		strcpy(ret, strFullName);
	}
	return ret;
}

void ScanFont(char *directory)
{
	char temp[255];
	
	if(FontNumber+2 == MENU_MAX_ITEMS_VALUE) return;
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(directory);
	if(d==NULL) return;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		if(FontNumber+2 == MENU_MAX_ITEMS_VALUE) {
			closedir(d);
			return;
		}
		
		sprintf(temp, "%s/%s", directory, dir->d_name);
		
		if(dir->d_type & DT_DIR) {
			ScanFont(temp);
		}
		if(strcasecmp(get_ext(temp), ".ttf")) continue;	
				
		FontNumber++;
		FontName[FontNumber] = get_ttf_name(temp);
		if(FontName[FontNumber] == NULL) {
			FontName[FontNumber] = strcpy_malloc(dir->d_name);
		}
		FontPath[FontNumber] = strcpy_malloc(temp);
	}
	closedir(d);
}

void GetFont()
{
	int i;
	
	FontName = (char **) malloc(MENU_MAX_ITEMS_VALUE * sizeof(char*));
	FontPath = (char **) malloc(MENU_MAX_ITEMS_VALUE * sizeof(char*));
	for(i=0; i<MENU_MAX_ITEMS_VALUE; i++) FontName[i]=NULL;
	for(i=0; i<MENU_MAX_ITEMS_VALUE; i++) FontPath[i]=NULL;
	FontNumber = -1;
	
	u8 FontDirNumber = 2;
	char FontDir[FontDirNumber][64];
	
	sprintf(FontDir[0], "/dev_hdd0/game/%s/USRDIR/GUI",  ManaGunZ_id);
	strcpy(FontDir[1], "/dev_flash/data/font");
	
	for(i=0; i<FontDirNumber; i++) {
		ScanFont(FontDir[i]);
		if(FontNumber+2 == MENU_MAX_ITEMS_VALUE) return;
	}
}

void LoadFont()
{
	TTFUnloadFont();
	
	texture_pointer = texture_mem + TEXTURE_POINTER_FONT;
	
	TTFLoadFont(0, Font, NULL, 0);
	TTFLoadFont(1, "/dev_flash/data/font/SCE-PS3-DH-R-CGB.TTF", NULL, 0);
	TTFLoadFont(2, "/dev_flash/data/font/SCE-PS3-SR-R-JPN.TTF", NULL, 0);
	TTFLoadFont(3, "/dev_flash/data/font/SCE-PS3-YG-R-KOR.TTF", NULL, 0);
	
	texture_pointer = (u32 *) init_ttf_table((u16 *) texture_pointer);
	
	//TEXTURE_FONT_SIZE = texture_pointer;
}

float new_line(float nb)
{
	//return GetFontY() + GetFontHeight()*nb;
	return GetFontHeight()*nb;
}

void FontSize(float size)
{
	SetFontSize((float) (3 * size / 4),  size );
}

void FontColor(u32 color)
{
	SetFontColor(color, 0);
}

//*******************************************************
// 
//*******************************************************

void Draw_BoxGradiant(u8 direction, float x, float y, float z, float w, float h, u32 color1, u32 color2, u8 texture) 
{
	
	if(direction == VERTICAL) { 
		tiny3d_SetPolygon(TINY3D_QUADS);
		tiny3d_VertexPos(x	 	, y	 , z);
		tiny3d_VertexColor(color1);
		if(texture) tiny3d_VertexTexture(0.0f, 0.0f);
			
		tiny3d_VertexPos(x + w	, y	 , z);
		tiny3d_VertexColor(color1);
		if(texture) tiny3d_VertexTexture(1.0f, 0.0f);
		
		tiny3d_VertexPos(x + w	, y + h	, z);
		tiny3d_VertexColor(color2);
		if(texture) tiny3d_VertexTexture(1.0f, 1.0f);
		
		tiny3d_VertexPos(x	 	, y + h	, z);
		tiny3d_VertexColor(color2);
		if(texture) tiny3d_VertexTexture(0.0f, 1.0f);
		tiny3d_End();
	} else 
	if(direction == HORIZONTAL) {
		tiny3d_SetPolygon(TINY3D_QUADS);
		tiny3d_VertexPos(x	 	, y	 , z);
		tiny3d_VertexColor(color1);
		if(texture) tiny3d_VertexTexture(0.0f, 0.0f);
			
		tiny3d_VertexPos(x  	, y	+ h , z);
		tiny3d_VertexColor(color1);
		if(texture) tiny3d_VertexTexture(0.0f, 1.0f);
		
		tiny3d_VertexPos(x + w	, y + h	, z);
		tiny3d_VertexColor(color2);
		if(texture) tiny3d_VertexTexture(1.0f, 1.0f);
		
		tiny3d_VertexPos(x + w  , y		, z);
		tiny3d_VertexColor(color2);
		if(texture) tiny3d_VertexTexture(1.0f, 0.0f);
		tiny3d_End();
	}
	
	
	
}

void Draw_Box(float x, float y, float z, float r, float w, float h, u32 rgba, u8 texture) //texture only if r=0
{
	if(r > w || r > h) r=0;
	
	if(r==0){
		tiny3d_SetPolygon(TINY3D_QUADS);
		tiny3d_VertexPos(x	 	, y	 , z);
		tiny3d_VertexColor(rgba);
		if(texture) tiny3d_VertexTexture(0.0f, 0.0f);
		
		tiny3d_VertexPos(x + w	, y	 , z);
		tiny3d_VertexColor(rgba);
		if(texture) tiny3d_VertexTexture(1.0f, 0.0f);
		
		tiny3d_VertexPos(x + w	, y + h	, z);
		tiny3d_VertexColor(rgba);
		if(texture) tiny3d_VertexTexture(1.0f, 1.0f);
		
		tiny3d_VertexPos(x	 	, y + h	, z);
		tiny3d_VertexColor(rgba);
		if(texture) tiny3d_VertexTexture(0.0f, 1.0f);
		
		tiny3d_End();
	}
	else {
		int t;
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(rgba);
		x+=r;
		y+=r;
		for(t=-90; t>=-180 ; t-=10) {
			tiny3d_VertexPos( x + r*cos(t*PI/180), y + r*sin(t*PI/180), z);
		}
		y+= h-2*r;
		for(t=180; t>=90 ; t-=10) {
			tiny3d_VertexPos( x + r*cos(t*PI/180), y + r*sin(t*PI/180), z);
		}
		x+= w-2*r;
		for(t=90; t>=0 ; t-=10) {
			tiny3d_VertexPos( x + r*cos(t*PI/180), y + r*sin(t*PI/180), z);
		}
		y-= h-2*r;
		for(t=0; t>=-90 ; t-=10) {
			tiny3d_VertexPos( x + r*cos(t*PI/180), y + r*sin(t*PI/180), z);
		}
		
		tiny3d_End();
	}
	
}

void Draw_BoxLine(float x, float y, float z, float w, float h, u32 color)
{
	tiny3d_SetPolygon(TINY3D_LINE_LOOP);
	tiny3d_VertexPos(x , y , z);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x+w , y , z);
	tiny3d_VertexPos(x+w , y+h , z);
	tiny3d_VertexPos(x   , y+h , z);
	tiny3d_End();
}

void Draw_LineBoxOutside(float x, float y, float z, float e, float w, float h, u32 color)
{
	Draw_Box(x-e, y-e, z, 0, e, h+2*e, color, NO);
	Draw_Box(x+w, y-e, z, 0, e, h+2*e, color, NO);
	
	Draw_Box(x, y-e, z, 0, w, e, color, NO);
	Draw_Box(x, y+h, z, 0, w, e, color, NO);
}

void Draw_LineBoxInside(float x, float y, float z, float e, float w, float h, u32 color)
{
	//VERTICALS
	Draw_Box(x, y, z, 0, e, h, color, NO);
	Draw_Box(x+w-e, y, z, 0, e, h, color, NO);
	
	//HORIZONTALS
	Draw_Box(x+e, y, z, 0, w-2*e, e, color, NO);
	Draw_Box(x+e, y+h-e, z, 0, w-2*e, e, color, NO);
}

void DrawCapacityBar(float x, float y, float z, float w, float h, u64 TotalSpace, u64 FreeSpace)
{
	if( TotalSpace == 0) return;
	if(y<0) return;
	
	float t, u;
	simple(TotalSpace, t);
	simple(TotalSpace - FreeSpace, u);
	float w2 = u * w / t ;
	
	Draw_BoxGradiant(VERTICAL, x, y, z, w, h, WHITE, 0xCCCCCCFF, NO);
	Draw_BoxGradiant(VERTICAL, x, y, z, w2, h, 0xEAEAFFFF, 0x9C9CFFFF, NO);
	Draw_BoxLine(x,	y, z, w, h, 0xA0A0A0FF);
}

u32 color_light(u32 color)
{
	return GetRED(color)/2 * 0x1000000 + GetGREEN(color)/2 * 0x10000 + GetBLUE(color)/2 * 0x100 + GetALPHA(color);
}

float Draw_toggle(float x, float y, float z, float h, u8 state, u8 active)
{
	
	if( PICTURE_offset[TOGGLE_ON] && PICTURE_offset[TOGGLE_OFF] ) {
		u32 color = WHITE;
		if(!active) color = SetALPHA(GetALPHA(color)/2, color);
		
		u8 toggle = TOGGLE_OFF;
		if(state) toggle = TOGGLE_ON;
		
		tiny3d_SetTexture(0, PICTURE_offset[toggle], PICTURE[toggle].width, PICTURE[toggle].height, PICTURE[toggle].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, 2*h, h, color, YES);
	} else {
		
		u32 color = COLOR_2;	
		if(!state) color = 0.299*GetRED(color) + 0.587*GetGREEN(color) + 0.114*GetBLUE(color);
		u32 color2 = color_light(color);
		
		if(!active) {
			color = SetALPHA(GetALPHA(color)/2, color);
			color2 = SetALPHA(GetALPHA(color)/2, color2);
		}
		
		float rb = (h/4);
		float xb = x + (h/2) - rb;
		float yb = y + (h/2) - rb;
		float hb = 2*rb;
		float wb = (h/2)*3;
		
		Draw_Box(xb, yb, z, rb, wb, hb, color2, NO);
		
		
		float xc = xb + rb;
		if( state ) xc = xb + wb - rb;
		float yc = yb + rb;
		float rc = (h/2);
		
		int t;
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(color);
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( xc + rc*sin(t*PI/180), yc + rc*cos(t*PI/180), z);
		}
		tiny3d_End();
	}
	
	return x + 2*h;
}

float Draw_checkbox(float x, float y, float z, char *str, u8 state, u8 active)
{
	if( PICTURE_offset[CHECKBOX_FALSE] && PICTURE_offset[CHECKBOX_TRUE]) {		
		u32 color = WHITE;
		if(!active) color = SetALPHA(3*GetALPHA(color)/4, color);
		
		u8 cb = CHECKBOX_FALSE;
		if(state) cb = CHECKBOX_TRUE;
		
		tiny3d_SetTexture(0, PICTURE_offset[cb], PICTURE[cb].width, PICTURE[cb].height, PICTURE[cb].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, 14, 14, color, YES);
	} else {
		
		u32 color = COLOR_1;
		if(active) color = COLOR_2;
		
		Draw_Box(x, y, 0, 0, 14, 14, color, NO);
		Draw_Box(x+2, y+2, 0, 0, 10, 10, BLACK, NO);
		
		if(state) Draw_Box(x+3, y+3, 0, 0, 8, 8, COLOR_2, NO);
	}
	
	if(active) FontColor(COLOR_2);
	else FontColor(COLOR_1);
	
	FontSize(15);
	
	return DrawString(x+20, y, str);
}

float Draw_itembox(float x, float y, float z, char *str, u8 state, u8 active, u8 error, u32 color)
{
	if( error ) Draw_Box(x-1.5, y-1.5, 0, 0, 17, 17, color, NO);
	
	return Draw_checkbox(x, y, z, str, state, active);
}

void Draw_title(float x, float y, char *str)
{
	int xt;
	FontSize(18);
	Draw_Box(x+5, y+4, 9, 0, 8, 8, COLOR_3, NO);
	FontColor(COLOR_3);
	xt=DrawString(x+20, y, str);
	y+=18;
	Draw_Box(x, y, 9, 0, xt-x, 2, COLOR_3, NO); //underline
	FontSize(15);
	FontColor(COLOR_1);
}

u8 is_ntfs(char *path)
{
	u8 n=0;
	if(path[0] == '/') n=1;
	if( strncmp(&path[n], "ntfs", 4) == 0) return YES;
	
	return NO;
}

u8 support_big_files(char *path)
{
	if( is_exFAT(path) ) return YES;
	if( is_ntfs(path) ) return YES;
	if( strncmp(path, "/dev_hdd0", 9) == 0) return YES;
	
	return NO;
}

// this one (recursive) use mkdir from mgz_io.h, 
// so, it support ntfs/exfat
int MGZ_mkdir_recursive(char *path)
{
	struct stat stat_buf;
	if (stat(path, &stat_buf) == 0 ) return 0;
	
	int len = strlen (path);
	char *temp = malloc (len + 1);
	int i;
	int ret = 0;

	memcpy (temp, path, len);

	if (temp[0] == '/')
		i = 1;
	else
		i = 0;
	while (i < len) {
		for (; i < len && temp[i] != '/'; i++);
		temp[i] = 0;
		if (stat (temp, &stat_buf) != 0) {
			ret = mkdir(temp, 0777);
			if (ret != 0) goto end;
		}
		if (i < len)
			temp[i] = '/';
		i++;
	}
end:
	free(temp);
	return ret;
}

u8 path_info(char *path) 
{
	struct stat s;
	if(stat(path, &s) != 0) return _NOT_EXIST;
	if(S_ISDIR(s.st_mode)) return _DIRECTORY; else
	return _FILE;
}

u8 exist(char *path)
{
	if(path_info(path) == _NOT_EXIST) return NO;
	return YES;
}

u8 can_opendir(char *path)
{
	DIR *d=NULL;
	d = opendir(path);
	if(d==NULL) return NO;
	closedir(d);
	
	return YES;
}

char *GetExtension(char *path)
{
    int n = strlen(path);
    int m = n;

    while(m > 0 && path[m] != '.' && path[m] != '/') m--;
    
	if(path[m] != '.') return &path[n];
	
    if(strcmp(&path[m], ".0")==0 || strcmp(&path[m], ".66600")==0) { // splitted
       int o = m-1;
       while(o > 0 && path[o] != '.' && path[o] != '/') o--;
       if(path[o]=='.') m=o;
    }
	
	if(strcasecmp(&path[m], ".gz")==0) {
		if(strcasecmp(&path[m-4], ".tar.gz")==0) {
			m-=4;
		}
	}
	if(strcasecmp(&path[m], ".bz2")==0) {
		if(strcmp(&path[m-4], ".tar.bz2")==0) {
			m-=4;
		}
	}
	if(strcasecmp(&path[m], ".iso")==0) {
		if(strcasecmp(&path[m-4], ".enc.iso")==0) {
			m-=4;
		}
	}
	
    if(path[m] == '.') return &path[m];

    return &path[n];
}

void RemoveExtension(char *path)
{
    char *extension = GetExtension(path);
	
    int le = strlen(extension);
    int lp = strlen(path);
    
    while(le>0) {path[lp-le]=0; le--;}
}

s8 ddsLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{
	print_load("ddsRead");
	(*data).bmp_out = ddsRead(buffer, DDS_READER_ARGB, 0);
	if( (*data).bmp_out == NULL) return -1;
	
	print_load("ddsGetWidth");
	(*data).width = ddsGetWidth(buffer);
	print_load("ddsGetHeight");
	(*data).height = ddsGetHeight(buffer);
	print_load("ddsGetPitch");
	(*data).pitch = ddsGetWidth(buffer)*4;
	
	return 0;
}

s8 ddsLoadFromFile(char *imgPath, imgData *data)
{
	int file_size;

	u8 *buffer = (u8 *) LoadFile(imgPath, &file_size);
	if( buffer == NULL) return -1;
	
	int ret = ddsLoadFromBuffer((const void *) buffer, file_size, data);
	
	free(buffer);
	
	return ret;
}

s8 tgaLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{
	print_load("tgaRead");
	(*data).bmp_out = tgaRead(buffer, TGA_READER_ARGB);
	if( (*data).bmp_out == NULL) return -1;
	
	print_load("tgaGetWidth");
	(*data).width = tgaGetWidth(buffer);
	print_load("tgaGetHeight");
	(*data).height = tgaGetHeight(buffer);
	print_load("tgaGetPitch");
	(*data).pitch = tgaGetWidth(buffer)*4;
	
	return 0;
}


s8 tgaLoadFromFile(char *imgPath, imgData *data)
{
	int file_size;

	u8 *buffer = (u8 *) LoadFile(imgPath, &file_size);
	if( buffer == NULL) return -1;
	
	int ret = tgaLoadFromBuffer((const void *) buffer, file_size, data);
	
	free(buffer);
	
	return ret;
}

s8 gtfLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{
	
	uint8_t *dds_buffer=NULL;
	uint32_t dds_size=0;
	
	gtf2ddsFromBuffer((uint8_t *) buffer, (uint32_t) file_size, &dds_buffer, &dds_size,  0, 0);
	
	if( dds_size == 0 || dds_buffer == NULL ) return -1;
	
	int ret = ddsLoadFromBuffer((const void *) dds_buffer, dds_size, data);
	
	free(dds_buffer);
	
	return ret;
}

// (https://www.psdevwiki.com/ps3/Graphic_Image_Map_(GIM))
typedef struct      
{
	u32 signature; // PS3 : ".GIM"
	u32 version;
	u32 format_style;
	u32 unk;  
} gim_file_header;


// block_id
#define GIM_BLOCK_ROOT     2
#define GIM_BLOCK_PICTURE  3
#define GIM_BLOCK_IMAGE    4
#define GIM_BLOCK_PALETTE  5
#define GIM_BLOCK_FILEINFO 0xFF

typedef struct
{
	u16 id;
	u16 unk;
	u32 size;       
	u32	header_next;       
	u32 data_offset;     
} gim_block_header;
 
#define GIM_IMAGE_FORMAT_RGBA5650 		0x00 	//(16 bit no alpha)
#define GIM_IMAGE_FORMAT_RGBA5551 		0x01 	//(16 bit sharp alpha)
#define GIM_IMAGE_FORMAT_RGBA4444 		0x02 	//(16 bit gradient alpha)
#define GIM_IMAGE_FORMAT_RGBA8888 		0x03 	//(32 bit gradient alpha)
#define GIM_IMAGE_FORMAT_INDEX4 		0x04 	//(16 colors)
#define GIM_IMAGE_FORMAT_INDEX8 		0x05 	//(256 colors)
#define GIM_IMAGE_FORMAT_INDEX16 		0x06 	//(16 colors with alpha ?)
#define GIM_IMAGE_FORMAT_INDEX32 		0x07 	//(256 colors with alpha ?)
#define GIM_IMAGE_FORMAT_DXT1 			0x08 	//(no alpha)
#define GIM_IMAGE_FORMAT_DXT3 			0x09 	//(sharp alpha)
#define GIM_IMAGE_FORMAT_DXT5 			0x0A 	//(gradient alpha)
#define GIM_IMAGE_FORMAT_DXT1EXT	    0x108
#define GIM_IMAGE_FORMAT_DXT3EXT	    0x109
#define GIM_IMAGE_FORMAT_DXT5EXT		0x10A

#define GIM_PIXEL_ORDER_NORMAL			0x0
#define GIM_PIXEL_ORDER_FAST			0x1

typedef struct
{
	u16 data_lenght;
	u16 b45_unk1;
	u16 image_format;       
	u16	pixel_order;       
	u16 width;
	u16 height;
	u16 bpp;
	u16 pitch_align;
	u16 height_align;
	u16 b45_unk2;
	u32 b45_unk3;
	u32 index_start; // relative offset of block_image_index
	u32 pixels_start;
	u32 pixels_end;
	u32 plane_mask;
	u16 level_type;
	u16 level_count;
	u16 frame_type;
	u16 frame_count;
} gim_block_image_data;

u8 get_pad(u32 align, u32 size)
{
	return (~size + 1) & (align - 1);
}

s8 gimLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{
	u8 *buff = (u8 *) buffer;
	
	//print_load("gim signature");
	gim_file_header file_header;
	memcpy(&file_header, buff, sizeof(gim_file_header));
	if(file_header.signature != 0x2E47494D ) {
		//print_load("bad magic gimLoadFromBuffer");
		return -1;
	}
	
	gim_block_header block;
	
	u32 pos = sizeof(gim_file_header);
	
	//print_load("Search GIM_BLOCK_IMAGE");
		
	while(1) {	
		memcpy(&block, buff + pos, sizeof(gim_block_header));
		
		//print_load("* block offset 0x%X, block.id 0x%X", pos, block.id);
		if( block.id == GIM_BLOCK_IMAGE ) {
			pos += block.data_offset;
			break;
		}
		pos += block.header_next;
		
		if( pos > file_size) {
			//print_load("GIM_BLOCK_IMAGE not found");
			return -1;
		}
	}
	
	gim_block_image_data image_data;
	memcpy(&image_data, buff + pos, sizeof(gim_block_image_data));
	
	if( image_data.image_format != GIM_IMAGE_FORMAT_RGBA8888) {
		//print_load("Unsupported format %X", image_data.image_format);
		return -1;
	}
	/*
	if( DEBUG ) {
		sprintf(picture_viewer_info,
		"data_lenght   0x%02X\n"
		"b45_unk1      0x%04X\n"
		"image_format; 0x%04X\n"
		"pixel_order;  0x%04X\n"     
		"width;        0x%04X\n"
		"height;       0x%04X\n"
		"bpp           0x%04X\n"
		"pitch_align;  0x%04X\n"
		"height_align; 0x%04X\n"
		"b45_unk2      0x%04X\n"
		"b45_unk3      0x%08X\n"
		"index_start;  0x%08X\n"
		"pixels_start; 0x%08X\n"
		"pixels_end;   0x%08X\n"
		"plane_mask;   0x%08X\n"
		"level_type;   0x%04X\n"
		"level_count;  0x%04X\n"
		"frame_type;   0x%04X\n"
		"frame_count;  0x%04X\n",
		image_data.data_lenght,
		image_data.b45_unk1,
		image_data.image_format,
		image_data.pixel_order,
		image_data.width,   
		image_data.height,     
		image_data.bpp,        
		image_data.pitch_align,
		image_data.height_align,
		image_data.b45_unk2,
		image_data.b45_unk3,
		image_data.index_start,
		image_data.pixels_start,
		image_data.pixels_end, 
		image_data.plane_mask, 
		image_data.level_type, 
		image_data.level_count,
		image_data.frame_type,
		image_data.frame_count);
	}
	*/
	
	u8 *rgba = buff + pos + image_data.pixels_start;
		
	(*data).width=image_data.width;
	(*data).height=image_data.height;
	(*data).pitch=(*data).width*4;
	
	(*data).bmp_out = (u8 *) malloc((*data).pitch * (*data).height);
	if( (*data).bmp_out == NULL) {
		print_load("malloc gimLoadFromBuffer");
		return -1;
	}
	
	u8 pad = get_pad(image_data.pitch_align, image_data.width * image_data.bpp/8);
	
	s64 i = 0;
	s64 k = 0;
	s64 j = 0;
	for (i = 0; i<(*data).height ; i++) {
		k=i*(*data).width;
		for (j=k; j < k+(*data).width; j++) {	
			u8 ARGB[4]={0};
			ARGB[0] = rgba[j*4 + i*pad + 3];
			ARGB[1] = rgba[j*4 + i*pad   ];
			ARGB[2] = rgba[j*4 + i*pad + 1];
			ARGB[3] = rgba[j*4 + i*pad + 2];
			memcpy((*data).bmp_out + j*4, ARGB, 4);
		}
	}
	
	return 0;
}


s8 webpLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{

	int height, width;
	(*data).bmp_out = WebPDecodeARGB((const uint8_t*) buffer, (size_t) file_size, &width, &height);
	if((*data).bmp_out==NULL) return -1;

	
	(*data).width = width;
	(*data).height= height;
	(*data).pitch = width*4;
	
	
	return 0;
}

s8 tiffLoadFromFile(char *file, imgData *data)
{
	print_load("TIFFOpen");
	TIFF* tif = TIFFOpen(file, "r");
	if( tif ==  NULL) return -1;
	
	u8 *abgr=NULL;
	
	print_load("TIFFGetField width");
	if( TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &(*data).width) != 1) goto error;
    print_load("TIFFGetField height");
	if( TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &(*data).height) != 1) goto error;
	
	(*data).pitch = (*data).width*4;
	
	print_load("malloc abgr");
	abgr = (u8 *) malloc( (*data).pitch * (*data).height);
	if(!abgr) goto error;
	memset(abgr, 0, (*data).pitch * (*data).height);
	
	print_load("TIFFReadRGBAImageOriented");
	// it's ABGR !
	if ( TIFFReadRGBAImageOriented(tif, (*data).width, (*data).height, (uint32_t *) abgr, ORIENTATION_TOPLEFT, 0) != 1) goto error;
	
	print_load("malloc bmp_out");
	(*data).bmp_out = (u8 *) malloc((*data).pitch * (*data).height);
	if(!(*data).bmp_out) goto error;
	
	print_load("loop");
	s64 i = 0;
	s64 k = 0;
	s64 j = 0;
	for (i = 0; i<(*data).height ; i++) {
		k=i*(*data).width;
		for (j=k; j < k+(*data).width; j++) {	
			u8 ARGB[4]={0};
			ARGB[0] = abgr[j*4 + 0];
			ARGB[1] = abgr[j*4 + 3];
			ARGB[2] = abgr[j*4 + 2];
			ARGB[3] = abgr[j*4 + 1];
			memcpy((*data).bmp_out + j*4, ARGB, 4);
		}
	}
	
	print_load("FREE");
	FREE(abgr);
	print_load("TIFFClose");
	if(tif) TIFFClose(tif);
	
	return 0;
	
error:
	
	print_load("error");
	FREE((*data).bmp_out)
	FREE(abgr);
	if(tif) TIFFClose(tif);
	return -1;
}

u8 imgLoadFromFile(char *imgPath, imgData *out, u8 gray)
{
	//memset(picture_viewer_info, 0, sizeof(picture_viewer_info));
	
	int file_size = 0;
	
	out->bmp_out = NULL;
		
	char *buff = LoadFile((char *) imgPath, &file_size);
	if(buff==NULL) return FAILED;
	
	int ret=-1;
	imgData tp;
	char *ext = get_ext(imgPath);
	if( !strcasecmp(ext, ".png") ) {
		ret = pngLoadFromBuffer((const void *) buff, file_size, (pngData *) &tp);
	} else 
	if( !strcasecmp(ext, ".jpg") || !strcasecmp(ext, ".jpeg") || !strcasecmp(ext, ".jpe")) {
		ret = jpgLoadFromBuffer((const void *) buff, file_size, (jpgData *) &tp);
	} else 
	if( !strcasecmp(ext, ".dds") ) {
		ret = ddsLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	} else 
	if( !strcasecmp(ext, ".tga") ) {
		ret = tgaLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	} else 
	if( !strcasecmp(ext, ".bmp") ) {
		ret = bmpLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	} else
	if( !strcasecmp(ext, ".gim") ) {
		ret = gimLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	} else 
	if( !strcasecmp(ext, ".webp") ) {
		ret = webpLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	} else
	if( !strcasecmp(ext, ".gtf")) {
		ret = gtfLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	} else
	if( !strcasecmp(ext, ".tiff") || !strcasecmp(ext, ".tif") ) {
		ret = tiffLoadFromFile(imgPath, (imgData *) &tp);
	}
	
	if( ret != 0 ) {
		ret = MagickLoadFromBuffer((const void *) buff, file_size, (imgData *) &tp);
	}
	
	FREE(buff);
	
	if( ret != 0 ) return FAILED;
	
	out->height = tp.height;
	out->width = tp.width;
	out->pitch = tp.pitch;
	out->bmp_out = (u8 *) malloc(tp.pitch*tp.height+1);
	
	if( gray ) {
					
		u64 d;

		// L8
		// out->height = tp.height;
		// out->width = tp.width;
		// out->pitch = tp.pitch/4;
		// out->bmp_out = (u8 *) malloc(tp.pitch*tp.height/4+1);

		// for(d=0; d< tp.pitch*tp.height; d+=4) {
			// u8 ARGB[4];
			// memcpy(&ARGB, tp.bmp_out+d, 4);
			// u8 Y = (0.299*ARGB[1] + 0.587*ARGB[2] + 0.114*ARGB[3])*((float) (ARGB[0]/0xFF));
			// memcpy(out->bmp_out + d/4, &Y, 1);
		// }
		
		for(d=0; d< tp.pitch*tp.height; d+=4) {
			u8 ARGB[4];
			memcpy(&ARGB, tp.bmp_out+d, 4);
			u8 Y = (0.299*ARGB[1] + 0.587*ARGB[2] + 0.114*ARGB[3]);
			
			u8 new_ARGB[4]={0};
			new_ARGB[0] = ARGB[0];
			new_ARGB[1] = Y;
			new_ARGB[2] = Y;
			new_ARGB[3] = Y;
			
			memcpy(out->bmp_out + d, new_ARGB, 4);
		}
		
	} else {
		memcpy(out->bmp_out, tp.bmp_out, tp.pitch*tp.height);
	}

	free(tp.bmp_out);
	
	return SUCCESS;
}


u8 convert_to_png(char *src, char *dst)
{
	imgData DataPic;
	
	if( imgLoadFromFile(src, &DataPic, NO) == FAILED ) return FAILED;
	
	if( make_png(dst, DataPic) == FAILED )  return FAILED;
	
	FREE(DataPic.bmp_out);

	return SUCCESS;
}

//*******************************************************
// SCREENSHOT
//******************************************************

// https://en.wikipedia.org/wiki/BMP_file_format
typedef struct                       /**** BMP file header structure ****/
{
	u32 bfSize;           /* Size of file */
	u16 bfReserved1;      /* Reserved */
	u16 bfReserved2;      /* ... */
	u32 bfOffBits;        /* Offset to bitmap data */
} bmp_file_header;

typedef struct                       /**** BMP file info structure ****/
{
	u32 biSize;           /* Size of info header */
	s32 biWidth;          /* Width of image */
	s32 biHeight;         /* Height of image */
	u16	biPlanes;         /* Number of color planes */
	u16 biBitCount;       /* Number of bits per pixel */
	u32 biCompression;    /* Type of compression to use */
	u32 biSizeImage;      /* Size of image data */
	s32 biXPelsPerMeter;  /* X pixels per meter */
	s32 biYPelsPerMeter;  /* Y pixels per meter */
	u32 biClrUsed;        /* Number of colors used */
	u32 biClrImportant;   /* Number of important colors */
} bmp_info_header;


void es_bmp_file_header(bmp_file_header *w)
{
	w->bfSize = ENDIAN_SWAP_32(w->bfSize);
	w->bfReserved1 = ENDIAN_SWAP_16(w->bfReserved1);
	w->bfReserved2 = ENDIAN_SWAP_16(w->bfReserved2);
	w->bfOffBits = ENDIAN_SWAP_32(w->bfOffBits);  
}

void es_bmp_info_header(bmp_info_header *w)
{
	w->biSize = ENDIAN_SWAP_32(w->biSize);
	w->biWidth = ENDIAN_SWAP_32(w->biWidth); 
	w->biHeight = ENDIAN_SWAP_32(w->biHeight);    
	w->biPlanes = ENDIAN_SWAP_16(w->biPlanes);       
	w->biBitCount = ENDIAN_SWAP_16(w->biBitCount);     
	w->biCompression = ENDIAN_SWAP_32(w->biCompression);  
	w->biSizeImage = ENDIAN_SWAP_32(w->biSizeImage);    
	w->biXPelsPerMeter = ENDIAN_SWAP_32(w->biXPelsPerMeter);
	w->biYPelsPerMeter = ENDIAN_SWAP_32(w->biYPelsPerMeter);
	w->biClrUsed = ENDIAN_SWAP_32(w->biClrUsed);      
	w->biClrImportant = ENDIAN_SWAP_32(w->biClrImportant); 
}

s8 bmpLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{
	bmp_file_header bfh;
	bmp_info_header bih;
	
	u8 *buff = (u8 *) buffer;
	
	print_load("Magic bmpLoadFromBuffer");
	char magic[2];
	memcpy(magic, buff, 2);
	if( magic[0] != 'B' || magic[1] != 'M') {
		print_load("Magic bmpLoadFromBuffer");
		return -1;
	}
	
	print_load("bfh memcpy bmpLoadFromBuffer");
	memcpy(&bfh, buff + 2, sizeof(bmp_file_header));
	print_load("bih memcpy bmpLoadFromBuffer");
	memcpy(&bih, buff + 2 + sizeof(bmp_file_header), sizeof(bmp_info_header));
	
	print_load("bih es_bmp_file_header bmpLoadFromBuffer");
	es_bmp_file_header(&bfh);
	print_load("bih es_bmp_info_header bmpLoadFromBuffer");
	es_bmp_info_header(&bih);
		
	if( bih.biWidth < 0 || bih.biHeight < 0) {
		print_load("bih.biHeight < 0 || bih.biWidth < 0 bmpLoadFromBuffer");
		return -1;
	}
	
	u32 BPP = bih.biBitCount / 8;
	
	if( BPP != 4 && BPP != 3 && BPP != 1) {
		print_load("Error : bmpLoadFromBuffer BPP %d ", BPP);
		return -1;
	}
	
	print_load("pixels malloc bmpLoadFromBuffer");
	u8 *pixels = (u8 *) malloc(bih.biWidth * bih.biHeight * 4);
	if (pixels == NULL) {
		print_load("Error : pixels malloc bmpLoadFromBuffer");
		return -1;
	}
	
	print_load("bmpLoadFromBuffer loop");

	u8 pad  = (4 - ((3*bih.biWidth) & 3)) & 3;
	
	s64 i = 0;
	s64 k = 0;
	s64 l = 0;
	s64 j = 0;
	for (i = bih.biHeight-1; 0<=i ; i--)
	{
		k=i*bih.biWidth;
		for (j=k; j < k+bih.biWidth; j++)
		{	
			pixels[l] = 0xFF; // alpha
			l++;
			if( BPP == 1 ) {
				pixels[l] = buff[bfh.bfOffBits + j + i*pad];
				l++;        
				pixels[l] = buff[bfh.bfOffBits + j + i*pad];
				l++;        
				pixels[l] = buff[bfh.bfOffBits + j + i*pad];
				l++;
			} else
			if( BPP == 3 || BPP == 4) {
				pixels[l] = buff[bfh.bfOffBits + j*BPP + i*pad + 2];
				l++;        
				pixels[l] = buff[bfh.bfOffBits + j*BPP + i*pad + 1];
				l++;        
				pixels[l] = buff[bfh.bfOffBits + j*BPP + i*pad   ];
				l++;
			}
			
		}
	}
	
	print_load("bmpLoadFromBuffer memcpy bmp_out");
	(*data).bmp_out	= (u8 *) malloc(bih.biWidth * bih.biHeight * 4); 
	memcpy((*data).bmp_out, pixels, bih.biWidth * bih.biHeight * 4);

	free(pixels);
	
	(*data).width = bih.biWidth;
	(*data).height = bih.biHeight;
	(*data).pitch = (*data).width*4;
	
	return 0;
}

u8 SaveBMP(char *bmp_path, u8 *pixels, u32 x, u32 y, u32 w, u32 h)
{

	print_load("Open file %s", bmp_path);
	FILE *f = fopen(bmp_path, "wb");
	if (!f) {
		print_load("Error : failed to open %s", bmp_path);
		return FAILED;
	}
	
	print_load("Define headers");
	bmp_file_header bfh;
	bmp_info_header bih;

	u32 size_of_file_header = sizeof(bmp_file_header);
	u32 size_of_info_header = sizeof(bmp_info_header);
	
	unsigned short bfType=0x424D; // magic "BM"       
	bfh.bfReserved1 = 0;
	bfh.bfReserved2 = 0;
	bfh.bfSize = 2 + size_of_file_header + size_of_info_header + w * h * 3;
	bfh.bfOffBits = 2 + size_of_file_header + size_of_info_header;

	bih.biSize = size_of_info_header;
	bih.biWidth = w;
	bih.biHeight = h;
	bih.biPlanes = 1;
	bih.biBitCount = 24;
	bih.biCompression = 0;
	bih.biSizeImage = 0;
	bih.biXPelsPerMeter = 0;
	bih.biYPelsPerMeter = 0;
	bih.biClrUsed = 0;
	bih.biClrImportant = 0;

	es_bmp_file_header(&bfh);
	es_bmp_info_header(&bih);

print_load("Write headers");
	fwrite(&bfType,1,sizeof(bfType),f);
	fwrite(&bfh, 1, sizeof(bfh), f);
	fwrite(&bih, 1, sizeof(bih), f);
	
print_head("Get bitmap data...");
	s64 i;
	s64 j;
	s64 k;
	u64 l=0;
	u8 pad  = (4 - ((3*w) & 3)) & 3;
	u8 *bitmap= (u8 *) malloc(w*h*3 + h*pad + 1); 
	prog_bar1_value = 0;
	for(i=y+h-1; i>=y; i--) {
		k=i*Video_Resolution.width;
		prog_bar1_value = (y+h-1-i)/h;
		for(j=x+k; j<x+k+w; j++) {
			bitmap[l] = pixels[3+j*4];
			l++;
			bitmap[l] = pixels[2+j*4];
			l++;
			bitmap[l] = pixels[1+j*4];
			l++;
		}
		for(j=0; j<pad; j++) {
			bitmap[l] = 0; 
			l++;
		}
	}

print_head("Writing bitmap data...");
	prog_bar1_value = 0;
	int write = 0;
	while(write < l) {
		int wrlen = 1024;
		if(write+wrlen > l) wrlen = l-write;
		fwrite(bitmap+write, wrlen, 1, f);
		write += wrlen;
		prog_bar1_value = (write*100) / l;
	}
	prog_bar1_value = -1;
	
	fclose(f);
	
	SetFilePerms(bmp_path);
	
	free(bitmap);
	
	return SUCCESS;
}

void ScreenShot()
{
	if( ComboNewPad(BUTTON_L2, BUTTON_R2) == NO ) return;

	if(Video_currentBuffer==NO) return;
	
	u8 *mem = malloc(Video_Resolution.width*Video_Resolution.height*4 + 1);
	memcpy(mem, Video_buffer[1], Video_Resolution.width*Video_Resolution.height*4);
	
	if( DEBUG ) start_loading();
	
	print_load("Get size scaled...");
	double sx = (double) Video_Resolution.width;
	double sy = (double) Video_Resolution.height;
	double psx = (double) (1000 + videoscale_x)/1000.0;
	double psy = (double) (1000 + videoscale_y)/1000.0;
	
	u32 w = (u32) (sx * psx);
	u32 h = (u32) (sy * psy);
	u32 x = (u32) (((u32)sx - w) / 2);
	u32 y = (u32) (((u32)sy - h) / 2);
	
	mkdir("/dev_hdd0/photo", 0777);
	
	char ScreenShotPath[128];
	int o;
	for(o=0; o<1000; o++) {
		sprintf(ScreenShotPath, "/dev_hdd0/photo/ManaGunZ_%03d.bmp", o);
		if(path_info(ScreenShotPath) == _NOT_EXIST) break;
	}
	
	SaveBMP(ScreenShotPath, mem, x, y, w, h);
	
	FREE(mem);

	end_loading();
}

//*******************************************************
// NPDATA  -  EDAT / SDAT
//*******************************************************

u8 npd_bf_elf(char *dir_path, char *npd_file, u8 *rifkey, u8 *dev_klicensee)
{
	u8 ret = FAILED;
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(dir_path);
	if(d==NULL) return ret;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		char full_path[1024]={0};
		sprintf(full_path, "%s/%s", dir_path, dir->d_name);
		
		if(dir->d_type & DT_DIR) {
			npd_bf_elf(full_path, npd_file, rifkey, dev_klicensee);
			continue;
		}
		
		char *ext = GetExtension(dir->d_name);
		
		if( !strcasecmp(ext, ".elf") || !strcasecmp(ext, ".prx") || !strcasecmp(dir->d_name, _EBOOT_ELF)) {
			ret = npdata_bruteforce(npd_file, full_path, NPDATA_BF_MODE_BINARY | NPDATA_BF_MODE_TEXT | NPDATA_BF_MODE_UNICODE, dev_klicensee);
			if(ret == SUCCESS) {
				break;
			}
		} else
		if( !strcasecmp(dir->d_name, _EBOOT_BIN) || !strcasecmp(ext, ".self") || !strcasecmp(ext, ".sprx") ) {
			char out[1024]={0};
			strcpy(out, full_path);
			RemoveExtension(out);
			if( !strcasecmp(dir->d_name, _EBOOT_BIN) ) {
				strcat(out, ".elf");
			} else
			if( !strcasecmp(ext, ".self") ) {
				strcat(out, ".elf");
			} else
			if( !strcasecmp(ext, ".sprx") ) {
				strcat(out, ".prx");
			}
			
			if( Extract_SELF(full_path, out, rifkey) == SUCCESS) {
				ret = npdata_bruteforce(npd_file, out, NPDATA_BF_MODE_BINARY | NPDATA_BF_MODE_TEXT | NPDATA_BF_MODE_UNICODE, dev_klicensee);
				Delete(out);
				if(ret == SUCCESS) {
					break;
				}
			}
		}
	}
	
	closedir(d);
	
	return ret;
}

u8 npd_decrypt(char *in)
{
	char out[1024]={0};
	char content_id[36]={0};
	char rap_path[1024]={0};
	char rif_path[1024]={0};
	u8 rifkey[0x10]={0};
	char home[] = "/dev_hdd0/home";
	char klic_db[512]={0};
	u8 dev_klicensee[0x10]={0};
	int i;
	
	
//	get content_id
	FILE *fi = fopen(in, "rb");
	if(fi==NULL) {
		print_load("Error : cannot fopen %s", in);
		return FAILED;
	}
	fseek(fi, 0x10, SEEK_SET);
	fread(content_id, 36, 1, fi);
	fclose(fi);
	
//	set out
	strcpy(out, in);
	RemoveExtension(out);
	strcat(out, ".dat");
	
//	search rap/rif file
	DIR *d;
	struct dirent *dir;
	
	d = opendir(home);
	if(d!=NULL) {
		while ((dir = readdir(d))) {
			if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
			
			memset(rap_path, 0, 1024);
			memset(rif_path, 0, 1024);
			 
			sprintf(rap_path, "%s/%s/exdata/%s.rap", home, dir->d_name, content_id);
			print_load(rap_path);
			if(path_info(rap_path) == _FILE) {
				closedir(d);
				goto get_rif_key;
			}
			sprintf(rif_path, "%s/%s/exdata/%s.rif", home, dir->d_name, content_id);
			print_load(rif_path);
			if(path_info(rif_path) == _FILE) {
				closedir(d);
				goto get_rif_key;
			}
		}
		closedir(d);
	}
	
	for(i=0; i<=device_number; i++) {
		memset(rap_path, 0, 1024);
		memset(rif_path, 0, 1024);
		
		sprintf(rap_path, "/%s/exdata/%s.rap", list_device[i], content_id);
		if(path_info(rap_path) == _FILE) {
			goto get_rif_key;
		}
		
		sprintf(rif_path, "/%s/exdata/%s.rif", list_device[i], content_id);
		if(path_info(rif_path) == _FILE) {
			goto get_rif_key;
		}
	}
	
get_rif_key:
	get_rifkey(rif_path, rap_path, rifkey);

	// get dev_klic
	sprintf(klic_db, "/dev_hdd0/game/%s/USRDIR/sys/dev_klics.txt", ManaGunZ_id);
	if( npdata_bruteforce(in, klic_db, NPDATA_BF_MODE_LINES_STREAM, dev_klicensee) == SUCCESS) {
		goto decrypt;
	}
	
	// webman MOD
	if( npdata_bruteforce(in, "/dev_hdd0/klic.log", NPDATA_BF_MODE_LINES_STREAM, dev_klicensee) == SUCCESS) {
		goto db_add;
	}
	
	// evilnat CFW
	if( npdata_bruteforce(in, "/dev_hdd0/tmp/cfw_settings.log", NPDATA_BF_MODE_LINES_STREAM, dev_klicensee) == SUCCESS) {
		goto db_add;
	}
	
	// mysis xai_plugin
	if( npdata_bruteforce(in, "/dev_hdd0/tmp/cfw-settings.log", NPDATA_BF_MODE_LINES_STREAM, dev_klicensee) == SUCCESS) {
		goto db_add;
	}
	
	// mysis poc
	if( npdata_bruteforce(in, "/dev_hdd0/game/PRXLOADER/USRDIR/PS3_PPU_Project1.log", NPDATA_BF_MODE_LINES_STREAM, dev_klicensee) == SUCCESS) {
		goto db_add;
	}
	
	// search in self, sprx -> elf, prx
	char *pt = strstr(in, "USRDIR");
	char usrdir[512]={0};
	if(pt) {
		strncpy(usrdir, in, pt - in + 6);
		printf(usrdir);
		if( npd_bf_elf(usrdir, in, rifkey, dev_klicensee) == SUCCESS) {
			goto db_add;	
		}
	}
	
	print_load("Error : cannot find dev_klicensee");
	return FAILED;
	
db_add: ;
	char rifkey_str[0x20]={0};
	FILE *db = fopen(klic_db, "a");
	if( db == NULL) goto db_upload;
	for(i=0; i<0x10; i++) {
		sprintf(rifkey_str + i*2, "%02X", rifkey[i]);
	}
	fputs(rifkey_str, db);
	fputs("\n", db);
	fclose(db);
	
// todo
db_upload:
	
	
decrypt:
	if( npdata_decrypt(in, out, dev_klicensee, rifkey) == FAILED ) {
		print_debug("Error : failed to decrypt %s", in);
		return FAILED;
	}
	
	return SUCCESS;
}

//*******************************************************
// TEST ZONE
//*******************************************************

void test_permit()
{
	int ret = sysModuleLoad(0x003E); // SYSMODULE_SYSUTIL_GAME
	if( ret < 0) {
		print_load("Error : failed to load SYSMODULE_SYSUTIL_GAME");
	} else {
		print_load("Succeeded to load SYSMODULE_SYSUTIL_GAME");
	}
	char contentInfoPath[256];
	char usrdirPath[256];
	unsigned int type = 0;
	unsigned int attributes = 0;
	
	ret = sysGameBootCheck(&type, &attributes, NULL, NULL);
	print_load("sysGameBootCheck %X", ret);
	
	ret = sysGameContentPermit(contentInfoPath, usrdirPath);
	print_load("sysGameBootCheck %X", ret);
	print_load("ContentInfo %s", contentInfoPath);
	print_load("usrdirPath %s", usrdirPath);
	
	char test_title_id[SYS_GAME_SYSP_TITLEID_SIZE];
	ret = sysGameGetParamString(SYS_GAME_PARAMID_TITLE_ID, test_title_id, SYS_GAME_SYSP_TITLEID_SIZE);
	if( ret < 0) {
		print_load("Error : failed to sysGameGetParamString");
	} else {
		print_load("success %s", test_title_id);;
	}
	
	ret = sysModuleUnload(0x003E);
	if( ret < 0) {
		print_load("Error : failed to unload SYSMODULE_SYSUTIL_GAME");
	} else {
		print_load("Succeeded to unload SYSMODULE_SYSUTIL_GAME");
	}	
}

char *FRESULT_STR[20] = {
	"Succeeded",
	"A hard error occurred in the low level disk I/O layer",
	"Assertion failed",
	"The physical drive cannot work",
	"Could not find the file",
	"Could not find the path",
	"The path name format is invalid",
	"Access denied due to prohibited access or directory full",
	"Access denied due to prohibited access",
	"The file/directory object is invalid",
	"The physical drive is write protected",
	"The logical drive number is invalid",
	"The volume has no work area",
	"There is no valid FAT volume",
	"The f_mkfs() aborted due to any problem",
	"Could not get a grant to access the volume within defined period",
	"The operation is rejected according to the file sharing policy",
	"LFN working buffer could not be allocated",
	"Number of open files > FF_FS_LOCK",
	"Given parameter is invalid"
};


void exFAT_test()
{
	DEBUG = YES;
	
	char root[32];
	strcpy(root, "exFAT0:/");
	
	int ret = exFAT_mount(0);
	
	print_load("%d : %s", ret, FRESULT_STR[ret]);;
	
	print_load("is_mounted : %d", exFAT_is_mounted(0));
	
	if(ret != 0) return;
	
	FDIR fdir;
	
	ret = f_opendir(&fdir, root);
	
	print_load("opendir %s", FRESULT_STR[ret]);
	
	if( ret != 0) return;
	FILINFO fno;
	
	while (f_readdir(&fdir, &fno) == FR_OK) {
		if(fno.fname[0] == 0) break;
		print_load("f_readdir %s , name %s", FRESULT_STR[ret], fno.fname);
	}
	
	ret = f_closedir(&fdir);
	
	print_load("f_closedir %s", FRESULT_STR[ret]);
	
	FIL f;
	char bu[255];
	u32 br;
	char test[255];
	sprintf(test, "%stest.txt", root);
	
	print_load(test); sleep(1);
	
	ret = f_open(&f, test, FA_READ);

	print_load("f_open %s", FRESULT_STR[ret]);
	
	int s = f_size(&f);
	print_load("f_size = %d", s);
	
	ret = f_read(&f, bu, 10, &br);	
	
	print_load("f_open %s", FRESULT_STR[ret]);
	
	print_load("bu %s", bu);
	
	print_load("test %s", test);
	
	print_load("f_read %s", FRESULT_STR[ret]);
	
	ret = f_close(&f);
	
	print_load("f_close %s", FRESULT_STR[ret]);

	print_load("f_stat !");
	
	ret = f_stat(test, &fno);
	
	print_load("f_stat %s", FRESULT_STR[ret]);
	
	print_load("f_size %d, f_stat fno.fsize = %d", s, fno.fsize);
	
	sleep(2);
	
	struct stat st;
	print_load("stat !");
	if(stat(test, &st) != 0) print_load("Error !");
	else print_load("stat st.st_size %d", st.st_size);

	print_load("MGZ IO");
	sleep(1);
	// stdio
	
	FILE *fp;
	
	fp = fopen(test, "r");
	if(fp == NULL) return;
	sleep(1);
	
	print_load("fread"); sleep(1);
	fread(bu, 10, 1, fp);
	print_load("bu %s", bu);
	
	print_load("fgets %s", bu); sleep(1);
	char lin[255];
	fgets(lin, 255, fp);
	print_load("lin 1 : %s", lin);
	
	fgets(lin, 255, fp);
	print_load("lin 2 : %s", lin);
	
	print_load("fclose"); sleep(1);
	fclose(fp);
	
	sprintf(test, "%stest2.txt", root);
	
	print_load("fopen w"); sleep(1);
	fp = fopen(test, "w");
	if(fp==NULL) return
	
	print_load("fputs w"); sleep(1);
	fputs("lolilol", fp);
	
	print_load("fwrite w"); sleep(1);
	fwrite(test, 5, 1, fp);
	
	print_load("fclose w"); sleep(1);
	fclose(fp);
	
	sprintf(test, "%stestdir", root);
	
	print_load("mkdir"); sleep(1);
	
	mkdir(test, 0777);
	
	sprintf(test, "%stestdir", root);
	
	rename(test, "/exFAT0:/testdirnew");
	
	print_load("create file"); sleep(1);
	fp = fopen("/exFAT0:/testdirnew/todel.txt", "w");
	if(!fp) return;
	fclose(fp);
	
	print_load("unlink"); sleep(1);
	unlink("/exFAT0:/testdirnew/todel.txt");
	
	DIR *d;
	struct dirent *dir;
	
	print_load("opendir"); sleep(1);
	d = opendir(root);
	if(d==NULL) return;
	
	print_load("readdir"); sleep(1);
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		print_load("readdir : %s", dir->d_name); sleep(1);
	}
	print_load("closedir"); sleep(1);
	closedir(d);
	
	print_load("unmount"); sleep(1);
	ret = exFAT_unmount(0);
	print_load("f_unmount %s", FRESULT_STR[ret]);
	
	print_load("is_mounted : %d", exFAT_is_mounted(0));
	
	DEBUG = NO;
	
}


// http://www.psdevwiki.com/ps3/AIM_Manager#0x19003_-_Get_Device_ID

u8 TEST_IDPS[0x10];
void GetIDPS()
{
	lv2syscall2(867, 0x19003, (u64) TEST_IDPS);
}

//  https://www.imagemagick.org/api/magick-image.php
void ConvertImage(char *file_in, char *file_out)
{
	MagickWandGenesis();
	
	MagickWand *mw = NULL;
	/* Create a wand */
	mw = NewMagickWand();
	/* Read the input image */
	if( MagickReadImage(mw, file_in) == MagickFalse ) {
		print_load("Error : failed to read file_in");
		return;
	}
	
	MagickSetImageType(mw, TrueColorAlphaType); // type 6
	
	/* write it */
	if( MagickWriteImage(mw, file_out) == MagickFalse ) {
		print_load("Error : failed to write file_out");
		return;
	}
	/* Tidy up */
	if(mw) mw = DestroyMagickWand(mw);
	MagickWandTerminus();
}

void Crop_Image(char *file_in, char *file_out, float x, float y, float w, float h)
{
	MagickWandGenesis();
	
	MagickWand *mw = NULL;
	/* Create a wand */
	mw = NewMagickWand();
	/* Read the input image */
	if( MagickReadImage(mw, file_in) == MagickFalse ) {
		print_load("Error : failed to read %s", file_in);
		return;
	}
	
	if( MagickCropImage(mw, w, h, x, y) == MagickFalse ) {
		print_load("Error : failed to crop");
		return;
	}
	
	/* write it */
	if( MagickWriteImage(mw, file_out) == MagickFalse ) {
		print_load("Error : failed to write %s", file_out);
		return;
	}
	/* Tidy up */
	if(mw) mw = DestroyMagickWand(mw);
	MagickWandTerminus();
}

s8 MagickLoadFromBuffer(const void *buffer, int file_size, imgData *data)
{
	print_load("MagickWandGenesis");
	
	MagickWandGenesis();
	
	MagickWand *mw = NULL;
	
	mw = NewMagickWand();
	
	print_load("MagickReadImageBlob");
	if( MagickReadImageBlob(mw, buffer, file_size) == MagickFalse ) return -1;
	
	print_load("MagickSetImageType");
	if( MagickSetImageType(mw, TrueColorAlphaType) == MagickFalse ) {
		print_load("failed to MagickSetImageType");
	}
	
	print_load("MagickSetImageFormat");
	if( MagickSetImageFormat(mw, "png") == MagickFalse ) {
		print_load("failed MagickSetImageFormat");
	}
	
	size_t blob_len;
	
	print_load("MagickGetImageBlob");
	unsigned char *blob = MagickGetImageBlob(mw, &blob_len);
	
	int ret = pngLoadFromBuffer(blob, blob_len, (pngData *) data);

	MagickRelinquishMemory(blob);
	
	
	print_load("DestroyMagickWand");
	if(mw) mw = DestroyMagickWand(mw);
	
	MagickWandTerminus();
	
	return ret;
}

// MagickSetImageFormat(mw, "ARGB") return false
// ugly fix : convert it to "png" then use pngLoad
u8 MagickLoadFromFile(char *file_in, imgData *data)
{
	print_load("MagickWandGenesis");
	
	MagickWandGenesis();
	
	MagickWand *mw = NULL;
	
	mw = NewMagickWand();
	
	print_load("MagickReadImage");
	if( MagickReadImage(mw, file_in) == MagickFalse ) {
		print_load("Error : failed to MagickReadImage");
		return -1;
	}
	
	print_load("MagickReadImage");
	if( MagickSetImageType(mw, TrueColorAlphaType) == MagickFalse ) {
		print_load("Error : failed to MagickReadImage");
		return -1;
	}
	
	print_load("MagickSetImageFormat");
	if( MagickSetImageFormat(mw, "png") == MagickFalse ) {
		print_load("Error : failed MagickSetImageFormat");
	}
	
	size_t blob_len;
	
	print_load("MagickGetImageBlob");
	unsigned char *blob = MagickGetImageBlob(mw, &blob_len);
	
	int ret = pngLoadFromBuffer(blob, blob_len, (pngData *) data);
	
	MagickRelinquishMemory(blob);
	
	print_load("DestroyMagickWand");
	if(mw) mw = DestroyMagickWand(mw);
	
	MagickWandTerminus();
	
	return ret;
}

// save supported image format supporte by this lib
void SaveMagicList()
{
	size_t l;
	ExceptionInfo exception;
	char **list = GetMagickList("*", &l, &exception);
	
	FILE *f;
	
	f = fopen("/dev_hdd0/MagicList.txt", "w");
	
	int i;
	for(i=0; i<l; i++){
		fputs(list[i], f);
		fputs("\n", f);
		list[i] = (char *)RelinquishMagickMemory(list[i]);
	}
	fclose(f);
	RelinquishMagickMemory(list);
}

void Load_FM()
{
	if(Load_GAMEPIC_busy) return;
	
	u8 loaded=NO;
	
	if(loading == NO) {
		loaded=YES;
		start_loading();
	}

	texture_pointer = texture_mem + TEXTURE_POINTER_TMP;
	
	memset(&TMP_PIC, 0, sizeof(TMP_PIC));
	TMP_PIC_offset = 0;
	position_CURPIC=-1;
	
	if(is_apng(TMP_PIC_path) == YES) {
		Load_APNG(TMP_PIC_path);
		if(loaded == YES) end_loading();
		return;
	}
	
	LoadTexture(TMP_PIC_path, &TMP_PIC_offset ,&TMP_PIC, NULL, NO);
	
	//SaveFile("/dev_hdd0/test2.raw", TMP_PIC.bmp_out, TMP_PIC.pitch * TMP_PIC.height);
	
	if(loaded == YES) end_loading();
}

static void* jpg_malloc(u32 size,void *usrdata)
{
	return malloc(size);
}

static void jpg_free(void *ptr,void *usrdata)
{
	free(ptr);
}

u8 GetInfo_JPG(char *path, u32 *w, u32 *h) 
{
	jpgDecSource source;
	
	memset(&source,0,sizeof(jpgDecSource));

	source.stream = JPGDEC_FILE;
	source.file_name = __get_addr32(path);
	source.enable = JPGDEC_DISABLE;
	
	s32 mHandle,sHandle,ret;
	u32 space_allocated;
	jpgDecInfo DecInfo;
	jpgDecThreadInParam InThdParam;
	jpgDecThreadOutParam OutThdParam;

	InThdParam.enable = 0;
	InThdParam.ppu_prio = 512;
	InThdParam.spu_prio = 200;
	InThdParam.malloc_func = __get_addr32(__get_opd32(jpg_malloc));
	InThdParam.malloc_arg = 0; // no args
	InThdParam.free_func = __get_addr32(__get_opd32(jpg_free));
	InThdParam.free_arg = 0; // no args

	ret = jpgDecCreate(&mHandle,&InThdParam,&OutThdParam);

	if(ret==0) {
		ret = jpgDecOpen(mHandle,&sHandle,&source,&space_allocated);
		if(ret==0) {
			ret = jpgDecReadHeader(mHandle,sHandle,&DecInfo);
			if(ret==0) {
				*w = DecInfo.width;
				*h = DecInfo.height;
			}
			jpgDecClose(mHandle,sHandle);
		}
		jpgDecDestroy(mHandle);
	}
	
	if( ret==0 ) return SUCCESS;
	else return FAILED;
}

u8 GetInfo_PNG(char * path, u32 *w, u32 *h)
{
	FILE *f;
	u32 magic;
	
	f=fopen(path, "rb");
	if( f == NULL ) return FAILED;
	
	fread(&magic, sizeof(32), 1, f);
	
	if(magic != 0x89504E47) {
		fclose(f); 
		return FAILED;
	}
	
	fseek(f, 0x10, SEEK_SET);
	
	u32 width, height;
	fread(&width, sizeof(32), 1, f);
	fread(&height, sizeof(32), 1, f);
	
	fclose(f);
	
	*w = width;
	*h = height;
	
	return SUCCESS;
}

u8 Get_PICType(u32 w, u32 h)
{

	if( w == 320.0 && h == 176.0 )  return GAMEPIC_ICON0;
	
	if( w == 250.0 && h == 250.0 )  return GAMEPIC_COVER2D; // PS1
	if( w == 450.0 && h == 450.0 )  return GAMEPIC_COVER2D; // PS1 FRONT
	if( w == 600.0 && h == 450.0 )  return GAMEPIC_COVER3D; // PS1 BACK
	
	if( w == 250.0 && h == 350.0 )  return GAMEPIC_COVER2D; // PS2
	if( w == 850.0 && h == 570.0 )  return GAMEPIC_COVER3D; // PS2
	
	if( w == 260.0 && h == 300.0 )  return GAMEPIC_COVER2D; // PS3
	if( w == 950.0 && h == 520.0 )  return GAMEPIC_COVER3D; // PS3
	
	if( w == 200.0 && h == 340.0 )  return GAMEPIC_COVER2D; // PSP
	if( w == 800.0 && h == 640.0 )  return GAMEPIC_COVER3D; // PSP
	
	if( w <= h) return GAMEPIC_COVER2D;
	
	float ratio = (float) w / (float) h ;
	float ratio_ICON0 = 320.0/176.0;
	float e = fabs(ratio_ICON0 - ratio);
	if( e < 0.02 ) return GAMEPIC_ICON0;
	
	return GAMEPIC_COVER3D;
}

u8 Get_PIC(char *path)
{
	u32 width, height;
	
	if(GetInfo_PNG(path, &width, &height)==FAILED)
	if(GetInfo_JPG(path, &width, &height)==FAILED) return GAMEPIC_COVER_UNK;
	
	return Get_PICType(width, height);
}

char *GetPath_GAMEPIC_COVER3D(int game_pos, int n)
{
	u8 is_PS1 = (list_game_platform[game_pos] == ISO_PS1 || list_game_platform[game_pos] == JB_PS1);
	
	char t[10] = {0};
	if(is_PS1) strcpy(t, "_FRONT");
	
	if(n==0) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/3D/%s%s.jpg", ManaGunZ_id, list_game_ID[game_pos], t);
	if(n==1) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/3D/%s%s.JPG", ManaGunZ_id, list_game_ID[game_pos], t);
	if(n==2) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/3D/%s%s.png", ManaGunZ_id, list_game_ID[game_pos], t);
	if(n==3) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/3D/%s%s.PNG", ManaGunZ_id, list_game_ID[game_pos], t);
	
	return NULL;
}

char *GetPath_GAMEPIC_COVER2D(int game_pos, int n)
{	
	if(n==0) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/%s.jpg", ManaGunZ_id, list_game_ID[game_pos]);
	if(n==1) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/%s.JPG", ManaGunZ_id, list_game_ID[game_pos]);
	if(n==2) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/%s.png", ManaGunZ_id, list_game_ID[game_pos]);
	if(n==3) return sprintf_malloc("/dev_hdd0/game/%s/USRDIR/covers/%s.PNG", ManaGunZ_id, list_game_ID[game_pos]);
	
	if(n==4) return sprintf_malloc("/dev_hdd0/tmp/covers/%s.jpg", list_game_ID[game_pos]);
	if(n==5) return sprintf_malloc("/dev_hdd0/tmp/covers/%s.JPG", list_game_ID[game_pos]);
	if(n==6) return sprintf_malloc("/dev_hdd0/tmp/covers/%s.png", list_game_ID[game_pos]);
	if(n==7) return sprintf_malloc("/dev_hdd0/tmp/covers/%s.PNG", list_game_ID[game_pos]);
	
	if(n==8) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers/%s.jpg", list_game_ID[game_pos]);
	if(n==9) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers/%s.JPG", list_game_ID[game_pos]);
	if(n==10) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers/%s.png", list_game_ID[game_pos]);
	if(n==11) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers/%s.PNG", list_game_ID[game_pos]);
	
	if( 12 <= n && n <=15) {
	
		char temp[512];
		strcpy(temp, list_game_path[game_pos]);
		RemoveExtension(temp);
		
		if(n==12) return sprintf_malloc( "%s.COVER.jpg", temp);
		if(n==13) return sprintf_malloc( "%s.COVER.JPG", temp);
		if(n==14) return sprintf_malloc( "%s.COVER.png", temp);
		if(n==15) return sprintf_malloc( "%s.COVER.PNG", temp);
	}
	
	if( list_game_platform[game_pos] == ISO_PS3 || list_game_platform[game_pos] == JB_PS3 || list_game_platform[game_pos] == BDVD) return NULL;
	
	if(n==16) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers_retro/psx/%s_COV.jpg", list_game_ID[game_pos]);
	if(n==17) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers_retro/psx/%s_COV.JPG", list_game_ID[game_pos]);
	if(n==18) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers_retro/psx/%s_COV.png", list_game_ID[game_pos]);
	if(n==19) return sprintf_malloc("/dev_hdd0/game/BLES80608/USRDIR/covers_retro/psx/%s_COV.PNG", list_game_ID[game_pos]);
	
	return NULL;
	
}

char *GetPath_GAMEPIC_UNK(int game_pos, int n)
{
	char temp[512];
	strcpy(temp, list_game_path[game_pos]);
	RemoveExtension(temp);
	
	if(n==0) return sprintf_malloc( "%s.jpg", temp);
	if(n==1) return sprintf_malloc( "%s.JPG", temp);
	if(n==2) return sprintf_malloc( "%s.png", temp);
	if(n==3) return sprintf_malloc( "%s.PNG", temp);
	
	return NULL;
}

char *GetPath_GAMEPIC_ICON0(int game_pos, int n)
{
	char temp[512];
	strcpy(temp, list_game_path[game_pos]);
	RemoveExtension(temp);
	
	if(n==0) return sprintf_malloc( "%s.ICON0.jpg", temp);
	if(n==1) return sprintf_malloc( "%s.ICON0.JPG", temp);
	if(n==2) return sprintf_malloc( "%s.ICON0.png", temp);
	if(n==3) return sprintf_malloc( "%s.ICON0.PNG", temp);
	
	return NULL;
}

u8 Have_GAMEPIC(int game_pos)
{
	u8 ret = GAMEPIC_NONE;
	int n = 0;
	
	if(list_game_platform[game_pos] == ISO_PS3 || list_game_platform[game_pos] == JB_PS3 || list_game_platform[game_pos] == BDVD
	|| list_game_platform[game_pos] == ISO_PSP || list_game_platform[game_pos] == JB_PSP) {
		ret |= GAMEPIC_ICON0;
	} else {
		// Create ICON0
		n=0;
		while(1)
		{
			char *GAMEPIC_path = GetPath_GAMEPIC_ICON0(game_pos, n);
			if( GAMEPIC_path == NULL) break;
			
			if(path_info(GAMEPIC_path) == _FILE) { ret |= GAMEPIC_ICON0; break; }
			FREE(GAMEPIC_path);
			
			n++;
		}
	}
	
	
// 3D
	n=0;
	while(1)
	{
		char *GAMEPIC_path = GetPath_GAMEPIC_COVER3D(game_pos, n);
		if( GAMEPIC_path == NULL) break;
		
		if(path_info(GAMEPIC_path) == _FILE) { ret |= GAMEPIC_COVER3D; break; }
		FREE(GAMEPIC_path);
		
		n++;
	}
			
	n=0;
	while(1)
	{
		char *GAMEPIC_path = GetPath_GAMEPIC_COVER2D(game_pos, n);
		if( GAMEPIC_path == NULL) break;
		
		if(path_info(GAMEPIC_path) == _FILE) { ret |= GAMEPIC_COVER2D; break; }
		FREE(GAMEPIC_path);
		
		n++;
	}
	
	n=0;
	while(1)
	{
		char *GAMEPIC_path = GetPath_GAMEPIC_UNK(game_pos, n);
		if( GAMEPIC_path == NULL) break;
		
		if(path_info(GAMEPIC_path) == _FILE) { ret |= Get_PIC(GAMEPIC_path); break; }
		FREE(GAMEPIC_path);
		
		n++;
	}

	
	return ret;
}

u8 Read_PS1BACK(int game_pos, imgData *DataPic)
{
	u8 is_PS1 = (list_game_platform[game_pos] == ISO_PS1 || list_game_platform[game_pos] == JB_PS1);
	
	if(is_PS1==NO || UI_position!=FLOW || FLOW_3D == NO) return FAILED;
		
// TODO 
// support 3 pictures = 2 sides + 1 back 
// FULL   450 x 600
// BACK   450 x 510
// LEFT   450 x 45
// RIGHT  450 x 45
// merge them in 1 imgData ?
	
	char temp[128];
	
	sprintf(temp, "/dev_hdd0/game/%s/USRDIR/covers/3D/%s.JPG", ManaGunZ_id, list_game_ID[game_pos]);
	if(imgLoadFromFile(temp, DataPic, NO) == SUCCESS) return SUCCESS;
	sprintf(temp, "/dev_hdd0/game/%s/USRDIR/covers/3D/%s.jpg", ManaGunZ_id, list_game_ID[game_pos]);
	if(imgLoadFromFile(temp, DataPic, NO) == SUCCESS) return SUCCESS;
	sprintf(temp, "/dev_hdd0/game/%s/USRDIR/covers/3D/%s.PNG", ManaGunZ_id, list_game_ID[game_pos]);
	if(imgLoadFromFile(temp, DataPic, NO) == SUCCESS) return SUCCESS;
	sprintf(temp, "/dev_hdd0/game/%s/USRDIR/covers/3D/%s.png", ManaGunZ_id, list_game_ID[game_pos]);
	if(imgLoadFromFile(temp, DataPic, NO) == SUCCESS) return SUCCESS;

	return FAILED;
}

u8 Read_GAMEPIC_COVER3D(int game_pos, imgData *DataPic)
{
	
	if( !(list_game_havepic[game_pos] & GAMEPIC_COVER3D) ) return FAILED;
	
	int n = 0;
	while(1)
	{
		char *COVER3D_path = GetPath_GAMEPIC_COVER3D(game_pos, n);
		if( COVER3D_path == NULL) break;
		
		int ret = imgLoadFromFile(COVER3D_path, DataPic, NO);
		FREE(COVER3D_path);
		
		if(ret == SUCCESS) return SUCCESS;
		
		n++;
	}

	n=0;
	while(1)
	{
		char *COVER3D_path = GetPath_GAMEPIC_UNK(game_pos, n);
		if( COVER3D_path == NULL) break;
		
		int ret = imgLoadFromFile(COVER3D_path, DataPic, NO);
		FREE(COVER3D_path);
		
		if(ret == SUCCESS) return SUCCESS;
		
		n++;
	}
	
	return FAILED;
}

u8 Read_GAMEPIC_COVER2D(int game_pos, imgData *DataPic)
{
	if( !(list_game_havepic[game_pos] & GAMEPIC_COVER2D) ) return FAILED;
	
	int n = 0;
	while(1)
	{
		char *COVER2D_path = GetPath_GAMEPIC_COVER2D(game_pos, n);
		if( COVER2D_path == NULL) break;
		
		int ret = imgLoadFromFile(COVER2D_path, DataPic, NO);
		FREE(COVER2D_path);
		
		if(ret == SUCCESS) return SUCCESS;
		
		n++;
	}

	n=0;
	while(1)
	{
		char *COVER2D_path = GetPath_GAMEPIC_UNK(game_pos, n);
		if( COVER2D_path == NULL) break;
		
		int ret = imgLoadFromFile(COVER2D_path, DataPic, NO);
		FREE(COVER2D_path);
		
		if(ret == SUCCESS) return SUCCESS;
		
		n++;
	}
	
	return FAILED;
}

u8 Read_GAMEPIC_ICON0(int game_pos, imgData *DataPic)
{
	char temp[512];
	
	if( !(list_game_havepic[game_pos] & GAMEPIC_ICON0) ) return FAILED;
	
	if(list_game_platform[game_pos] == ISO_PS3) {
		int size;
		char *mem = LoadFileFromISO(NO, list_game_path[game_pos], "/PS3_GAME/ICON0.PNG", &size);
		if(mem==NULL) return FAILED;
		if(pngLoadFromBuffer((const void *) mem, size, (pngData *) DataPic) == 0)  {free(mem); return SUCCESS;}
	} else
	if(list_game_platform[game_pos] == ISO_PSP) {
		int size;
		char *mem = LoadFileFromISO(NO, list_game_path[game_pos], "/PSP_GAME/ICON0.PNG", &size);
		if(mem==NULL) return FAILED;
		if(pngLoadFromBuffer((const void *) mem, size, (pngData *) DataPic) == 0) {free(mem); return SUCCESS;}
	} else	
	if(list_game_platform[game_pos] == JB_PS3 || list_game_platform[game_pos] == BDVD) {
		sprintf(temp, "%s/PS3_GAME/ICON0.PNG", list_game_path[game_pos]);
		if(imgLoadFromFile(temp, DataPic, NO) == SUCCESS) return SUCCESS;
	} else
	if(list_game_platform[game_pos] == JB_PSP) {
		sprintf(temp, "%s/PSP_GAME/ICON0.PNG", list_game_path[game_pos]);
		if(imgLoadFromFile(temp, DataPic, NO) == SUCCESS) return SUCCESS;
	} else
	{
		int n = 0;
		while(1)
		{
			char *GAMEPIC_path = GetPath_GAMEPIC_ICON0(game_pos, n);
			if( GAMEPIC_path == NULL) break;
			
			int ret = imgLoadFromFile(GAMEPIC_path, DataPic, NO);
			FREE(GAMEPIC_path);
			
			if(ret == SUCCESS) return SUCCESS;
			
			n++;
		}
		n=0;
		while(1)
		{
			char *GAMEPIC_path = GetPath_GAMEPIC_UNK(game_pos, n);
			if( GAMEPIC_path == NULL) break;
			
			int ret = imgLoadFromFile(GAMEPIC_path, DataPic, NO);
			FREE(GAMEPIC_path);
			
			if(ret == SUCCESS) return SUCCESS;
			
			n++;
		}
	}
	
	return FAILED;
}

u8 Read_GAMEPIC(int game_pos, imgData *DataPic)
{
	
	if(list_game_havepic[game_pos] == GAMEPIC_NONE) return FAILED;

	if(UI_position==FLOW) {
		
		if(FLOW_3D) {
			if( Read_GAMEPIC_COVER3D(game_pos, DataPic) == SUCCESS) return SUCCESS;
		} 
			
		if(FLOW_3D || Show_COVER) {
			if( Read_GAMEPIC_COVER2D(game_pos, DataPic) == SUCCESS) return SUCCESS;
		}
		
		if( Read_GAMEPIC_ICON0(game_pos, DataPic) == SUCCESS) return SUCCESS;
		
	} else
	if(UI_position==LIST) {
		if(Show_ICON0) {
			if( Read_GAMEPIC_ICON0(game_pos, DataPic) == SUCCESS) return SUCCESS;
		}
		if(Show_COVER) {
			if( Read_GAMEPIC_COVER2D(game_pos, DataPic) == SUCCESS) return SUCCESS;
		}
	} else {
		if( Read_GAMEPIC_ICON0(game_pos, DataPic) == SUCCESS) return SUCCESS;
		
		if(Show_COVER) {
			if( Read_GAMEPIC_COVER2D(game_pos, DataPic) == SUCCESS) return SUCCESS;
		}	
	}
	
	return FAILED;
}

int VRAM_GetSlotUsed()
{
	int i;
	int nb=0;
	for(i=0; i<GAMEPIC_MAX; i++) {
		if( GAMEPIC_SLOT_POS[i] != -1 ) nb++;
	}
	
	return nb;
}

int VRAM_GetSlot(int gamepos)
{
	int i;
	for(i=0; i<GAMEPIC_MAX; i++) {
		if( GAMEPIC_SLOT_POS[i] == gamepos ) return i;
	}
	
	return (-1);
}

int VRAM_NewSlot(int gamepos)
{
	int i;
	for(i=0; i<GAMEPIC_MAX; i++) {
		if( GAMEPIC_SLOT_POS[i] == -1 ) return i;
	}
	return (-1);
}

void update_VRAM()
{
	int FirstGame = GAMEPIC_SLOT_POS[GAMEPIC_SLOT_FIRST];
	int LastGame = GAMEPIC_SLOT_POS[GAMEPIC_SLOT_LAST];
	int i;
	
	strcpy(GAMEPIC_LOG, "VRAM_update");
	
	for(i=0; i<GAMEPIC_MAX; i++)
	{
		if(	FirstGame < LastGame) {
			if(FirstGame <= GAMEPIC_SLOT_POS[i] && GAMEPIC_SLOT_POS[i] <= LastGame) continue;
		}
		if( LastGame < FirstGame) {
			if( GAMEPIC_SLOT_POS[i] <= LastGame ) continue;
			if( FirstGame <=  GAMEPIC_SLOT_POS[i] ) continue;
		}
		GAMEPIC_SLOT_POS[i] = -1;
		GAMEPIC_offset[i]=0;
	}
}

void VRAM_init()
{
	int e = 0;
	int texture_number = 0;
	GAMEPIC_SLOT_LAST = 0;
	GAMEPIC_SLOT_FIRST = 0;
	GAMEPIC_POSITION = position;
	
	strcpy(GAMEPIC_LOG, "VRAM_init");
	
	int i;
	for(i=0; i<=game_number; i++)
	{
		if(GAMEPIC_MAX<=texture_number) break;
		if(game_number<texture_number) break;
		
		int gamepos = GAMEPIC_POSITION + e;
		if(game_number<gamepos) gamepos = gamepos - game_number - 1;
		if(gamepos<0) gamepos = game_number + gamepos + 1;

		if( list_game_havepic[gamepos] == GAMEPIC_NONE ) goto next;
		
		texture_number++;
		
		int slot = VRAM_GetSlot(gamepos);
		if(slot == -1) goto next;
		
		if(e>0) GAMEPIC_SLOT_LAST = slot;
		if(e<0) GAMEPIC_SLOT_FIRST = slot;
next:
		e=-e; if(0<=e) e++;
	}
	
	update_VRAM();
}

u8 VRAM_isFull()
{
	int i;
	for(i=0; i<GAMEPIC_MAX; i++) {
		if( GAMEPIC_SLOT_POS[i] == -1 ) return NO;
	}
	
	return YES;
}

void Load_GAMEPIC()
{
	Load_GAMEPIC_busy = YES;
	
	int e = 0;
	int texture_loaded_number = 0;
	int LOCAL_SLOT_LAST = 0;
	int LOCAL_SLOT_FIRST = 0;
	
	VRAM_init();
	
	strcpy(GAMEPIC_LOG, "Load_GAMEPIC");
	
	int i;
	for(i=0; i<=game_number; i++)
	{
		if(GAMEPIC_MAX<=texture_loaded_number) break;
		if(game_number<texture_loaded_number) break;
		
		int gamepos = GAMEPIC_POSITION + e;
		if(game_number<gamepos) gamepos = gamepos - game_number - 1;
		if(gamepos<0) gamepos = game_number + gamepos + 1;
		
		int slot;
		slot = VRAM_GetSlot(gamepos);
		if(slot != -1) goto already_loaded;
		
		slot = VRAM_NewSlot(gamepos);
		if( slot == -1)  break;
		
		if( Read_GAMEPIC(gamepos, &GAMEPIC[slot]) == FAILED ) goto next;
		
		GAMEPIC_SLOT_POS[slot] = gamepos;
		texture_pointer = texture_mem + TEXTURE_POINTER_GAMEPIC(slot);	
		memcpy(texture_pointer, GAMEPIC[slot].bmp_out, GAMEPIC[slot].pitch * GAMEPIC[slot].height);
		free(GAMEPIC[slot].bmp_out);
		GAMEPIC_offset[slot] = tiny3d_TextureOffset(texture_pointer);
				
		PS1BACK_offset[slot] = 0;
		if( Read_PS1BACK(gamepos, &PS1BACK[slot]) == FAILED) goto next;
		texture_pointer = texture_mem + TEXTURE_POINTER_GAMEPIC(slot) + TEXTURE_GAMEPIC_SIZE(slot);
		memcpy(texture_pointer, PS1BACK[slot].bmp_out, PS1BACK[slot].pitch * PS1BACK[slot].height);
		free(PS1BACK[slot].bmp_out);
		PS1BACK_offset[slot] = tiny3d_TextureOffset(texture_pointer);
		
already_loaded:

		if(e>0) LOCAL_SLOT_LAST = slot;
		if(e<0) LOCAL_SLOT_FIRST = slot;
		
		texture_loaded_number++;
		
next:
		e=-e; if(e>=0) e++;
	}
	
	GAMEPIC_SLOT_LAST = LOCAL_SLOT_FIRST;
	GAMEPIC_SLOT_LAST = LOCAL_SLOT_LAST;
	
	Load_GAMEPIC_busy = NO;
}

void init_Load_GAMEPIC()
{
	if(UI_position==FLOW && FLOW_3D==YES) {
		TEXTURE_GAMEPIC_SIZE_MAX = TEXTURE_GAMEPIC_SIZE_3D;
	} else {
		TEXTURE_GAMEPIC_SIZE_MAX = TEXTURE_GAMEPIC_SIZE_2D;
	}
	
	memset(GAMEPIC_offset, 0, sizeof(GAMEPIC_offset));
	memset(GAMEPIC, 0, sizeof(GAMEPIC));
	
	if(position < 0) GAMEPIC_POSITION = position;
	
	int i;
	for(i=0; i<GAMEPIC_MAX; i++) GAMEPIC_SLOT_POS[i] = -1;
	
	Load_GAMEPIC_init = YES;
}

static sys_ppu_thread_t Load_GAMEPIC_id;

void Load_GAMEPIC_thread(void *unused)
{
	init_Load_GAMEPIC();
	
	while(Load_GAMEPIC_flag == YES) {
		Load_GAMEPIC_busy = NO;
		if( Load_GAMEPIC_init ) {
			Load_GAMEPIC_busy=YES;
			int i;
			for(i=0; i<=game_number; i++) list_game_havepic[i] = Have_GAMEPIC(i);
			Load_GAMEPIC_init=NO;
			Load_GAMEPIC();
		} else
		if(position < 0) {
			sleep(1);
		} else
		if(GAMEPIC_MAX < game_number) 
		{
			if( GAMEPIC_POSITION != position ) Load_GAMEPIC();
		}
		usleep(100);
	}
	Load_GAMEPIC_flag=-1;
	sysThreadExit(0);
}


void end_Load_GAMEPIC()
{
	u64 ret;
	if(Load_GAMEPIC_flag==YES) {
		Load_GAMEPIC_flag=NO;
		while(Load_GAMEPIC_flag==NO) usleep(1000);
		sysThreadJoin(Load_GAMEPIC_id, &ret);
		Load_GAMEPIC_flag=NO;
	}
}

void start_Load_GAMEPIC()
{	
	if(Load_GAMEPIC_flag==NO) {
		Load_GAMEPIC_flag = YES;
		sysThreadCreate(&Load_GAMEPIC_id, Load_GAMEPIC_thread, NULL, 999, 0x2000, THREAD_JOINABLE, "Load_GAMEPIC");
	}
}


void Draw_Load_GAMEPIC()
{
	if(Load_GAMEPIC_busy) DrawLoadingIcon();
}

void Draw_CASE(int pos, float xi, float yi, float z, float wi, float hi)
{
	float xj,yj,wj,hj;
	float xl,yl,wl,hl;
	
	if(list_game_platform[pos] == ISO_PS3 || list_game_platform[pos] == JB_PS3 || list_game_platform[pos] == BDVD ) {
		if(PICTURE_offset[PS3_CASE] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[PS3_CASE], PICTURE[PS3_CASE].width, PICTURE[PS3_CASE].height, PICTURE[PS3_CASE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			xl = 0;
			yl = 30;
			wl = 260;
			hl = 300;
			
			xj = xi - xl * wi / wl;
			yj = yi - yl * hi / hl;
			wj = PICTURE[PS3_CASE].width * wi / wl;
			hj = PICTURE[PS3_CASE].height * hi / hl;
							
			Draw_Box(xj, yj, z, 0, wj, hj, WHITE, YES);
		}
	} else
	if(list_game_platform[pos] == ISO_PS2 || list_game_platform[pos] == JB_PS2) {
		if(PICTURE_offset[PS2_CASE] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[PS2_CASE], PICTURE[PS2_CASE].width, PICTURE[PS2_CASE].height, PICTURE[PS2_CASE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			xl = 0;
			yl = 10;
			wl = 260;
			hl = 370;
			
			xj = xi - xl * wi / wl;
			yj = yi - yl * hi / hl;
			wj = PICTURE[PS2_CASE].width * wi / wl;
			hj = PICTURE[PS2_CASE].height * hi / hl;
							
			Draw_Box(xj, yj, z, 0, wj, hj, WHITE, YES);
		}
	} else
	if(list_game_platform[pos] == ISO_PS1 || list_game_platform[pos] == JB_PS1) {
		if(PICTURE_offset[PS1_CASE] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[PS1_CASE], PICTURE[PS1_CASE].width, PICTURE[PS1_CASE].height, PICTURE[PS1_CASE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			xl = 30;
			yl = 5;
			wl = 240;
			hl = 240;
			
			xj = xi - xl * wi / wl;
			yj = yi - yl * hi / hl;
			wj = PICTURE[PS1_CASE].width * wi / wl;
			hj = PICTURE[PS1_CASE].height * hi / hl;
							
			Draw_Box(xj, yj, z, 0, wj, hj, WHITE, YES);
		}
	} else
	if(list_game_platform[pos] == ISO_PSP || list_game_platform[pos] == JB_PSP) {
		if(PICTURE_offset[PSP_CASE] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[PSP_CASE], PICTURE[PSP_CASE].width, PICTURE[PSP_CASE].height, PICTURE[PSP_CASE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			xl = 0;
			yl = 10;
			wl = 200;
			hl = 340;
			
			xj = xi - xl * wi / wl;
			yj = yi - yl * hi / hl;
			wj = PICTURE[PSP_CASE].width * wi / wl;
			hj = PICTURE[PSP_CASE].height * hi / hl;
							
			Draw_Box(xj, yj, z, 0, wj, hj, WHITE, YES);
		}
	}
	
}

void Draw_COVER(int pos, float x, float y, float z, float w, float h, u32 CoverOffset, imgData CoverIMG, u8 center, u32 color)
{
	if(pos < 0 || game_number < pos) return;
	if(CoverOffset==0) return;
	
	float xi,yi,wi,hi;
	float xj,yj,wj,hj;
	float xl,yl,wl,hl;
	
	u8 plat;
	
	xj = x;
	yj = y;
	wj = w;
	hj = h;
	
	if(center) {
		xj -= wj/2;
		yj -= hj/2;
	}
	
	if(list_game_platform[pos] == ISO_PS3 || list_game_platform[pos] == JB_PS3 || list_game_platform[pos] == BDVD) {
		plat = PS3_CASE;
		xl = 0;
		yl = 30;
		wl = 260;
		hl = 300;
	} else
	if(list_game_platform[pos] == ISO_PS2 || list_game_platform[pos] == JB_PS2) {
		plat = PS2_CASE;
		xl = 0;
		yl = 10;
		wl = 260;
		hl = 370;
	}else
	if(list_game_platform[pos] == ISO_PS1 || list_game_platform[pos] == JB_PS1) {
		plat = PS1_CASE;
		xl = 30;
		yl = 5;
		wl = 240;
		hl = 240;
	} else
	if(list_game_platform[pos] == ISO_PSP || list_game_platform[pos] == JB_PSP) {
		plat = PSP_CASE;
		xl = 0;
		yl = 10;
		wl = 200;
		hl = 340;
	} else return;
	
	// SQUARE used sman, xmb, webmanMOD. It won't be displayed with game boxes.
	u8 square = NO;
	if( CoverIMG.width == CoverIMG.height ) {
		if( CoverIMG.width == 320 || list_game_platform[pos] != ISO_PS1 ) {
			xl=0;
			yl=0;
			hl=320;
			wl=320;
			square=YES;
		}
	}
	
	float ph = hl;
	float pw = wl;
	if(PICTURE_offset[plat] && Show_GameCase && !square) {
		ph=PICTURE[plat].height;
		pw=PICTURE[plat].width;
	}
	
	if(h==0 && w!=0) {
		xi = x;
		yi = y;
		wi = w;
		hi = ph*w/pw;
	} else
	if(h!=0 && w==0) {
		xi = x;
		yi = y;
		wi = pw*h/ph;
		hi = h;
	} else
	if(h==0 && w==0) {
		xi = x;
		yi = y;
		wi = pw;
		hi = ph;
	} else {
		xi = x;
		yi = y;
		wi = w;
		hi = h;
	}
	
	if(center) {
		xi -= wi/2;
		yi -= hi/2;
	}
	
	xj = xi;
	yj = yi;
	wj = wl * wi / pw;
	hj = hl * hi / ph;
		
	if(PICTURE_offset[plat] && Show_GameCase && !square) {
		xj+= xl * wi / pw;
		yj+= yl * hi / ph;
	}
	
	tiny3d_SetTexture(0, CoverOffset, CoverIMG.width, CoverIMG.height, CoverIMG.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
	Draw_Box(xj, yj, z, 0, wj, hj, color, YES);
	
	//Game boxes pictures are transparents to have a reflect effect.
	if(PICTURE_offset[plat] && Show_GameCase && !square) {
		tiny3d_SetTexture(0, PICTURE_offset[plat], PICTURE[plat].width, PICTURE[plat].height, PICTURE[plat].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(xi, yi, z, 0, wi, hi, color, YES);
	}
}

u8 get_SectorSize(FILE*  fd, u32 *SectorSize, u32 *jmp)
{
	char CD01[8] = {0x01, 0x43, 0x44, 0x30, 0x30, 0x31, 0x01, 0x00};
	
	u32 all_sizes[4] = {0x800, 0x930, 0x920, 0x990};
	u32 sector_size=0;
	u32 jp=0;
	char *data = (char *) malloc(9);
	
	int i;
	for(i=0; i<4; i++) {
		memset(data, 0, sizeof(data));
		fseek(fd, all_sizes[i]*0x10, SEEK_SET);
		fread(data, 8, 1, fd);
		if(!memcmp((char *) data, (char *) CD01, 8)) {
			sector_size=all_sizes[i];
			jp=0;
			break;
		}
		fseek(fd, all_sizes[i]*0x10+0x18, SEEK_SET);
		fread(data, 8, 1, fd);
		if(!memcmp((char *) data, (char *) CD01, 8)) {
			sector_size=all_sizes[i];
			jp=0x18;
			break;
		}
	}
	free(data);
	
	if(sector_size==0) return FAILED;
	
	*SectorSize = sector_size;
	*jmp = jp;
	
	return SUCCESS;
	
}

u8 get_FileOffset(FILE* fd, char *path, u64 *FileOffset, u32 *FileSize)
{
	u32 root_table = 0;
	u32 SectSize=0;
	u32 JP=0;
	
	if( get_SectorSize(fd, &SectSize, &JP) == FAILED) return FAILED;
	
	fseek(fd, SectSize*0x10+0xA2+JP, SEEK_SET);
	
	fread(&root_table, sizeof(u32), 1, fd);
	if(root_table == 0) return FAILED;
	
	fseek(fd, SectSize*root_table, SEEK_SET);
	
	char *sector = (char *) malloc(SectSize);
	if(sector == NULL) {
		print_load("Error : get_FileOffset : malloc");
		return FAILED;
	}
	
	int i;
	int k=0;
	int len = strlen(path);
	char item_name[255];
	for(i=0; i <= len; i++) {
		if(i==0 && path[0] == '/') continue;
		
		if(path[i] == '/' || i==len) {
			strncpy(item_name, path+i-k, k);
			memset(sector, 0, sizeof(sector));
			u32 offset=0;
			fread(sector, 1, SectSize, fd);
			int j;
			for(j=0; j<SectSize; j++) {
				if(strncmpi((char *) &sector[j], (char *) item_name , k)==0) {
					if(i==len) {
						memcpy(&offset, &sector[j-0x1B], 4);
						*FileOffset = (u64)offset*(u64)SectSize+(u64)JP;
						u32 size=0;
						memcpy(&size, &sector[j-0x13], 4);
						*FileSize = size;
						free(sector);
						return SUCCESS;
					}
					memcpy(&offset, &sector[j-0x1B], 4);
					fseek(fd, SectSize*offset, SEEK_SET);
				
					break;
				}
			}
			
			if(offset == 0) {
				free(sector);
				return FAILED;
			}
			memset(item_name, 0, sizeof(item_name));
			k=0;
		}
		else k++;
	}
	
	free(sector);
	return FAILED;
}

u8 ExtractFromISO(char *isopath, char *filename, char *output)
{
	int size;
	char *mem = LoadFileFromISO(NO, isopath, filename, &size);
	if(mem==NULL) return FAILED;

	if( SaveFile(output, mem, size) == FAILED) {
		free(mem);
		return FAILED;
	}
	
	free(mem);
	return SUCCESS;
}

void Extract_IconParam()
{
	char ICON_OUT[128];
	char PARAM_OUT[128];
	char ICON_IN[128];
	char PARAM_IN[128];
	int i;
	for(i=0; i<=game_number; i++) {
		if(list_game_platform[i] != ISO_PS3 && list_game_platform[i] != ISO_PSP) continue;
		
		if(list_game_platform[i] == ISO_PS3) {
			strcpy(ICON_IN, "/PS3_GAME/ICON0.PNG");
			strcpy(PARAM_IN, "/PS3_GAME/PARAM.SFO");
		}
		else
		if(list_game_platform[i] == ISO_PSP) {
			strcpy(ICON_IN, "/PSP_GAME/ICON0.PNG");
			strcpy(PARAM_IN, "/PSP_GAME/PARAM.SFO");
		}
		
		strcpy(ICON_OUT, list_game_path[i]);
		RemoveExtension(ICON_OUT);
		strcat(ICON_OUT, ".PNG");
		strcpy(PARAM_OUT, list_game_path[i]);
		RemoveExtension(PARAM_OUT);
		strcat(PARAM_OUT, ".SFO");
		
		if(path_info(ICON_OUT)==_NOT_EXIST) {
			ExtractFromISO(list_game_path[i], ICON_IN, ICON_OUT);
		}
		if(path_info(PARAM_OUT)==_NOT_EXIST) {
			if(ExtractFromISO(list_game_path[i], PARAM_IN, PARAM_OUT) == SUCCESS) {
				if(GetParamSFO("TITLE", list_game_title[i], list_game_path[i])==FAILED) {
					strcpy(list_game_title[i], list_game_path[i]);
					strcpy(list_game_title[i], &strrchr(list_game_title[i], '/')[1]);
					RemoveExtension(list_game_title[i]);
				}
			}
		}
	}
}

void Draw_DEFAULT(int pos, float x , float y, float z,  float w, float h, u8 center, u32 color)
{
	if(pos < 0 || game_number < pos) return;
	
	int type = list_game_platform[pos];
	u8 plat = 222;
	if(type == JB_PS1 || type == JB_PS2 || type == JB_PS3 || type == JB_PSP || type == BDVD) {
		if(PICTURE_offset[DEFAULT_JB] != 0) {
			plat = DEFAULT_JB;
		}
	} else
	if(type == ISO_PS1 || type == ISO_PS2 || type == ISO_PS3 || type == ISO_PSP) {
		if(PICTURE_offset[DEFAULT_ISO] != 0) {
			plat = DEFAULT_ISO;
		}
	} else {
		if(PICTURE_offset[DEFAULT] != 0) {
			plat = DEFAULT;
		}		
	}
	
	if(plat==222) {
		Draw_Box(x, y, z, 0, w, h, color, NO);
		return;
	}
	
	float h1 = h;
	float w1 = w;
	if( h==0 && w==0 ) {
		h1 = PICTURE[plat].height;
		w1 = PICTURE[plat].width;
	}
	if( h==0 ) {
		h1 = (PICTURE[plat].height * w) / PICTURE[plat].width;
	}
	if( w==0 ) {
		w1 = (PICTURE[plat].width * h) / PICTURE[plat].height;
	}
	
	float x1 = x;
	float y1 = y;
	if(center) {
		x1-= w1/2;
		y1-= h1/2;
	}
	
	tiny3d_SetTexture(0, PICTURE_offset[plat], PICTURE[plat].width, PICTURE[plat].height, PICTURE[plat].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
	
	u32 col = color;
	if(type == JB_PS1 || type == ISO_PS1) col = SetALPHA(GetALPHA(color), COLOR_PS1);
	if(type == JB_PS2 || type == ISO_PS2) col = SetALPHA(GetALPHA(color), COLOR_PS2);
	if(type == JB_PS3 || type == ISO_PS3 || type == BDVD) col = SetALPHA(GetALPHA(color), COLOR_PS3);
	if(type == JB_PSP || type == ISO_PSP) col = SetALPHA(GetALPHA(color), COLOR_PSP);
	Draw_Box(x1, y1, z, 0, w1, h1, col , YES);
	
}

u8 Get_GAMEPIC_TYPE(int pos, int *slot)
{
	if(pos < 0 || game_number < pos) return GAMEPIC_NONE;
	
	int TextSlot = VRAM_GetSlot(pos);
	
	if(TextSlot < 0) return GAMEPIC_NONE;
		
	if(GAMEPIC_offset[TextSlot] == 0) return GAMEPIC_NONE;
	
	*slot = TextSlot;
	
	return Get_PICType(GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height);		
}

void Draw_GAMEPIC(int pos, u8 pic, float x, float y, float z,  float w, float h, u8 center, u32 color)
{
	int TextSlot=0;
	
	u8 PICType = Get_GAMEPIC_TYPE(pos, &TextSlot);
	
	if(pic & GAMEPIC_ICON0) {
		if(PICType==GAMEPIC_ICON0) {
			float h1 = h;
			float w1 = w;
			if( h==0 && w==0 ) {
				h1 = GAMEPIC[TextSlot].height;
				w1 = GAMEPIC[TextSlot].width;
			} else
			if( h==0 ) {
				h1 = (GAMEPIC[TextSlot].height * w) / GAMEPIC[TextSlot].width;
			} else
			if( w==0 ) {
				w1 = (GAMEPIC[TextSlot].width * h) / GAMEPIC[TextSlot].height;
			}
			
			tiny3d_SetTexture(0, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height, GAMEPIC[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			float x1 = x;
			float y1 = y;
			if(center) {
				x1-= w1/2; 
				y1-= h1/2;
			}
			Draw_Box(x1, y1, z, 0, w1, h1, color, YES);
			return;
		}
	}
	
	if(pic & GAMEPIC_COVER2D) {
		if(PICType == GAMEPIC_COVER2D) {
			if(UI_position==GRID) {
				tiny3d_SetTexture(0, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height, GAMEPIC[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
				float w1= (GAMEPIC[TextSlot].width * h) / GAMEPIC[TextSlot].height;
				float h1=h;
				float x1 = x + (w-w1)/2;
				float y1 = y;
				if(center) {
					x1 -= w1/2;
					y1 -= h1/2;
				}
				Draw_Box(x1, y1, z, 0, w1, h1, color, YES);
				return;
			} else {
				Draw_COVER(pos, x, y, z, w, h, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot], center, color);
				return;
			}
		}
	}
	
	if(pic & GAMEPIC_ICON0_DEFAULT) {
		Draw_DEFAULT(pos, x, y, z, w, h, center, color);
		return;
	}
}

void Draw_MMTHM_XMB(float x , float y, float z, float w, float h,  u8 n_icon)
{
	
	if(n_icon<24) {
		if(XMB_MMTHM_XMB_offset != 0) {
			
			float local_y = y + h*n_icon;
			float tot_h = h*24;
			
			tiny3d_SetTextureWrap(0, XMB_MMTHM_XMB_offset, XMB_MMTHM_XMB.width, XMB_MMTHM_XMB.height, XMB_MMTHM_XMB.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTWRAP_CLAMP, TEXTWRAP_CLAMP, TEXTURE_LINEAR);
			
			tiny3d_SetPolygon(TINY3D_QUADS);

			tiny3d_VertexPos(x	 , y-local_y , z);
			tiny3d_VertexColor(0xFFFFFF00);
			tiny3d_VertexTexture(0.0f, 0.0f);

			tiny3d_VertexPos(x + w, y-local_y  , z);
			tiny3d_VertexTexture(1.0f, 0.0f);

			tiny3d_VertexPos(x + w, y-local_y+tot_h, z);
			tiny3d_VertexTexture(1.0f, 1.0f);

			tiny3d_VertexPos(x	, y-local_y+tot_h, z);
			tiny3d_VertexTexture(0.0f, 1.0f);

			tiny3d_End();
			
			tiny3d_SetPolygon(TINY3D_QUADS);

			tiny3d_VertexPos(x	 , y , z);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexTexture(0.0f, (local_y-y)/tot_h);

			tiny3d_VertexPos(x + w, y  , z);
			tiny3d_VertexTexture(1.0f, (local_y-y)/tot_h);

			tiny3d_VertexPos(x + w, y+h, z);
			tiny3d_VertexTexture(1.0f, (local_y-y+h)/tot_h);

			tiny3d_VertexPos(x	, y+h, z);
			tiny3d_VertexTexture(0.0f, (local_y-y+h)/tot_h);

			tiny3d_End();
			
		}
	}
	else if(n_icon < 35) {
		if(XMB_MMTHM_XMB2_offset != 0) {
			
			float local_y = y + h*(n_icon-24);
			float tot_h = h*24;
			
			tiny3d_SetTextureWrap(0, XMB_MMTHM_XMB2_offset, XMB_MMTHM_XMB2.width, XMB_MMTHM_XMB2.height, XMB_MMTHM_XMB2.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTWRAP_CLAMP, TEXTWRAP_CLAMP, TEXTURE_LINEAR);
			
			tiny3d_SetPolygon(TINY3D_QUADS);

			tiny3d_VertexPos(x	 , y-local_y , z);
			tiny3d_VertexColor(0xFFFFFF00);
			tiny3d_VertexTexture(0.0f, 0.0f);

			tiny3d_VertexPos(x + w, y-local_y  , z);
			tiny3d_VertexTexture(1.0f, 0.0f);

			tiny3d_VertexPos(x + w, y-local_y+tot_h, z);
			tiny3d_VertexTexture(1.0f, 1.0f);

			tiny3d_VertexPos(x	, y-local_y+tot_h, z);
			tiny3d_VertexTexture(0.0f, 1.0f);

			tiny3d_End();
			
			tiny3d_SetPolygon(TINY3D_QUADS);

			tiny3d_VertexPos(x	 , y , z);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexTexture(0.0f, (local_y-y)/tot_h);

			tiny3d_VertexPos(x + w, y  , z);
			tiny3d_VertexTexture(1.0f, (local_y-y)/tot_h);

			tiny3d_VertexPos(x + w, y+h, z);
			tiny3d_VertexTexture(1.0f, (local_y-y+h)/tot_h);

			tiny3d_VertexPos(x	, y+h, z);
			tiny3d_VertexTexture(0.0f, (local_y-y+h)/tot_h);

			tiny3d_End();
			
		}
	}
}

//*******************************************************
// APNG
//*******************************************************
//https://fr.wikipedia.org/wiki/Portable_Network_Graphics

#define MAGIC_PNG 0x89504E470D0A1A0A

#define IHDR 0x49484452
#define acTL 0x6163544C
#define fcTL 0x6663544C 
#define IDAT 0x49444154
#define fdAT 0x66644154
#define IEND 0x49454E44

typedef struct 
{
	u32 length;
	u32 type;
} chunk_header;

typedef struct 
{
	u32 width;
	u32 height;
	u8 depth;
	u8 color_type;
	u8 compression;
	u8 filter;
	u8 interlace;
} IHDR_data;

typedef struct
{
	u64 magic;
	chunk_header chunk_IHDR;
	IHDR_data data_IHDR;
	u32 IHDR_CRC;
	chunk_header chunk_IDAT;
} frame_header;

typedef struct 
{
	u32 num_frames;
	u32 num_plays;
} acTL_data;

typedef struct 
{
	u32 sequence_number;	// Sequence number of the animation chunk, starting from 0
	u32 width;				// Width of the following frame
	u32 height;				// Height of the following frame
	u32 x_offset;			// X position at which to render the following frame
	u32 y_offset;			// Y position at which to render the following frame
	u16 delay_num;			// Frame delay fraction numerator
	u16 delay_den;			// Frame delay fraction denominator
	u8 dispose_op;			// Type of frame area disposal to be done after rendering this frame
	u8 blend_op;			// Type of frame area rendering for this frame
} fcTL_data;		 

enum {
   APNG_DISPOSE_OP_NONE	   = 0,
   APNG_DISPOSE_OP_BACKGROUND = 1,
   APNG_DISPOSE_OP_PREVIOUS   = 2,
};

enum {
	APNG_BLEND_OP_SOURCE = 0,
	APNG_BLEND_OP_OVER   = 1,
};

u32 APNG_num_frames;
pngData APNG[MAX_FRAME];
fcTL_data APNG_data[MAX_FRAME];
u32 APNG_offset[MAX_FRAME];
u32 APNG_frame=0;

fcTL_data BG_data[MAX_FRAME];
u32 BG_frame=0;
u32 BG_num_frames;

static u64 time_s[5]={0};
static u64 time_e[5]={0};
static u64 time_n_s[5]={0};
static u64 time_n_e[5]={0};

void start_timer(u8 i)
{
	sysGetCurrentTime(&time_s[i], &time_n_s[i]);
}

u64 get_time(u8 i)
{
	sysGetCurrentTime(&time_e[i], &time_n_e[i]);
	return (((1000000000*time_e[i] + time_n_e[i]) - (1000000000*time_s[i] + time_n_s[i]))/1000000.0);
}

u64 nTime()
{
	u64 time_s=0;
	u64 time_n=0;
	sysGetCurrentTime(&time_s, &time_n);
	return 1000000000ULL*time_s + time_n;
}

u64 sTime()
{
	u64 time_s=0;
	u64 time_n=0;
	sysGetCurrentTime(&time_s, &time_n);
	
	return time_s;
}

void init_timer(u8 i)
{
	time_s[i]=0;
	time_e[i]=0;
	time_n_s[i]=0;
	time_n_e[i]=0;
}
			
u8 is_apng(char *file)
{
	FILE* f;
	u64 magic;
	chunk_header ch;
	u64 pos=0;
	
	memset(APNG_data, 0, sizeof(APNG_data));
	memset(APNG, 0, sizeof(APNG));
	memset(APNG_offset, 0, sizeof(APNG_offset));
	APNG_num_frames = 0;
	
	f=fopen(file, "rb");
	if(f==NULL) return NO;
	
	fread(&magic, 1, 8, f);
	
	if(magic != MAGIC_PNG) { 
		//print_load("Error : Magic number is not correct");
		fclose(f); return NO;
	}

	fread(&ch, 1, 8, f); 
	
	if(ch.type != IHDR) {
		//print_load("Error : ch.type != IHDR");
		fclose(f); return NO;
	}

	do { // loop to ignore unknown chunk
		pos = ftell(f) + ch.length + 4; // length of chunk_data + CRC
		
		fseek(f, pos, SEEK_SET);
		fread(&ch, 1, 8, f);
		
		if(ch.type == acTL) {
			fclose(f); 
			return YES;
		}
		
	} while (ch.type != IDAT);
	
	fclose(f);
	
	return NO;
}

u8 Load_APNG(char* filename)
{
	u64 magic;
	u32 pos;
	chunk_header ch;
	
	u8 IEND_[0xC] = {0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
	
	u8 Frame_Header[0x29];
	acTL_data ad;

	texture_pointer = texture_mem + TEXTURE_POINTER_TMP;	
	
	memset(APNG_data, 0, sizeof(APNG_data));
	memset(APNG, 0, sizeof(APNG));
	memset(APNG_offset, 0, sizeof(APNG_offset));
	APNG_num_frames = 0;
	
	print_load("Loading %s", filename);
	
	int size;
	u8 *data = (u8*) LoadFile(filename, &size);
	if(data==NULL) {
		print_load("Error :  failed to load file");
		return NO;
	}
	
	memcpy(&magic, data, 8);
	
	if(magic != MAGIC_PNG) { 
		print_load("Error :  bad magic");
		free(data);
		return NO;
	}
	
	memcpy(Frame_Header, data, 0x21);
	
	memcpy(&ch, data+0x21, 0x8);
	
	pos=0x21+8;
	
	while (ch.type != acTL)  
	{
		pos += ch.length + 4; // ignore CRC
		memcpy(&ch, data+pos, 8); pos+=8;
		
		if(ch.type == IDAT) {
			print_load("Error : no actl");
			return NO;
		}
	}
	
	memcpy(&ad, data+pos, ch.length); pos+=ch.length;
	
	APNG_num_frames = ad.num_frames;

	pos += 4; // ignore CRC
	
	u32 i;
	
	for(i=0; i<ad.num_frames; i++) {
		
		memcpy(&ch, data+pos, 8); pos+=8;
		
		while (ch.type != fcTL)
		{
			pos += ch.length + 4; // ignore CRC
			memcpy(&ch, data+pos, 8); pos+=8;
		}
		memcpy(&APNG_data[i], data+pos, ch.length); pos+=ch.length;
		
		*(u32 *) &Frame_Header[0x10] = APNG_data[i].width;
		*(u32 *) &Frame_Header[0x14] = APNG_data[i].height;
		*(u32 *) &Frame_Header[0x25] = IDAT;
		
		pos += 4; // ignore CRC
		memcpy(&ch, data+pos, 8); pos+=8;
		
		while (ch.type != IDAT && ch.type != fdAT)
		{	
			pos += ch.length + 4; // ignore CRC
			memcpy(&ch, data+pos, 8); pos+=8;
		}
		
		u32 n_AT=0;
		u32 tot_size=0;
		u32 chunk_size[1024]={0};
		u32 first_pos = pos - 8;
		
	next:
		if(ch.type == IDAT) {
			tot_size+=ch.length;
			chunk_size[n_AT]=ch.length;
			n_AT++;
			
			pos += ch.length + 4; // ignore CRC 
			memcpy(&ch, data+pos, 8); pos+=8;
						
			goto next;
		} else 
		if(ch.type == fdAT) {
			tot_size+=ch.length - 4; // ignore sequence
			chunk_size[n_AT]=ch.length - 4;
			n_AT++;
			
			pos += ch.length + 4; // ignore CRC 
			memcpy(&ch, data+pos, 8); pos+=8;
			
			goto next;
		} else {
			memcpy(&ch, data+first_pos, 8); pos = first_pos + 8;
		}
		
		*(u32 *) &Frame_Header[0x21] = tot_size;
		
		u32 ihdr_crc = crc32(0L, Z_NULL, 0);
		ihdr_crc = crc32(ihdr_crc, (const unsigned char*)Frame_Header+0xC, 0x11);
		memcpy(Frame_Header+0x1D, &ihdr_crc, 4);
		
		u8 *frame = (u8 *) malloc(0x29 + tot_size + 4 + 0xC);
		if(frame==NULL) {
			print_load("Error : failed to malloc");
			free(data);
			return NO;
		}
		
		memcpy(frame, &Frame_Header, 0x29);
		
		u32 j, cur_size=0;
		for(j=0; j<n_AT; j++) {
			if(ch.type == IDAT) {
				memcpy(frame + 0x29 + cur_size, data+pos, chunk_size[j]); pos+=chunk_size[j]+4; // ignore CRC
				memcpy(&ch, data+pos, 8); pos+=8;
			} else
			if(ch.type == fdAT) {
				pos += 4; // ignore sequence_number
				memcpy(frame + 0x29 + cur_size, data+pos, chunk_size[j]); pos+=chunk_size[j]+4; // ignore CRC
				memcpy(&ch, data+pos, 8); pos+=8;
			}
			cur_size+=chunk_size[j];
		}
		pos -= 8;	
		
		u32 crc = crc32(0L, Z_NULL, 0);
		crc = crc32(crc, (const unsigned char*)frame+0x25, 4 + tot_size);
		memcpy(frame+0x29+tot_size, &crc, 4);
		
		memcpy(frame+0x29+tot_size+4, IEND_, 0xC);
		
		//FILE* x;
		//char frame_path[128];
		//mkdir("/dev_hdd0/frames", 0777);
		//sprintf(frame_path, "/dev_hdd0/frames/frame_%d.png", i);
		//x = fopen(frame_path, "wb");
		//fwrite(frame, 1, 0x29 + tot_size + 4 + 0xC, x);
		//fclose(x);
		
		pngLoadFromBuffer((const void *) frame, 0x29 + tot_size + 4 + 0xC, &APNG[i]);
		
		free(frame);
		
		if(APNG[i].bmp_out) {
			memcpy(texture_pointer, APNG[i].bmp_out, APNG[i].pitch * APNG[i].height);
			free(APNG[i].bmp_out);
			APNG_offset[i] = tiny3d_TextureOffset(texture_pointer);
			texture_pointer += ((APNG[i].pitch * APNG[i].height + 15) & ~15) / 4;
		}
	}
	
	free(data);
	
	init_timer(0);

	return YES;
}

// u8 Load_APNG(char* filename)
// {
	// FILE* f;
	// u64 magic;
	// u32 pos;
	// chunk_header ch;
	
	// u8 IEND_[0xC] = {0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
	
	// u8 Frame_Header[0x29];
	// acTL_data ad;

	// texture_pointer = texture_mem + TEXTURE_POINTER_TMP;	
	
	// memset(APNG_data, 0, sizeof(APNG_data));
	// memset(APNG, 0, sizeof(APNG));
	// memset(APNG_offset, 0, sizeof(APNG_offset));
	// APNG_num_frames = 0;
	
	// f = fopen(filename, "rb");

	// if(f==NULL) {
		// //print_load("Error :  failed to open file");
		// return NO;
	// }
	
	// fread(&magic, 1, 8, f);
	
	// if(magic != MAGIC_PNG) { 
		// //print_load("Error :  bad magic"); 
		// fclose(f); return NO;
	// }
	
	// fseek(f, 0, SEEK_SET);
	// fread(&Frame_Header, 1, 0x21, f);
	
	// fread(&ch, 1, 8, f);
		
	// while (ch.type != acTL)  
	// {
		// pos = ftell(f) + ch.length + 4; // ignore CRC
		// fseek(f, pos, SEEK_SET);
		// fread(&ch, 1, 8, f);
		
		// if(ch.type == IDAT) {
			// //print_load("Error : no actl");
			// fclose(f);
			// return NO;
		// } // not GRID_ANIMATED
	// }
	

	// fread(&ad, 1, ch.length, f);
	
	// APNG_num_frames = ad.num_frames;

	// pos = ftell(f) + 4; // ignore CRC
	// fseek(f, pos, SEEK_SET);
	// u32 i;
	
	// for(i=0; i<ad.num_frames; i++) {
		// fread(&ch, 1, 8, f);
		
		// while (ch.type != fcTL)
		// {
			// pos = ftell(f) + ch.length + 4; // ignore CRC
			// fseek(f, pos, SEEK_SET);
			// fread(&ch, 1, 8, f);
		// }
		// fread(&APNG_data[i], 1, ch.length, f);
		
		// *(u32 *) &Frame_Header[0x10] = APNG_data[i].width;
		// *(u32 *) &Frame_Header[0x14] = APNG_data[i].height;
		// *(u32 *) &Frame_Header[0x25] = IDAT;
		
		// pos = ftell(f) + 4; // ignore CRC
		// fseek(f, pos, SEEK_SET);
		
		// fread(&ch, 1, 8, f);
		
		// while (ch.type != IDAT && ch.type != fdAT)
		// {	
			// pos = ftell(f) + ch.length + 4; // ignore CRC
			// fseek(f, pos, SEEK_SET);
			// fread(&ch, 1, 8, f);
		// }
		
		// u32 n_AT=0;
		// u32 tot_size=0;
		// u32 chunk_size[1024]={0};
		// u32 first_pos = ftell(f) - 8;
		
	// next:
		// if(ch.type == IDAT) {
			// tot_size+=ch.length;
			// chunk_size[n_AT]=ch.length;
			// n_AT++;
			
			// pos = ftell(f) + ch.length + 4; // ignore CRC 
			// fseek(f, pos, SEEK_SET);
			// fread(&ch, 1, 8, f);
			
			// goto next;
		// } else 
		// if(ch.type == fdAT) {
			// tot_size+=ch.length - 4; // ignore sequence
			// chunk_size[n_AT]=ch.length - 4;
			// n_AT++;
			
			// pos = ftell(f) + ch.length + 4; // ignore CRC
			// fseek(f, pos, SEEK_SET);
			// fread(&ch, 1, 8, f);
			
			// goto next;
		// } else {
			// fseek(f, first_pos, SEEK_SET); 
			// fread(&ch, 1, 8, f);
		// }
		
		// *(u32 *) &Frame_Header[0x21] = tot_size;
		
		// u32 ihdr_crc = crc32(0L, Z_NULL, 0);
		// ihdr_crc = crc32(ihdr_crc, (const unsigned char*)Frame_Header+0xC, 0x11);
		// memcpy(Frame_Header+0x1D, &ihdr_crc, 4);
		
		// u8 *frame = (u8 *) malloc(0x29 + tot_size + 4 + 0xC);
		// if(frame==NULL) {
			// //print_load("Error : failed to malloc");
			// return NO;
		// }
		
		// memcpy(frame, &Frame_Header, 0x29);
		
		// u32 j, cur_size=0;
		// for(j=0; j<n_AT; j++) {
			// if(ch.type == IDAT) {
				// fread(frame + 0x29 + cur_size, 1, chunk_size[j], f);
				// pos = ftell(f) + 4; // ignore CRC
				// fseek(f, pos, SEEK_SET);
				// fread(&ch, 1, 8, f);
			// } else
			// if(ch.type == fdAT) {
				// pos = ftell(f) + 4; // ignore sequence_number
				// fseek(f, pos, SEEK_SET);
				// fread(frame + 0x29 + cur_size, 1, chunk_size[j], f);
				// pos = ftell(f) + 4; // ignore CRC
				// fseek(f, pos, SEEK_SET);
				// fread(&ch, 1, 8, f);
			// }
			// cur_size+=chunk_size[j];
		// }
		// pos = ftell(f) - 8;
		// fseek(f, pos, SEEK_SET);
		
		
		// u32 crc = crc32(0L, Z_NULL, 0);
		// crc = crc32(crc, (const unsigned char*)frame+0x25, 4 + tot_size);
		// memcpy(frame+0x29+tot_size, &crc, 4);
		
		// memcpy(frame+0x29+tot_size+4, IEND_, 0xC);
		
		// //FILE* x;
		// //char frame_path[128];
		// //mkdir("/dev_hdd0/frames", 0777);
		// //sprintf(frame_path, "/dev_hdd0/frames/frame_%d.png", i);
		// //x = fopen(frame_path, "wb");
		// //fwrite(frame, 1, 0x29 + tot_size + 4 + 0xC, x);
		// //fclose(x);
		
		// pngLoadFromBuffer((const void *) frame, 0x29 + tot_size + 4 + 0xC, &APNG[i]);
		
		// free(frame);
		
		// if(APNG[i].bmp_out) {
			// memcpy(texture_pointer, APNG[i].bmp_out, APNG[i].pitch * APNG[i].height);
			// free(APNG[i].bmp_out);
			// APNG_offset[i] = tiny3d_TextureOffset(texture_pointer);
			// texture_pointer += ((APNG[i].pitch * APNG[i].height + 15) & ~15) / 4;
		// }
	// }
	
	// init_timer(0);
	
	// return YES;
// }

void Draw_APNG()
{
	
	if(time_s[0]==0) start_timer(0);
	
	SetFontZ(0);
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO); // DARK 50%
	
	
	if(APNG_frame >= APNG_num_frames) APNG_frame = 0;
	
	if(APNG_offset[APNG_frame] != 0) {
		tiny3d_SetTexture(0, APNG_offset[APNG_frame], APNG[APNG_frame].width, APNG[APNG_frame].height, APNG[APNG_frame].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		float x0, y0, w0, h0;
		float xf, yf, wf, hf;
		float r;		
		
		if( APNG[0].width > 748) {
			r = 748 / (float) APNG[0].width;
			w0 = 748;
			h0 = (float) APNG[0].height * r;
			wf = (float) APNG[APNG_frame].width * r;
			hf = (float) APNG[APNG_frame].height * r;
		} else 
		if (APNG[0].height > 412) {
			r = 412 / (float) APNG[0].height;
			h0 = 412;
			w0 = (float) APNG[0].width * r;
			wf = (float) APNG[APNG_frame].width * r;
			hf = (float) APNG[APNG_frame].height * r;
		} else {
			w0 = (float) APNG[0].width;
			h0 = (float) APNG[0].height;
			wf = (float) APNG[APNG_frame].width;
			hf = (float) APNG[APNG_frame].height;
		}
		x0 = (848 - w0) / 2;
		y0 = (512 - h0) / 2;
		xf = x0 + (float) APNG_data[APNG_frame].x_offset;
		yf = y0 + (float) APNG_data[APNG_frame].y_offset;
		
		Draw_Box(xf, yf, 0, 0, wf, hf, WHITE, YES);
	}
	
	Draw_Box(0, 460, 0, 0, 848, 20, BLACK, NO);
	FontColor(WHITE);
	DrawStringFromCenterX(424, 462 , &strrchr(TMP_PIC_path, '/')[1]);
	
	if(APNG_data[APNG_frame].delay_den == 0) APNG_data[APNG_frame].delay_den=100;
	//usleep((float) APNG_data[APNG_frame].delay_num * 1000000 / (float) APNG_data[APNG_frame].delay_den);
	
	if( get_time(0) > (APNG_data[APNG_frame].delay_num * 1000 / APNG_data[APNG_frame].delay_den) ) {
		start_timer(0);
		APNG_frame++;
	}
	
}

void Load_ANIMATED_BG(char* filename)
{
	FILE* f;
	u64 magic;
	u32 pos;
	chunk_header ch;
	
	u8 IEND_[0xC] = {0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
	
	u8 Frame_Header[0x29];
	acTL_data ad;
	
	memset(BG_data, 0, sizeof(BG_data));
	memset(BG, 0, sizeof(BG));
	memset(BG_offset, 0, sizeof(BG_offset));
	BG_num_frames = 0;
	
	prog_bar2_value=0;
	
	f = fopen(filename, "rb");

	if(f==NULL) {
		//print_load("Error :  failed to open file");
		return;
	}
	
	fread(&magic, 1, 8, f);
	
	if(magic != MAGIC_PNG) { 
		//print_load("Error :  bad magic"); 
		fclose(f); return;
	}
	
	fseek(f, 0, SEEK_SET);
	fread(&Frame_Header, 1, 0x21, f);
	
	fread(&ch, 1, 8, f);
		
	while (ch.type != acTL)  
	{
		pos = ftell(f) + ch.length + 4; // ignore CRC
		fseek(f, pos, SEEK_SET);
		fread(&ch, 1, 8, f);
		
		if(ch.type == IDAT) {
			//print_load("Error : no actl");
			fclose(f);
			return;
		} // not GRID_ANIMATED
	}

	fread(&ad, 1, ch.length, f);
	
	BG_num_frames = ad.num_frames;

	pos = ftell(f) + 4; // ignore CRC
	fseek(f, pos, SEEK_SET);
	u32 i;
	
	for(i=0; i<ad.num_frames; i++) {
		prog_bar2_value=i*100/ad.num_frames;
		fread(&ch, 1, 8, f);
		
		while (ch.type != fcTL)
		{
			pos = ftell(f) + ch.length + 4; // ignore CRC
			fseek(f, pos, SEEK_SET);
			fread(&ch, 1, 8, f);
		}
		fread(&BG_data[i], 1, ch.length, f);
		
		*(u32 *) &Frame_Header[0x10] = BG_data[i].width;
		*(u32 *) &Frame_Header[0x14] = BG_data[i].height;
		*(u32 *) &Frame_Header[0x25] = IDAT;
		
		pos = ftell(f) + 4; // ignore CRC
		fseek(f, pos, SEEK_SET);
		
		fread(&ch, 1, 8, f);
		
		while (ch.type != IDAT && ch.type != fdAT)
		{	
			pos = ftell(f) + ch.length + 4; // ignore CRC
			fseek(f, pos, SEEK_SET);
			fread(&ch, 1, 8, f);
		}
		
		u32 n_AT=0;
		u32 tot_size=0;
		u32 chunk_size[1024]={0};
		u32 first_pos = ftell(f) - 8;
		
	next:
		if(ch.type == IDAT) {
			tot_size+=ch.length;
			chunk_size[n_AT]=ch.length;
			n_AT++;
			
			pos = ftell(f) + ch.length + 4; // ignore CRC 
			fseek(f, pos, SEEK_SET);
			fread(&ch, 1, 8, f);
			
			goto next;
		} else 
		if(ch.type == fdAT) {
			tot_size+=ch.length - 4; // ignore sequence
			chunk_size[n_AT]=ch.length - 4;
			n_AT++;
			
			pos = ftell(f) + ch.length + 4; // ignore CRC
			fseek(f, pos, SEEK_SET);
			fread(&ch, 1, 8, f);
			
			goto next;
		} else {
			fseek(f, first_pos, SEEK_SET); 
			fread(&ch, 1, 8, f);
		}
		
		*(u32 *) &Frame_Header[0x21] = tot_size;
		
		u32 ihdr_crc = crc32(0L, Z_NULL, 0);
		ihdr_crc = crc32(ihdr_crc, (const unsigned char*)Frame_Header+0xC, 0x11);
		memcpy(Frame_Header+0x1D, &ihdr_crc, 4);
		
		u8 *frame = (u8 *) malloc(0x29 + tot_size + 4 + 0xC);
		if(frame==NULL) {
			//print_load("Error : failed to malloc");
			return;
		}
		
		memcpy(frame, &Frame_Header, 0x29);
		
		u32 j, cur_size=0;
		for(j=0; j<n_AT; j++) {
			if(ch.type == IDAT) {
				fread(frame + 0x29 + cur_size, 1, chunk_size[j], f);
				pos = ftell(f) + 4; // ignore CRC
				fseek(f, pos, SEEK_SET);
				fread(&ch, 1, 8, f);
			} else
			if(ch.type == fdAT) {
				pos = ftell(f) + 4; // ignore sequence_number
				fseek(f, pos, SEEK_SET);
				fread(frame + 0x29 + cur_size, 1, chunk_size[j], f);
				pos = ftell(f) + 4; // ignore CRC
				fseek(f, pos, SEEK_SET);
				fread(&ch, 1, 8, f);
			}
			cur_size+=chunk_size[j];
		}
		pos = ftell(f) - 8;
		fseek(f, pos, SEEK_SET);
		
		
		u32 crc = crc32(0L, Z_NULL, 0);
		crc = crc32(crc, (const unsigned char*)frame+0x25, 4 + tot_size);
		memcpy(frame+0x29+tot_size, &crc, 4);
		
		memcpy(frame+0x29+tot_size+4, IEND_, 0xC);
		
		//FILE* x;
		//char frame_path[128];
		//mkdir("/dev_hdd0/frames", 0777);
		//sprintf(frame_path, "/dev_hdd0/frames/frame_%d.png", i);
		//x = fopen(frame_path, "wb");
		//fwrite(frame, 1, 0x29 + tot_size + 4 + 0xC, x);
		//fclose(x);
		
		if( FILTER_BG==ENABLED) {
			imgData tp;
			
			pngLoadFromBuffer((const void *) frame, 0x29 + tot_size + 4 + 0xC, (pngData *) &tp);
						
			BG[i].height = tp.height;
			BG[i].width = tp.width;
			BG[i].pitch = tp.pitch;
			BG[i].bmp_out = (u8 *) malloc(tp.pitch*tp.height+1);
			
			u64 d;
			for(d=0; d< tp.pitch*tp.height; d+=4) {
				u8 ARGB[4];
				memcpy(&ARGB, tp.bmp_out+d, 4);
				u8 Y = 0.299*ARGB[1] + 0.587*ARGB[2] + 0.114*ARGB[3];
				u8 new_ARGB[4]={0};
				new_ARGB[0]=ARGB[0];
				new_ARGB[1]=Y;
				new_ARGB[2]=Y;
				new_ARGB[3]=Y;
				memcpy(BG[i].bmp_out + d, new_ARGB, 4);
			}
			
		} else {
			pngLoadFromBuffer((const void *) frame, 0x29 + tot_size + 4 + 0xC, (pngData *) &BG[i]);
		}
		
		free(frame);
		
		if(BG[i].bmp_out) {
			memcpy(texture_pointer, BG[i].bmp_out, BG[i].pitch * BG[i].height);
			free(BG[i].bmp_out);
			BG_offset[i] = tiny3d_TextureOffset(texture_pointer);
			texture_pointer += ((BG[i].pitch * BG[i].height + 15) & ~15) / 4;
			TEXTURE_THEME_SIZE += ((BG[i].pitch * BG[i].height + 15) & ~15) / 4;
		}
	}
	
	init_timer(1);
	BG_frame=0;
	
	prog_bar2_value=-1;
	
	return;
}

void Draw_ABG(u32 color)
{
	if(time_s[1]==0) start_timer(1);	
	
	if(BG_frame >= BG_num_frames) BG_frame = 0;
	
	if(BG_offset[BG_frame] != 0) {		
		tiny3d_SetTexture(0, BG_offset[BG_frame], BG[BG_frame].width, BG[BG_frame].height, BG[BG_frame].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(0, 0, 1000, 0, 848, 512, color, YES);
	}
	
	if(BG_data[BG_frame].delay_den == 0) BG_data[BG_frame].delay_den=100;
	
	if( get_time(1) > (BG_data[BG_frame].delay_num * 1000 / BG_data[BG_frame].delay_den) ) {
		start_timer(1);
		BG_frame++;
	}
}

void float_to_fract(float f, uint16_t *num, uint16_t *den)
{
	uint16_t a, h[3] = { 0, 1, 0 }, k[3] = { 1, 0, 0 };
	int64_t x, d, n = 1;
	int i, neg = 0;

	if (f < 0) { neg = 1; f = -f; }

	while (f != floor(f)) { n <<= 1; f *= 2; }
	d = f;

	for (i = 0; i < 15; i++) {

		a = n ? d / n : 0;
		if (i && !a) break;

		x = d; d = n; n = x % n; x = a;
		
		if (k[1] * a + k[0] >= 0xFFFF) {
			x = (0xFFFF - k[0]) / k[1];
			if (x * 2 >= a || k[1] >= 0xFFFF)
				i = 16;
			else
				break;
		}

		h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];
		k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];
	}
	*den = k[1];
	*num = neg ? -h[1] : h[1];
}

int Build_APNG(char **pngs, uint32_t nb, char *apng, float time)
{
	print_head("Making APNG...");
	
	FILE* in;
	FILE* out;
	int i;
	uint32_t ch[2];
	uint8_t Header[0x21];
	uint32_t crc;
	uint16_t num;
	uint16_t den;
	
	if(time == 0) float_to_fract(0.1, &num, &den);
	else float_to_fract(time, &num, &den);
	
	out = fopen(apng, "wb");
	if(out==NULL) return FAILED;

	prog_bar1_value = 0;
	
	for(i=0; i<nb; i++) {
		prog_bar1_value = i*100/nb;
		print_load("FILE : %s", &strrchr(pngs[i], '/')[1]);
		in = NULL;
		in = fopen(pngs[i], "rb");
		if(in == NULL) {
			fclose(out);
			Delete(apng);
			print_load("Error : Failed to open %s", pngs[i]);
			return FAILED;
		}
		
		if(cancel == YES) {	fclose(in); fclose(out); Delete(apng); return FAILED; }
		
		if(i==0) {

			fread(&Header, 0x21, 1, in);
			
			fwrite(&Header, 0x21, 1, out);
			
			uint32_t ACTL[5];
			ACTL[0]=0x8;
			ACTL[1]=acTL;
			ACTL[2]=nb;
			ACTL[3]=0;
			crc = crc32(0L, Z_NULL, 0);
			crc = crc32(crc, (const unsigned char*) &ACTL[1], 12);
			ACTL[4]	= crc;
			fwrite(&ACTL, 0x14, 1, out);
		}
		
		if(cancel == YES) {	fclose(in); fclose(out); Delete(apng); return FAILED; }

		uint8_t FCTL[0x26];
		FCTL[0] = 0; FCTL[1] = 0; FCTL[2] = 0; FCTL[3] = 0x1A;		// size
		*(uint32_t *) &FCTL[0x4] = (uint32_t) fcTL;					// flag
		if(i==0) *(uint32_t *) &FCTL[0x8] = (uint32_t) 0;
		else *(uint32_t *) &FCTL[0x8] = (uint32_t) i*2-1; 			// sequence number
		*(uint32_t *) &FCTL[0xC] = *(uint32_t *) &Header[0x10];		// w
		*(uint32_t *) &FCTL[0x10] = *(uint32_t *) &Header[0x14];	// h
		*(uint32_t *) &FCTL[0x14] = (uint32_t) 0;					// x
		*(uint32_t *) &FCTL[0x18] = (uint32_t) 0;					// y
		*(uint16_t *) &FCTL[0x1C] = (uint16_t) num;					// n
		*(uint16_t *) &FCTL[0x1E] = (uint16_t) den;					// d : n/d = 100/1000 = 0.1s = 100 ms
		FCTL[0x20] = APNG_DISPOSE_OP_NONE;
		FCTL[0x21] = APNG_BLEND_OP_SOURCE;
		
		crc = crc32(0L, Z_NULL, 0);
		crc = crc32(crc, (const unsigned char*) FCTL+0x4, 0x1E);

		memcpy(FCTL+0x22, &crc, 4);

		fwrite(FCTL, 0x26, 1, out);
		
		fseek(in, 0x21, SEEK_SET);
		
		crc = crc32(0L, Z_NULL, 0);
		uint32_t size = 4;
		char *data;
		
		if(cancel == YES) {	fclose(in); fclose(out); Delete(apng); return FAILED; }
		
		uint32_t pos = ftell(out);
		
		fwrite(&size, 4, 1, out);

		if(i==0) {
			data = malloc(4);
			*(uint32_t *) &data[0x0] = IDAT;
		
			crc = crc32(crc, (const unsigned char*) data, 4);
			fwrite(data, 4, 1, out);
			
		} else {
			data = malloc(8);
			*(uint32_t *) &data[0x0] = fdAT;
			*(uint32_t *) &data[0x4] = i*2;
		
			crc = crc32(crc, (const unsigned char*) data, 8);
			fwrite(data, 8, 1, out);
		}
		
		free(data);	
		
	next:
		
		if(cancel == YES) {	fclose(in); fclose(out); Delete(apng); return FAILED; }
	
		fread(&ch, 1, 8, in);

		while (ch[1] != IDAT && ch[1] != IEND)
		{	

			fseek(in, ch[0] + 4, SEEK_CUR);
			fread(&ch, 1, 8, in);
			
			if(cancel == YES) {	fclose(in); fclose(out); Delete(apng); return FAILED; }
			
			//if(feof(in)) {print_load("Error : EOF, IDAT/IEND not found"); fclose(in); fclose(out); Delete(apng); return FAILED;}
		}
		
		if( ch[1] == IDAT ) {
			data = malloc(ch[0]);
			fread(data, 1, ch[0], in);
			fwrite(data, 1, ch[0], out);
			crc = crc32(crc, (const unsigned char*) data, ch[0]);
			size+=ch[0];
			fseek(in, 4, SEEK_CUR);
			free(data);
			goto next;
		}
		
		
		if(cancel == YES) {	fclose(in); fclose(out); Delete(apng); return FAILED; }
		
		fwrite(&crc, 4, 1, out);
		
		uint32_t pos2 = ftell(out);
		
		fseek(out, pos, SEEK_SET);
		
		if(i==0) size = size-4;
		
		fwrite(&size, 4, 1, out);
		
		fseek(out, pos2, SEEK_SET);
		
		fclose(in);

	}
	
	uint8_t IEND_[0xC] = {0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
	fwrite(&IEND_, 0xC, 1, out);
	
	fclose(out);
	
	prog_bar1_value = -1;
	
	return SUCCESS;
}

u8 make_ABG(char *dir_path, char *file_out)
{
	
	int ret;
	char JS[255];
	int i,j,k,l,m, min;
	int png_number=-1;
	
	u8 Header_REF[0x21];
	u8 Header[0x21];
	
	char **PNGS = (char **) malloc(MAX_FRAME*sizeof(char *));
	for(i=0; i<MAX_FRAME; i++) PNGS[i]=NULL;
	
	DIR *d;
	struct dirent *dir;

	d = opendir(dir_path);
	if(d==NULL) return FAILED;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		memset(Header, 0, sizeof(Header));
		
		print_load("%s", dir->d_name);
		
		char temp[255];
		sprintf(temp, "%s/%s", dir_path, dir->d_name);
		char *ext = get_ext(temp);
		
		if( !strcasecmp(ext, ".js") ) {
			strcpy(JS, temp);
		} else
		if( !strcasecmp(ext, ".png") ) {

			FILE* fo;
			fo = fopen(temp, "rb");
			fread(&Header, 0x21, 1, fo);
			fclose(fo);
			
			if( png_number == -1 ) {

				u32 w = *(uint32_t *) &Header[0x10];	
				u32 h = *(uint32_t *) &Header[0x14];

				if( w > 640 && h > 480) {

					memcpy(Header_REF, Header, 0x21);
					png_number++;
					PNGS[png_number] = strcpy_malloc(temp);
				}
 			} 
			else {

				if( memcmp(Header, Header_REF, 0x21) == 0 ) {
					png_number++;
					PNGS[png_number] = strcpy_malloc(temp);
				}
			}
		}
	}
	closedir(d);
	
	if(png_number < 0) return FAILED; else
	if(png_number==0) {
		ret = Copy(PNGS[0], file_out);
		FREE(PNGS[0]);
		FREE(PNGS);
		return ret;
	}
	
	char *ta=NULL;
	char *tb=NULL;
	
	for(i = 0; i<png_number; i++) { 
		min = i;
		for (j = i+1; j <= png_number; j++) { 
						
			ta = strcpy_malloc(PNGS[j]);
			tb = strcpy_malloc(PNGS[min]);
			
			k=-1;
			l=-1;
			
			sscanf(strrchr(ta, '/'), "%*[^0-9]%d", &k);
			sscanf(strrchr(tb, '/'), "%*[^0-9]%d", &l);
			
			if(k==-1 || l==-1) {
				FREE(ta); FREE(tb);
				for(m=0;m<MAX_FRAME; m++) FREE(PNGS[m]);
				FREE(PNGS);
				return FAILED;
			}
			
			if( k < l ) min = j;
			
			FREE(ta); FREE(tb);
		}
		
		if(min==i) continue;
		ta = strcpy_malloc(PNGS[min]);
		FREE(PNGS[min]);
		PNGS[min] = strcpy_malloc(PNGS[i]); 
		FREE(PNGS[i]);
		PNGS[i] = strcpy_malloc(ta); 
	}
	FREE(ta); FREE(tb);

	float time=0.0;
	int size;
	char temp[64];

	char *script = LoadFile(JS, &size);
	if(script == NULL) {
		ret = Build_APNG(PNGS, png_number, file_out, 0);
		for(m=0;m<MAX_FRAME; m++) FREE(PNGS[m]);
		FREE(PNGS);
		return ret;
	}

	if( strstr(script, " IntervalTimer(") == NULL) {
		FREE(script);
		ret = Build_APNG(PNGS, png_number, file_out, 0);
		for(m=0;m<MAX_FRAME; m++) FREE(PNGS[m]);
		FREE(PNGS);
		return ret;
	}

	memcpy(temp, strstr(script, " IntervalTimer(") + 15, 64);
	
	if( strstr(temp, ",") == NULL) {
		FREE(script);
		ret = Build_APNG(PNGS, png_number, file_out, 0);
		for(m=0;m<MAX_FRAME; m++) FREE(PNGS[m]);
		FREE(PNGS);
		return ret;
	}
	strtok(temp, ",");
	sscanf(temp, "%f", &time);

	if(time == 0) {
		strcat(temp, " = ");
		char temp2[64];

		memcpy(temp2, strstr(script, temp) + strlen(temp), 64);
		if( strstr(temp2, ";") != NULL) {
			strtok(temp2, ";");
			sscanf(temp2, "%f", &time);
		}
	}
	
	FREE(script);
	
	ret = Build_APNG(PNGS, png_number, file_out, time);
	
	for(m=0;m<MAX_FRAME; m++) FREE(PNGS[m]);
	FREE(PNGS);
	
	return ret;
}

//###################################################
//	LANGUAGE
//###################################################

#define LANG(x, y, z) FREE(x); x = language(flang, y, z);

#define LOAD_STR(VALUE) LANG(STR_##VALUE, "STR_##VALUE", STR_##VALUE_DEFAULT);

char *strcpy_malloc(char *STR_DEFAULT)
{
	if(STR_DEFAULT==NULL) return NULL;
	u32 size = strlen(STR_DEFAULT)+1;
	char *STR = malloc(size+1);
	if(STR==NULL) return NULL;
	memset(STR, 0, size+1);
	strcpy(STR, STR_DEFAULT);
	return STR;
}

char *strncpy_malloc(char *STR_DEFAULT, u32 size)
{
	if(STR_DEFAULT==NULL) return NULL;
	char *STR = malloc(size+1);
	if(STR==NULL) return NULL;
	memset(STR, 0, size+1);
	strncpy(STR, STR_DEFAULT, size);
	return STR;
}

static char buff3[4096];
char *sprintf_malloc(char *format, ...)
{
	char *str = (char *) buff3;
	va_list	opt;
	
	va_start(opt, format);
	vsprintf( (void *) buff3, format, opt);
	va_end(opt);
	
	return strcpy_malloc(str);
}

char *language(char *lang_mem, const char *strName, char *str_default)
{
	if(lang_mem==NULL) return strcpy_malloc(str_default);
	
	char t[255];
	sprintf(t, "%s ", strName);
	
	char *res = strstr(lang_mem, t);
	if(res == NULL) {
		sprintf(t, "%s\t", strName);
		res = strstr(lang_mem, t);
		if(res == NULL) return strcpy_malloc(str_default);
	}
	
	char *start=strchr(res, '{');
	if(start == NULL) return strcpy_malloc(str_default);
	
	char *end=strchr(start, '}');
	if(end == NULL) return strcpy_malloc(str_default);
	
	return strncpy_malloc(&start[1], end-start-1);
}

void init_lang()
{
	
	char LOCPath[512];
	char TXTPath[512];
	
	lang_N = 0;
	STR_LANGUAGE[lang_N] = strcpy_malloc("English (default)");
	LANGCODE[lang_N] = LANG_DEFAULT;

	lang_N++;
	
	sprintf(LOCPath, "/dev_hdd0/game/%s/USRDIR/sys/loc", ManaGunZ_id);
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(LOCPath);
	if(d==NULL) return;

	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		sprintf(TXTPath, "%s/%s", LOCPath, dir->d_name);
		
		int flang_size=0;
		char* flang = LoadFile(TXTPath, &flang_size);
		if(flang==NULL) continue;
		
		LANG(STR_LANGUAGE[lang_N], "STR_LANGUAGE", NULL); 
		
		if(STR_LANGUAGE[lang_N] != NULL ) {
			char *temp_str = language(flang, "STR_LANGCODE", NULL);
			if(temp_str!=NULL) {
				short unsigned int val=0;
				sscanf(&temp_str[2], "%hX", &val);
				LANGCODE[lang_N] = (u8) val;
				FREE(temp_str);
											
				FREE(lang_path[lang_N]);
				lang_path[lang_N] = strcpy_malloc(TXTPath);
				
				lang_N++;
			}
		}
		
		FREE(flang);
	}
	closedir(d);
	
}

void update_lang()
{
	int flang_size=0;
	char *flang=NULL;
	if(lang>0) flang = LoadFile(lang_path[lang], &flang_size);
	
	LANG(STR_LANG, "STR_LANG", STR_LANG_DEFAULT);
	LANG(STR_LANG_DESC, "STR_LANG_DESC", STR_LANG_DESC_DEFAULT);
	LANG(STR_GATHERING, "STR_GATHERING", STR_GATHERING_DEFAULT);
	LANG(STR_COPYING, "STR_COPYING", STR_COPYING_DEFAULT);
	LANG(STR_FROM, "STR_FROM", STR_FROM_DEFAULT);
	LANG(STR_TO, "STR_TO", STR_TO_DEFAULT);
	LANG(STR_FILES, "STR_FILES", STR_FILES_DEFAULT);
	LANG(STR_DIRS, "STR_DIRS", STR_DIRS_DEFAULT);
	LANG(STR_UNKNOWN, "STR_UNKNOWN", STR_UNKNOWN_DEFAULT);
	LANG(STR_FILE, "STR_FILE", STR_FILE_DEFAULT);
	LANG(STR_CANCEL, "STR_CANCEL", STR_CANCEL_DEFAULT);
	LANG(STR_TURNOFF, "STR_TURNOFF", STR_TURNOFF_DEFAULT);
	LANG(STR_CANCELLED, "STR_CANCELLED", STR_CANCELLED_DEFAULT);
	LANG(STR_UNIT, "STR_UNIT", STR_UNIT_DEFAULT);
	LANG(STR_TOTALSIZE, "STR_TOTALSIZE", STR_TOTALSIZE_DEFAULT);
	LANG(STR_HIDELOGS, "STR_HIDELOGS", STR_HIDELOGS_DEFAULT);
	LANG(STR_SHOWLOGS, "STR_SHOWLOGS", STR_SHOWLOGS_DEFAULT);
	LANG(STR_BOOST, "STR_BOOST", STR_BOOST_DEFAULT);
	LANG(STR_GAMEMENU, "STR_GAMEMENU", STR_GAMEMENU_DEFAULT);
	LANG(STR_SETTINGS, "STR_SETTINGS", STR_SETTINGS_DEFAULT);
	LANG(STR_MOUNTGAME, "STR_MOUNTGAME", STR_MOUNTGAME_DEFAULT);
	LANG(STR_FILTER, "STR_FILTER", STR_FILTER_DEFAULT);
	LANG(STR_FAVORITE, "STR_FAVORITE", STR_FAVORITE_DEFAULT);
	LANG(STR_FILEMANAGER, "STR_FILEMANAGER", STR_FILEMANAGER_DEFAULT);
	LANG(STR_HOLD, "STR_HOLD", STR_HOLD_DEFAULT);
	LANG(STR_EXIT, "STR_EXIT", STR_EXIT_DEFAULT);
	LANG(STR_GAME_PROP, "STR_GAME_PROP", STR_GAME_PROP_DEFAULT);
	LANG(STR_GAME_TITLE, "STR_GAME_TITLE", STR_GAME_TITLE_DEFAULT);
	LANG(STR_GAME_PATH, "STR_GAME_PATH", STR_GAME_PATH_DEFAULT);
	LANG(STR_GAME_FORMAT, "STR_GAME_FORMAT", STR_GAME_FORMAT_DEFAULT);
	LANG(STR_GAME_SIZE, "STR_GAME_SIZE", STR_GAME_SIZE_DEFAULT);
	LANG(STR_GAME_PLATFORM, "STR_GAME_PLATFORM", STR_GAME_PLATFORM_DEFAULT);
	LANG(STR_SYSVERS, "STR_SYSVERS", STR_SYSVERS_DEFAULT);
	LANG(STR_GAMEID, "STR_GAMEID", STR_GAMEID_DEFAULT);
	LANG(STR_ELFCRC, "STR_ELFCRC", STR_ELFCRC_DEFAULT);
	LANG(STR_ELFCRCO, "STR_ELFCRCO", STR_ELFCRCO_DEFAULT);
	LANG(STR_BACK, "STR_BACK", STR_BACK_DEFAULT);
	LANG(STR_ENTER, "STR_ENTER", STR_ENTER_DEFAULT);
	LANG(STR_UPDATE_FOUND, "STR_UPDATE_FOUND", STR_UPDATE_FOUND_DEFAULT);
	LANG(STR_UPDATE, "STR_UPDATE", STR_UPDATE_DEFAULT);
	LANG(STR_SIZE, "STR_SIZE", STR_SIZE_DEFAULT);
	LANG(STR_SYSTEM, "STR_SYSTEM", STR_SYSTEM_DEFAULT);
	LANG(STR_DL, "STR_DL", STR_DL_DEFAULT);
	LANG(STR_DL_ALL, "STR_DL_ALL", STR_DL_ALL_DEFAULT);
	LANG(STR_UNPLUG, "STR_UNPLUG", STR_UNPLUG_DEFAULT);
	LANG(STR_PATH, "STR_PATH", STR_PATH_DEFAULT);
	LANG(STR_TYPE, "STR_TYPE", STR_TYPE_DEFAULT);
	LANG(STR_FOLDER, "STR_FOLDER", STR_FOLDER_DEFAULT);
	LANG(STR_DIR, "STR_DIR", STR_DIR_DEFAULT);
	LANG(STR_MULT, "STR_MULT", STR_MULT_DEFAULT);
	LANG(STR_THM_SETTINGS, "STR_THM_SETTINGS", STR_THM_SETTINGS_DEFAULT);
	LANG(STR_THM, "STR_THM", STR_THM_DEFAULT);
	LANG(STR_THM_DESC, "STR_THM_DESC", STR_THM_DESC_DEFAULT);
	LANG(STR_CREATE, "STR_CREATE", STR_CREATE_DEFAULT);
	LANG(STR_ZOOM_OUT, "STR_ZOOM_OUT", STR_ZOOM_OUT_DEFAULT);
	LANG(STR_ZOOM_IN, "STR_ZOOM_IN", STR_ZOOM_IN_DEFAULT);
	LANG(STR_MOVE_FRAME, "STR_MOVE_FRAME", STR_MOVE_FRAME_DEFAULT);
	LANG(STR_CHECK, "STR_CHECK", STR_CHECK_DEFAULT);
	LANG(STR_UNCHECK, "STR_UNCHECK", STR_UNCHECK_DEFAULT);
	LANG(STR_GAME_OPTION, "STR_GAME_OPTION", STR_GAME_OPTION_DEFAULT);
	LANG(STR_ADD_FAV, "STR_ADD_FAV", STR_ADD_FAV_DEFAULT);
	LANG(STR_REM_FAV, "STR_REM_FAV", STR_REM_FAV_DEFAULT);
	LANG(STR_FAV_DESC, "STR_FAV_DESC", STR_FAV_DESC_DEFAULT);
	LANG(STR_RENAME, "STR_RENAME", STR_RENAME_DEFAULT);
	LANG(STR_RENAME_DESC, "STR_RENAME_DESC", STR_RENAME_DESC_DEFAULT);
	LANG(STR_DELETE, "STR_DELETE", STR_DELETE_DEFAULT);
	LANG(STR_DELETE_DESC, "STR_DELETE_DESC", STR_DELETE_DESC_DEFAULT);
	LANG(STR_COPY, "STR_COPY", STR_COPY_DEFAULT);
	LANG(STR_COPY_DESC, "STR_COPY_DESC", STR_COPY_DESC_DEFAULT);
	LANG(STR_CREATE_ICON0, "STR_CREATE_ICON0", STR_CREATE_ICON0_DEFAULT);
	LANG(STR_CREATE_ICON0_DESC, "STR_CREATE_ICON0_DESC", STR_CREATE_ICON0_DESC_DEFAULT);
	LANG(STR_REST_PNACH, "STR_REST_PNACH", STR_REST_PNACH_DEFAULT);
	LANG(STR_REST_PNACH_DESC, "STR_REST_PNACH_DESC", STR_REST_PNACH_DESC_DEFAULT);
	LANG(STR_APPLY_PNACH, "STR_APPLY_PNACH", STR_APPLY_PNACH_DEFAULT);
	LANG(STR_APPLY_PNACH_DESC, "STR_APPLY_PNACH_DESC", STR_APPLY_PNACH_DESC_DEFAULT);
	LANG(STR_DISABLE_WS, "STR_DISABLE_WS", STR_DISABLE_WS_DEFAULT);
	LANG(STR_ENABLE_WS, "STR_ENABLE_WS", STR_ENABLE_WS_DEFAULT);
	LANG(STR_WS_DESC, "STR_WS_DESC", STR_WS_DESC_DEFAULT);
	LANG(STR_DISABLE_480P, "STR_DISABLE_480P", STR_DISABLE_480P_DEFAULT);
	LANG(STR_ENABLE_480P, "STR_ENABLE_480P", STR_ENABLE_480P_DEFAULT);
	LANG(STR_480P_DESC, "STR_480P_DESC", STR_480P_DESC_DEFAULT);
	LANG(STR_DISABLE_YFIX, "STR_DISABLE_YFIX", STR_DISABLE_YFIX_DEFAULT);
	LANG(STR_ENABLE_YFIX, "STR_ENABLE_YFIX", STR_ENABLE_YFIX_DEFAULT);
	LANG(STR_YFIX_DESC, "STR_YFIX_DESC", STR_YFIX_DESC_DEFAULT);
	LANG(STR_DISABLE_FMVSKIP, "STR_DISABLE_FMVSKIP", STR_DISABLE_FMVSKIP_DEFAULT);
	LANG(STR_ENABLE_FMVSKIP, "STR_ENABLE_FMVSKIP", STR_ENABLE_FMVSKIP_DEFAULT);
	LANG(STR_FMVSKIP_DESC, "STR_FMVSKIP_DESC", STR_FMVSKIP_DESC_DEFAULT);
	LANG(STR_DISABLE_NETEMU, "STR_DISABLE_NETEMU", STR_DISABLE_NETEMU_DEFAULT);
	LANG(STR_ENABLE_NETEMU, "STR_ENABLE_NETEMU", STR_ENABLE_NETEMU_DEFAULT);
	LANG(STR_NETEMU_DESC, "STR_NETEMU_DESC", STR_NETEMU_DESC_DEFAULT);
	LANG(STR_SAVE_CONFIG, "STR_SAVE_CONFIG", STR_SAVE_CONFIG_DEFAULT);
	LANG(STR_CONFIG, "STR_CONFIG", STR_CONFIG_DEFAULT);	
	LANG(STR_CONFIG_DESC, "STR_CONFIG_DESC", STR_CONFIG_DESC_DEFAULT);
	LANG(STR_NONE, "STR_NONE", STR_NONE_DEFAULT);
	LANG(STR_CHECK_MD5, "STR_CHECK_MD5", STR_CHECK_MD5_DEFAULT);
	LANG(STR_PROPS, "STR_PROPS", STR_PROPS_DEFAULT);
	LANG(STR_PROPS_DESC, "STR_PROPS_DESC", STR_PROPS_DESC_DEFAULT);
	LANG(STR_GAME_SETTINGS, "STR_GAME_SETTINGS", STR_GAME_SETTINGS_DEFAULT);
	LANG(STR_DIRECT_BOOT, "STR_DIRECT_BOOT", STR_DIRECT_BOOT_DEFAULT);
	LANG(STR_DIRECT_BOOT_DESC, "STR_DIRECT_BOOT_DESC", STR_DIRECT_BOOT_DESC_DEFAULT);
	LANG(STR_YES, "STR_YES", STR_YES_DEFAULT);
	LANG(STR_NO, "STR_NO", STR_NO_DEFAULT);
	LANG(STR_CLEAN_SYSCALL, "STR_CLEAN_SYSCALL", STR_CLEAN_SYSCALL_DEFAULT);
	LANG(STR_CLEAN_SYSCALL_DESC, "STR_CLEAN_SYSCALL_DESC", STR_CLEAN_SYSCALL_DESC_DEFAULT);
	LANG(STR_CHANGE_IDPS, "STR_CHANGE_IDPS", STR_CHANGE_IDPS_DEFAULT);
	LANG(STR_CHANGE_IDPS_DESC, "STR_CHANGE_IDPS_DESC", STR_CHANGE_IDPS_DESC_DEFAULT);
	LANG(STR_EXT_GAME_DATA, "STR_EXT_GAME_DATA", STR_EXT_GAME_DATA_DEFAULT);
	LANG(STR_EXT_GAME_DATA_DESC, "STR_EXT_GAME_DATA_DESC", STR_EXT_GAME_DATA_DESC_DEFAULT);
	LANG(STR_PAYLOAD, "STR_PAYLOAD", STR_PAYLOAD_DEFAULT);
	LANG(STR_PAYLOAD_DESC, "STR_PAYLOAD_DESC", STR_PAYLOAD_DESC_DEFAULT);
	LANG(STR_PRIM_USB, "STR_PRIM_USB", STR_PRIM_USB_DEFAULT);
	LANG(STR_PRIM_USB_DESC, "STR_PRIM_USB_DESC", STR_PRIM_USB_DESC_DEFAULT);
	LANG(STR_BDEMU, "STR_BDEMU", STR_BDEMU_DEFAULT);
	LANG(STR_BDEMU_DESC, "STR_BDEMU_DESC", STR_BDEMU_DESC_DEFAULT);
	LANG(STR_PATCH_LIBFS, "STR_PATCH_LIBFS", STR_PATCH_LIBFS_DEFAULT);
	LANG(STR_PATCH_LIBFS_DESC, "STR_PATCH_LIBFS_DESC", STR_PATCH_LIBFS_DESC_DEFAULT);
	LANG(STR_MOUNT_APPHOME, "STR_MOUNT_APPHOME", STR_MOUNT_APPHOME_DEFAULT);
	LANG(STR_MOUNT_APPHOME_DESC, "STR_MOUNT_APPHOME_DESC", STR_MOUNT_APPHOME_DESC_DEFAULT);
	LANG(STR_PATCH_EXP, "STR_PATCH_EXP", STR_PATCH_EXP_DEFAULT);
	LANG(STR_PATCH_EXP_DESC, "STR_PATCH_EXP_DESC", STR_PATCH_EXP_DESC_DEFAULT);
	LANG(STR_MAKE_SHTCUT_PKG, "STR_MAKE_SHTCUT_PKG", STR_MAKE_SHTCUT_PKG_DEFAULT);
	LANG(STR_MAKE_SHTCUT_PKG_DESC, "STR_MAKE_SHTCUT_PKG_DESC", STR_MAKE_SHTCUT_PKG_DESC_DEFAULT);
	LANG(STR_PATCH_EBOOT, "STR_PATCH_EBOOT", STR_PATCH_EBOOT_DEFAULT);
	LANG(STR_PATCH_EBOOT_DESC, "STR_PATCH_EBOOT_DESC", STR_PATCH_EBOOT_DESC_DEFAULT);
	LANG(STR_RESIGN, "STR_RESIGN", STR_RESIGN_DEFAULT);
	LANG(STR_RESIGN_DESC, "STR_RESIGN_DESC", STR_RESIGN_DESC_DEFAULT);
	LANG(STR_RESTORE, "STR_RESTORE", STR_RESTORE_DEFAULT);
	LANG(STR_RESTORE_DESC, "STR_RESTORE_DESC", STR_RESTORE_DESC_DEFAULT);
	LANG(STR_EXTRACT_ISO, "STR_EXTRACT_ISO", STR_EXTRACT_ISO_DEFAULT);
	LANG(STR_EXTRACT_ISO_DESC, "STR_EXTRACT_ISO_DESC", STR_EXTRACT_ISO_DESC_DEFAULT);
	LANG(STR_CONVERT_ISO, "STR_CONVERT_ISO", STR_CONVERT_ISO_DEFAULT);
	LANG(STR_CONVERT_ISO_DESC, "STR_CONVERT_ISO_DESC", STR_CONVERT_ISO_DESC_DEFAULT);
	LANG(STR_FIX_PERMS, "STR_FIX_PERMS", STR_FIX_PERMS_DEFAULT);
	LANG(STR_FIX_PERMS_DESC, "STR_FIX_PERMS_DESC", STR_FIX_PERMS_DESC_DEFAULT);
	LANG(STR_CHECK_IRD, "STR_CHECK_IRD", STR_CHECK_IRD_DEFAULT);
	LANG(STR_CHECK_DESC, "STR_CHECK_DESC", STR_CHECK_DESC_DEFAULT);
	LANG(STR_DL_UPDATE, "STR_DL_UPDATE", STR_DL_UPDATE_DEFAULT);
	LANG(STR_DL_UPDATE_DESC, "STR_DL_UPDATE_DESC", STR_DL_UPDATE_DESC_DEFAULT);
	LANG(STR_OPEN_WINDOW, "STR_OPEN_WINDOW", STR_OPEN_WINDOW_DEFAULT);
	LANG(STR_MOUNT_DEVBLIND, "STR_MOUNT_DEVBLIND", STR_MOUNT_DEVBLIND_DEFAULT);
	LANG(STR_DUMP_LV1, "STR_DUMP_LV1", STR_DUMP_LV1_DEFAULT);
	LANG(STR_DUMP_LV2, "STR_DUMP_LV2", STR_DUMP_LV2_DEFAULT);
	LANG(STR_DUMP_FLASH, "STR_DUMP_FLASH", STR_DUMP_FLASH_DEFAULT);
	LANG(STR_REFRESH, "STR_REFRESH", STR_REFRESH_DEFAULT);
	LANG(STR_NEWFOLDER, "STR_NEWFOLDER", STR_NEWFOLDER_DEFAULT);
	LANG(STR_NEWFILE, "STR_NEWFILE", STR_NEWFILE_DEFAULT);
	LANG(STR_PASTE, "STR_PASTE", STR_PASTE_DEFAULT);
	LANG(STR_CUT, "STR_CUT", STR_CUT_DEFAULT);
	LANG(STR_UNSELECT_ALL, "STR_UNSELECT_ALL", STR_UNSELECT_ALL_DEFAULT);
	LANG(STR_SELECT_ALL, "STR_SELECT_ALL", STR_SELECT_ALL_DEFAULT);
	LANG(STR_MAKE_PKG, "STR_MAKE_PKG", STR_MAKE_PKG_DEFAULT);
	LANG(STR_GETMD5, "STR_GETMD5", STR_GETMD5_DEFAULT);
	LANG(STR_GETSHA1, "STR_GETSHA1", STR_GETSHA1_DEFAULT);
	LANG(STR_VIEW, "STR_VIEW", STR_VIEW_DEFAULT);
	LANG(STR_VIEW_TXT, "STR_VIEW_TXT", STR_VIEW_TXT_DEFAULT);
	LANG(STR_VIEW_SFO, "STR_VIEW_SFO", STR_VIEW_SFO_DEFAULT);
	LANG(STR_READ_XREG, "STR_READ_XREG", STR_READ_XREG_DEFAULT);
	LANG(STR_EXTRACT_ELF, "STR_EXTRACT_ELF", STR_EXTRACT_ELF_DEFAULT);
	LANG(STR_RESIGN_SELF, "STR_RESIGN_SELF", STR_RESIGN_SELF_DEFAULT);
	LANG(STR_LAUNCH_SELF, "STR_LAUNCH_SELF", STR_LAUNCH_SELF_DEFAULT);
	LANG(STR_EXTRACT_EBOOT, "STR_EXTRACT_EBOOT", STR_EXTRACT_EBOOT_DEFAULT);
	LANG(STR_RESIGN_EBOOT, "STR_RESIGN_EBOOT", STR_RESIGN_EBOOT_DEFAULT);
	LANG(STR_LAUNCH_EBOOT, "STR_LAUNCH_EBOOT", STR_LAUNCH_EBOOT_DEFAULT);
	LANG(STR_SIGN_ELF, "STR_SIGN_ELF", STR_SIGN_ELF_DEFAULT);
	LANG(STR_SIGN_EBOOT, "STR_SIGN_EBOOT", STR_SIGN_EBOOT_DEFAULT);
	LANG(STR_SIGN_PRX, "STR_SIGN_PRX", STR_SIGN_PRX_DEFAULT);
	LANG(STR_EXTRACT_PRX, "STR_EXTRACT_PRX", STR_EXTRACT_PRX_DEFAULT);
	LANG(STR_RESIGN_SPRX, "STR_RESIGN_SPRX", STR_RESIGN_SPRX_DEFAULT);
	LANG(STR_REMOVE_PRXLOADER, "STR_REMOVE_PRXLOADER", STR_REMOVE_PRXLOADER_DEFAULT);
	LANG(STR_ADD_PRXLOADER, "STR_ADD_PRXLOADER", STR_ADD_PRXLOADER_DEFAULT);
	LANG(STR_REMOVE_PRXLOADER2, "STR_REMOVE_PRXLOADER2", STR_REMOVE_PRXLOADER2_DEFAULT);
	LANG(STR_ADD_PRXLOADER2, "STR_ADD_PRXLOADER2", STR_ADD_PRXLOADER2_DEFAULT);
	LANG(STR_REMOVE_MAMBA, "STR_REMOVE_MAMBA", STR_REMOVE_MAMBA_DEFAULT);
	LANG(STR_ADD_MAMBA, "STR_ADD_MAMBA", STR_ADD_MAMBA_DEFAULT);
	LANG(STR_REMOVE_COBRA, "STR_REMOVE_COBRA", STR_REMOVE_COBRA_DEFAULT);
	LANG(STR_ADD_COBRA, "STR_ADD_COBRA", STR_ADD_COBRA_DEFAULT);
	LANG(STR_EXTRACT_RCO, "STR_EXTRACT_RCO", STR_EXTRACT_RCO_DEFAULT);
	LANG(STR_EXTRACT_PKG, "STR_EXTRACT_PKG", STR_EXTRACT_PKG_DEFAULT);
	LANG(STR_PKG_INFO, "STR_PKG_INFO", STR_PKG_INFO_DEFAULT);
	LANG(STR_EXTRACT_TRP, "STR_EXTRACT_TRP", STR_EXTRACT_TRP_DEFAULT);
	LANG(STR_COMPRESS_ISO, "STR_COMPRESS_ISO", STR_COMPRESS_ISO_DEFAULT);
	LANG(STR_CHECK_CRC32, "STR_CHECK_CRC32", STR_CHECK_CRC32_DEFAULT);
	LANG(STR_DECOMPRESS_CSO, "STR_DECOMPRESS_CSO", STR_DECOMPRESS_CSO_DEFAULT);
	LANG(STR_EXTRACT_THM, "STR_EXTRACT_THM", STR_EXTRACT_THM_DEFAULT);
	LANG(STR_EXTRACT_P3T, "STR_EXTRACT_P3T", STR_EXTRACT_P3T_DEFAULT);
	LANG(STR_EXTRACT_RAF, "STR_EXTRACT_RAF", STR_EXTRACT_RAF_DEFAULT);
	LANG(STR_EXTRACT_QRC, "STR_EXTRACT_QRC", STR_EXTRACT_QRC_DEFAULT);
	LANG(STR_EXTRACT_HERE, "STR_EXTRACT_HERE", STR_EXTRACT_HERE_DEFAULT);
	LANG(STR_CONVERT_JSX_JS, "STR_CONVERT_JSX_JS", STR_CONVERT_JSX_JS_DEFAULT);
	LANG(STR_CONVERT_VAG_WAV, "STR_CONVERT_VAG_WAV", STR_CONVERT_VAG_WAV_DEFAULT);
	LANG(STR_CONVERT_GTF_DDS, "STR_CONVERT_GTF_DDS", STR_CONVERT_GTF_DDS_DEFAULT);
	LANG(STR_CONVERT_DDS_PNG, "STR_CONVERT_DDS_PNG", STR_CONVERT_DDS_PNG_DEFAULT);
	LANG(STR_MAKE_APNG, "STR_MAKE_APNG", STR_MAKE_APNG_DEFAULT);
	LANG(STR_SET_PERMS, "STR_SET_PERMS", STR_SET_PERMS_DEFAULT);
	LANG(STR_NOGAME, "STR_NOGAME", STR_NOGAME_DEFAULT);
	LANG(STR_GLOB_SETTINGS, "STR_GLOB_SETTINGS", STR_GLOB_SETTINGS_DEFAULT);
	LANG(STR_ADJUST, "STR_ADJUST", STR_ADJUST_DEFAULT);
	LANG(STR_ADJUST_DESC, "STR_ADJUST_DESC", STR_ADJUST_DESC_DEFAULT);
	LANG(STR_DL_COVER, "STR_DL_COVER", STR_DL_COVER_DEFAULT);
	LANG(STR_DL_COVER_DESC, "STR_DL_COVER_DESC", STR_DL_COVER_DESC_DEFAULT);
	LANG(STR_PLUGIN_MANAGER, "STR_PLUGIN_MANAGER", STR_PLUGIN_MANAGER_DEFAULT);
	LANG(STR_PLUGIN_MANAGER_DESC, "STR_PLUGIN_MANAGER_DESC", STR_PLUGIN_MANAGER_DESC_DEFAULT);
	LANG(STR_UPD_MGZ, "STR_UPD_MGZ", STR_UPD_MGZ_DEFAULT);
	LANG(STR_UPD_MGZ_DESC, "STR_UPD_MGZ_DESC", STR_UPD_MGZ_DESC_DEFAULT);
	LANG(STR_GAME_PATHS, "STR_GAME_PATHS", STR_GAME_PATHS_DEFAULT);
	LANG(STR_GAME_PATHS_DESC, "STR_GAME_PATHS_DESC", STR_GAME_PATHS_DESC_DEFAULT);
	LANG(STR_XMB_PRIO, "STR_XMB_PRIO", STR_XMB_PRIO_DEFAULT);
	LANG(STR_XMB_PRIO_DESC, "STR_XMB_PRIO_DESC", STR_XMB_PRIO_DESC_DEFAULT);
	LANG(STR_HELP, "STR_HELP", STR_HELP_DEFAULT);
	LANG(STR_HELP_DESC, "STR_HELP_DESC", STR_HELP_DESC_DEFAULT);
	LANG(STR_COLOR_1, "STR_COLOR_1", STR_COLOR_1_DEFAULT);
	LANG(STR_COLOR_2, "STR_COLOR_2", STR_COLOR_2_DEFAULT);
	LANG(STR_COLOR_3, "STR_COLOR_3", STR_COLOR_3_DEFAULT);
	LANG(STR_COLOR_4, "STR_COLOR_4", STR_COLOR_4_DEFAULT);
	LANG(STR_COLOR_DESC, "STR_COLOR_DESC", STR_COLOR_DESC_DEFAULT);
	LANG(STR_UI_SETTINGS, "STR_UI_SETTINGS", STR_UI_SETTINGS_DEFAULT);
	LANG(STR_UI, "STR_UI", STR_UI_DEFAULT);
	LANG(STR_UI_DESC, "STR_UI_DESC", STR_UI_DESC_DEFAULT);
	LANG(STR_SIDE_MENU, "STR_SIDE_MENU", STR_SIDE_MENU_DEFAULT);
	LANG(STR_SIDE_MENU_DESC, "STR_SIDE_MENU_DESC", STR_SIDE_MENU_DESC_DEFAULT);
	LANG(STR_SHOW_PIC1, "STR_SHOW_PIC1", STR_SHOW_PIC1_DEFAULT);
	LANG(STR_SHOW_PIC1_DESC, "STR_SHOW_PIC1_DESC", STR_SHOW_PIC1_DESC_DEFAULT);
	LANG(STR_SHOW_COVER, "STR_SHOW_COVER", STR_SHOW_COVER_DEFAULT);
	LANG(STR_SHOW_COVER_DESC, "STR_SHOW_COVER_DESC", STR_SHOW_COVER_DESC_DEFAULT);
	LANG(STR_SHOW_GAMECASE, "STR_SHOW_GAMECASE", STR_SHOW_GAMECASE_DEFAULT);
	LANG(STR_SHOW_GAMECASE_DESC, "STR_SHOW_GAMECASE_DESC", STR_SHOW_GAMECASE_DESC_DEFAULT);
	LANG(STR_SHOW_ICON0, "STR_SHOW_ICON0", STR_SHOW_ICON0_DEFAULT);
	LANG(STR_SHOW_ICON0_DESC, "STR_SHOW_ICON0_DESC", STR_SHOW_ICON0_DESC_DEFAULT);
	LANG(STR_GRID_TYPE, "STR_GRID_TYPE", STR_GRID_TYPE_DEFAULT);
	LANG(STR_GRID_TYPE_DESC, "STR_GRID_TYPE_DESC", STR_GRID_TYPE_DESC_DEFAULT);
	LANG(STR_SCROLL, "STR_SCROLL", STR_SCROLL_DEFAULT);
	LANG(STR_PAGE, "STR_PAGE", STR_PAGE_DEFAULT);
	LANG(STR_DIRECTION, "STR_DIRECTION", STR_DIRECTION_DEFAULT);
	LANG(STR_DIRECTION_DESC, "STR_DIRECTION_DESC", STR_DIRECTION_DESC_DEFAULT);
	LANG(STR_VERTICAL, "STR_VERTICAL", STR_VERTICAL_DEFAULT);
	LANG(STR_HORIZONTAL, "STR_HORIZONTAL", STR_HORIZONTAL_DEFAULT);
	LANG(STR_ANIMATED, "STR_ANIMATED", STR_ANIMATED_DEFAULT);
	LANG(STR_ANIMATED_DESC, "STR_ANIMATED_DESC", STR_ANIMATED_DESC_DEFAULT);
	LANG(STR_KEEP_PROP, "STR_KEEP_PROP", STR_KEEP_PROP_DEFAULT);
	LANG(STR_KEEP_PROP_DESC, "STR_KEEP_PROP_DESC", STR_KEEP_PROP_DESC_DEFAULT);
	LANG(STR_NB_COL, "STR_NB_COL", STR_NB_COL_DEFAULT);
	LANG(STR_NB_COL_DESC, "STR_NB_COL_DESC", STR_NB_COL_DESC_DEFAULT);
	LANG(STR_NB_LINE, "STR_NB_LINE", STR_NB_LINE_DEFAULT);
	LANG(STR_NB_LINE_DESC, "STR_NB_LINE_DESC", STR_NB_LINE_DESC_DEFAULT);
	LANG(STR_INVERSE, "STR_INVERSE", STR_INVERSE_DEFAULT);
	LANG(STR_INVERSE_DESC, "STR_INVERSE_DESC", STR_INVERSE_DESC_DEFAULT);
	LANG(STR_3D, "STR_3D", STR_3D_DEFAULT);
	LANG(STR_3D_DESC, "STR_3D_DESC", STR_3D_DESC_DEFAULT);
	LANG(STR_ADD, "STR_ADD", STR_ADD_DEFAULT);
	LANG(STR_LOAD, "STR_LOAD", STR_LOAD_DEFAULT);
	LANG(STR_CHANGE, "STR_CHANGE", STR_CHANGE_DEFAULT);
	LANG(STR_COLOR, "STR_COLOR", STR_COLOR_DEFAULT);
	LANG(STR_RESET, "STR_RESET", STR_RESET_DEFAULT);
	LANG(STR_FAILED, "STR_FAILED", STR_FAILED_DEFAULT);
	LANG(STR_DONE, "STR_DONE", STR_DONE_DEFAULT);
	LANG(STR_OPEN, "STR_OPEN", STR_OPEN_DEFAULT);
	LANG(STR_CLOSE, "STR_CLOSE", STR_CLOSE_DEFAULT);
	LANG(STR_OPTION, "STR_OPTION", STR_OPTION_DEFAULT);
	LANG(STR_SELECT, "STR_SELECT", STR_SELECT_DEFAULT);
	LANG(STR_WINDOW, "STR_WINDOW", STR_WINDOW_DEFAULT);
	LANG(STR_CLICK, "STR_CLICK", STR_CLICK_DEFAULT);
	LANG(STR_CURSOR, "STR_CURSOR", STR_CURSOR_DEFAULT);
	LANG(STR_NEXT, "STR_NEXT", STR_NEXT_DEFAULT);
	LANG(STR_PREVIOUS, "STR_PREVIOUS", STR_PREVIOUS_DEFAULT);
	LANG(STR_SET_COLOR, "STR_SET_COLOR", STR_SET_COLOR_DEFAULT);
	LANG(STR_HIDETV, "STR_HIDETV", STR_HIDETV_DEFAULT);
	LANG(STR_SHOWTV, "STR_SHOWTV", STR_SHOWTV_DEFAULT);
	LANG(STR_MOVE_TO_PLUGINS, "STR_MOVE_TO_PLUGINS", STR_MOVE_TO_PLUGINS_DEFAULT);
	LANG(STR_ASK_PLUGINS, "STR_ASK_PLUGINS", STR_ASK_PLUGINS_DEFAULT);
	LANG(STR_CHANGE_VALUE, "STR_CHANGE_VALUE", STR_CHANGE_VALUE_DEFAULT);
	LANG(STR_LOAD_IDPS_LV2, "STR_LOAD_IDPS_LV2", STR_LOAD_IDPS_LV2_DEFAULT);
	LANG(STR_LOAD_IDPS_EID5, "STR_LOAD_IDPS_EID5", STR_LOAD_IDPS_EID5_DEFAULT);
	LANG(STR_NAME, "STR_NAME", STR_NAME_DEFAULT);
	LANG(STR_DOCK_RIGHT, "STR_DOCK_RIGHT", STR_DOCK_RIGHT_DEFAULT);
	LANG(STR_DOCK_LEFT, "STR_DOCK_LEFT", STR_DOCK_LEFT_DEFAULT);
	LANG(STR_DOCK_FULL, "STR_DOCK_FULL", STR_DOCK_FULL_DEFAULT);
	LANG(STR_PLUGIN_MONITOR, "STR_PLUGIN_MONITOR", STR_PLUGIN_MONITOR_DEFAULT);
	LANG(STR_UNUSED, "STR_UNUSED", STR_UNUSED_DEFAULT);
	LANG(STR_UNLOAD, "STR_UNLOAD", STR_UNLOAD_DEFAULT);
	LANG(STR_BOOT_FILE, "STR_BOOT_FILE", STR_BOOT_FILE_DEFAULT);
	LANG(STR_CURRENT, "STR_CURRENT", STR_CURRENT_DEFAULT);	
	LANG(STR_NET, "STR_NET", STR_NET_DEFAULT);
	LANG(STR_SOFT, "STR_SOFT", STR_SOFT_DEFAULT);	
	LANG(STR_GX, "STR_GX", STR_GX_DEFAULT);
	LANG(STR_CUSTOM, "STR_CUSTOM", STR_CUSTOM_DEFAULT);
	LANG(STR_NEW_CMD, "STR_NEW_CMD", STR_NEW_CMD_DEFAULT);	
	LANG(STR_PNACH, "STR_PNACH", STR_PNACH_DEFAULT);
	LANG(STR_WIDESCREEN, "STR_WIDESCREEN", STR_WIDESCREEN_DEFAULT);
	LANG(STR_480P, "STR_480P", STR_480P_DEFAULT);
	LANG(STR_YFIX, "STR_YFIX", STR_YFIX_DEFAULT);	
	LANG(STR_FMV, "STR_FMV", STR_FMV_DEFAULT);
	LANG(STR_SIMPLE, "STR_SIMPLE", STR_SIMPLE_DEFAULT);	
	LANG(STR_ADVANCED, "STR_ADVANCED", STR_ADVANCED_DEFAULT);
	LANG(STR_INSTALL_MGZ, "STR_INSTALL_MGZ", STR_INSTALL_MGZ_DEFAULT);
	LANG(STR_UP2DATE, "STR_UP2DATE", STR_UP2DATE_DEFAULT);	
	LANG(STR_SHOW_WAVES, "STR_SHOW_WAVES", STR_SHOW_WAVES_DEFAULT);
	LANG(STR_SHOW_WAVES_DESC, "STR_SHOW_WAVES_DESC", STR_SHOW_WAVES_DESC_DEFAULT);
	LANG(STR_WAVES_COLOR, "STR_WAVES_COLOR", STR_WAVES_COLOR_DEFAULT);
	LANG(STR_WAVES_COLOR_DESC, "STR_WAVES_COLOR_DESC", STR_WAVES_COLOR_DESC_DEFAULT);
	LANG(STR_USE_CONFIG, "STR_USE_CONFIG", STR_USE_CONFIG_DEFAULT);
	LANG(STR_COLORSET, "STR_COLORSET", STR_COLORSET_DEFAULT);
	LANG(STR_COLORSET_DESC, "STR_COLORSET_DESC", STR_COLORSET_DESC_DEFAULT);
	LANG(STR_GRID_SCROLL, "STR_GRID_SCROLL", STR_GRID_SCROLL_DEFAULT);
	LANG(STR_ADD_LIMG, "STR_ADD_LIMG", STR_ADD_LIMG_DEFAULT);
	LANG(STR_REMOVE_LIMG, "STR_REMOVE_LIMG", STR_REMOVE_LIMG_DEFAULT);
	LANG(STR_LIMG_DESC, "STR_LIMG_DESC", STR_LIMG_DESC_DEFAULT);
	LANG(STR_FONT, "STR_FONT", STR_FONT_DEFAULT);
	LANG(STR_FONT_DESC, "STR_FONT_DESC", STR_FONT_DESC_DEFAULT);
	LANG(STR_MOVE, "STR_MOVE", STR_MOVE_DEFAULT);
	LANG(STR_JOIN, "STR_JOIN", STR_JOIN_DEFAULT);
	LANG(STR_JOIN_DESC, "STR_JOIN_DESC", STR_JOIN_DESC_DEFAULT);
	LANG(STR_COLOR_FILTER, "STR_COLOR_FILTER", STR_COLOR_FILTER_DEFAULT);
	LANG(STR_COLOR_NOTIF, "STR_COLOR_NOTIF", STR_COLOR_NOTIF_DEFAULT);
	LANG(STR_COLOR_BOXHEAD, "STR_COLOR_BOXHEAD", STR_COLOR_BOXHEAD_DEFAULT);
	LANG(STR_COLOR_BOXBODY, "STR_COLOR_BOXBODY", STR_COLOR_BOXBODY_DEFAULT);
	LANG(STR_COLOR_SIDEBAR, "STR_COLOR_SIDEBAR", STR_COLOR_SIDEBAR_DEFAULT);
	LANG(STR_COLOR_BGS, "STR_COLOR_BGS", STR_COLOR_BGS_DEFAULT);
	LANG(STR_COLOR_BG, "STR_COLOR_BG", STR_COLOR_BG_DEFAULT);
	LANG(STR_ROOT_DISPLAY, "STR_ROOT_DISPLAY", STR_ROOT_DISPLAY_DEFAULT);
	LANG(STR_ROOT_DISPLAY_DESC, "STR_ROOT_DISPLAY_DESC", STR_ROOT_DISPLAY_DEFAULT);
	LANG(STR_STYLE, "STR_STYLE", STR_STYLE_DEFAULT);
	LANG(STR_STYLE_CUSTOM, "STR_STYLE_CUSTOM", STR_STYLE_CUSTOM_DEFAULT);
	LANG(STR_STYLE1, "STR_STYLE1", STR_STYLE1_DEFAULT);
	LANG(STR_STYLE2, "STR_STYLE2", STR_STYLE2_DEFAULT);
	LANG(STR_STYLE3, "STR_STYLE3", STR_STYLE3_DEFAULT);
	LANG(STR_STYLE4, "STR_STYLE4", STR_STYLE4_DEFAULT);
	LANG(STR_STYLE5, "STR_STYLE5", STR_STYLE5_DEFAULT);
	LANG(STR_STYLE6, "STR_STYLE6", STR_STYLE6_DEFAULT);
	LANG(STR_FREEOF, "STR_FREEOF", STR_FREEOF_DEFAULT);
	LANG(STR_ROOTLABEL, "STR_ROOTLABEL", STR_ROOTLABEL_DEFAULT);
	LANG(STR_FM_ICONSIZE, "STR_FM_ICONSIZE", STR_FM_ICONSIZE_DEFAULT);
	LANG(STR_FM_BIG, "STR_FM_BIG", STR_FM_BIG_DEFAULT);
	LANG(STR_FM_SMALL, "STR_FM_SMALL", STR_FM_SMALL_DEFAULT);
	LANG(STR_FM_ROWNUMBER, "STR_FM_ROWNUMBER", STR_FM_ROWNUMBER_DEFAULT);
	LANG(STR_FM_ROWSIZE, "STR_FM_ROWSIZE", STR_FM_ROWSIZE_DEFAULT);
	LANG(STR_FM_LEFT_CONTENT, "STR_FM_LEFT_CONTENT", STR_FM_LEFT_CONTENT_DEFAULT);
	LANG(STR_FM_RIGHT_CONTENT, "STR_FM_RIGHT_CONTENT", STR_FM_RIGHT_CONTENT_DEFAULT);
	LANG(STR_FM_EMPTY, "STR_FM_EMPTY", STR_FM_EMPTY_DEFAULT);
	LANG(STR_FM_MOUNTPOINT, "STR_FM_MOUNTPOINT", STR_FM_MOUNTPOINT_DEFAULT);
	LANG(STR_FM_DEVICE, "STR_FM_DEVICE", STR_FM_DEVICE_DEFAULT);
	LANG(STR_FM_LABEL, "STR_FM_LABEL", STR_FM_LABEL_DEFAULT);
	LANG(STR_FM_CAPACITY, "STR_FM_CAPACITY", STR_FM_CAPACITY_DEFAULT);
	LANG(STR_FM_MEMINSIDE, "STR_FM_MEMINSIDE", STR_FM_MEMINSIDE_DEFAULT);
	LANG(STR_FM_MEMOUTSIDE, "STR_FM_MEMOUTSIDE", STR_FM_MEMOUTSIDE_DEFAULT);
	LANG(STR_FM_FILESYSTEM, "STR_FM_FILESYSTEM", STR_FM_FILESYSTEM_DEFAULT);
	LANG(STR_FM_CB_WIDTH, "STR_FM_CB_WIDTH", STR_FM_CB_WIDTH_DEFAULT);
	LANG(STR_FM_MEMORY, "STR_FM_MEMORY", STR_FM_MEMORY_DEFAULT);
	LANG(STR_FM_ICON, "STR_FM_ICON", STR_FM_ICON_DEFAULT);
	LANG(STR_FM_FILEFOLDER, "STR_FM_FILEFOLDER", STR_FM_FILEFOLDER_DEFAULT);
	LANG(STR_FM_CUSTOM, "STR_FM_CUSTOM", STR_FM_CUSTOM_DEFAULT);
	LANG(STR_FM_CB_FILL, "STR_FM_CB_FILL", STR_FM_CB_FILL_DEFAULT);
	LANG(STR_EDIT_IDPS, "STR_EDIT_IDPS", STR_EDIT_IDPS_DEFAULT);
	LANG(STR_FILTER_NOGAME, "STR_FILTER_NOGAME", STR_FILTER_NOGAME_DEFAULT);
	LANG(STR_SYMLINK_SRC, "STR_SYMLINK_SRC", STR_SYMLINK_SRC_DEFAULT);
	LANG(STR_SYMLINK_TARGET, "STR_SYMLINK_TARGET", STR_SYMLINK_TARGET_DEFAULT);
	LANG(STR_LOAD_MAMBA, "STR_LOAD_MAMBA", STR_LOAD_MAMBA_DEFAULT);
	LANG(STR_CONVERT_TO_PNG, "STR_CONVERT_TO_PNG", STR_CONVERT_TO_PNG_DEFAULT);
	LANG(STR_UNMOUNT_DEVBLIND, "STR_UNMOUNT_DEVBLIND", STR_UNMOUNT_DEVBLIND_DEFAULT);
	LANG(STR_BT_AUDIO, "STR_BT_AUDIO", STR_BT_AUDIO_DEFAULT);
	LANG(STR_BT_AUDIO_DESC, "STR_BT_AUDIO_DESC", STR_BT_AUDIO_DESC_DEFAULT);	
	LANG(STR_CURRENT_VERS, "STR_CURRENT_VERS", STR_CURRENT_VERS_DEFAULT);	    
	LANG(STR_CANT_MOUNT_PEEKPOKE, "STR_CANT_MOUNT_PEEKPOKE", STR_CANT_MOUNT_PEEKPOKE_DEFAULT);	
	LANG(STR_CANT_MOUNT_UNKFW, "STR_CANT_MOUNT_UNKFW", STR_CANT_MOUNT_UNKFW_DEFAULT);	
	LANG(STR_CANT_MOUNT, "STR_CANT_MOUNT", STR_CANT_MOUNT_DEFAULT);
	LANG(STR_ONLY_FAV, "STR_ONLY_FAV", STR_ONLY_FAV_DEFAULT);	
	LANG(STR_ALL_GAMES, "STR_ALL_GAMES", STR_ALL_GAMES_DEFAULT);
	LANG(STR_DISPLAY, "STR_DISPLAY", STR_DISPLAY_DEFAULT);
	LANG(STR_DUMP_DEC, "STR_DUMP_DEC", STR_DUMP_DEC_DEFAULT);
	LANG(STR_DUMP_DEC_DESC, "STR_DUMP_DEC_DESC", STR_DUMP_DEC_DESC_DEFAULT);
	LANG(STR_DUMP_ENC, "STR_DUMP_ENC", STR_DUMP_ENC_DEFAULT);
	LANG(STR_DUMP_ENC_DESC, "STR_DUMP_ENC_DESC", STR_DUMP_ENC_DESC_DEFAULT);
	LANG(STR_DUMP_ERK, "STR_DUMP_ERK", STR_DUMP_ERK_DEFAULT);
	LANG(STR_DUMP_ERK_DESC, "STR_DUMP_ERK_DESC", STR_DUMP_ERK_DESC_DEFAULT);
	LANG(STR_DUMP_3DUMP, "STR_DUMP_3DUMP", STR_DUMP_3DUMP_DEFAULT);
	LANG(STR_DUMP_3DUMP_DESC, "STR_DUMP_3DUMP_DESC", STR_DUMP_3DUMP_DESC_DEFAULT);
	LANG(STR_SYSTEM_TOOLS, "STR_SYSTEM_TOOLS", STR_SYSTEM_TOOLS_DEFAULT);
	LANG(STR_DECRYPT_NPDATA, "STR_DECRYPT_NPDATA", STR_DECRYPT_NPDATA_DEFAULT);
	LANG(STR_REDUMP_LOG, "STR_REDUMP_LOG", STR_REDUMP_LOG_DEFAULT);
	LANG(STR_REDUMP_LOG_DESC, "STR_REDUMP_LOG_DESC", STR_REDUMP_LOG_DESC_DEFAULT);
	LANG(STR_DUMP_OPTION, "STR_DUMP_OPTION", STR_DUMP_OPTION_DEFAULT);
	LANG(STR_IGNORE_ERR, "STR_IGNORE_ERR", STR_IGNORE_ERR_DEFAULT);
	LANG(STR_IGNORE_ERR_DESC, "STR_IGNORE_ERR_DESC", STR_IGNORE_ERR_DESC_DEFAULT);
	LANG(STR_3K3Y_HEADER, "STR_3K3Y_HEADER", STR_3K3Y_HEADER_DEFAULT);
	LANG(STR_3K3Y_HEADER_DESC, "STR_3K3Y_HEADER_DESC", STR_3K3Y_HEADER_DESC_DEFAULT);
	LANG(STR_ELAPSED, "STR_ELAPSED", STR_ELAPSED_DEFAULT);
	LANG(STR_REMAINING, "STR_REMAINING", STR_REMAINING_DEFAULT);
	LANG(STR_DYNAREC, "STR_DYNAREC", STR_DYNAREC_DEFAULT);
	LANG(STR_DYNAREC_DESC, "STR_DYNAREC_DESC", STR_DYNAREC_DESC_DEFAULT);
	LANG(STR_BUILD_ISO, "STR_BUILD_ISO", STR_BUILD_ISO_DEFAULT);
	LANG(STR_BUILD_ISO_DESC, "STR_BUILD_ISO_DESC", STR_BUILD_ISO_DESC_DEFAULT);
	LANG(STR_UPLOADER, "STR_UPLOADER", STR_UPLOADER_DEFAULT);
	LANG(STR_UPLOADER_DESC, "STR_UPLOADER_DESC", STR_UPLOADER_DESC_DEFAULT);
	LANG(STR_BOX3D_ALIGN, "STR_BOX3D_ALIGN", STR_BOX3D_ALIGN_DEFAULT);
	LANG(STR_BOX3D_ALIGN_DESC, "STR_BOX3D_ALIGN_DESC", STR_BOX3D_ALIGN_DESC_DEFAULT);
	LANG(STR_BOX3D_GAP, "STR_BOX3D_GAP", STR_BOX3D_GAP_DEFAULT);
	LANG(STR_BOX3D_GAP_DESC, "STR_BOX3D_GAP_DESC", STR_BOX3D_GAP_DESC_DEFAULT);
	LANG(STR_SHORT, "STR_SHORT", STR_SHORT_DEFAULT);
	LANG(STR_MEDIUM, "STR_MEDIUM", STR_MEDIUM_DEFAULT);
	LANG(STR_LONG, "STR_LONG", STR_LONG_DEFAULT);
	LANG(STR_MOUNT_DVD, "STR_MOUNT_DVD", STR_MOUNT_DVD_DEFAULT);
	LANG(STR_MOUNT_BD, "STR_MOUNT_BD", STR_MOUNT_BD_DEFAULT);
	LANG(STR_SHOWLOGS_DESC, "STR_SHOWLOGS_DESC", STR_SHOWLOGS_DESC_DEFAULT);
	LANG(STR_OVERWRITE, "STR_OVERWRITE", STR_OVERWRITE_DEFAULT);
	LANG(STR_OVERWRITE_DESC, "STR_OVERWRITE_DESC", STR_OVERWRITE_DESC_DEFAULT);	
	LANG(STR_OVERWRITE_ALWAYS, "STR_OVERWRITE_ALWAYS", STR_OVERWRITE_ALWAYS_DEFAULT);
	LANG(STR_OVERWRITE_NEVER, "STR_OVERWRITE_NEVER", STR_OVERWRITE_NEVER_DEFAULT);
	LANG(STR_OVERWRITE_ASK, "STR_OVERWRITE_ASK", STR_OVERWRITE_ASK_DEFAULT);
	LANG(STR_OVERWRITE_DUPLICATE, "STR_OVERWRITE_DUPLICATE", STR_OVERWRITE_DUPLICATE_DEFAULT);
	LANG(STR_ASK_TO_OVERWRITE, "STR_ASK_TO_OVERWRITE", STR_ASK_TO_OVERWRITE_DEFAULT);
	LANG(STR_ASK_TO_DELETE, "STR_ASK_TO_DELETE", STR_ASK_TO_DELETE_DEFAULT);
	LANG(STR_DUMPER_MAX_TRY, "STR_DUMPER_MAX_TRY", STR_DUMPER_MAX_TRY_DEFAULT);
	LANG(STR_DUMPER_MAX_TRY_DESC, "STR_DUMPER_MAX_TRY_DESC", STR_DUMPER_MAX_TRY_DESC_DEFAULT);
	LANG(STR_HDD_UNLOCK_SPACE, "STR_HDD_UNLOCK_SPACE", STR_HDD_UNLOCK_SPACE);
	LANG(STR_HDD_UNLOCK_SPACE_DESC, "STR_HDD_UNLOCK_SPACE_DESC", STR_HDD_UNLOCK_SPACE_DESC_DEFAULT);
	
	
	FREE(STR_MGZ_CUSTOM);
	STR_MGZ_CUSTOM = sprintf_malloc( MGZ_PREFIX "%s", STR_CUSTOM);	
	
	FREE(flang);
	lang_code_loaded = lang_code;
}

void load_lang()
{
	int i;
	
#ifndef RPCS3	
	if(lang_code == LANG_UNDEFINED) {
		int res = get_xreg_value((char*)"/setting/system/language");
		if( res == -1 ) {
			lang = 0;
			lang_code = LANG_DEFAULT;
			write_setting();
			return;
		}
		lang_code = (u8) res;
	}
#endif

	for(i=0; i < lang_N ;i++) {
		if(LANGCODE[i] == lang_code) {
			lang = i;
			write_setting();
			return;
		}
	}
	
	lang = 0;
	lang_code = LANG_DEFAULT;
	
	write_setting();
}

//###################################################
//	THEME
//###################################################

uint32_t convert32(char * bytes);
uint16_t convert16(char * bytes);

typedef struct
{
	u32 magic;
	u32 version;
	char Name[0x40];
	u8 file_number;
} thm_header;

typedef struct
{
	u32 Offset;
	u32 Size;
	char Name[0x40];
} thm_file;

u8 ExtractTHM(char *thm)
{
	FILE* f=NULL;
	int i;
	thm_header header;
	thm_file file;
	char file_path[255];
	char dir[255];
	strcpy(dir, thm);
	dir[strlen(dir)-4]=0;
	
	Delete(dir);
	if( mkdir(dir, 0777) != 0) {
		print_load("Error : failed to create dir %s", dir);
		return FAILED;
	}
	
	f=fopen(thm, "rb");
	if(f==NULL) {
		print_load("Error : Failed to open thm file");
		return FAILED;
	}
	
	fread(&header, 0x49, 1, f);

	if( header.magic != 0x434D544D ) {
		print_load("Error : bad magic");
		fclose(f);
		return FAILED;
	}

	for(i=0 ; i < header.file_number; i++){
		fseek(f, 0x49 + 0x48*i, SEEK_SET);
		
		fread(&file, sizeof(thm_file), 1, f);
		
		uint8_t *data = (uint8_t *) malloc(file.Size);
		if(data == NULL) {
			print_load("Error : failed to malloc %s %d",  file.Size, file.Name);
			fclose(f);
			return FAILED;
		}
		fseek(f, file.Offset, SEEK_SET);
		fread(data, file.Size, 1, f);
		
		FILE* fp;
		sprintf(file_path, "%s/%s", dir, file.Name);
		fp = fopen(file_path, "wb");
		if(f==NULL) {
			print_load("Error : failed to create %s", file.Name);
			fclose(f);
			fclose(fp);
			free(data);
			return FAILED;
		}
		fwrite(data, file.Size, 1, fp);
		fclose(fp);
		free(data);
	}
	
	fclose(f);
	
	return SUCCESS;
}

u8 GetFromTHM(char *thm, char *file, char *dst)
{
	FILE* f=NULL;
	uint8_t nb_files;
	int i;
	char fileName[0x40];
	uint32_t fileSize=0;
	uint32_t fileOffset=0;

	f=fopen(thm, "rb");
	if(f==NULL) {
		print_load("Error : Failed to open thm file");
		return FAILED;
	}
	
	if(strcmp(file, "name") == 0 ) {
		fseek(f, 0x8, SEEK_SET);
		fread(fileName, 1, 0x40, f);
		fclose(f);
		strcpy(dst, fileName);
		return SUCCESS;
	}
	
	fseek(f, 0x48, SEEK_SET);
	fread(&nb_files, 1, 1, f);

	for(i=0 ; i<nb_files; i++){
		fseek(f, 0x51 + i*0x48, SEEK_SET);
		fread(fileName, 1, 0x40, f);
		if(strcmp(file, fileName) == 0) {
			fseek(f, 0x51 + i*0x48 - 0x8, SEEK_SET);
			fread(&fileOffset, 1, 4, f);
			fread(&fileSize, 1, 4, f);
			break;
		}
	}
	
	if(fileSize==0 || fileOffset==0) {
		print_load("Error : %s not found", file, fileSize, fileOffset);
		return FAILED;
	}
	uint8_t *data = (uint8_t *) malloc(fileSize);
	
	fseek(f, fileOffset, SEEK_SET);
	fread(data, 1, fileSize, f);
	fclose(f);
	
	f=fopen(dst, "wb");
	if(f==NULL) {
		print_load("Error : failed to open %s", dst);
		free(data);
		return FAILED;
	}
	
	fwrite(data, 1, fileSize, f);
	fclose(f);
	
	free(data);
	
	return SUCCESS;
}

extern int uncompressGIMBuffer(void* compressed_buffer, size_t compressed_buffer_size, void** gim_buffer);
int GIM2PNG(char *in, char *out)
{
	return gim2png(in, out);
}
int VAG2WAV(char *in, char *out)
{
	return vag_to_wav(in, out);
}
void JSX2JS(char *in, char *out)
{
	JSX_to_JS(in, out);
}

u8 GetFromP3T(char *src, char *file, char *dst)
{

 // *** header ***
	//u32 magic = 0x50335446;	// 0x00 "P3TF"
	//u32 version;				// 0x04
	u32 tree_table_offset;   	// 0x08
	u32 tree_table_size; 		// 0x0C
	u32 ID_table_offset; 		// 0x10
	u32 ID_table_size;			// 0x14
	u32 string_table_offset;	// 0x18
	u32 string_table_size;	// 0x1C
	//u32 integer_array_offset; // 0x20
	//u32 integer_array_size; 	// 0x2C
	//u32 float_Array_offset;	// 0x28
	//u32 float_array_size;		// 0x2C
	u32 file_table_offset;		// 0x30
	//u32 file_table_size;		// 0x34
	//u32 unk_table_offset;		// 0x38
	//u32 unk_table_size;		// 0x3C
	
	u32 file_offset;
	u32 file_size_c;
	int file_size_d;
	u8 GRID_ANIMATED = NO;
	FILE* fp;
	
	fp=fopen(src, "rb");
	if(fp==NULL) {
		print_load("Error : can't read file %s", src);
		return FAILED;
	}
	
	fseek(fp, 0x8, SEEK_SET);
	fread(&tree_table_offset, sizeof(u32), 1, fp);
	fread(&tree_table_size, sizeof(u32), 1, fp);
	fread(&ID_table_offset, sizeof(u32), 1, fp);
	fread(&ID_table_size, sizeof(u32), 1, fp);
	fread(&string_table_offset, sizeof(u32), 1, fp);
	fread(&string_table_size, sizeof(u32), 1, fp);
	
	fseek(fp, 0x30, SEEK_SET);
	fread(&file_table_offset, sizeof(u32), 1, fp);
	
//UGLY !
	if(strcmp(file, "background") == 0 ) {
		fseek(fp, string_table_offset, SEEK_SET);
		
		u8 *string_table = (u8 *) malloc(string_table_size);
		
		fread(string_table, string_table_size, 1, fp);
		u32 flag=0;
		u32 temp;
		unsigned int n;
		for(n=0; n < string_table_size; n++){
			if(memcmp((char *) &string_table[n], "anim\0", 5) == 0) {
				GRID_ANIMATED = YES;
				flag=n;
				break;
			} else
			if(memcmp((char *) &string_table[n], "hd\0", 3) == 0) {
				flag=n;
				break;
			}
		}
		free(string_table);
		
		if(flag == 0) return FAILED;
		
		fseek(fp, 0x40, SEEK_SET);
		
		for(n=0; n < tree_table_size/4; n++){
			fread(&temp, sizeof(u32), 1, fp);
			if(temp==flag) {
				fread(&temp, sizeof(u32), 1, fp);
				if(temp==6) {
					fread(&file_offset, sizeof(u32), 1, fp);
					fread(&file_size_c, sizeof(u32), 1, fp);
					break;
				}
			}
		}
		if(temp != 6) return FAILED;
	}
	else if(strcmp(file, "name") == 0) {
		fseek(fp, string_table_offset, SEEK_SET);
		
		u8 *string_table = (u8 *) malloc(string_table_size);
		fread(string_table, string_table_size, 1, fp);
		fclose(fp);
		
		unsigned int n;
		for(n=0; n < string_table_size; n++){
			if(memcmp((char *) &string_table[n], "name\0", 5) == 0) {
				strcpy((char *) dst, (char *) &string_table[n+5]);
				free(string_table);
				return SUCCESS;
			}
		}
		return FAILED;
	}
	else {
		fseek(fp, ID_table_offset, SEEK_SET);
		u32 file_tree_table_offset = 0;
		u8 *ID_table = (u8 *) malloc(ID_table_size);
		
		fread(ID_table, ID_table_size, 1, fp);
		
		unsigned int n;
		for(n=0; n < ID_table_size; n++){
			if(memcmp((char *) &ID_table[n], (char *) file, strlen(file)) == 0 && memcmp((char *) &ID_table[n+strlen(file)], "\0", 1) == 0) {
				memcpy(&file_tree_table_offset, &ID_table[n-4], 4);
				file_tree_table_offset += tree_table_offset;
				break;
			}
		}
		
		free(ID_table);
		
		if(file_tree_table_offset<=tree_table_offset) {
			fclose(fp);
			print_load("Error : File not found in ID_table");	
			return FAILED;
		}
		
		fseek(fp, file_tree_table_offset + 0x24, SEEK_SET);
		fread(&file_offset, sizeof(u32), 1, fp);
		fread(&file_size_c, sizeof(u32), 1, fp);
		
	}
	
	file_offset += file_table_offset;
	
	fseek(fp, file_offset, SEEK_SET);
	
	char *file_data_c = (char *) malloc(file_size_c);
	if(!file_data_c) {
		print_load("Error : failed to malloc file_size_c");
		return FAILED;
	}
	
	fread(file_data_c, file_size_c, 1, fp);
	fclose(fp);

	if(strcmp(file, "background") == 0) {
		if(GRID_ANIMATED == NO) {
			fp=fopen(dst, "wb");
			fwrite(file_data_c, file_size_c, 1, fp);
			fclose(fp);
			free(file_data_c);
		} else {
			u32 RAF_size = convert32(&file_data_c[4]);
			u8 *RAF_data = (u8 *) malloc(RAF_size);
			RAF_size = 0;
			zlib_decompress((char *) &file_data_c[8], (char *) RAF_data, file_size_c, (int *) &RAF_size);
			
			free(file_data_c);
			
			if(RAF_size != 0) {
				char raf_tmp[128];
				char tmp_dir[128];
				sprintf(tmp_dir, "/dev_hdd0/game/%s/USRDIR/temp", ManaGunZ_id);
				//Delete(tmp_dir);
				mkdir(tmp_dir, 0777);
				
				sprintf(raf_tmp, "%s/bg_anim.raf", tmp_dir);
				
				fp=fopen(raf_tmp, "wb");
				if(fp==NULL) return FAILED;
				fwrite(RAF_data, RAF_size, 1, fp);
				fclose(fp);
				
				free(RAF_data);
				
				print_head("Extracting Background...");
				cxml_extract(raf_tmp);
				
				sprintf(raf_tmp, "%s/bg_anim", tmp_dir);
				
				dst[strlen(dst)-3] = 'P';
				dst[strlen(dst)-2] = 'N';
				dst[strlen(dst)-1] = 'G';
				
				print_head("Making GRID_ANIMATED Background...");
				if(make_ABG((char *) raf_tmp, (char *) dst)  == FAILED) {
					Delete(tmp_dir);
					print_load("Error : Failed to build Animated Background");
					return FAILED;
				}
				Delete(tmp_dir);
				
			} else free(RAF_data);
		}
	}
	else {
		void* file_data_d;
		file_size_d = uncompressGIMBuffer(file_data_c, file_size_c, &file_data_d);	
		free(file_data_c);
		
		// .gim to .png
		char gim[128];
		strcpy(gim, dst);
		RemoveExtension(gim);
		strcat(gim, ".gim");
		fp=fopen(gim, "wb");

		if(fp==NULL) {
			print_load("Error : cannot write file %s", dst);
			return FAILED;
		}
		fwrite(file_data_d, file_size_d, 1, fp);
		fclose(fp);
		
		if( gim2png((char *) gim, (char *) dst) == false) {
			print_load("Error : to convert gim to png");
			return FAILED;
		} 
		remove(gim);
		
	}

	return SUCCESS;
}

u8 ExtractQRC(char *src)
{
	
	int qrc_size;
	
	char *qrc = LoadFile(src, &qrc_size);
	if(qrc==NULL) {
		print_load("Error : Failed to load qrc");
		return FAILED;
	}
	
	if(memcmp((char *) qrc, (char *) "QRCF", 4) == 0) {
		cxml_extract(src);
		return SUCCESS;
	}

	
	if(memcmp((char *) qrc, (char *) "QRCC", 4) != 0) {
		print_load("Error : bad magic QRCC");
		return FAILED;
	}
	
	u32 qrcf_size = convert32(&qrc[4]);
	u8 *qrcf = (u8 *) malloc(qrcf_size);
	qrcf_size = 0;
	
	zlib_decompress((char *) &qrc[8], (char *) qrcf, qrc_size, (int *) &qrcf_size);
			
	free(qrc);
			
	if(qrcf_size != 0) {
		
		char dst[255];

		if(strstr(src, "dev_flash") != NULL) {
			strcpy(dst, "/dev_hdd0/tmp");
			mkdir(dst, 0777);
			strcat(dst, "/CXML");
			mkdir(dst, 0777);
			strcat(dst, &strrchr(src, '/')[1]);
		} 
		else strcpy(dst, src);
		
		strcat(dst, "f"); //QRCF
	
		FILE* fp;
		
		fp=fopen(dst, "wb");
		if(fp==NULL) return FAILED;
		fwrite(qrcf, qrcf_size, 1, fp);
		fclose(fp);
		
		free(qrcf);
		
		cxml_extract(dst);
		
		return SUCCESS;
	}
	
	return FAILED;
}

#define RAFO_INTEGER		1
#define RAFO_FLOAT	 		2
#define RAFO_STRING	 		3
#define RAFO_INT_ARRAY		4
#define RAFO_FLOAT_ARRAY	5
#define RAFO_FILE	 		6
#define RAFO_ID_WITH_REF	7
#define RAFO_ID				8

void ExtractRAFO(char *src)
{
	// *** header ***
	//u32 magic = 0x5241464F;	// 0x00 "RAFO"
	//u32 version;				// 0x04
	u32 tree_table_offset;   	// 0x08
	u32 tree_table_size; 		// 0x0C
	u32 ID_table_offset; 		// 0x10
	u32 ID_table_size;			// 0x14
	u32 string_table_offset;	// 0x18
	u32 string_table_size;		// 0x1C
	//u32 integer_array_offset; // 0x20
	//u32 integer_array_size; 	// 0x2C
	//u32 float_Array_offset;	// 0x28
	//u32 float_array_size;		// 0x2C
	u32 file_table_offset;		// 0x30
	//u32 file_table_size;		// 0x34
	//u32 unk_table_offset;		// 0x38
	//u32 unk_table_size;		// 0x3C

	char dst[128];
	strcpy(dst, src);
	dst[strlen(dst)-4]=0;
	mkdir(dst, 0777);
	
	FILE* fp;
	fp=fopen(src, "rb");
	if(fp==NULL) {print_load("Error : can't read file %s", src); return;}
	
	fseek(fp, 0x8, SEEK_SET);
	fread(&tree_table_offset, sizeof(u32), 1, fp);
	fread(&tree_table_size, sizeof(u32), 1, fp);
	fread(&ID_table_offset, sizeof(u32), 1, fp);
	fread(&ID_table_size, sizeof(u32), 1, fp);
	fread(&string_table_offset, sizeof(u32), 1, fp);
	fread(&string_table_size, sizeof(u32), 1, fp);
	
	fseek(fp, 0x30, SEEK_SET);
	fread(&file_table_offset, sizeof(u32), 1, fp);
	
	fseek(fp, ID_table_offset, SEEK_SET);
	
	u32 item_offset, type, file_offset, file_size;
	u32 pos = ftell(fp);
	
	char name[128];
	while( pos < ID_table_offset + ID_table_size) {
		type=0; file_offset=0; item_offset=0; file_size=0;
		memset(name, 0, 128);
		
		fread(&item_offset,  sizeof(u32), 1, fp);
		char c = fgetc(fp);
		while( c != 0 ) {
			name[strlen(name)]=c;
			c = fgetc(fp);
		}
		
		pos = ftell(fp);
		
		fseek(fp, item_offset+0x40+0x20, SEEK_SET);
		
		fread(&type,  sizeof(u32), 1, fp);

		if(type ==  RAFO_FILE) {
			
			fread(&file_offset,  sizeof(u32), 1, fp);
			fread(&file_size,  sizeof(u32), 1, fp);
			
			fseek(fp, file_table_offset+file_offset, SEEK_SET);
			
			u8 *data = (u8 *) malloc(file_size);
			fread(data, file_size, 1, fp);
			
			char dst_file[128];
			FILE* out;
			sprintf(dst_file, "%s/%s", dst, name);
			out = fopen(dst_file, "wb");
			fwrite(data, file_size, 1, out);
			fclose(out);
			
			free(data);
		}
		
		fseek(fp, pos, SEEK_SET);
	}
	fclose(fp);
}

u8 GetThemeType(char *ThemePath)
{
	int len = strlen(ThemePath)-4;
	
	if( ThemePath[len] == '.'
	&& (ThemePath[len+1] == 't' || ThemePath[len+1] == 'T')
	&& (ThemePath[len+2] == 'h' || ThemePath[len+2] == 'H')
	&& (ThemePath[len+3] == 'm' || ThemePath[len+3] == 'M') ) {
		return THM;
	}
	else if(ThemePath[len] == '.'
	&& (ThemePath[len+1] == 'p' || ThemePath[len+1] == 'P')
	&& (ThemePath[len+2] == '3')
	&& (ThemePath[len+3] == 't' || ThemePath[len+3] == 'T') ) {
		return P3T;
	}
	else return MGZ;
	
}

void GetThemes()
{
	char THM_path[255];
	char THM_subpath[255];
	
	char TempPath[255];
	char TempName[255];
	int i;
	u8 ret;
	
	Themes_number[0]=-1;
	Themes_number[1]=-1;
	Themes_number[2]=-1;
	Themes_number[3]=-1;

	memset(Themes_Paths_list, 0, sizeof(Themes_Paths_list));
	memset(Themes_Names_list, 0, sizeof(Themes_Names_list));

	for(i=0; i<=device_number; i++) {
		
		if(strstr(list_device[i], "dev_usb") != NULL) {
			sprintf(THM_path, "/%s/Themes", list_device[i]);
		} else
		if(strstr(list_device[i], "ntfs") != NULL) {
			sprintf(THM_path, "/%s/Themes", list_device[i]);
		} else
		if(strstr(list_device[i], "dev_hdd0") != NULL) {
			sprintf(THM_path, "/dev_hdd0/game/%s/USRDIR/GUI", ManaGunZ_id);
		} else continue;
		
		DIR *d;
		struct dirent *dir;
	
		d = opendir(THM_path);
		if(d==NULL) continue;
	
		while ((dir = readdir(d))) {
			if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
			
			int k = -1;
			u8 ThemeType = GetThemeType(dir->d_name);
			
			if(ThemeType == THM) {
				
				sprintf(TempPath, "%s/%s", THM_path, dir->d_name);
				ret = GetFromTHM(TempPath, "name", TempName);
				if(ret==FAILED) {
					memcpy(TempName, dir->d_name, strlen(dir->d_name)-4);
				}
				
				Themes_number[XMB]++;
				strcpy(Themes_Paths_list[XMB][Themes_number[XMB]], TempPath);
				strcpy(Themes_Names_list[XMB][Themes_number[XMB]], TempName);
				
				Themes_number[FLOW]++;
				strcpy(Themes_Paths_list[FLOW][Themes_number[FLOW]], TempPath);
				strcpy(Themes_Names_list[FLOW][Themes_number[FLOW]], TempName);
				
				continue;
			} else
			if(ThemeType == P3T) {
			
				sprintf(TempPath, "%s/%s", THM_path, dir->d_name);
				ret = GetFromP3T(TempPath, "name", TempName);
				if(ret==FAILED) {
					memcpy(TempName, dir->d_name, strlen(dir->d_name)-4);
				}
				
				Themes_number[XMB]++;
				strcpy(Themes_Paths_list[XMB][Themes_number[XMB]], TempPath);
				strcpy(Themes_Names_list[XMB][Themes_number[XMB]], TempName);
				
				continue;
			}
			else if(strcmp(dir->d_name, UI[LIST]) == 0) k=LIST;
			else if(strcmp(dir->d_name, UI[GRID]) == 0) k=GRID;					
			else if(strcmp(dir->d_name, UI[XMB] ) == 0) k=XMB;
			else if(strcmp(dir->d_name, UI[FLOW]) == 0) k=FLOW;
			
			if(k==-1) continue;
			
			sprintf(THM_subpath, "%s/%s", THM_path, dir->d_name);
			DIR *d2;
			struct dirent *dir2;

			d2 = opendir(THM_subpath);
			if(d2==NULL) continue;
		
			while ((dir2 = readdir(d2))) {
				if(!strncmp(dir2->d_name,"..", 2) || !strncmp(dir2->d_name,".", 1)) continue;

				sprintf(TempPath, "%s/%s", THM_subpath, dir2->d_name);
				strcpy(TempName, dir2->d_name);
				
				Themes_number[k]++;
				strcpy(Themes_Paths_list[k][Themes_number[k]], TempPath);
				strcpy(Themes_Names_list[k][Themes_number[k]], TempName);
			}
			closedir(d2);
		}
		closedir(d);
	}
	
}

u8 InstallTheme()
{
	char folder[255];
	u8 ret=SUCCESS;
	
	if(strstr(Themes_Paths_list[UI_position][Themes_position[UI_position]], "dev_hdd0") != NULL) {
		strcpy(Themes[UI_position], Themes_Names_list[UI_position][Themes_position[UI_position]]);
		return SUCCESS;
	}
	
	u8 ThemeType = GetThemeType( Themes_Paths_list[UI_position][Themes_position[UI_position]]);
	
	sprintf(folder, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], Themes_Names_list[UI_position][Themes_position[UI_position]]);
	
	print_head("Installing Theme...");
			
	mkdir(folder, 0777);
	
	if(ThemeType == THM) {
		
		char dst[255];
		
		if(UI_position == FLOW) {
			
			sprintf(dst, "%s/BG.PNG", folder);
			ret=GetFromTHM(Themes_Paths_list[UI_position][Themes_position[UI_position]], "PICPA.PNG" , dst);
			
			sprintf(dst, "%s/BGS.JPG", folder);
			ret=GetFromTHM(Themes_Paths_list[UI_position][Themes_position[UI_position]], "PSVBG.JPG" , dst);
			
		}
		else if(UI_position == XMB) {
					
			sprintf(dst, "%s/BG.PNG", folder);
			ret=GetFromTHM(Themes_Paths_list[UI_position][Themes_position[UI_position]], "XMBBG.PNG" , dst);
			
			sprintf(dst, "%s/BGS.JPG", folder);
			ret=GetFromTHM(Themes_Paths_list[UI_position][Themes_position[UI_position]], "PSVBG.JPG" , dst);
			
			sprintf(dst, "%s/MMTHM_XMB.PNG", folder);
			ret=GetFromTHM(Themes_Paths_list[UI_position][Themes_position[UI_position]], "XMB.PNG" , dst);
			
			sprintf(dst, "%s/MMTHM_XMB2.PNG", folder);
			ret=GetFromTHM(Themes_Paths_list[UI_position][Themes_position[UI_position]], "XMB2.PNG" , dst);
			
		}
				
	}
	else if(ThemeType == P3T) {
		char tmp[128];
		sprintf(tmp, "/dev_hdd0/game/%s/USRDIR/temp", ManaGunZ_id);
		Delete(tmp);
		mkdir(tmp, 0777);
		strcat(tmp, "/tmp.p3t");
		
		Copy(Themes_Paths_list[UI_position][Themes_position[UI_position]], tmp);
		
		char dst[255];
		if(UI_position == XMB) {
					
			sprintf(dst, "%s/%s.PNG", folder, XMB_COLUMN_NAME[0]);
			ret=GetFromP3T(tmp, "icon_setting", dst);
			
			sprintf(dst, "%s/%s.PNG", folder, XMB_COLUMN_NAME[1]);
			ret=GetFromP3T(tmp, "icon_playermet", dst);
			
			sprintf(dst, "%s/%s.PNG", folder, XMB_COLUMN_NAME[2]);
			ret=GetFromP3T(tmp, "icon_game", dst);
			
			sprintf(dst, "%s/%s.PNG", folder, XMB_COLUMN_NAME[3]);
			ret=GetFromP3T(tmp, "icon_game", dst);
			
			sprintf(dst, "%s/%s.PNG", folder, XMB_COLUMN_NAME[4]);
			ret=GetFromP3T(tmp, "icon_game", dst);
			
			sprintf(dst, "%s/%s.PNG", folder, XMB_COLUMN_NAME[5]);
			ret=GetFromP3T(tmp, "icon_remoteplay", dst);
			
			sprintf(dst, "%s/BG.JPG", folder);
			GetFromP3T(tmp, "background", dst); // pas de ret car facultatif
			
			Delete(tmp);
		}
	
	}
	else {
		ret=Copy(Themes_Paths_list[UI_position][Themes_position[UI_position]], folder);
	}
	
	if(ret==FAILED) {
		Delete(folder);
		return FAILED;
	}
		
	Themes_number[UI_position]++;
	strcpy(Themes_Paths_list[UI_position][Themes_number[UI_position]], folder);
	strcpy(Themes_Names_list[UI_position][Themes_number[UI_position]], Themes_Names_list[UI_position][Themes_position[UI_position]]);
	Themes_position[UI_position]=Themes_number[UI_position];
	strcpy(Themes[UI_position], Themes_Names_list[UI_position][Themes_number[UI_position]]);
	
	return SUCCESS;

}

// **********************
// COLORS
// **********************

char *NextColorSetName(FILE *f)
{
	char line[255];
	
	char *ColorSetName=NULL;
	while(fgets(line, 255, f) != NULL) {
		ColorSetName = get_str_regex(line, "[*]");
		if(ColorSetName!=NULL) return ColorSetName;
		memset(line, 0, 255);
	}
	return NULL;
}

void LoadColorSet(char *ColorSetName)
{		
	u8 OLD_FILTER_NOTIF = FILTER_NOTIF;
	u8 OLD_FILTER_SIDEBAR = FILTER_SIDEBAR;
	u8 OLD_FILTER_BOXHEAD = FILTER_BOXHEAD;
	u8 OLD_FILTER_BOXBODY = FILTER_BOXBODY;
	u8 OLD_FILTER_BGS = FILTER_BGS;
	u8 OLD_FILTER_BG = FILTER_BG;
	
	FILTER_NOTIF=DISABLED;
	FILTER_SIDEBAR=DISABLED;
	FILTER_BOXHEAD=DISABLED;
	FILTER_BOXBODY=DISABLED;
	FILTER_BGS=DISABLED;
	FILTER_BG=DISABLED;
	
	FILE *f;
	char SysColorSetPath[128];
	sprintf(SysColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/colorset.ini",  ManaGunZ_id);

	f = fopen(SysColorSetPath, "rb");
	if(f==NULL) return;
	
	char *SysColorSetName=NULL;
	while((SysColorSetName=NextColorSetName(f)) != NULL) {
		
		if(strcmp(SysColorSetName, ColorSetName) != 0) {FREE(SysColorSetName); continue;}
		
		FREE(SysColorSetName);
		
		char line[255];
		while(fgets(line, 255, f) != NULL) {
			if(strstr(line, "[") != NULL ) break;
			if(strstr(line, "=") == NULL ) continue;
			
			if(strlen(&strrchr(line, '=')[1]) == 0) continue;
			
			u32 loc=0;
			sscanf(&strrchr(line, '=')[1], "%X", (unsigned int *) &loc);
			
			if(strstr(line, "COLOR_1")!=NULL) {
				COLOR_1 = loc;
			} else
			if(strstr(line, "COLOR_2")!=NULL) {
				COLOR_2 = loc;
			} else
			if(strstr(line, "COLOR_3")!=NULL) {
				COLOR_3 = loc;
			} else
			if(strstr(line, "COLOR_4")!=NULL) {
				COLOR_4 = loc;
			} else
			if(strstr(line, "WAVES_COLOR")!=NULL) {
				WAVES_COLOR = loc;
			} else
			if(strstr(line, "COLOR_NOTIF")!=NULL) {
				COLOR_NOTIF = loc;
				FILTER_NOTIF=ENABLED;
			}  else
			if(strstr(line, "COLOR_SIDEBAR")!=NULL) {
				COLOR_SIDEBAR = loc;
				FILTER_SIDEBAR=ENABLED;
			} else
			if(strstr(line, "COLOR_BOXHEAD")!=NULL) {
				COLOR_BOXHEAD = loc;
				FILTER_BOXHEAD=ENABLED;
			} else
			if(strstr(line, "COLOR_BOXBODY")!=NULL) {
				COLOR_BOXBODY = loc;
				FILTER_BOXBODY=ENABLED;
			} else
			if(strstr(line, "COLOR_BGS")!=NULL) {
				COLOR_BGS = loc;
				FILTER_BGS=ENABLED;
			} else
			if(strstr(line, "COLOR_BG")!=NULL) {
				COLOR_BG = loc;
				FILTER_BG=ENABLED;
			}
		}
		
		break;
	}
	fclose(f);
	
	if(OLD_FILTER_NOTIF != FILTER_NOTIF) ReloadTheme(NOTIF);
	if(OLD_FILTER_SIDEBAR != FILTER_SIDEBAR) ReloadTheme(SIDEBAR);
	if(OLD_FILTER_BOXHEAD != FILTER_BOXHEAD) ReloadTheme(BOXHEAD);
	if(OLD_FILTER_BOXBODY != FILTER_BOXBODY) ReloadTheme(BOXBODY);
	if(OLD_FILTER_BGS != FILTER_BGS) ReloadTheme(BGS);
	if(OLD_FILTER_BG != FILTER_BG) ReloadTheme(_BG_);
		
	write_setting();
}

void AddColorSet(char *ColorSetName)
{
	FILE *f;
	char temp[255];
	char SysColorSetPath[128];
	sprintf(SysColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/colorset.ini",  ManaGunZ_id);

	f = fopen(SysColorSetPath, "rb+");
	if(f==NULL) return;
	
	char *SysColorSetName=NULL;
	while((SysColorSetName=NextColorSetName(f)) != NULL) {
		if( strcmp(SysColorSetName, ColorSetName) == 0 ) {
			FREE(SysColorSetName);
			fclose(f);
			return;
		}
		FREE(SysColorSetName);
	}
	
	fseek(f, 0, SEEK_END);
	
	sprintf(temp, "[%s]\n", ColorSetName); fputs(temp, f);
	sprintf(temp, "COLOR_1=%08X\n", COLOR_1); fputs(temp, f);
	sprintf(temp, "COLOR_2=%08X\n", COLOR_2); fputs(temp, f);
	sprintf(temp, "COLOR_3=%08X\n", COLOR_3); fputs(temp, f);
	sprintf(temp, "COLOR_4=%08X\n", COLOR_4); fputs(temp, f);
	
	if(Show_COVER==YES) {sprintf(temp, "WAVES_COLOR=%08X\n", WAVES_COLOR); fputs(temp, f);}
	if(FILTER_NOTIF == ENABLED) {sprintf(temp, "COLOR_NOTIF=%08X\n", COLOR_NOTIF); fputs(temp, f);}
	if(FILTER_BOXHEAD == ENABLED) {sprintf(temp, "COLOR_BOXHEAD=%08X\n", COLOR_BOXHEAD); fputs(temp, f);}
	if(FILTER_BOXBODY == ENABLED) {sprintf(temp, "COLOR_BOXBODY=%08X\n", COLOR_BOXBODY); fputs(temp, f);}
	if(FILTER_SIDEBAR == ENABLED) {sprintf(temp, "COLOR_SIDEBAR=%08X\n", COLOR_SIDEBAR); fputs(temp, f);}
	if(FILTER_BGS == ENABLED) {sprintf(temp, "COLOR_BGS=%08X\n", COLOR_BGS); fputs(temp, f);}
	if(FILTER_BG == ENABLED) {sprintf(temp, "COLOR_BG=%08X\n", COLOR_BG); fputs(temp, f);}
	
	fputs("\n", f);
	
	fclose(f);
	
}

void RemoveColorSet(char *ColorSetName)
{
	char SysColorSetPath[128];
	int SysColorSetSize;
	sprintf(SysColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/colorset.ini",  ManaGunZ_id);
	
	char *ColorSetData = LoadFile(SysColorSetPath, &SysColorSetSize);
	if(ColorSetData == NULL) return;
	
	if(strstr(ColorSetData, ColorSetName) == NULL) {
		FREE(ColorSetData);
		return;
	}
	
	char *NewColorSetData = malloc(SysColorSetSize);
	if(NewColorSetData==NULL) {
		FREE(ColorSetData);
		return;
	}
	
	int i;
	int NewSysColorSetSize=0;
	
	int start = strstr(ColorSetData, ColorSetName) - ColorSetData;
	int end;
	if(strstr(&ColorSetData[start+1], "[") != NULL) {
		end = strstr(&ColorSetData[start+1], "[") - ColorSetData;
	} else {
		end = SysColorSetSize;
	}
	
	for(i=0; i<SysColorSetSize; i++)
	{
		if(i<start || end<=i) {
			NewColorSetData[NewSysColorSetSize] = ColorSetData[i];
			NewSysColorSetSize++;
		}
	}
	
	SaveFile(SysColorSetPath, NewColorSetData, NewSysColorSetSize);
	
	FREE(ColorSetData);
	FREE(NewColorSetData);
}

void AddThemeColorSet()
{
	FILE *f1;
	FILE *f2;
	char ThemeColorSetPath[128];
	char ColorSetPath[128];
	
	sprintf(ThemeColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s/colorset.ini",  ManaGunZ_id, UI[UI_position], Themes[UI_position]);
	sprintf(ColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/colorset.ini",  ManaGunZ_id);

	f1 = fopen(ThemeColorSetPath, "rb");
	if(f1==NULL) return;
	
	f2 = fopen(ColorSetPath, "rb+");
	if(f2==NULL) { fclose(f1); return; }
	
	char *ThemeColorSetName=NULL;
	char *ColorSetName=NULL;
	
	while((ThemeColorSetName=NextColorSetName(f1)) != NULL) {
		fseek(f2, 0, SEEK_SET);
		u8 add = YES;
		while((ColorSetName=NextColorSetName(f2)) != NULL) {
			if( strcmp(ColorSetName, ThemeColorSetName) == 0 ) {
				add = NO;
				FREE(ColorSetName);
				break;
			}
			FREE(ColorSetName);
		}
		if(add) {
			fseek(f2, 0, SEEK_END);
			fputs(ThemeColorSetName, f2);
			fputs("\n", f2);
			
			char line[255];
			memset(line, 0, 255);
			int pos = ftell(f1);
			while(fgets(line, 255, f1) != NULL) {
				
				ColorSetName = get_str_regex(line, "[*]");
				if(ColorSetName!=NULL) {
					fseek(f1, pos, SEEK_SET);
					FREE(ColorSetName);
					break;
				}
				
				if( strstr(line, "WAVES_COLOR") == NULL
				&&  strstr(line, "COLOR_1") == NULL
				&&  strstr(line, "COLOR_2") == NULL
				&&  strstr(line, "COLOR_3") == NULL
				&&  strstr(line, "COLOR_4") == NULL	
				&&  strstr(line, "COLOR_NOTIF") == NULL	
				&&  strstr(line, "COLOR_BOXHEAD") == NULL	
				&&  strstr(line, "COLOR_BOXBODY") == NULL	
				&&  strstr(line, "COLOR_SIDEBAR") == NULL
				&&  strstr(line, "COLOR_BGS") == NULL
				&&  strstr(line, "COLOR_BG") == NULL) continue;
				if( strstr(line, "=") == NULL ) continue;
				
				
				int l=strlen(line);
				int i;
				for(i=0; i<l; i++) {
					if( line[i]==' ') continue;
					if( line[i]=='\n' || line[i]=='r') break;
					
					fputc(line[i], f2);
				}
				fputc('\n', f2);
				memset(line, 0, 255);
				
				pos = ftell(f1);
			}
			fputc('\n', f2);
		}
		FREE(ThemeColorSetName);
	}
	
	fclose(f1);
	fclose(f2);
}

char *GetCurrentColorSet()
{
	char *ret=NULL;
	
	FILE *f;
	char SysColorSetPath[128];
	sprintf(SysColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/colorset.ini",  ManaGunZ_id);

	f = fopen(SysColorSetPath, "rb");
	if(f==NULL) return strcpy_malloc(STR_NONE);
	
	char *SysColorSetName=NULL;
	while((SysColorSetName=NextColorSetName(f)) != NULL) {
		
		int flag=NO;
		
		char line[255];
		while(fgets(line, 255, f) != NULL) {
			if(strstr(line, "[") != NULL ) break;
			if(strstr(line, "=") == NULL ) continue;
			
			if(strlen(&strrchr(line, '=')[1]) == 0) continue;
			
			u32 loc=0;
			sscanf(&strrchr(line, '=')[1], "%X", (unsigned int *) &loc);
			
			if(strstr(line, "COLOR_1")!=NULL) {
				if( loc == COLOR_1) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_2")!=NULL) {
				if( loc == COLOR_2) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_3")!=NULL) {
				if( loc == COLOR_3) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_4")!=NULL) {
				if( loc == COLOR_4) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "WAVES_COLOR")!=NULL) {
				if( loc == WAVES_COLOR) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_NOTIF")!=NULL) {
				if( loc == COLOR_NOTIF) flag=YES;  
				else {flag=NO; break;}
			}  else
			if(strstr(line, "COLOR_SIDEBAR")!=NULL) {
				if( loc == COLOR_SIDEBAR) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_BOXHEAD")!=NULL) {
				if( loc == COLOR_BOXHEAD) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_BOXBODY")!=NULL) {
				if( loc == COLOR_BOXBODY) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_BGS")!=NULL) {
				if( loc == COLOR_BGS) flag=YES;  
				else {flag=NO; break;}
			} else
			if(strstr(line, "COLOR_BG")!=NULL) {
				if( loc == COLOR_BG) flag=YES;  
				else {flag=NO; break;}
			}	
		}
		
		if(flag==YES) {
			ret = strcpy_malloc(SysColorSetName);
			FREE(SysColorSetName);
			break;
		}
		
		FREE(SysColorSetName);
	}
	fclose(f);
	
	if(ret == NULL) return strcpy_malloc(STR_NONE);

	return ret;
}

void LoadThemeFont()
{
	char ThemeFontPath[128];
	
	sprintf(ThemeFontPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s/FONT.TTF",  ManaGunZ_id, UI[UI_position], Themes[UI_position]);
	
	if(path_info(ThemeFontPath) == _NOT_EXIST) return;

	strcpy(Font, ThemeFontPath);
	
	LoadFont();
}

void LoadThemeColorSet()
{
	u8 OLD_FILTER_NOTIF = FILTER_NOTIF;
	u8 OLD_FILTER_SIDEBAR = FILTER_SIDEBAR;
	u8 OLD_FILTER_BOXHEAD = FILTER_BOXHEAD;
	u8 OLD_FILTER_BOXBODY = FILTER_BOXBODY;
	u8 OLD_FILTER_BGS = FILTER_BGS;
	u8 OLD_FILTER_BG = FILTER_BG;
	
	FILTER_NOTIF=DISABLED;
	FILTER_SIDEBAR=DISABLED;
	FILTER_BOXHEAD=DISABLED;
	FILTER_BOXBODY=DISABLED;
	FILTER_BGS=DISABLED;
	FILTER_BG=DISABLED;
	
	FILE *f;
	char ThemeColorSetPath[128];
	
	sprintf(ThemeColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s/colorset.ini",  ManaGunZ_id, UI[UI_position], Themes[UI_position]);

	f = fopen(ThemeColorSetPath, "rb");
	if(f==NULL) return;
	
	char *ColorSetName=NextColorSetName(f);
	if(ColorSetName == NULL) return;
	FREE(ColorSetName);
	
	char line[255];
	while(fgets(line, 255, f) != NULL) {
		if(strstr(line, "[") != NULL ) break;
		if(strstr(line, "=") == NULL ) continue;
		if(strlen(&strrchr(line, '=')[1]) == 0) continue;
		
		u32 loc=0;
		sscanf(&strrchr(line, '=')[1], "%X", (unsigned int *) &loc);
		
		if(strstr(line, "COLOR_1")!=NULL) {
			COLOR_1 = loc;
		} else
		if(strstr(line, "COLOR_2")!=NULL) {
			COLOR_2 = loc;
		} else
		if(strstr(line, "COLOR_3")!=NULL) {
			COLOR_3 = loc;
		} else
		if(strstr(line, "COLOR_4")!=NULL) {
			COLOR_4 = loc;
		} else
		if(strstr(line, "WAVES_COLOR")!=NULL) {
			WAVES_COLOR = loc;
		} else
		if(strstr(line, "COLOR_NOTIF")!=NULL) {
			COLOR_NOTIF = loc;
			FILTER_NOTIF=ENABLED;
		}  else
		if(strstr(line, "COLOR_SIDEBAR")!=NULL) {
			COLOR_SIDEBAR = loc;
			FILTER_SIDEBAR=ENABLED;
		} else
		if(strstr(line, "COLOR_BOXHEAD")!=NULL) {
			COLOR_BOXHEAD = loc;
			FILTER_BOXHEAD=ENABLED;
		} else
		if(strstr(line, "COLOR_BOXBODY")!=NULL) {
			COLOR_BOXBODY = loc;
			FILTER_BOXBODY=ENABLED;
		} else
		if(strstr(line, "COLOR_BGS")!=NULL) {
			COLOR_BGS = loc;
			FILTER_BGS=ENABLED;
		} else
		if(strstr(line, "COLOR_BG")!=NULL) {
			COLOR_BG = loc;
			FILTER_BG=ENABLED;
		}
	}
	
	fclose(f);
	
	if(OLD_FILTER_NOTIF != FILTER_NOTIF) ReloadTheme(NOTIF);
	if(OLD_FILTER_SIDEBAR != FILTER_SIDEBAR) ReloadTheme(SIDEBAR);
	if(OLD_FILTER_BOXHEAD != FILTER_BOXHEAD) ReloadTheme(BOXHEAD);
	if(OLD_FILTER_BOXBODY != FILTER_BOXBODY) ReloadTheme(BOXBODY);
	if(OLD_FILTER_BGS != FILTER_BGS) ReloadTheme(BGS);
	if(OLD_FILTER_BG != FILTER_BG) ReloadTheme(_BG_);
}

u8 LoadTexture(char *texture_path, u32 *texture_offset, imgData *texture_data, u32 *texture_size, u8 gray)
{

	if( imgLoadFromFile(texture_path, texture_data, gray) == FAILED ) { 
		*texture_offset=0;
		return FAILED;
	}
	
	if((*texture_data).bmp_out == NULL) {
		*texture_offset=0;
		return FAILED;
	}
	
	memcpy(texture_pointer, (*texture_data).bmp_out, (*texture_data).pitch * (*texture_data).height);
	free((*texture_data).bmp_out);
	*texture_offset = tiny3d_TextureOffset(texture_pointer);
	
	texture_pointer += (((*texture_data).pitch * (*texture_data).height + 15) & ~15) / 4;
	
	if(texture_size != NULL) *texture_size += (((*texture_data).pitch * (*texture_data).height + 15) & ~15) / 4;
	
	return SUCCESS;
}

u32 texture_NOTIF = 0;
u32 texture_BOXHEAD = 0;
u32 texture_BOXBODY = 0;
u32 texture_SIDEBAR = 0;
u32 texture_BGS = 0;
u32 texture_BG = 0;

// to reload fast for COLORFILTER
void ReloadTheme(u8 i)
{
	char temp[255];
	char thmPath[255];
	u32 SIZE=0;
	u8 gray=NO;
	
	sprintf(thmPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], Themes[UI_position]);
	if(path_info(thmPath) == _NOT_EXIST) {
		strcpy(Themes[UI_position], STR_NONE);
		sprintf(thmPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], Themes[UI_position]);
	}
	
	if(i == NOTIF) texture_pointer = texture_mem + TEXTURE_POINTER_THEME + texture_NOTIF;
	if(i == BOXHEAD) texture_pointer = texture_mem + TEXTURE_POINTER_THEME + texture_BOXHEAD;
	if(i == BOXBODY) texture_pointer = texture_mem + TEXTURE_POINTER_THEME + texture_BOXBODY;
	if(i == SIDEBAR) texture_pointer = texture_mem + TEXTURE_POINTER_THEME + texture_SIDEBAR;
	if(i == BGS) texture_pointer = texture_mem + TEXTURE_POINTER_THEME + texture_BGS;
	if(i == _BG_) texture_pointer = texture_mem + TEXTURE_POINTER_THEME + texture_BG;
	
	if( i==NOTIF && FILTER_NOTIF==ENABLED) gray = YES; else
	if( i==BOXHEAD && FILTER_BOXHEAD==ENABLED) gray = YES; else
	if( i==BOXBODY && FILTER_BOXBODY==ENABLED) gray = YES; else
	if( i==SIDEBAR && FILTER_SIDEBAR==ENABLED) gray = YES; else
	if( i==BGS && FILTER_BGS==ENABLED) gray = YES; else
	gray = NO;
	
	if(i == _BG_) {
		sprintf(temp, "%s/BG.PNG", thmPath);
		if(is_apng(temp) == YES) {
			Load_ANIMATED_BG(temp);
		} else {
			if( LoadTexture(temp, &BG_offset[0], &BG[0], &SIZE, FILTER_BG) == FAILED ) {
				sprintf(temp, "%s/BG.JPG", thmPath);
				LoadTexture(temp, &BG_offset[0], &BG[0], &SIZE, FILTER_BG);
			}
			
		}
		return;
	}
	
	
	sprintf(temp, "%s/%s.PNG", thmPath, PICTURE_NAME[i]);
	if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &SIZE, gray) == SUCCESS ) return;
		
	sprintf(temp, "%s/%s.JPG", thmPath, PICTURE_NAME[i]);
	if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &SIZE, gray) == SUCCESS ) return;
	
	sprintf(temp, "/dev_hdd0/game/%s/USRDIR/GUI/common/%s.PNG", ManaGunZ_id, PICTURE_NAME[i]);
	if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &SIZE, gray) == SUCCESS ) return;
		
	sprintf(temp, "/dev_hdd0/game/%s/USRDIR/GUI/common/%s.JPG", ManaGunZ_id, PICTURE_NAME[i]);
	if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &SIZE, gray) == SUCCESS ) return;
}

void Load_Theme()
{
	char temp[255];
	char thmPath[255];
	int i;
	
	GetThemes();
	
	AddThemeColorSet();
	
	texture_pointer = texture_mem + TEXTURE_POINTER_THEME;
	
	memset(PICTURE_offset, 0, sizeof(PICTURE_offset));
	memset(BG_offset, 0, sizeof(BG_offset));
	memset(XMB_Col_offset, 0, sizeof(XMB_Col_offset));
	XMB_MMTHM_XMB2_offset = 0;
	XMB_MMTHM_XMB_offset = 0;
	TEXTURE_THEME_SIZE=0;
	
	texture_NOTIF = 0;
	texture_BOXHEAD = 0;
	texture_BOXBODY = 0;
	texture_SIDEBAR = 0;
	texture_BG = 0;
	texture_BGS = 0;
	
	sprintf(thmPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], Themes[UI_position]);
	if(path_info(thmPath) == _NOT_EXIST) {
		strcpy(Themes[UI_position], STR_NONE);
		sprintf(thmPath, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], Themes[UI_position]);
	}
	u8 gray = NO;
	for(i=0; i<PICTURE_NUMBER; i++) {
		if( i==NOTIF && FILTER_NOTIF==ENABLED) gray = YES; else
		if( i==BOXHEAD && FILTER_BOXHEAD==ENABLED) gray = YES; else
		if( i==BOXBODY && FILTER_BOXBODY==ENABLED) gray = YES; else
		if( i==SIDEBAR && FILTER_SIDEBAR==ENABLED) gray = YES; else
		if( i==BGS && FILTER_BGS==ENABLED) gray = YES; else
		gray = NO;
		
		if( i==NOTIF) texture_NOTIF = TEXTURE_THEME_SIZE; else
		if( i==BOXHEAD)texture_BOXHEAD = TEXTURE_THEME_SIZE; else
		if( i==BOXBODY) texture_BOXBODY = TEXTURE_THEME_SIZE; else
		if( i==SIDEBAR) texture_SIDEBAR = TEXTURE_THEME_SIZE; else
		if( i==BGS) texture_BGS = TEXTURE_THEME_SIZE;
		
		sprintf(temp, "%s/%s.PNG", thmPath, PICTURE_NAME[i]);
		if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &TEXTURE_THEME_SIZE, gray) == SUCCESS ) continue;
		
		sprintf(temp, "%s/%s.JPG", thmPath, PICTURE_NAME[i]);
		if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &TEXTURE_THEME_SIZE, gray) == SUCCESS ) continue;
		
		sprintf(temp, "/dev_hdd0/game/%s/USRDIR/GUI/common/%s.PNG", ManaGunZ_id, PICTURE_NAME[i]);
		if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &TEXTURE_THEME_SIZE, gray) == SUCCESS ) continue;
		
		sprintf(temp, "/dev_hdd0/game/%s/USRDIR/GUI/common/%s.JPG", ManaGunZ_id, PICTURE_NAME[i]);
		if( LoadTexture(temp, &PICTURE_offset[i], &PICTURE[i], &TEXTURE_THEME_SIZE, gray) == SUCCESS ) continue;
		
	}	

	if(UI_position==XMB) {
		int i;
		for(i=0; i<6; i++) {
			sprintf(temp, "%s/%s.PNG", thmPath, XMB_COLUMN_NAME[i]);
			if( LoadTexture(temp, &XMB_Col_offset[i], &XMB_Col[i], &TEXTURE_THEME_SIZE, NO) == FAILED ) {
				sprintf(temp, "%s/%s.JPG", thmPath, XMB_COLUMN_NAME[i]);
				LoadTexture(temp, &XMB_Col_offset[i], &XMB_Col[i], &TEXTURE_THEME_SIZE, NO);
			}
		}
		
		sprintf(temp, "%s/MMTHM_XMB.PNG", thmPath);
		if( LoadTexture(temp, &XMB_MMTHM_XMB_offset, &XMB_MMTHM_XMB, &TEXTURE_THEME_SIZE, NO) == FAILED ) {
			sprintf(temp, "%s/MMTHM_XMB.JPG", thmPath);
			LoadTexture(temp, &XMB_MMTHM_XMB_offset, &XMB_MMTHM_XMB, &TEXTURE_THEME_SIZE, NO);
		}
		
		sprintf(temp, "%s/MMTHM_XMB2.PNG", thmPath);
		if( LoadTexture(temp, &XMB_MMTHM_XMB2_offset, &XMB_MMTHM_XMB2, &TEXTURE_THEME_SIZE, NO) == FAILED ) {
			sprintf(temp, "%s/MMTHM_XMB2.JPG", thmPath);
			LoadTexture(temp, &XMB_MMTHM_XMB2_offset, &XMB_MMTHM_XMB2, &TEXTURE_THEME_SIZE, NO);
		}
	}
	
	
	texture_BG = TEXTURE_THEME_SIZE;
	
	sprintf(temp, "%s/BG.PNG", thmPath);
	if(is_apng(temp) == YES) {
		Load_ANIMATED_BG(temp);
	} else {
		if( LoadTexture(temp, &BG_offset[0], &BG[0], &TEXTURE_THEME_SIZE, FILTER_BG) == FAILED ) {
			sprintf(temp, "%s/BG.JPG", thmPath);
			LoadTexture(temp, &BG_offset[0], &BG[0], &TEXTURE_THEME_SIZE, FILTER_BG);
		}
	}
}

u8 ExistInISO(char *path, char *filename)
{
	FILE* f = fopen(path, "rb");	
	if(f==NULL) return NO;
	
	u64 file_offset=0;
	int file_size=0;

	u8 ret = get_FileOffset(f, filename, &file_offset, (u32 *) &file_size);
	//print_load("Error : %s %llX", path, file_offset);
	fclose(f);
	
	return ret;
}

char *LoadFileFromISO(u8 prog, char *path, char *filename, int *size)
{
	FILE* f;
	f = fopen(path, "rb");	
	if(f==NULL) return NULL;
	
	u64 file_offset=0;
	u8 ret=0;
	int file_size=0;

	ret = get_FileOffset(f, filename, &file_offset, (u32 *) &file_size);
	//print_load("Error : %s %llX", path, file_offset);
	if(file_offset==0 || file_size==0 || ret == FAILED) {fclose(f); return NULL;}
	
	u8 split666 = is_66600(path);
	
	if(is_splitted_iso(path)==YES || split666) {

		char iso_path[128];
		char temp[128];
		u64 fsize=0;
		int i;
		int l = strlen(path);
		
		strcpy(iso_path, path);
		iso_path[l-1]=0;
		if(split666) iso_path[l-2]=0;
		strcpy(temp, iso_path);
		
		for(i=0; i<100; i++) {
			if(split666) sprintf(iso_path, "%s%02d", temp, i);
			else sprintf(iso_path, "%s%d", temp, i);

			fsize = get_size(iso_path);
			
			if(file_offset<fsize) {
				if(i!=0) {					 
					fclose(f);
					f = fopen(iso_path, "rb");	
					if(f==NULL) return NULL;
				}
				break;
			}
			file_offset -= fsize;
		}
	}
	
	u64 val64;
	fseek(f, file_offset-0x14, SEEK_SET);
	fread(&val64, sizeof(u64), 1, f);
	
	u8 is_bin=NO;
	if(val64==0xFFFFFFFFFFFFFF00) is_bin=YES;
	
	fseek(f, file_offset, SEEK_SET);
	
	char *mem = malloc(file_size);
	if(mem == NULL) {fclose(f); return NULL;}
	
	if(prog) prog_bar1_value=0;
	u64 read = 0;
	while(read < file_size) {
		u32 wrlen = 2048;
		if(read+wrlen > file_size) wrlen = (u32)file_size-read;
		fread(mem+read, sizeof(u8), wrlen, f);
		if(is_bin) fseek(f, 0x130, SEEK_CUR);
		read += wrlen;
		if(prog) prog_bar1_value = (read*100)/file_size;
	}
	fclose(f);
	
	if(prog) prog_bar1_value=-1;
	
	*size= file_size;
	return mem;
}

void LOAD_PIC1()
{
	if(Show_PIC1 == NO) return; 
	if(position_CURPIC<0) return;
	
	char *mem = NULL;
	int size=0;
	
	TMP_PIC_offset=0;
	
	if( list_game_platform[position_CURPIC] != ISO_PS3 && list_game_platform[position_CURPIC] != ISO_PSP &&
		list_game_platform[position_CURPIC] != JB_PS3 && list_game_platform[position_CURPIC] != BDVD) return;
		
	if( list_game_platform[position_CURPIC] == ISO_PS3 ) {
		mem = LoadFileFromISO(YES, list_game_path[position_CURPIC], "/PS3_GAME/PIC1.PNG", &size);
	} else
	if( list_game_platform[position_CURPIC] == ISO_PSP ) {
		mem = LoadFileFromISO(YES, list_game_path[position_CURPIC], "/PSP_GAME/PIC1.PNG", &size);
	} else
	if( list_game_platform[position_CURPIC] == JB_PS3 || list_game_platform[position_CURPIC] == BDVD) {
		char temp[255];
		sprintf(temp, "%s/PS3_GAME/PIC1.PNG", list_game_path[position_CURPIC]);
		mem = LoadFileProg(temp, &size);
	}
	if(mem==NULL) return;
	
	if(pngLoadFromBuffer(mem, size, (pngData *) &TMP_PIC) != 0) {free(mem); return;}
	
	free(mem);
	
	texture_pointer = texture_mem + TEXTURE_POINTER_TMP;
	
	if(TMP_PIC.bmp_out) {
		memcpy(texture_pointer, TMP_PIC.bmp_out, TMP_PIC.pitch * TMP_PIC.height);
		free(TMP_PIC.bmp_out);
		TMP_PIC_offset = tiny3d_TextureOffset(texture_pointer);
		texture_pointer += ((TMP_PIC.pitch * TMP_PIC.height + 15) & ~15) / 4;
	}
}

void LOAD_COVER() 
{	
	COVER_offset = 0;
	
	if(Show_COVER == NO) return;
	if(position_CURPIC<0) return;

	if(Read_GAMEPIC_COVER2D(position, &COVER) == SUCCESS) {
		texture_pointer = texture_mem + TEXTURE_POINTER_COVER;
		memcpy(texture_pointer, COVER.bmp_out, COVER.pitch*COVER.height);
		free(COVER.bmp_out);
		COVER_offset = tiny3d_TextureOffset(texture_pointer);
	}
}

void Draw_CURPIC()
{
	if(position == -1) return;
	
	if( Show_PIC1==YES || (Show_COVER==YES && (UI_position==LIST || UI_position==XMB)) ) 
		start_load_CURPIC(); 
	else {
		end_load_CURPIC(); 
		return;
	}
	
	if(MENU==YES && MENU_SIDE==NO) {return;}
	
	if(TMP_PIC_offset != 0 ) {
		if( UI_position==XMB || UI_position==FLOW)
		{
			tiny3d_SetTexture(0, TMP_PIC_offset, TMP_PIC.width, TMP_PIC.height, TMP_PIC.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			if(UI_position==FLOW)
				Draw_Box(0, 0, ITEM_moveZ[position]+1, 0, X_MAX, Y_MAX, WHITE, YES);
			else 
				Draw_Box(0, 0, 11, 0, X_MAX, Y_MAX, WHITE, YES);
		} else
		if((UI_position==LIST || UI_position==GRID) && Display_PIC1 == YES)
		{
			tiny3d_SetTexture(0, TMP_PIC_offset, TMP_PIC.width, TMP_PIC.height, TMP_PIC.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(50, 50, 0, 0, X_MAX-100, Y_MAX-100, WHITE, YES);
		}
	}
	
	if(0 <= prog_bar1_value && prog_bar1_value < 100) Draw_Progress_Bar(50, 15, 1, prog_bar1_value, COLOR_2);
}

static sys_ppu_thread_t load_CURPIC_id;

void load_CURPIC_thread(void *unused)
{
	while(Load_CURPIC_flag == YES) {
		if(position == -1) {
			sleep(1);
		} else
		if(position_CURPIC != position) {
			COVER_offset=0;
			TMP_PIC_offset = 0;
			position_CURPIC=position;
			usleep(100000);
			if(position_CURPIC == position) {
				LOAD_COVER();
				LOAD_PIC1();
			}
		}
		else usleep(10000);
		if( Game_stuff == NO ) {
			COVER_offset=0;
			TMP_PIC_offset=0;
			position_CURPIC=-1;
		}
	}
	Load_CURPIC_flag=-1;
	sysThreadExit(0);
}

void start_load_CURPIC()
{
	if(Load_CURPIC_flag==NO) {
		Load_CURPIC_flag = YES;
		sysThreadCreate(&load_CURPIC_id, load_CURPIC_thread, NULL, 1500, 0x2000, THREAD_JOINABLE, "Load_CURPIC_flag");
	}
}

void end_load_CURPIC()
{
	if(Load_CURPIC_flag==YES) {
		u64 ret;
		Load_CURPIC_flag = NO;
		while(Load_CURPIC_flag==NO) usleep(1000);
		sysThreadJoin(load_CURPIC_id, &ret);
		Load_CURPIC_flag=NO;
	}
}

void Translate(float *value, float target, float TranslateSpeed)
{
	float local;
	memcpy(&local, value, sizeof(float));
	
	if(local - TranslateSpeed < target && target < local + TranslateSpeed) {
		*value = target;
	} else
	if(local > target) {
		local-=TranslateSpeed;
		*value = local;
	} else
	if(local < target) {
		local+=TranslateSpeed;
		*value = local;
	}
}

void DrawParticle(float x, float y, float r, u32 color)
{
	int t;	
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(color);
	for(t=x; t<=x+360; t+=60) {
		tiny3d_VertexPos( x + r*sin(t*PI/180), y + r*cos(t*PI/180), 999);
	}
	tiny3d_End();
}

void DrawSmallParticle(float x, float y, u32 color)
{
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexPos(x,y,999);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x+1,y+1,999);
	tiny3d_VertexPos(x-1,y+1,999);
	tiny3d_End();
}

typedef struct
{
	float x;
	float y;
	float r;
	float a;
} particle;

typedef struct
{
	float x;
	float y;
	float a;
} small_particle;

typedef struct
{
	float size;
	float height;
	float phase;
	float frequency;
} wave;

#define WAVES_NUMBER 6
#define PARTICLE_NUMBER 30
#define SMALL_PARTICLE_NUMBER 200

wave *waves = NULL;
wave *new_waves = NULL;
particle *particles = NULL;
small_particle *small_particles = NULL;

#define rand_wave_freq				200 + rand()%500
#define rand_wave_size				rand()%100
#define rand_wave_height			rand()%75
#define rand_wave_phase				rand()%360

#define rand_particle_x				rand()%(int)X_MAX
#define rand_particle_y				Y_MAX/2-75 + rand()%150
#define rand_particle_r				2 + rand()%6
#define rand_particle_a				rand()%0x40

#define rand_small_particle_x				rand()%(int)X_MAX
#define rand_small_particle_y				Y_MAX/2-50 + rand()%100
#define rand_small_particle_a				0x80+rand()%0x80

void Draw_Waves(u32 wav_color)
{	
	int i;
	if(Show_Waves==NO) {
		if(waves != NULL) {
			for(i=0; i<WAVES_NUMBER; i++) {
				FREE(waves);
				FREE(new_waves);
			}
			for(i=0; i<PARTICLE_NUMBER; i++) {
				FREE(particles);
			}
			for(i=0; i<SMALL_PARTICLE_NUMBER; i++) {
				FREE(small_particles);
			}
		}
		return;
	}
	
	if(waves == NULL) {
		srand(1);
		waves = (wave *) malloc( WAVES_NUMBER * sizeof(wave));
		for(i=0; i<WAVES_NUMBER; i++) {
			waves[i].size = rand_wave_size;
			waves[i].phase = rand_wave_phase;
			waves[i].frequency = rand_wave_freq;
			waves[i].height = rand_wave_height;
		}
		new_waves = (wave *) malloc( WAVES_NUMBER * sizeof(wave));
		for(i=0; i<WAVES_NUMBER; i++) {
			new_waves[i].size = rand_wave_size;
			new_waves[i].phase = rand_wave_phase;
			new_waves[i].frequency = rand_wave_freq;
			new_waves[i].height = rand_wave_height;
		}
		particles = (particle *) malloc(PARTICLE_NUMBER * sizeof(particle));
		for(i=0; i<PARTICLE_NUMBER; i++) {
			particles[i].x = rand_particle_x;
			particles[i].y = rand_particle_y;
			particles[i].r = rand_particle_r;
			particles[i].a = rand_particle_a;
		}
		small_particles = (small_particle *) malloc(SMALL_PARTICLE_NUMBER * sizeof(small_particle));
		for(i=0; i<SMALL_PARTICLE_NUMBER; i++) {
			small_particles[i].x = rand_small_particle_x;
			small_particles[i].y = rand_small_particle_y;
			small_particles[i].a = rand_small_particle_a;
		}
		
	}
	
	u8 alpha = GetALPHA(wav_color) / 2;
	
	u32 color = (wav_color>>8)*0x100;
	
	int j=1;
	int x;
	for(i=0; i<WAVES_NUMBER; i++) {
		
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(x=0; x<=X_MAX+8; x+=8) {
			tiny3d_VertexColor(color + alpha - j*alpha);
			tiny3d_VertexPos(x, Y_MAX/2 + sin(j*DEG(waves[i].phase) + x / waves[i].frequency) * waves[i].height                    , 999);
			
			tiny3d_VertexColor(color + alpha + j*alpha);
			tiny3d_VertexPos(x, Y_MAX/2 + sin(j*DEG(waves[i].phase) + x / waves[i].frequency) * waves[i].height + waves[i].size, 999);
		}		
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(x=0; x<=X_MAX+8; x+=8) {
			tiny3d_VertexColor(color + alpha - j*alpha);
			tiny3d_VertexPos(x, Y_MAX/2 + sin(j*DEG(waves[i].phase) + x / waves[i].frequency) * waves[i].height                    , 999);
			
			tiny3d_VertexColor(color + alpha + j*alpha);
			tiny3d_VertexPos(x, Y_MAX/2 + sin(j*DEG(waves[i].phase) + x / waves[i].frequency) * waves[i].height - waves[i].size, 999);
		}		
		tiny3d_End();
		
		Translate(&waves[i].size, new_waves[i].size, 0.2);
		Translate(&waves[i].frequency, new_waves[i].frequency, 0.2);
		Translate(&waves[i].height, new_waves[i].height, 0.2);
		
		if(360 < waves[i].phase) waves[i].phase=0;
		else waves[i].phase += 0.2;
		
		if(	waves[i].frequency == new_waves[i].frequency) {
			new_waves[i].frequency = rand_wave_freq;
		}
		if(	waves[i].size == new_waves[i].size) {
			new_waves[i].size = rand_wave_size;
		}
		if(	waves[i].height == new_waves[i].height) {
			new_waves[i].height = rand_wave_height;
		}
		
		j=j*(-1);
	}
	
	for(i=0; i<PARTICLE_NUMBER; i++) {
		DrawParticle(particles[i].x, particles[i].y, particles[i].r, color + (u8) particles[i].a);	
		
		Translate(&particles[i].x, particles[i].x+j, 0.1);
		//Translate(&particles[i].y, particles[i].y+j, 0.01);
		if(particles[i].r<=8) particles[i].r+=j*0.01;
		particles[i].a-=0.1;
		                                  
		if( particles[i].a<=0 || particles[i].x>X_MAX || particles[i].x<0) {
			particles[i].x = rand_particle_x;
			particles[i].y = rand_particle_y;
			particles[i].r = rand_particle_r;
			particles[i].a = rand_particle_a;
		}
		j=j*(-1);
	}

	//small particles
	for(i=0; i<SMALL_PARTICLE_NUMBER; i++) {
		DrawSmallParticle(small_particles[i].x, small_particles[i].y, color + (u8) small_particles[i].a);
		
		Translate(&small_particles[i].x, small_particles[i].x+j, 0.1);
		//Translate(&small_particles[i].y, small_particles[i].y, 0.1);
		small_particles[i].a-=0.2;
		
		if( small_particles[i].a<=0 || small_particles[i].x>X_MAX || small_particles[i].x<0) {
			small_particles[i].x = rand_small_particle_x;
			small_particles[i].y = rand_small_particle_y;
			small_particles[i].a = rand_small_particle_a;
		}
		j=j*(-1);
	}
	
}

void Draw_BG()
{
	if(MENU==YES && MENU_SIDE == NO) return;
	
	u32 color = WHITE;
	if(BG_offset[1] != 0 ) { // Animated
		if(FILTER_BG==ENABLED) color = COLOR_BG;
		
		Draw_ABG(color);
	} else 
	if(BG_offset[0] != 0 ) {
		if(FILTER_BG==ENABLED) color = COLOR_BG;
		
		tiny3d_SetTexture(0, BG_offset[0], BG[0].width, BG[0].height, BG[0].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(0, 0, 1000, 0, 848, 512, color, YES);
	} else 
	if(FILTER_BG==ENABLED) {
		color = COLOR_BG;
		Draw_Box(0, 0, 1000, 0, 848, 512, color, NO);
	}
	
	if(UI_position == FLOW || UI_position == XMB) {
		Draw_Waves(WAVES_COLOR);
	}
}

void Draw_BGS()
{	
	u32 color = WHITE;
	if(PICTURE_offset[BGS] != 0 ) {
		if(FILTER_BGS==ENABLED) color=COLOR_BGS;
		
		tiny3d_SetTexture(0, PICTURE_offset[BGS], PICTURE[BGS].width, PICTURE[BGS].height, PICTURE[BGS].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(0, 0, 1000, 0, 848, 512, color, YES);
		
	} else 
	if(BG_offset[1] != 0 ) { // Animated
		if(FILTER_BGS==ENABLED) color=COLOR_BGS; else
		if(FILTER_BG==ENABLED) color=COLOR_BG;
		
		Draw_ABG(color);
	} else
	if(BG_offset[0] != 0 ) {
		if(FILTER_BGS==ENABLED) color=COLOR_BGS; else
		if(FILTER_BG==ENABLED) color=COLOR_BG;
		
		tiny3d_SetTexture(0, BG_offset[0], BG[0].width, BG[0].height, BG[0].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(0, 0, 1000, 0, 848, 512, color, YES);
	} else
	if(FILTER_BGS==ENABLED) {
		color=COLOR_BGS;
		Draw_Box(0, 0, 1000, 0, 848, 512, color, NO);
	}
}

void Draw_TriangleGradiant(float x1, float y1, float x2, float y2, float x3, float y3, float z, u32 color1, u32 color2, u32 color3)
{
	
	tiny3d_SetPolygon(TINY3D_TRIANGLES);
	tiny3d_VertexPos(x1 , y1 , z);
	tiny3d_VertexColor(color1);
	tiny3d_VertexPos(x2, y2 , z);
	tiny3d_VertexColor(color2);
	tiny3d_VertexPos(x3, y3, z);
	tiny3d_VertexColor(color3);
	tiny3d_End();
}

void Draw_Triangle(float x1, float y1, float x2, float y2, float x3, float y3, float z, u32 color)
{
	tiny3d_SetPolygon(TINY3D_TRIANGLES);
	tiny3d_VertexPos(x1 , y1 , z);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x2, y2 , z);
	tiny3d_VertexPos(x3, y3, z);
	tiny3d_End();
}

void DrawUp(float x, float y)  // equilateral abc, b vers le haut Xb=x, Ya=Yc=y
{
	Draw_Triangle(x-5, y,
				  x, y-5,
				  x+5, y,
				  0,  COLOR_4);
}

void DrawDown(float x, float y)  // equilateral abc, b vers le bas Xb=x, Ya=Yc=y
{
	Draw_Triangle(x-5, y,
				  x, y+5,
				  x+5, y,
				  0,  COLOR_4);
}

void Draw_DISK(float x, float y, float z, float d, u32 color)
{
	if(PICTURE_offset[DISC] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[DISC], PICTURE[DISC].width, PICTURE[DISC].height, PICTURE[DISC].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x+d/8, y+d/8, z, 0, d*3/4, d*3/4, WHITE, YES);
	} else {
		x+=d/2;
		y+=d/2;
		int t;
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(color);
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( x + d/2.5*sin(t*PI/180), y + d/2.5*cos(t*PI/180), z);
		}
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(WHITE);
		for(t=120; t<=150 ; t+=10) {
			tiny3d_VertexPos( x + d/3*sin(t*PI/180), y + d/3*cos(t*PI/180), z);
		}
		for(t=150; t>=120 ; t-=10) {
			tiny3d_VertexPos( x + d/6*sin(t*PI/180), y + d/6*cos(t*PI/180), z);
		}
		tiny3d_End();
		
		/*
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(WHITE);
		for(t=-60; t<=-30 ; t+=10) {
			tiny3d_VertexPos( x + d/2.5*sin(t*PI/180), y + d/2.5*cos(t*PI/180), z);
		}
		for(t=-30; t>=-60 ; t-=10) {
			tiny3d_VertexPos( x + d/6*sin(t*PI/180), y + d/6*cos(t*PI/180), z);
		}
		tiny3d_End();
		*/
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(WHITE);
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( x + d/6*sin(t*PI/180), y + d/6*cos(t*PI/180), z);
		}
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(color);
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( x + d/8*sin(t*PI/180), y + d/8*cos(t*PI/180), z);
		}
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(WHITE);
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( x + d/12*sin(t*PI/180), y + d/12*cos(t*PI/180), z);
		}
		tiny3d_End();
	}
}

int Draw_USB(float x, float y, float font_size, u32 rgba ,int nb)
{
	float s=font_size/4;
	
	float e=font_size/24;
	
	Draw_Box(x, y, 0, 0, 5 + s*5 + 5, font_size, 0xA0A0A0A0, NO);
	
	y+=font_size/2;
	
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(rgba);
	tiny3d_VertexPos( x + 2*s - e, y - s, 0);
	tiny3d_VertexPos( x + 2*s - e, y + 2*e - s, 0);
	tiny3d_VertexPos( x + 3*s, y + 2*e - s, 0);
	tiny3d_VertexPos( x + 3*s, y - s, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(rgba);
	tiny3d_VertexPos( x + 3*s - e, y + s, 0);
	tiny3d_VertexPos( x + 3*s - e, y + s - 2*e, 0);
	tiny3d_VertexPos( x + 4*s, y + s - 2*e, 0);
	tiny3d_VertexPos( x + 4*s, y + s, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(rgba);
	tiny3d_VertexPos( x + s - e*1.5 , y  , 0);
	tiny3d_VertexPos( x + s + e , y  , 0);
	tiny3d_VertexPos( x + 2*s + e , y - s , 0);
	tiny3d_VertexPos( x + 2*s - e , y - s , 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(rgba);
	tiny3d_VertexPos( x + 2*s - e*1.5, y  , 0);
	tiny3d_VertexPos( x + 2*s + e, y  , 0);
	tiny3d_VertexPos( x + 3*s + e, y + s , 0);
	tiny3d_VertexPos( x + 3*s - e, y + s , 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(rgba);
	tiny3d_VertexPos( x , y - e, 0);
	tiny3d_VertexPos( x , y + e, 0);
	tiny3d_VertexPos( x + 5*s, y + e, 0);
	tiny3d_VertexPos( x + 5*s , y - e, 0);
	tiny3d_End();
	
	FontSize(font_size/2);
	FontColor(COLOR_1);
	DrawFormatString(x+3.5*s, y-font_size/2, "%d", nb);
	FontSize(font_size);
	
	return x + 10 + 5*s;
}

void Draw_Button(float x, float y, float d)
{
	x+=d/2;
	y+=d/2;
	int t;
		
	tiny3d_SetPolygon(TINY3D_POLYGON);
	tiny3d_VertexColor(0x3F3F41ff);
	for(t=0; t<=360 ; t+=10) {
		tiny3d_VertexPos( x + d/1.9*sin(t*PI/180), y + d/1.9*cos(t*PI/180), 0);
	}
	tiny3d_End();
	
}

void Draw_Line(float x1, float y1, float x2, float y2, float z, u32 color)
{
	tiny3d_SetPolygon(TINY3D_LINES);
	tiny3d_VertexPos(x1, y1, z);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x2, y2, z);
	tiny3d_End();
}

void DrawChildArrow2(float x, float y, float z, float w, float h, u32 color)
{
	tiny3d_SetPolygon(TINY3D_LINES);
	tiny3d_VertexPos(x, y, z);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x, y+h, z);
	tiny3d_VertexPos(x+w, y+h, z);
	tiny3d_VertexPos(x+w-w/2, y+h+h/4, z);
	tiny3d_End();
	
	Draw_Line(x+w, y+h, x+w-w/2, y+h-h/4, z, color);
}

void DrawChildArrow(float x, float y, float z, float w, float h, u32 color)
{
	tiny3d_SetPolygon(TINY3D_TRIANGLE_STRIP);
	tiny3d_VertexPos(x-1 , y , z);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x+1 , y , 0);
	tiny3d_VertexPos(x-1 , y+h+1 , 0);
	tiny3d_VertexPos(x+1 , y+h+1 , 0);
	tiny3d_VertexPos(x+w-5 , y+h+1 , 0);
	tiny3d_VertexPos(x+1 , y+h-1 , 0);
	tiny3d_VertexPos(x+w-5 , y+h-1 , 0);
	tiny3d_End();

	tiny3d_SetPolygon(TINY3D_TRIANGLES);
	tiny3d_VertexPos(x+w-5 , y+h-1-2 , 0);
	tiny3d_VertexColor(color);
	tiny3d_VertexPos(x+w, y+h , 0);
	tiny3d_VertexPos(x+w-5, y+h+1+2, 0);
	tiny3d_End();
}

s8 spam_CIRCLE=-1;
#define spam_CIRCLE_MAX 3

void DrawProgRing(float x, float y, float d, float e, float value, u32 color)
{
	float t;
	float v = value*3.6;
	if(v>360) v=360;
	
	
	float r1 = d / 2;
	float le = e;
	if(r1<=le) le = d/10;
	float r2 = r1-le;
	
	
	if(v<10) {
		tiny3d_SetPolygon(TINY3D_LINES);
		tiny3d_VertexPos(x, y - r1, 0);
		tiny3d_VertexColor(color);
		tiny3d_VertexPos(x, y - r2, 0);
		tiny3d_End();
		return;
	}
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexColor(color);
	for(t=0; t<=v ; t+=10) {
		tiny3d_VertexPos( x + r1*sin(t*PI/180), y - r1*cos(t*PI/180), 0);
		tiny3d_VertexPos( x + r2*sin(t*PI/180), y - r2*cos(t*PI/180), 0);
	}
	tiny3d_End();
}

float DrawSpam(float x, float y)
{
	// float c = 5;
	// float e = 1;
	
	// if(spam_CIRCLE < 0 ) return x + c + 4;
	
	// u32 color;
	// if(0 <= spam_CIRCLE) color=COLOR_2; 
	// else color=BLACK;
	// Draw_Box(x, y, 0, 0, c, c, color, NO);
	// Draw_BoxLine(x,	y, 0, c, c, WHITE);
	
	// if(1 <= spam_CIRCLE) color=COLOR_2; 
	// else color=BLACK;
	// Draw_Box(x, y+c+e, 0, 0, c, c, color, NO);
	// Draw_BoxLine(x,	y+c+e, 0, c, c, WHITE);
	
	// if(2 <= spam_CIRCLE) color=COLOR_2; 
	// else color=BLACK;
	// Draw_Box(x, y+c+e+c+e, 0, 0, c, c, color, NO);
	// Draw_BoxLine(x,	y+c+e+c+e, 0, c, c, WHITE);
	
	// return x + c + 4;
	
	
	if(spam_CIRCLE < 0 ) return x;
	
	float val = (spam_CIRCLE*100 + 100) / spam_CIRCLE_MAX;
	
	DrawProgRing(x+8, y+8, 22.5, 5, val, COLOR_1);
	
	if(hold_CIRCLE) DrawProgRing(x+8, y+8, 20.5, 2, (float) ((hold_CIRCLE * 100) / MAX_HOLD), COLOR_3);
	
	if(0<=spam_CIRCLE) Draw_Line(x+8, y+8, x+8 + 22.5/2*sin(0), y+8 - 22.5/2*cos(0), 0, BLACK);
	if(1<=spam_CIRCLE) Draw_Line(x+8, y+8, x+8 + 22.5/2*sin(2*PI/3), y+8 - 22.5/2*cos(2*PI/3), 0, BLACK); 
	if(2<=spam_CIRCLE) Draw_Line(x+8, y+8, x+8 + 22.5/2*sin(4*PI/3), y+8 - 22.5/2*cos(4*PI/3), 0, BLACK);
	
	return x;
}

int Draw_Button_Circle(float x, float y, float size)
{
	if(PICTURE_offset[CIRCLE] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[CIRCLE], PICTURE[CIRCLE].width, PICTURE[CIRCLE].height, PICTURE[CIRCLE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, 0, 0, size, size, WHITE, YES);

		return x+size;
	}
	else {
		Draw_Button(x, y, size);
		
		x+=size/2;
		y+=size/2;
		int t;
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0xFF646Fff);
			
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( x + size/2*3/4*sin(t*PI/180), y + size/2*3/4*cos(t*PI/180), 0);
		}
		tiny3d_End();
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x3F3F41ff);
		for(t=0; t<=360 ; t+=10) {
			tiny3d_VertexPos( x + size/2*5/8*sin(t*PI/180), y + size/2*5/8*cos(t*PI/180), 0);
		}
		tiny3d_End();
		
		return x+size/2;
	}	
}

int Draw_Button_Square(float x, float y, float size)
{
	if(PICTURE_offset[SQUARE] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[SQUARE], PICTURE[SQUARE].width, PICTURE[SQUARE].height, PICTURE[SQUARE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, 0, 0, size, size, WHITE, YES);
		
		return x+size;
	}
	else {
		Draw_Button(x, y, size);
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0xF88DD7ff);
		x+=size/2;
		y+=size/2;
		tiny3d_VertexPos( x - size/2*7/8*sqrt(2)/2, y - size/2*7/8*sqrt(2)/2, 0);
		tiny3d_VertexPos( x + size/2*7/8*sqrt(2)/2, y - size/2*7/8*sqrt(2)/2, 0);
		tiny3d_VertexPos( x + size/2*7/8*sqrt(2)/2, y + size/2*7/8*sqrt(2)/2, 0);
		tiny3d_VertexPos( x - size/2*7/8*sqrt(2)/2, y + size/2*7/8*sqrt(2)/2, 0);
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x3F3F41FF);
		tiny3d_VertexPos( x - size/2*11/16*sqrt(2)/2, y - size/2*11/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x + size/2*11/16*sqrt(2)/2, y - size/2*11/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x + size/2*11/16*sqrt(2)/2, y + size/2*11/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x - size/2*11/16*sqrt(2)/2, y + size/2*11/16*sqrt(2)/2, 0);
		tiny3d_End();
		
		return x+size/2;
	}
}

int Draw_Button_Triangle(float x, float y, float size)
{
	if(PICTURE_offset[TRIANGLE] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[TRIANGLE], PICTURE[TRIANGLE].width, PICTURE[TRIANGLE].height, PICTURE[TRIANGLE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, 0, 0, size, size, WHITE, YES);
		
		return x+size;
	}
	else {
		Draw_Button(x, y, size);
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x00CDC7ff);
		x+=size/2;
		y+=size/2;
		tiny3d_VertexPos( x - size/2*7/8*sqrt(3)/2, y + size/2/2*7/8, 0);
		tiny3d_VertexPos( x + size/2*7/8*sqrt(3)/2, y + size/2/2*7/8, 0);
		tiny3d_VertexPos( x, y - size/2*7/8, 0);
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x3F3F41FF);
		tiny3d_VertexPos( x - size/2*11/16*sqrt(3)/2, y + size/2/2*11/16, 0);
		tiny3d_VertexPos( x + size/2*11/16*sqrt(3)/2, y + size/2/2*11/16, 0);
		tiny3d_VertexPos( x, y - size/2*11/16, 0);
		tiny3d_End();
		
		return x+size/2;
	}
}

int Draw_Button_Cross(float x, float y, float size)
{

	if(PICTURE_offset[CROSS] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[CROSS], PICTURE[CROSS].width, PICTURE[CROSS].height, PICTURE[CROSS].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, 0, 0, size, size, WHITE, YES);
		
		return x+size;
	}
	else {
		Draw_Button(x, y, size);
		
		x+=size/2;
		y+=size/2;
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x82B4EBff);
		tiny3d_VertexPos( x - size/2*15/16*sqrt(2)/2, y - size/2*13/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x - size/2*13/16*sqrt(2)/2, y - size/2*15/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x + size/2*15/16*sqrt(2)/2 , y + size/2*13/16*sqrt(2)/2 , 0);
		tiny3d_VertexPos( x + size/2*13/16*sqrt(2)/2 , y + size/2*15/16*sqrt(2)/2 , 0);
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x82B4EBff);
		tiny3d_VertexPos( x + size/2*13/16*sqrt(2)/2, y - size/2*15/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x + size/2*15/16*sqrt(2)/2, y - size/2*13/16*sqrt(2)/2, 0);	
		tiny3d_VertexPos( x - size/2*13/16*sqrt(2)/2, y + size/2*15/16*sqrt(2)/2, 0);
		tiny3d_VertexPos( x - size/2*15/16*sqrt(2)/2, y + size/2*13/16*sqrt(2)/2, 0);
		tiny3d_End();
		
		return size/2+x;
	}
}

int Draw_Button_Start(float x, float y, float size)
{	
	if(PICTURE_offset[START] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[START], PICTURE[START].width, PICTURE[START].height, PICTURE[START].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		tiny3d_SetPolygon(TINY3D_QUADS);

		tiny3d_VertexPos(x	 , y	 , 0);
		tiny3d_VertexColor(0xFFFFFFFF);
		tiny3d_VertexTexture(0.0f, 0.0f);

		tiny3d_VertexPos(x + size, y	 , 0);
		tiny3d_VertexTexture(1.0f, 0.0f);

		tiny3d_VertexPos(x + size, y + size, 0);
		tiny3d_VertexTexture(1.0f, 1.0f);

		tiny3d_VertexPos(x	 , y + size, 0);
		tiny3d_VertexTexture(0.0f, 1.0f);

		tiny3d_End();
		return x+size;
	}
	else {
		y-=size/20;
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexColor(0x3F3F41ff);
		tiny3d_VertexPos( x, y + size/4 , 0);
		tiny3d_VertexPos( x, y + 3*size/4 , 0);
		tiny3d_VertexPos( x + size, y + size/2 , 0);
		tiny3d_End();
		return x + size ;
	}
}

int Draw_Button_Select(float x, float y,  float size) {

	if(PICTURE_offset[SELECT] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[SELECT], PICTURE[SELECT].width, PICTURE[SELECT].height, PICTURE[SELECT].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, 0, 0, size, size, WHITE, YES);
		
	} else {
		Draw_Box(x, y+size/3, 0, 2, size, size/3, 0x3F3F41ff, NO);
	}
	
	return x+size;
}

float Draw_Button_L1(float x, float y, float z, float size)
{
	if(PICTURE_offset[L1] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[L1], PICTURE[L1].width, PICTURE[L1].height, PICTURE[L1].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "L1");
}

float Draw_Button_L2(float x, float y, float z, float size)
{
	if(PICTURE_offset[L2] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[L2], PICTURE[L2].width, PICTURE[L2].height, PICTURE[L2].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "L2");
}

float Draw_Button_L3(float x, float y, float z, float size)
{
	if(PICTURE_offset[L3] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[L3], PICTURE[L3].width, PICTURE[L3].height, PICTURE[L3].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "L3");
}

float Draw_Button_L(float x, float y, float z, float size)
{
	if(PICTURE_offset[L] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[L], PICTURE[L].width, PICTURE[L].height, PICTURE[L].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "L");
}

float Draw_Button_R2(float x, float y, float z, float size)
{
	if(PICTURE_offset[R2] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[R2], PICTURE[R2].width, PICTURE[R2].height, PICTURE[R2].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "R2");
}

float Draw_Button_R1(float x, float y, float z, float size)
{
	if(PICTURE_offset[R1] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[R1], PICTURE[R1].width, PICTURE[R1].height, PICTURE[R1].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "R1");
}

float Draw_Button_R3(float x, float y, float z, float size)
{
	if(PICTURE_offset[R3] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[R3], PICTURE[R3].width, PICTURE[R3].height, PICTURE[R3].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "R3");
}

float Draw_Button_R(float x, float y, float z, float size)
{
	if(PICTURE_offset[R] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[R], PICTURE[R].width, PICTURE[R].height, PICTURE[R].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, size, size, WHITE, YES);
		return x+size;
	} else	return DrawString(x, y, "R");
}

float Draw_Pad(int button, float x, float y, float z,  float size) {

	if(PICTURE_offset[ALL] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[ALL], PICTURE[ALL].width, PICTURE[ALL].height, PICTURE[ALL].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		tiny3d_VertexPos(x, y, z);
		tiny3d_VertexColor(0xFFFFFFFF);
		tiny3d_VertexTexture(0.0f, 0.0f);
		tiny3d_VertexPos(x + size, y, z);
		tiny3d_VertexTexture(1.0f, 0.0f);
		tiny3d_VertexPos(x+size, y+size, z);
		tiny3d_VertexTexture(1.0f, 1.0f);
		tiny3d_VertexPos(x, y+size, z);
		tiny3d_VertexTexture(0.0f, 1.0f);
		tiny3d_End();
	}
	
	if(button & BUTTON_UP) {
		if(PICTURE_offset[UP] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[UP], PICTURE[UP].width, PICTURE[UP].height, PICTURE[UP].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			tiny3d_SetPolygon(TINY3D_QUADS);
			tiny3d_VertexPos(x, y, z);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexTexture(0.0f, 0.0f);
			tiny3d_VertexPos(x + size, y, z);
			tiny3d_VertexTexture(1.0f, 0.0f);
			tiny3d_VertexPos(x+size, y+size, z);
			tiny3d_VertexTexture(1.0f, 1.0f);
			tiny3d_VertexPos(x, y+size, z);
			tiny3d_VertexTexture(0.0f, 1.0f);
			tiny3d_End();
		}
	}
	if(button & BUTTON_LEFT) {
		if(PICTURE_offset[LEFT] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[LEFT], PICTURE[LEFT].width, PICTURE[LEFT].height, PICTURE[LEFT].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			tiny3d_SetPolygon(TINY3D_QUADS);
			tiny3d_VertexPos(x, y, z);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexTexture(0.0f, 0.0f);
			tiny3d_VertexPos(x + size, y, z);
			tiny3d_VertexTexture(1.0f, 0.0f);
			tiny3d_VertexPos(x+size, y+size, z);
			tiny3d_VertexTexture(1.0f, 1.0f);
			tiny3d_VertexPos(x, y+size, z);
			tiny3d_VertexTexture(0.0f, 1.0f);
			tiny3d_End();
		}
	}
	if(button & BUTTON_DOWN) {
		if(PICTURE_offset[DOWN] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[3], PICTURE[DOWN].width, PICTURE[DOWN].height, PICTURE[DOWN].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			tiny3d_SetPolygon(TINY3D_QUADS);
			tiny3d_VertexPos(x, y, z);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexTexture(0.0f, 0.0f);
			tiny3d_VertexPos(x + size, y, z);
			tiny3d_VertexTexture(1.0f, 0.0f);
			tiny3d_VertexPos(x+size, y+size, z);
			tiny3d_VertexTexture(1.0f, 1.0f);
			tiny3d_VertexPos(x, y+size, z);
			tiny3d_VertexTexture(0.0f, 1.0f);
			tiny3d_End();
		}
	}
	if(button & BUTTON_RIGHT) {
		if(PICTURE_offset[RIGHT] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[RIGHT], PICTURE[RIGHT].width, PICTURE[RIGHT].height, PICTURE[RIGHT].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			
			tiny3d_SetPolygon(TINY3D_QUADS);
			tiny3d_VertexPos(x, y, z);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexTexture(0.0f, 0.0f);
			tiny3d_VertexPos(x + size, y, z);
			tiny3d_VertexTexture(1.0f, 0.0f);
			tiny3d_VertexPos(x+size, y+size, z);
			tiny3d_VertexTexture(1.0f, 1.0f);
			tiny3d_VertexPos(x, y+size, z);
			tiny3d_VertexTexture(0.0f, 1.0f);
			tiny3d_End();
		}
	}
	
	return x+size;
}

float DrawButton(float x, float y, char *str, int button)
{
	float button_size = 16;
	FontSize(button_size);

	if(button & BUTTON_CROSS) x=Draw_Button_Cross(x, y, button_size); 
	if(button & BUTTON_SQUARE) x=Draw_Button_Square(x, y, button_size); 
	if(button & BUTTON_TRIANGLE) x=Draw_Button_Triangle(x, y, button_size);
	if(button & BUTTON_CIRCLE) x=Draw_Button_Circle(x, y, button_size); 
	if(button & BUTTON_SELECT) x=Draw_Button_Select(x, y, button_size); 
	if(button & BUTTON_START) x=Draw_Button_Start(x, y, button_size);
	if(button & BUTTON_L1) x=Draw_Button_L1(x, y, 0, button_size);
	if(button & BUTTON_L2) x=Draw_Button_L2(x, y, 0, button_size);
	if(button & BUTTON_L3) x=Draw_Button_L3(x, y, 0, button_size);
	if(button & BUTTON_L ) x=Draw_Button_L (x, y, 0, button_size);
	if(button & BUTTON_R1) x=Draw_Button_R1(x, y, 0, button_size);
	if(button & BUTTON_R2) x=Draw_Button_R2(x, y, 0, button_size);
	if(button & BUTTON_R3) x=Draw_Button_R3(x, y, 0, button_size);
	if(button & BUTTON_R ) x=Draw_Button_R (x, y, 0, button_size);
	if((button & BUTTON_RIGHT) || (button & BUTTON_LEFT) || (button & BUTTON_DOWN) || (button & BUTTON_UP))	x=Draw_Pad(button, x, y, 0, button_size);
	
	x=DrawString(x+5, y+1, str);
	
	return x+10;
}

u8 GetRED(u32 rgba) 
{
	return (u8) (rgba >> 24) ;
}

u8 GetGREEN(u32 rgba) 
{
	return (u8) ((rgba - (rgba >> 24)*0X1000000) >> 16 );
}

u8 GetBLUE(u32 rgba) {	
	return (u8) ((rgba - (rgba >> 16)*0X10000) >> 8 );
}

u8 GetALPHA(u32 rgba) 
{
	return (u8) (rgba - (rgba>>8)*0x100) ;
}

u32 SetRED(u8 red, u32 rgba){
	return rgba - GetRED(rgba) * 0x1000000 + red*0x1000000;
}

u32 SetGREEN(u8 green, u32 rgba){
	return rgba - GetGREEN(rgba) * 0x10000 + green*0x10000;
}

u32 SetBLUE(u8 blue, u32 rgba){
	return rgba - GetBLUE(rgba) * 0x100 + blue*0x100;
}

u32 SetALPHA(u8 alpha, u32 rgba)
{
	return rgba - GetALPHA(rgba) + alpha;
}

void Draw_NOT(float x, float y, float z, float w, float h)
{	
	if(PICTURE_offset[NOT] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[NOT], PICTURE[NOT].width, PICTURE[NOT].height, PICTURE[NOT].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	}
}

void Draw_SIDEBAR(float x)
{
	if(UI_position!=XMB) Draw_Box(0, 0, 9, 0, 848, 512, 0x000000B0, NO);
	
	u32 color=COLOR_SIDEBAR_DEFAULT;
	if(PICTURE_offset[SIDEBAR] != 0) {
		if(FILTER_SIDEBAR==ENABLED) color=COLOR_SIDEBAR;
		else color=WHITE;
		
		tiny3d_SetTexture(0, PICTURE_offset[SIDEBAR], PICTURE[SIDEBAR].width, PICTURE[SIDEBAR].height, PICTURE[SIDEBAR].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, 0, 9, 0, X_MAX-x, 512, color, YES);
	} else {
		if(FILTER_SIDEBAR==ENABLED) {
			color=COLOR_SIDEBAR;
			Draw_Box(x, 0, 9, 0, X_MAX-x, 512, color, NO);
			Draw_Box(x, 0, 9, 0, 1, 512, color, NO);
		} else {
			Draw_Box(x, 0, 9, 0, X_MAX-x, 512, COLOR_SIDEBAR_DEFAULT, NO);
			Draw_Box(x, 0, 9, 0, 1, 512, WHITE, NO);
		}
		
	}
	
}

int Draw_Progress_Bar(float x, float y, u8 size, float value, u32 color)
{	
	float w=size*100;
	
	float e = size;
	float h = size*2;
	
	Draw_Box(x  , y  , 0, 0, w+e*2+2, h+e*2+2,  COLOR_1, NO);
	Draw_Box(x+e, y+e, 0, 0, w+2	, h+2	, 0x000000FF, NO);
	
	Draw_Box(x+e+1, y+e+1, 0, 0, value*size, h, color, NO);
	
	return x+w+2*e;
	
}

float Draw_Progress_Bar_Advanced(float x, float y, float z, float r, float w, float h, 
								 float border, u32 border_color, u32 bg_color, u32 bar_color, u64 max, u64 value)
{
	//background
	Draw_Box(x, y, z, r, w, h, bg_color, NO);
	
	//border
	if( border != 0 ) Draw_Box(x-border, y-border, z, r, w+border*2, h+border*2, border_color, NO);
	
	// bar
	float bar_w = w*value/max;
	Draw_Box(x, y, z, r, bar_w, h, bar_color, NO);
	
	return x+w+border;
}

void DrawNotBody(float x, float y, float z, float w, float h)
{
	u32 color = WHITE;
	
	if(PICTURE_offset[NOTIF]!=0) {
		
		if(FILTER_NOTIF==ENABLED) color = COLOR_NOTIF;
		else color = WHITE;
		
		tiny3d_SetTextureWrap(0, PICTURE_offset[NOTIF], PICTURE[NOTIF].width, PICTURE[NOTIF].height, PICTURE[NOTIF].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTWRAP_CLAMP, TEXTWRAP_CLAMP, TEXTURE_LINEAR);
		
		float wn=PICTURE[NOTIF].width/4;
		float hn=PICTURE[NOTIF].height/4;
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x, y, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.0f, 0.0f);

		tiny3d_VertexPos(x+wn, y, z);
		tiny3d_VertexTexture(0.25f, 0.0f);

		tiny3d_VertexPos(x+wn, y+hn, z);
		tiny3d_VertexTexture(0.25f, 0.25f);
		
		tiny3d_VertexPos(x, y+hn, z);
		tiny3d_VertexTexture(0.0f, 0.25f);
		
		tiny3d_End();
		
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x+wn, y, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.25f, 0.0f);

		tiny3d_VertexPos(x+w-wn, y, z);
		tiny3d_VertexTexture(0.75f, 0.0f);

		tiny3d_VertexPos(x+w-wn, y+hn, z);
		tiny3d_VertexTexture(0.75f, 0.25f);
		
		tiny3d_VertexPos(x+wn, y+hn, z);
		tiny3d_VertexTexture(0.25f, 0.25f);
		
		tiny3d_End();
		
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x+w-wn, y, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.75f, 0.0f);

		tiny3d_VertexPos(x+w, y, z);
		tiny3d_VertexTexture(1.0f, 0.0f);

		tiny3d_VertexPos(x+w, y+hn, z);
		tiny3d_VertexTexture(1.0f, 0.25f);
		
		tiny3d_VertexPos(x+w-wn, y+hn, z);
		tiny3d_VertexTexture(0.75f, 0.25f);
		
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x, y+hn, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.0f, 0.25f);

		tiny3d_VertexPos(x+wn, y+hn, z);
		tiny3d_VertexTexture(0.25f, 0.25f);

		tiny3d_VertexPos(x+wn, y+h-hn, z);
		tiny3d_VertexTexture(0.25f, 0.75f);
		
		tiny3d_VertexPos(x, y+h-hn, z);
		tiny3d_VertexTexture(0.0f, 0.75f);
		
		tiny3d_End();
		
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x+wn, y+hn, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.25f, 0.25f);

		tiny3d_VertexPos(x+w-wn, y+hn, z);
		tiny3d_VertexTexture(0.75f, 0.25f);

		tiny3d_VertexPos(x+w-wn, y+h-hn, z);
		tiny3d_VertexTexture(0.75f, 0.75f);
		
		tiny3d_VertexPos(x+wn, y+h-hn, z);
		tiny3d_VertexTexture(0.25f, 0.75f);
		
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x+w-wn, y+hn, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.75f, 0.25f);

		tiny3d_VertexPos(x+w, y+hn, z);
		tiny3d_VertexTexture(1.0f, 0.25f);

		tiny3d_VertexPos(x+w, y+h-hn, z);
		tiny3d_VertexTexture(1.0f, 0.75f);
		
		tiny3d_VertexPos(x+w-wn, y+h-hn, z);
		tiny3d_VertexTexture(0.75f, 0.75f);
		
		tiny3d_End();
		
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x, y+h-hn, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.0f, 0.75f);

		tiny3d_VertexPos(x+wn, y+h-hn, z);
		tiny3d_VertexTexture(0.25f, 0.75f);

		tiny3d_VertexPos(x+wn, y+h, z);
		tiny3d_VertexTexture(0.25f, 1.0f);
		
		tiny3d_VertexPos(x, y+h, z);
		tiny3d_VertexTexture(0.0f, 1.0f);
		
		tiny3d_End();
		
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x+wn, y+h-hn, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.25f, 0.75f);

		tiny3d_VertexPos(x+w-wn, y+h-hn, z);
		tiny3d_VertexTexture(0.75f, 0.75f);

		tiny3d_VertexPos(x+w-wn, y+h, z);
		tiny3d_VertexTexture(0.75f, 1.0f);
		
		tiny3d_VertexPos(x+wn, y+h, z);
		tiny3d_VertexTexture(0.25f, 1.0f);
		
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_QUADS);
		
		tiny3d_VertexPos(x+w-wn, y+h-hn, z);
		tiny3d_VertexColor(color);
		tiny3d_VertexTexture(0.75f, 0.75f);

		tiny3d_VertexPos(x+w, y+h-hn, z);
		tiny3d_VertexTexture(1.0f, 0.75f);

		tiny3d_VertexPos(x+w, y+h, z);
		tiny3d_VertexTexture(1.0f, 1.0f);
		
		tiny3d_VertexPos(x+w-wn, y+h, z);
		tiny3d_VertexTexture(0.75f, 1.0f);
		
		tiny3d_End();
	} else {
		if(FILTER_NOTIF==ENABLED) color = COLOR_NOTIF;
		else color = COLOR_NOTIF_DEFAULT;
		
		Draw_Box(590, 40, 0, 3, 213, 50, color, NO);
	}
}

void Draw_Notification()
{
	if(not_msg[0] == 0)	return;
	time_not++;
	if(time_not > 100) {
		time_not=0; 
		memset(not_msg, 0, sizeof(not_msg));
		return ;
	}
	
	SetFontZ(0);
	FontColor(COLOR_1);
	FontSize(14);
			
	DrawNotBody(590, 40, 0, 213, 50);
	
	Draw_NOT(600, 50, 0, 30, 30);

	DrawString(635, 58, not_msg);
	
	SetFontZ(10);
	FontSize(15);
}

void show_msg(char *str)
{
	time_not=0;
	strcpy(not_msg, str);
}

void DrawLoadingIcon()
{
	if(LoadIconRot==720) LoadIconRot=360;
	
	float t;	
	float r1 = 7;
	float r2 = 5;
	float x = X_MAX - 20;
	float y = 20;
	/*
	float r1 = 50;
	float r2 = 30;
	float x = X_MAX/2;
	float y = Y_MAX/2;
	*/
	u32 color = COLOR_1;
	
	color = color - GetALPHA(color);
	
	u8 alpha = 0;
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=LoadIconRot; t<=LoadIconRot+360 ; t+=10) {
		tiny3d_VertexColor(color+alpha);
		tiny3d_VertexPos( x - r1*sin(t*PI/180), y - r1*cos(t*PI/180), 0);
		tiny3d_VertexPos( x - r2*sin(t*PI/180), y - r2*cos(t*PI/180), 0);
		alpha=(t-LoadIconRot)/360*0xFF;
	}
	tiny3d_End();
	
	LoadIconRot+=5;
}

u8 show_scene = NO;
static sys_ppu_thread_t loading_id;

u64 task_ProgressBar1_max=0;
u64 task_ProgressBar1_val=0;
u64 task_ProgressBar2_max=0;
u64 task_ProgressBar2_val=0;

void task_Init(const u64 max)
{
	if(task_ProgressBar1_max==0) {
		task_ProgressBar1_val = 0;
		task_ProgressBar1_max=max;
	} else {
		task_ProgressBar2_val= 0;
		task_ProgressBar2_max=max;
	}
}

void task_Update(u64 val)
{
	task_ProgressBar1_val+= val;
	task_ProgressBar2_val+= val;
}

void task_Update2(u64 val)
{
	if( task_ProgressBar2_max != 0 ) {
		task_ProgressBar1_val += val - task_ProgressBar2_val;
		task_ProgressBar2_val = val;
	} else {
		task_ProgressBar1_val = val;
	}
}

void task_End()
{
	if(task_ProgressBar2_max != 0) {
		task_ProgressBar2_max=0;
		task_ProgressBar2_val=0;
	} else {
		task_ProgressBar1_max=0;
		task_ProgressBar1_val=0;
	}
}

u8 loading_can_turnoff=NO;

void Draw_Loading(void *unused)
{
// bullet
	int bullet_move = 1;
	int speed = 3;
	int boost=100;
	int h=20, v=70;
		
	u32 color=GREEN;
	u8 have_log=NO;
	int i=0;
	int show_log=SHOW_LOG;
	u8 old_DEBUG = DEBUG;
	u8 shutdown=NO;
	
	cancel=NO;
	LoadIconRot=0;
	
	strcpy(head_title, "\0");
	for(i=0; i<=20; i++){
		strcpy(loading_log[i], "\0");
	}
	
	//if(scene == SCENE_FILEMANAGER) show_scene = YES;
	
	u64 start=0;
	u64 previous_val=0;
	
	while(loading) {
	
		if(!loading) break;
		
		int x=50, y=40;
		
		if(loading_log[0][0]!=0 || head_title[0] != 0 || prog_bar1_value >= 0) have_log=YES;
		
		if(show_scene) {
			Draw_scene();
			if((SHOW_LOG || DEBUG) && show_log && have_log) Draw_Box(0, 0, 0, 0, 848, 512, 0x000000C0, NO);
		} else Draw_BGS();
		
		FontSize(20);
		FontColor(COLOR_1);
		SetFontZ(0);
		
		if(!loading) break;
		
		if(!loading) break;
		
		if(!show_scene) {	
		
			int t;
			switch(bullet_move)
			{
				case 1: //droite
				{
					if(speed==9) {
						Draw_Box(h-17, v+2 , 0, 0, 15, 2, 0xFFFFFF50, NO);
						Draw_Box(h-22, v+9 , 0, 0, 20, 2, 0xFFFFFF50, NO);
						Draw_Box(h-17, v+16, 0, 0, 15, 2, 0xFFFFFF50, NO);
					}
					Draw_Box(h  , v, 0, 0, 3 , 20, 0xFFFFFF50, NO);
					Draw_Box(h+4, v, 0, 0, 16, 20, 0xFFFFFF50, NO);
					
					if(!loading) break;
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0xFFFFFF50);
					for(t=0; t<=180 ; t+=15) {
						tiny3d_VertexPos( h + 20 + 10*sin(t*PI/180), v + 10 + 10*cos(t*PI/180), 0);
					}
					tiny3d_End();
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0x000000A0);
					for(t=-135; t<=45 ; t+=15) {
						tiny3d_VertexPos( h + 20 + 2*sin(t*PI/180), v + 7 + 3*cos(t*PI/180), 0);
					}
					tiny3d_End();
					
					if(h>= 820) bullet_move = 2; else h+=speed;
				}
				break;
				case 2: //gauche
				{
					if(speed==9) {
						Draw_Box(h+22, v+2 , 0, 0, 15, 2, 0xFFFFFF50, NO);
						Draw_Box(h+22, v+9 , 0, 0, 20, 2, 0xFFFFFF50, NO);
						Draw_Box(h+22, v+16, 0, 0, 15, 2, 0xFFFFFF50, NO);
					}
					Draw_Box(h+17, v, 0, 0, 3 , 20, 0xFFFFFF50, NO);
					Draw_Box(h   , v, 0, 0, 16, 20, 0xFFFFFF50, NO);
					
					if(!loading) break;
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0xFFFFFF50);
					for(t=-180; t<=0 ; t+=15) {
						tiny3d_VertexPos( h + 10*sin(t*PI/180), v + 10 + 10*cos(t*PI/180), 0);
					}
					tiny3d_End();
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0x000000A0);
					for(t=-45; t<=135 ; t+=15) {
						tiny3d_VertexPos( h + 2*sin(t*PI/180), v + 7 + 3*cos(t*PI/180), 0);
					}
					tiny3d_End();
							
					if(h < 20) bullet_move = 1; else h-=speed;
				}
				break;
				case 3: // haut
				{
					if(speed==9) {
						Draw_Box(h+2 , v+22, 0, 0, 2, 15, 0xFFFFFF50, NO);
						Draw_Box(h+9 , v+22, 0, 0, 2, 20, 0xFFFFFF50, NO);
						Draw_Box(h+16, v+22, 0, 0, 2, 15, 0xFFFFFF50, NO);
					}
					
					Draw_Box(h, v+17, 0, 0, 20,  3, 0xFFFFFF50, NO);
					Draw_Box(h, v   , 0, 0, 20, 16, 0xFFFFFF50, NO);
					
					if(!loading) break;
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0xFFFFFF50);
					for(t=90; t<=270 ; t+=15) {
						tiny3d_VertexPos( h + 10 + 10*sin(t*PI/180), v + 10*cos(t*PI/180), 0);
					}
					tiny3d_End();
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0x000000A0);
					for(t=45; t<=225 ; t+=15) {
						tiny3d_VertexPos( h + 7 + 2*sin(t*PI/180), v + 3*cos(t*PI/180), 0);
					}
					tiny3d_End();
				
					if(v < 20) bullet_move = 4; else v-=speed;
				}
				break;
				case 4: // bas
				{
					if(speed==9) {
						Draw_Box(h+2 , v-17, 0, 0, 2, 15, 0xFFFFFF50, NO);
						Draw_Box(h+9 , v-22, 0, 0, 2, 20, 0xFFFFFF50, NO);
						Draw_Box(h+16, v-17, 0, 0, 2, 15, 0xFFFFFF50, NO);
					}
					Draw_Box(h, v  , 0, 0, 20, 3 , 0xFFFFFF50, NO);
					Draw_Box(h, v+4, 0, 0, 20, 16, 0xFFFFFF50, NO);
					
					if(!loading) break;
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0xFFFFFF50);
					for(t=-90; t<=90 ; t+=15) {
						tiny3d_VertexPos( h + 10 + 10*sin(t*PI/180), v + 20 + 10*cos(t*PI/180), 0);
					}
					tiny3d_End();
					
					tiny3d_SetPolygon(TINY3D_POLYGON);
					tiny3d_VertexColor(0x000000A0);
					for(t=45; t<=225 ; t+=15) {
						tiny3d_VertexPos( h + 7 + 2*sin(t*PI/180), v + 20 + 3*cos(t*PI/180), 0);
					}
					tiny3d_End();
					
					if(v > 490) bullet_move = 3; else v+=speed;
				}
				break;
				default: //droite
				{
					bullet_move = 1;
				}
			}
			
			if(speed==9) rumble2_on=1; else rumble2_on=0;
			if(boost<30) {
				color = RED;
			} else
			if(boost==100) {
				color = BLUE;
			} else
			if(boost<100) {
				color = GREEN;
			}
		}
		
		if( SHOW_LOG || DEBUG ) {
			if(show_log && have_log) {
				
				if(head_title[0] != 0) {
					FontColor(COLOR_2);
					DrawString(x, y, head_title);
					FontColor(COLOR_1);
					y+=20;
				}
				if( task_ProgressBar1_max != 0 && start == 0 && task_ProgressBar1_max != task_ProgressBar1_val) {
					start = sTime();
					init_timer(4);
					start_timer(4);
				}
				if( start ) {
					
					u64 progress_bar_w = 600;
					
					char speed_STR[32];
					char elapsed_STR[32];
					char remaining_STR[32];
					if( get_time(4) > 1000 ) {
						
						start_timer(4);
						s64 speed = task_ProgressBar1_val - previous_val;
						if( speed < 0) speed=0;
						char *copy_speed = get_unit((u64) speed);
						if(copy_speed) sprintf(speed_STR, "%s/s", copy_speed);
						FREE(copy_speed);
						
						previous_val = task_ProgressBar1_val;
						
						u64 ElapsedTime = sTime() - start;
						u64 RemainingTime = ElapsedTime * task_ProgressBar1_max / task_ProgressBar1_val - ElapsedTime;
					
						char *ElapsedTime_STR = GetTimeStr(ElapsedTime);
						if(ElapsedTime_STR) sprintf(elapsed_STR,  "%s: %s", STR_ELAPSED, ElapsedTime_STR);
						FREE(ElapsedTime_STR);	
						
						char *RemainingTime_STR = GetTimeStr(RemainingTime);
						if(RemainingTime_STR) sprintf(remaining_STR,  "%s: %s", STR_REMAINING, RemainingTime_STR);
						FREE(RemainingTime_STR);
					}
					
					DrawFormatString(x, y, elapsed_STR);
					
					y+=new_line(1);
					
					DrawFormatString(x, y, remaining_STR);
					
					y+=new_line(1);
					
					char *size_current = get_unit(task_ProgressBar1_val);
					if(size_current) DrawString(x, y, size_current);
					FREE(size_current);
					
					char *size_tot = get_unit(task_ProgressBar1_max);
					if(size_tot) DrawString(x+progress_bar_w-WidthFromStr(size_tot), y, size_tot);
					FREE(size_tot);
					
					DrawStringFromCenterX(x+progress_bar_w/2, y, speed_STR);
					
					y+=new_line(1);

					Draw_Progress_Bar_Advanced(x, y, 0, 0, progress_bar_w, 4, 1, WHITE, BLACK, GREEN,  task_ProgressBar1_max, task_ProgressBar1_val);
					
					y+=new_line(1);
					
					if( task_ProgressBar2_max != task_ProgressBar1_max && task_ProgressBar2_max != 0) {
						Draw_Progress_Bar_Advanced(x, y, 0, 0, progress_bar_w, 4, 1, WHITE, BLACK, GREEN,  task_ProgressBar2_max, task_ProgressBar2_val);
					}
					
					y+=new_line(1);
					
					if( task_ProgressBar1_max == task_ProgressBar1_val ) {
						 task_ProgressBar1_max=0;
						 task_ProgressBar1_val=0;
						 task_ProgressBar2_max=0;
						 task_ProgressBar2_val=0;
					}
					if( task_ProgressBar1_max == 0) start = 0;
				} else 
				if(prog_bar1_value >= 0) {
					Draw_Progress_Bar(x, y, 2, prog_bar1_value, COLOR_2);
					y+=15;
					if(prog_bar2_value >= 0) Draw_Progress_Bar(x, y, 2, prog_bar2_value, COLOR_2);
					y+=25;
				}
				
				if(!loading) break;
				
				for(i=0; i<=20; i++){
					
					if(strstr(loading_log[i], "Error")) FontColor(RED);
					else if(strstr(loading_log[i], "Warning")) FontColor(ORANGE);
					else FontColor(COLOR_1);
					
					DrawFormatString(x , y, loading_log[i]);
					y+=20;
					if(y>450) break;
				}
			}
		}
		if(!loading) break;
		
		// *** DISPLAY BUTTONS ***
		x=INPUT_X;
		y=INPUT_Y;
		FontSize(15);
		FontColor(COLOR_1);
		SetFontZ(0);
		
		if(show_scene) {
			if(LoadIconRot<180) {
				Draw_input();
				y=-50;
			}
		}
		
		if(have_log && (SHOW_LOG || DEBUG)) {
			if(show_log) x=DrawButton(x, y, STR_HIDELOGS, BUTTON_SELECT);
			else x=DrawButton(x, y, STR_SHOWLOGS, BUTTON_SELECT);
		}
		
		if(!show_scene) {
			x=Draw_Button_Square(x, y, 15);
			x=Draw_Progress_Bar(x+5, y+4, 1, boost, color);
			x=DrawFormatString( x+5, y, "%s ", STR_BOOST);
		}
		
		if(!loading) break;
		
		if(loading_can_turnoff) {
			x=DrawButton(x, y, STR_TURNOFF, BUTTON_L1);
			x=Draw_checkbox(x-3, y, 0, "", shutdown, YES);
		}
		
		if(AutoM) {
			x=DrawButton(x, y, STR_GAMEMENU, BUTTON_TRIANGLE);
		}
		if(prog_bar1_value >= 0 || task_ProgressBar1_max) {
			x=DrawButton(x, y, STR_CANCEL, BUTTON_CIRCLE);
		}
		
		if( old_DEBUG ) {
			x=DrawButton(x, y, "Disable DEBUG temporarily", BUTTON_R1);
			x=Draw_checkbox(x-3, y, 0, "", DEBUG, YES);
		}
		
		if(!loading) break;
		
		Draw_MemMonitor();
		DrawLoadingIcon();
		tiny3d_Flip();
		//ScreenShot();
		cls();
		
		ps3pad_read();
		
		if( old_DEBUG ) {
			if(OldPad(BUTTON_R1) ) DEBUG = NO;
			else DEBUG = YES;
		}
		if(loading_can_turnoff && NewPad(BUTTON_L1)) {
			shutdown= !shutdown;
		}
		if(NewPad(BUTTON_RIGHT)) {
			bullet_move = 1;
		}
		if(NewPad(BUTTON_LEFT)) {
			bullet_move = 2;
		}
		if(NewPad(BUTTON_UP)) {
			bullet_move = 3;
		}
		if(NewPad(BUTTON_DOWN)) {
			bullet_move = 4;
		}
		if(NewPad(BUTTON_CIRCLE) && (prog_bar1_value >= 0 || task_ProgressBar1_max)) {
			cancel=YES;
		}
		if((NewPad(BUTTON_TRIANGLE) || OldPad(BUTTON_TRIANGLE)) && AutoM) {
			gui_called=YES;
		}
		if(NewPad(BUTTON_SELECT)) {
			show_log=!show_log;
		}
		if(OldPad(BUTTON_SQUARE)) {
			if(0 < boost && boost <= 30 && speed==9 ) {
				speed=9;
				boost--;
			} 
			else if(boost > 30) {
				speed=9;
				boost--;
			}
			else {
				speed=3;
			}
		} else {
			speed=3;
			if(boost<100) {
				boost+=1;
			}
		}
	}
	
	cls();
	tiny3d_Flip();
	
	if(!cancel == NO && shutdown) {
		MGZ_exit();
		Delete("/dev_hdd0/tmp/turnoff");
		lv2syscall4(379,0x1100,0,0,0);
	}
	
	DEBUG = old_DEBUG;
	
	prog_bar1_value=-1;
	prog_bar2_value=-1;
	cancel=NO;
	
	strcpy(head_title, "\0");
	show_scene=NO;
	
	for(i=0; i<=20; i++){
		strcpy(loading_log[i], "\0");
	}
	
	loading=-1;
	sysThreadExit(0);
}

FILE *mgz_log=NULL;
static char buff[4096];
void print_load(char *format, ...)
{	
	char *str = (char *) buff;
	va_list	opt;
	
	va_start(opt, format);
	vsprintf( (void *) buff, format, opt);
	va_end(opt);
	
	int i;
	for(i=19; i>0; i--){
		strcpy(loading_log[i], loading_log[i-1]);
	}
	
	if( ERR == TRUE ) {
		sprintf(loading_log[0], "Error : %s", str);
	} else 
	if( WAR == TRUE ) {
		sprintf(loading_log[0], "Warning : %s", str);
	} else strcpy(loading_log[0], str);
	
	time_not=1;
	if(strstr(loading_log[0], "Warning ")) sleep(1);
	if(strstr(loading_log[0], "Error ")) sleep(2);
	
	ERR = FALSE;
	WAR = FALSE;
	
// TTY
	fprintf(stdout, loading_log[0]);
	fprintf(stdout, "\n");
	
	if( LOG ) {
		
		if( mgz_log == NULL ) {
			mkdir("/dev_hdd0/tmp", 0777);
			mgz_log = fopen("/dev_hdd0/tmp/mgz.log", "w");
		}
		if( mgz_log != NULL) {
			fputs(loading_log[0], mgz_log);
			fputs("\n", mgz_log);
			fflush(mgz_log);
		}
	}
	
	// If it freeze, it allow to display every messages before the freeze (loading screen thread is async)
	if( DEBUG ) {
		if( loading || gathering || copy_flag) sleep(1);
	}

}

static char buff2[4096];
void print_head(char *format2, ...)
{
	char *str2 = (char *) buff2;
	va_list	opt2;
	
	va_start(opt2, format2);
	vsprintf( (void *) buff2, format2, opt2);
	va_end(opt2);
	
	strcpy(head_title, str2);

// TTY
	fprintf(stdout, head_title);
	fprintf(stdout, "\n");
	
	if( LOG ) {	
		if( mgz_log == NULL ) {
			mkdir("/dev_hdd0/tmp", 0777);
			mgz_log = fopen("/dev_hdd0/tmp/mgz.log", "w");
			if( mgz_log == NULL ) return;
		}
		if( mgz_log != NULL ) {
			fputs(head_title, mgz_log);
			fputs("\n", mgz_log);
			fflush(mgz_log);
		}
	}
	
	// If it freeze, it allow to display every messages before the freeze
	if( DEBUG ) {
		if( loading || gathering || copy_flag) sleep(1);
	}
}

void hex_print_load(char *data, size_t len)
{
   int i = 0;
   char line[33];
   memset(line, 0, 33);
   
   while( i < len) {
       
        sprintf(&line[i%16*2], "%02X",  data[i]);
        if((i>0 && i%16 == 15) || i == (len-1)) {
            print_load("%s", line);
            memset(line, 0, 33);
        }
        i++;
   } 
}

void start_loading()
{
	if(loading==NO) {
		loading=YES;
		sysThreadCreate(&loading_id, Draw_Loading, NULL, 999, 0x2000, THREAD_JOINABLE, "loading");
	}
}

void end_loading()
{
	if(loading==YES) {
		u64 ret;
		loading=NO;
		while(loading==NO) usleep(1000);
		sysThreadJoin(loading_id, &ret);
		loading=NO;
	}
}

void reset_gathering()
{
	gathering_cancel=NO;
	gathering_total_size=0;
	gathering_nb_file=0;
	gathering_nb_directory=0;
}

static sys_ppu_thread_t gathering_id;	
void Draw_Gathering(void *unused)
{
	int i;
	for(i=0; i<=20; i++) strcpy(loading_log[i], "\0");
	
	while(gathering) {
				
		int x=50, y=40;
		
		Draw_BGS();
		
		FontSize(20);
		FontColor(COLOR_1);
		SetFontZ(0);

		
		FontColor(COLOR_1);
		DrawFormatString(x, y, STR_GATHERING);
		y+=20;
		DrawFormatString(x, y, "%s = %i", STR_FILES, gathering_nb_file);
		y+=20;
		DrawFormatString(x, y, "%s = %i", STR_DIRS, gathering_nb_directory);
		y+=20;
		char *size_tot = get_unit(gathering_total_size);
		DrawFormatString(x, y,"%s = %s", STR_TOTALSIZE, size_tot);
		y+=20;
		FREE(size_tot);
		
		for(i=0; i<=20; i++){
			if(strstr(loading_log[i], "Error")) FontColor(RED);
			else if(strstr(loading_log[i], "Warning")) FontColor(ORANGE);
			else FontColor(COLOR_1);
			
			DrawFormatString(x , y, loading_log[i]);
			y+=20;
			if(y>450) break;
		}
		
		// *** DISPLAY BUTTONS ***
		x=INPUT_X;
		y=INPUT_Y;
		FontSize(15);
		FontColor(COLOR_1);
		SetFontZ(0);
		
		x=DrawButton(x, y, STR_CANCEL, BUTTON_CIRCLE);
		
		Draw_MemMonitor();
		DrawLoadingIcon();
		tiny3d_Flip();
		//ScreenShot();
		cls();
		
		ps3pad_read();
		
		if(NewPad(BUTTON_CIRCLE) && gathering==YES) {
			gathering_cancel=YES;
		}
	}
	
	for(i=0; i<=20; i++) strcpy(loading_log[i], "\0");
	
	gathering=-1;
	sysThreadExit(0);
}

void start_gathering()
{
	if(gathering==NO) {
		gathering=YES;
		reset_gathering();
		print_debug("start of gathering thread");
		sysThreadCreate(&gathering_id, Draw_Gathering, NULL, 999, 0x2000, THREAD_JOINABLE, "gathering");
	}
}

void end_gathering()
{
	if(gathering==YES) {
		u64 ret;
		gathering=NO;
		print_debug("end of gathering thread");
		while(gathering==NO) usleep(1000);
		sysThreadJoin(gathering_id, &ret);
		gathering=NO;
	}
}


float DrawStringFromCenterX(float x, float y, char *txt)
{
	return DrawString(x-WidthFromStr(txt)/2, y, txt);
}



//*******************************************************
// Update Manager
//*******************************************************

// https://www.psdevwiki.com/ps3/Update_Manager

#define UM_UPDATE_PACKAGE_TOPHALF		0x6001
#define UM_INSPECT_PACKAGE_TOPHALF		0x6002
#define UM_GET_PACKAGE_INFO				0x6003
#define UM_GET_FIX_INSTRUCTION			0x6004
#define UM_EXTRACT_PACKAGE_TOPHALF		0x6005	
#define UM_GET_EXTRACT_PACKAGE			0x6006
#define UM_IS_FLASH_INITIALIZED			0x6007
#define UM_SET_FLASH_INITIALIZED		0x6008	
#define UM_GET_TOKEN_SEED               0x6009
#define UM_SET_TOKEN					0x600A
#define UM_READ_EPROM                   0x600B
#define UM_WRITE_EPROM                  0x600C
#define UM_GET_STATUS					0x600D
#define UM_MALLOC			            0x600E
#define UM_FREE			                0x600F
#define UM_CHECK_INTEGRITY				0x6010
#define UM_GET_APPLICABLE_VERSION		0x6011
#define UM_REALLOC                      0x6012

s32 update_manager(u32 packet_id, u64 arg1, u64 arg2, u64 arg3, u64 arg4, u64 arg5, u64 arg6)
{
	lv2syscall7(863, packet_id, arg1, arg2, arg3, arg4, arg5, arg6);
	return_to_user_prog(u32);
}

s32 GetApplicableVersion(void * data)
{
	return update_manager(UM_GET_APPLICABLE_VERSION, 1, (u64) data, 0,0,0,0);
}

u8 get_minver(char *minver)
{
	u16 data[0x10];
	
	int result = GetApplicableVersion(data);
	if( result != 0) {
		print_load("Error : GetApplicableVersion failed : 0x%08X", result);
		return FAILED;
	}
	
	sprintf(minver, "%02X.%02X", data[0], data[1]);
	
	//SaveFile("/dev_usb000/GetApplicableVersion.bin", (char *) data, 0x20);
	
	return SUCCESS;
}

char *get_date()
{
	char *date = (char *) malloc( 20 );
	if( date == NULL ) return NULL;
	
	time_t rawtime;
	struct tm * timeinfo;
	
	time ( &rawtime );
	timeinfo = localtime( &rawtime );
	sprintf(date, "%04d%02d%02d_%02d%02d%02d", timeinfo->tm_year+1900, timeinfo->tm_mon+1, timeinfo->tm_mday, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
	
	return date;
}

float get_fps()
{
	// TimeVal	time = FWTime::getCurrentTime();
	// float fFPS = 1.f / (float)(time - mLastTime);
	// mLastTime = time;
}

//*******************************************************
//lv2 syscalls
//*******************************************************

typedef struct
{
    char   Label[0x28];
	u64    sector_count;
    u32    sector_size;
    u32    unknown;
    u8     writable;
    u8     unknowns[7];
} __attribute__((packed)) device_info_t;

/*
struct storage_device_info {
	uint8_t res1[32];
	uint32_t vendor_id;
	uint32_t device_id;
	uint64_t capacity;
	uint32_t sector_size;
	uint32_t media_count;
	uint8_t res2[8];
};
*/

typedef struct
{
	char mount_point[0x20];
	char filesystem[0x20];
	char deviceName[0x40];
	char Unk[0x10];
	u32 ReadOnly;
} __attribute__((packed)) sys_fs_mount_info;


// https://en.wikipedia.org/wiki/Partition_type#List_of_partition_IDs
// supported = 0xB (FAT32) / 0x7 (NTFS)
// static char* PartitionType[] = {  /* 0x00 - 0x0f */ "Empty", "FAT12", "XENIX root", "XENIX usr", "FAT16", "Extended"," FAT16B", "IFS/HPFS/NTFS/exFAT/QNX", "", "", "", "FAT32", "FAT32", "FAT16", "Extended", "",
								  // /* 0x10 - 0x1f */ "","","","","","","","","","","","","","","","", 
								  // /* 0x20 - 0x2f */ "","","","","","","","","","","","","","","","", 
								  // /* 0x30 - 0x3f */ "","","","","","","","","","","","","","","","", 
							      // /* 0x40 - 0x4f */ "","","","","","","","","","","","","","","","", 
							      // /* 0x50 - 0x5f */ "","","","","","","","","","","","","","","","",
							      // /* 0x60 - 0x6f */ "","","","","","","","","","","","","","","","", 
								  // /* 0x70 - 0x7f */ "","","","","","","","","","","","","","","","",
								  // /* 0x80 - 0x8f */ "","","Linux Swap","Linux","","Linux Extended","","","","","","","","","Linux LVM","", 
								  // /* 0x90 - 0x9f */ "","","","","","","","","","","","","","","","", 
								  // /* 0xa0 - 0xaf */ "","","","","","","","","","","","","","","","HFS / HFS+", 
								  // /* 0xb0 - 0xbf */ "","","","","","","","","","","","","","","","", 
								  // /* 0xc0 - 0xcf */ "","","","","","","","","","","","","","","","", 
								  // /* 0xd0 - 0xdf */ "","","","","","","","","","","","","","","","", 
								  // /* 0xe0 - 0xef */ "","","","","","","","","","","","","","","GPT","EFI", 
								  // /* 0xf0 - 0xff */ "","","","","","","","","","","","","","","",""  
							    // };
// typedef struct
// {
	// u16 byte_per_sec;
	// u8 sector_per_cluster;
	// u16 reserved_sector;
	// u8 zero;
	// u32 unused0;
	// u8 media_descriptor;
	// u16 unused1;
	// u16 sector_per_track;
	// u16 number_of_heads;
	// u32 hidden_sectors;
	// u32 unused2;
	// u32 signature;
	// u64 total_sectors;
	// u64 MFT_cluster_number;
	// u64 MFTMirr_cluster_number;
	// u32 cluster_per_file;
	// u32 cluster_per_index;
	// u64 volume_serial;
	// u32 checksum;
// } __attribute__((packed)) NTFS_bios_parameter_t;

// typedef struct
// {
	// u8 JMP_inst[3];
	// char OEM_ID[8];
	// NTFS_bios_parameter_t bios_parameter;
	// u8 bootstrap[420];
	// u16 signature;
// } __attribute__((packed)) NTFS_boot_sector_t;

		
// N'OUBLIE PAS L'ENDIAN SWAP SI TU VEUX UTILISER CES DONNéES !
typedef struct
{
	u16 byte_per_sec;
	u8 sector_per_cluster;
	u16 reserved_sector;
	u8 number_of_FAT;
	u16 unused0;
	u16 unused00;
	u8 media_descriptor;
	u16 unused1;
	u16 sector_per_track;
	u16 number_of_heads;
	u32 hidden_sectors;
	u32 total_sectors;
	u32 sector_per_FAT;
	u16 extended_flag;
	u16 version;
	u32 root_cluster;
	u16 system_information_sector;
	u16 backup_boot_sector;
	u8 reserved[0xC];
} __attribute__((packed)) FAT32_bios_parameter_t;

typedef struct
{
	u8 physical_drive;
	u8 reserved;
	u8 extended_signature;
	u32 serial;
	char volume_label[0xB];
	char file_system[0x8];
} __attribute__((packed)) FAT32_extended_bios_parameter_t;

typedef struct
{
	u8 JMP_inst[3];
	char OEM_ID[8];
	FAT32_bios_parameter_t bios_parameter;
	FAT32_extended_bios_parameter_t extended_bios_parameter;
	u8 bootstrap[420];
	u16 signature;
} __attribute__((packed)) FAT32_boot_sector_t;

typedef struct
{
	u8 active_flag;
	u8 start_head;
	u8 start_sector;
	u8 start_cylinder;
	u8 partition_type;
	u8 end_head;
	u8 end_sector;
	u8 end_cylinder;
	u32 first_sector;
	u32 total_sector;
} __attribute__((packed)) mbr_table_entry_t;

typedef struct
{
	u8 bootstrap[0x1B8];
	u32 serial;
	u16 reserved;
	mbr_table_entry_t mbr_table_entry[4];
	u16 signature; // 0x55AA
} __attribute__((packed)) mbr_t;

u64 lv2peek(u64 addr)
{ 
	u64 l_addr = (u64) addr >> 0ULL; 
	if(l_addr  < 0x8000000000000000ULL) {
		l_addr += 0x8000000000000000ULL;
	}
	lv2syscall1(6, l_addr) ;
	return_to_user_prog(u64);
}

u64 lv2poke(u64 addr, u64 value) 
{ 
	u64 l_addr = (u64) addr >> 0ULL; 
	if(l_addr  < 0x8000000000000000ULL) {
		l_addr += 0x8000000000000000ULL;
	}
	lv2syscall2(7, l_addr, (u64) value);
	return_to_user_prog(u64);
}

u32 lv2peek32(uint64_t addr)
{
	return (u32)(lv2peek(addr) >> 32);
}

static void lv2poke32(u64 addr, uint32_t val)
{
	uint32_t next = lv2peek(addr) & 0xffffffff;
	lv2poke(addr, (((u64) val) << 32) | next);
}

static inline void _poke(u64 addr, u64 val)
{
	lv2poke(0x8000000000000000ULL + addr, val);
}

static inline void _poke32(u64 addr, uint32_t val)
{
	lv2poke32(0x8000000000000000ULL + addr, val);
}

u8 lv2peek8(u64 addr) {
	u8 ret = (u8) (lv2peek(addr) >> 56ULL);
	return ret;
}

u64 lv2poke8(u64 addr, u8 value) 
{ 
	return lv2poke(addr, (((u64) value) <<56) | (lv2peek(addr) & 0xffffffffffffffULL));
}

u64 lv1peek(u64 addr)
{ 
	if(cobra) {
		lv2syscall1(11, (u64) addr >> 0ULL);
		return_to_user_prog(u64);
	} else {
		lv2syscall1(8, (u64) addr >> 0ULL);
		return_to_user_prog(u64);
	}
}

void lv1poke( u64 addr, u64 val)
{
	lv2syscall2(9, addr, val);
}

int sys_fs_mount(char const* deviceName, char const* deviceFileSystem, char const* devicePath, int writeProt) 
{
	lv2syscall8(837, (u64) deviceName, (u64) deviceFileSystem, (u64) devicePath, 0, (u64) writeProt, 0, 0, 0 );
	return_to_user_prog(int);
}

int sys_fs_unmount(char const* devicePath) 
{
	lv2syscall3(838,  (u64) devicePath, 0, 0 );
	return_to_user_prog(int);
}

int sys_fs_chown(char *path, s32 uid, s32 gid)
{
	lv2syscall3(835, (u64) path, (u64) uid, (u64) gid);
	return_to_user_prog(int);
}

s64 sys_fs_disk_free(char *path, u64 *total_free, u64 *avail_free)
{
	lv2syscall3(840, (u64) path, (u64) total_free, (u64) avail_free);
	return_to_user_prog(int);
}

u64 syscall_40(u64 cmd, u64 arg)
{
	lv2syscall2(40, cmd, arg);
	return_to_user_prog(u64);
}

s32 sys_map_paths(char *paths[], char *new_paths[], unsigned int num)
{
	lv2syscall4(8, SYSCALL8_OPCODE_MAP_PATHS, (uint64_t)paths, (uint64_t)new_paths, num);
	return_to_user_prog(s32);
}

s32 sys_storage_ext_fake_storage_event(uint64_t event, uint64_t param, uint64_t device)
{
	lv2syscall4(8, SYSCALL8_OPCODE_FAKE_STORAGE_EVENT, event, param, device);
	return_to_user_prog(s32);
}

s32 sys_storage_open(u64 device_ID, int* fd)
{
	lv2syscall4( 600, device_ID, 0, (u64)fd, 0 );
	return_to_user_prog(s32);
}

s32 sys_storage_close(int fd)
{
	lv2syscall1( 601, fd );
	return_to_user_prog(s32);
}

s32 sys_storage_open2(u64 device_ID, int* fd, u64 mode, u64 flag)
{
	lv2syscall4( 600, device_ID, (u64) mode, (u64)fd, (u64) flag);
	return_to_user_prog(s32);
}

s32 sys_storage_read2(int fd, u64 start_sector, u64 nb_sector, const void* buffer, u32 *sectors_read, u64 flags, u64 mode)
{
	lv2syscall7( 602, fd, mode, start_sector, nb_sector, (u64)buffer, (u64)sectors_read, flags );
	return_to_user_prog(s32);
}

s32 sys_storage_read(int fd, u64 start_sector, u64 nb_sector, const void* buffer, u32 *sectors_read, u64 flags )
{
	lv2syscall7( 602, fd, 0, start_sector, nb_sector, (u64)buffer, (u64)sectors_read, flags );
	return_to_user_prog(s32);
}

s32 sys_storage_write(int fd, u64 start_sector, u64 nb_sector, const void* buffer, u32 *sectors_wrote, u64 flags )
{
	lv2syscall7( 603, fd, 0, start_sector, nb_sector, (u64)buffer, (u64)sectors_wrote, flags );
	return_to_user_prog(s32);
}

s32 sys_storage_get_device_info(u64 device_id, device_info_t *device_info)
{
	lv2syscall2( 609, device_id, (u64)device_info );
	return_to_user_prog(s32);
}

s32 sys_storage_execute_device_command(u32 dev_handle, u64 cmd, const void *cmdbuf, u64 cmdbuf_size, void *databuf, u64 databuf_size, u64 *unknown)
{
	lv2syscall7(616, (u64) dev_handle, (u64) cmd, (u64) cmdbuf, (u64) cmdbuf_size, (u64) databuf, (u64) databuf_size,(u64) unknown);
	return_to_user_prog(s32);
}

s32 device_command(u32 dev_handle, const void *atapi_cmnd, u64 cmdbuf_size)
{
	return sys_storage_execute_device_command(dev_handle, 1, atapi_cmnd, cmdbuf_size, NULL, 0, NULL);
}

s32 sys_fs_get_mount_info(sys_fs_mount_info *info, uint64_t size, uint64_t *rsize)
{
	lv2syscall3(842, (u64)info, size, (uint64_t)rsize);
	return_to_user_prog(s32);
}

s32 sys_fs_get_mount_info_size(uint64_t *size)
{
	lv2syscall1(841, (uint64_t)size);
	return_to_user_prog(s32);
}

// not working on RPCS3
s32 _sys_get_title_id(char *TitleID)
{
	//syscall(986,out:uint8[0x40])
	lv2syscall1(986, (u64) TitleID);
    return_to_user_prog(s32);
}
// not working on RPCS3
s32 _sys_process_get_paramsfo(char *TitleID)
{
	char tmp[0x40];
	lv2syscall1(30, (u64) tmp);
	strncpy(&tmp[1], TitleID, 9);
	TitleID[9]=0;
	return_to_user_prog(s32);
}

void TestCapFlag()
{
	int source;
	u32 read;
	
	char *sector = (char *) malloc(512);
	if(sector==NULL) return ;
	
	int ret = sys_storage_open(USB_MASS_STORAGE(0), &source);
	if( ret == 0 ) {
		ret = sys_storage_read(source, 0, 1, sector, &read, 0);
		print_load("Error : 0x%X", ret);
	}
	sys_storage_close(source);
	
	
	device_info_t device_info;
	memset(&device_info, 0, sizeof(device_info));
	ret = sys_storage_get_device_info(USB_MASS_STORAGE(0), &device_info);
	
	print_load("Error : %X", ret);
	
	print_load("Error : Label : %s, sc %016llX, ss %08lX, unk %08ll", 
			device_info.Label,
			(long long unsigned int) device_info.sector_count,
			(long unsigned int) device_info.sector_size,
			(long unsigned int) device_info.unknown);
			
	print_load("Error : %d , %X%X%X%X%X%X%X", 
					(int) device_info.writable,
					(int) device_info.unknowns[0],
					(int) device_info.unknowns[1],
					(int) device_info.unknowns[2],
					(int) device_info.unknowns[3],
					(int) device_info.unknowns[4],
					(int) device_info.unknowns[5],
					(int) device_info.unknowns[6]);
}

void DumpUSB000()
{
	int source;
	u32 read;
	
	char *sector = (char *) malloc(512);
	if(sector==NULL) return ;
	
	u64 read_flag=0;	
	uint64_t w, x;
	int ret = sys_storage_open(USB_MASS_STORAGE(0), &source);
	if( ret == 0 ) {
		memset(sector, 0, 512);
		for(w = 0; w < 64; w++) {
			read_flag = (uint64_t) 1<<w;
			ret = sys_storage_read(source, 0, 1, sector, &read, read_flag);
			if(ret==0) goto foundu;
		}
		for(x = 0; x < 64; x++)
		for(w = 0; w < 64; w++) {
			read_flag = (uint64_t) 1<<w | (uint8_t) 1<<x;
			ret = sys_storage_read(source, 0, 1, sector, &read, read_flag);
			if(ret==0) goto foundu;
		}
		sys_storage_close(source);
	}

foundu:
	if( ret == 0 ) {
		
		FILE *f = fopen("/dev_hdd0/flag.txt", "wb");
		char res[255];
		sprintf(res, "\tsys_storage_read flag 0x%016llX, ret 0x%X\n", (unsigned long long int) read_flag, ret);
		fputs(res, f);
		fclose(f);
	}
	
	/*
	f = fopen("/dev_hdd0/boot_sector.bin", "wb");
	fwrite(sector, 512, 1, f);
	fclose(f);
	*/
	FREE(sector);
	
	Delete("/dev_hdd0/tmp/turnoff");
	lv2syscall4(379,0x1100,0,0,0);
	
	
}

u8 DeviceDumpBootSector(u64 device_id, u32 sector_size, u32 first_sector, FAT32_boot_sector_t *boot_sector)
{
	int source;
	u32 read;
	
	char *sector = (char *) malloc(sector_size);
	if(sector==NULL) return FAILED;
	
	int ret = sys_storage_open(device_id, &source);
	if( ret != 0 ) {
		FREE(sector);
		return FAILED;
	}
	
	sys_storage_read(source, first_sector, 1, sector, &read, 0);
	sys_storage_close(source);
	
	memcpy(boot_sector, sector, sizeof(FAT32_boot_sector_t)); 
	FREE(sector);
	
	if( DEBUG ) {
		FILE *f;
		f = fopen("/dev_hdd0/boot_sector.bin", "wb");
		fwrite(boot_sector, sizeof(FAT32_boot_sector_t), 1, f);
		fclose(f);
	}
	
	return SUCCESS;
}

u8 DeviceDumpMBRInfo(u64 device_id, u32 sector_size, mbr_t *mbr)
{
	int source;
	u32 read;
	
	char *sector = (char *) malloc(sector_size);
	if(sector==NULL) return FAILED;
	
	int ret = sys_storage_open(device_id, &source);
	if( ret != 0 ) {
		FREE(sector);
		return FAILED;
	}
	
	sys_storage_read(source, 0, 1, sector, &read, 0);
	sys_storage_close(source);
	
	memcpy(mbr, sector, sizeof(mbr_t)); 
	FREE(sector);
	
	return SUCCESS;
}

char *GetVolumeLabel(u64 device_id, u32 sector_size, u32 sector_position)
{
	int source;
	u32 read;
	
	char *sector = (char *) malloc(sector_size);
	if(sector==NULL) return NULL;
	
	int ret = sys_storage_open(device_id, &source);
	if( ret != 0 ) {
		FREE(sector);
		return NULL;
	}
	
	sys_storage_read(source, sector_position, 1, sector, &read, 0);
	sys_storage_close(source);
	
	char *label = (char *) malloc(0xB);
	if(label==NULL) {
		FREE(sector);
		return NULL;
	}
	
	memcpy(label, sector, 0xB); 
	FREE(sector);
	
	return label;
}


u8 get_mount_info(char *mount_point, sys_fs_mount_info *mount_info)
{
	int ret = -1;
	uint64_t i, size;
	sys_fs_mount_info *info;
	
	ret = sys_fs_get_mount_info_size(&size);
	if (ret != 0) {
		//print_load("Error : sys_fs_get_mount_info_size FAILED ! %X", ret);
		return SUCCESS;
	}
	
	info = malloc(size*sizeof(sys_fs_mount_info));
	memset(info, 0, size*sizeof(sys_fs_mount_info));
	ret = sys_fs_get_mount_info(info, size, &size);
	if (ret != 0)
	{
		//print_load("Error : sys_fs_get_mount_info FAILED ! %X", ret);
		free(info);
		return SUCCESS;
	}
	
	for (i = 0; i < size; i++)
	{
		if (strcmp(info[i].mount_point, mount_point) == 0)
			break;
	}
	
	if (i == size)
	{
		//print_load("Error : FAILED to find mount_point !%X", ret);
		free(info);
		return SUCCESS;
	}
	
	strcpy( mount_info->mount_point, info[i].mount_point );
	strcpy( mount_info->filesystem, info[i].filesystem );
	strcpy( mount_info->deviceName, info[i].deviceName );
	mount_info->ReadOnly = info[i].ReadOnly;

	free(info);
	
	return SUCCESS;
}

u64 get_device(char *name)
{	
	if (strcmp(name, "CELL_FS_IOS:ATA_HDD") == 0)
		return ATA_HDD;
	
	if (strcmp(name, "CELL_FS_IOS:BDVD_DRIVE") == 0 || strcmp(name, "/dev_bdvd") == 0)
		return BDVD_DRIVE;
	
	if (strcmp(name, "CELL_FS_IOS:PATA0_HDD_DRIVE") == 0)
		return PATA0_HDD_DRIVE;
	
	if (strcmp(name, "CELL_FS_IOS:PATA0_BDVD_DRIVE") == 0 || strcmp(name, "/dev_bdvd") == 0)
		return PATA0_BDVD_DRIVE;
	
	if (strcmp(name, "CELL_FS_IOS:PATA1_HDD_DRIVE") == 0)
		return PATA1_HDD_DRIVE;
	
	if (strcmp(name, "CELL_FS_IOS:PATA1_BDVD_DRIVE") == 0)
		return PATA1_BDVD_DRIVE;
	
	if (strcmp(name, "CELL_FS_IOS:BUILTIN_FLASH") == 0 || strcmp(name, "/dev_flash") == 0)
		return BUILTIN_FLASH;
	
	if (strcmp(name, "CELL_FS_IOS:COMPACT_FLASH") == 0 || strcmp(name, "/dev_cf") == 0)
		return COMPACT_FLASH;
	
	if (strcmp(name, "CELL_FS_IOS:MEMORY_STICK") == 0 || strcmp(name, "/dev_ms") == 0)
		return MEMORY_STICK;
	
	if (strcmp(name, "CELL_FS_IOS:SD_CARD") == 0 || strcmp(name, "/dev_sd") == 0)
		return SD_CARD;
	
	if (strncmp(name, "CELL_FS_IOS:USB_MASS_STORAGE", 28) == 0)
	{	
		unsigned int num = ((name[28]-'0')*100) + ((name[29]-'0')*10) + (name[30]-'0');
		
		if (num > 127)
			return 0;
		
		return USB_MASS_STORAGE(num);
	}
	
	if (strncmp(name, "/dev_usb", 8) == 0)
	{	
		unsigned int num = ((name[8]-'0')*100) + ((name[9]-'0')*10) + (name[10]-'0');
		
		if (num > 127)
			return 0;
		
		return USB_MASS_STORAGE(num);
	}
	
	if (strcmp(name, "CELL_FS_IOS:BUILTIN_FLSH1") == 0 || strcmp(name, "/dev_flash1") == 0)
		return FLASH_PARTITION(2);
	
	if (strcmp(name, "CELL_FS_IOS:BUILTIN_FLSH2") == 0 || strcmp(name, "/dev_flash2") == 0)
		return FLASH_PARTITION(3);
	
	if (strcmp(name, "CELL_FS_IOS:BUILTIN_FLSH3") == 0 || strcmp(name, "/dev_flash3") == 0)
		return FLASH_PARTITION(4);
	
	if (strcmp(name, "CELL_FS_IOS:BUILTIN_FLSH4") == 0 || strcmp(name, "/dev_flash4") == 0)
		return FLASH_PARTITION(5);
	
	if (strcmp(name, "CELL_FS_UTILITY:HDD0") == 0 || strcmp(name, "/dev_hdd0") == 0)
		return HDD_PARTITION(1);
	
	if (strcmp(name, "CELL_FS_UTILITY:HDD1") == 0 || strcmp(name, "/dev_hdd1") == 0)
		return HDD_PARTITION(2);
	
	if (strcmp(name, "CELL_FS_UTILITY:HDD2") == 0 || strcmp(name, "/dev_hdd2") == 0)
		return HDD_PARTITION(3);
	
	if (strcmp(name, "CELL_FS_UTILITY:HDD") == 0)
		return ATA_HDD;	
	
	
	//print_load("Error : Failed to find device_id of %s", name);
	
	return FAILED;
}

u8 is_ExtDevice(char *mount_name)
{
	if( strncmp(mount_name, "/dev_usb", 8) == 0) return YES;
	if( strcmp(mount_name, "/dev_sd") == 0) return YES;
	if( strcmp(mount_name, "/dev_cf") == 0) return YES;
	if( strcmp(mount_name, "/dev_ms") == 0) return YES;
	
	return NO;
}

u64 GetFreeSpace(char *path)
{	
	char temp[64];
	int n = 1; 
	while(path[n] != '/' && path[n] != 0) n++;
    memcpy(temp, path, n);
    temp[n] = '/';
    temp[n + 1]=0;

	u64 freeSize = 0;
	u32 blockSize;
	if(is_ntfs(temp)) {
		struct statvfs vfs;
        ps3ntfs_statvfs(path, &vfs);
        freeSize = (((u64)vfs.f_bsize * vfs.f_bfree));
    } else
	if(is_exFAT(temp)) {
		u64 tot;
		exFAT_get_size(temp, &freeSize, &tot);
	} else {
        sysFsGetFreeSize(temp, &blockSize, &freeSize);
        freeSize = (((u64)blockSize * freeSize));
    }
	
	return freeSize;
}

void GetDeviceInfo(char *mount_point, DeviceInfo_t *DeviceInfo)
{
	char temp[64];
	
	int n = 1; 
	while(mount_point[n] != '/' && mount_point[n] != 0) n++;
    memcpy(temp, mount_point, n);
    temp[n] = '/';
    temp[n + 1]=0;
	
	u64 freeSize = 0;
	u32 blockSize;
	
	memset(DeviceInfo, 0, sizeof(DeviceInfo_t));
	
	if(is_ntfs(temp))
	{
		struct statvfs vfs;
        ps3ntfs_statvfs(temp, &vfs);
        DeviceInfo->FreeSpace = (((u64)vfs.f_bsize * vfs.f_bfree));
		DeviceInfo->TotalSpace = (((u64)vfs.f_bsize * vfs.f_blocks));
		temp[n]=0;
		
		strcpy(DeviceInfo->Label, ntfsGetVolumeName(temp));
		strcpy(DeviceInfo->FileSystem, "CELL_FS_NTFS");
		strcpy(DeviceInfo->MountPoint, temp);
		sprintf(DeviceInfo->Name, "CELL_FS_IOS:USB_MASS_STORAGE%03d", NTFS_Test_Device(&temp[1]));
		
		// interface.feature
		DeviceInfo->ReadOnly = NO;
		
    } else 
	if(is_exFAT(temp)) {
		
		strcpy(DeviceInfo->FileSystem, "CELL_FS_EXFAT");
		exFAT_get_size(temp, &DeviceInfo->FreeSpace, &DeviceInfo->TotalSpace);
		exFAT_get_label(temp, DeviceInfo->Label);
		strcpy(DeviceInfo->MountPoint, temp);
		
		int idx = exFAT_get_idx(temp);
		if(0 <= idx && idx < 128) {
			sprintf(DeviceInfo->Name, "CELL_FS_IOS:USB_MASS_STORAGE%03d", idx);
		} else {
			if(idx==128) strcpy(DeviceInfo->Name, "CELL_FS_IOS:MEMORY_STICK\0"); else
			if(idx==129) strcpy(DeviceInfo->Name, "CELL_FS_IOS:COMPACT_FLASH\0"); else
			if(idx==130) strcpy(DeviceInfo->Name, "CELL_FS_IOS:SD_CARD\0");			
		}
		DeviceInfo->ReadOnly = NO;
		
	} else {
		
		sysFsGetFreeSize(temp, &blockSize, &freeSize);
		DeviceInfo->FreeSpace = (((u64)blockSize * freeSize));
		temp[n]=0;
		
		strcpy(DeviceInfo->MountPoint, temp);
		
#ifdef RPCS3
		if(strcmp(temp, "/app_home")==0 || strcmp(temp, "/dev_flash")==0) {DeviceInfo->ReadOnly = YES; return;}
		
		DeviceInfo->TotalSpace = Go(500);
		strcpy(DeviceInfo->Label, "Device");
		strcpy(DeviceInfo->FileSystem, "CELL_FS_FAKE");
		strcpy(DeviceInfo->Name, "CELL_FS_FAKE:RPCS3");
		
		DeviceInfo->ReadOnly = NO;
#else		
		sys_fs_mount_info mount_info;
		if( get_mount_info(temp, &mount_info) == SUCCESS) {
			
			DeviceInfo->ReadOnly = mount_info.ReadOnly;
			strcpy(DeviceInfo->FileSystem, mount_info.filesystem);
			strcpy(DeviceInfo->Name, mount_info.deviceName);
			
			//DeviceInfo->ReadOnly is used to display lock icon.
			//if it's not accessible, it's locked.
			//if it's not writable, it's locked.
			if(strcmp(temp, "/host_root")==0 || strcmp(temp, "/app_home")==0) {
				if( DeviceInfo->ReadOnly==NO ) {
					DIR *d = opendir(temp);
					if(d==NULL) {
						DeviceInfo->ReadOnly = YES;
					} else {
						closedir(d);
					}
				}
			}
			
			u64 device_id = get_device(mount_info.deviceName);
			if(device_id != FAILED) {
			
				device_info_t device_info;
				memset(&device_info, 0, sizeof(device_info));
				sys_storage_get_device_info(device_id, &device_info);
				
				memset(DeviceInfo->Label, 0, 32);
				
				if(is_ExtDevice(mount_info.mount_point)) {
					
					mbr_t mbr;
					if( DeviceDumpMBRInfo(device_id, device_info.sector_size, &mbr) == SUCCESS) {
						
						//get 1st FAT32 partition, the other FAT32 aren't mounted...
						u32 first_sector=0;
						u32 total_sector=0;
						int i;
						for(i=0; i<4; i++) {
							if(mbr.mbr_table_entry[i].partition_type == 0xB) { // FAT32
								first_sector = ES(mbr.mbr_table_entry[i].first_sector);
								total_sector = ES(mbr.mbr_table_entry[i].total_sector);
								break;
							}
						}
						if(total_sector != 0) {
							DeviceInfo->TotalSpace = (u64) total_sector * (u64) device_info.sector_size;							
							//DeviceInfo->TotalSpace = (u64) total_sector * (u64) 512ULL;
							
							FAT32_boot_sector_t boot_sector;
							if( DeviceDumpBootSector(device_id, device_info.sector_size, first_sector, &boot_sector) == SUCCESS) {
								
								u32 entry_sector = ES(boot_sector.bios_parameter.sector_per_FAT) * boot_sector.bios_parameter.number_of_FAT 
													+ ES(boot_sector.bios_parameter.reserved_sector) 
													+ ES(boot_sector.bios_parameter.hidden_sectors);
								
								char *Label = GetVolumeLabel(device_id, ES(boot_sector.bios_parameter.byte_per_sec), entry_sector);
								if( Label != NULL) {
									strncpy( DeviceInfo->Label, Label, 0xB);
									FREE(Label);
								} else {
									strncpy( DeviceInfo->Label, boot_sector.extended_bios_parameter.volume_label, 0xB);
									if(strncmp(DeviceInfo->Label, "NO NAME    ", 0xB) == 0) {
										memset(DeviceInfo->Label, 0, 32);
									}
								}
								
								if( DeviceInfo->Label[0] != 0 ) {
									for(i=0xA; i>0; i--) {
										if( DeviceInfo->Label[i] != ' ') break;
										DeviceInfo->Label[i] = 0;
									}
								}
							}						
						} else {
							DeviceInfo->TotalSpace = (u64) device_info.sector_count * (u64) device_info.sector_size;
						}
					}
					
				} else {
					DeviceInfo->TotalSpace = (u64) device_info.sector_count * (u64) device_info.sector_size;
				}
			}
		}
#endif
	}
}

u8 fake_insert_event(u64 deviceId, u64 deviceType)
{
	u64 param = (u64)(deviceType) << 32ULL;
	sys_storage_ext_fake_storage_event(7, 0, deviceId);
	int ret = sys_storage_ext_fake_storage_event(3, param, deviceId);
	
	if(ret == 0) return SUCCESS;
	return FAILED;
}

u8 fake_eject_event(u64 deviceId)
{
	sys_storage_ext_fake_storage_event(4, 0, deviceId);
	int ret = sys_storage_ext_fake_storage_event(8, 0, deviceId);
	
	if(ret == 0) return SUCCESS;
	return FAILED;
}

int eject_insert(u8 eject, u8 insert)
{
	u8 atapi_cmnd2[56];
	u8 *atapi_cmnd = atapi_cmnd2;
	int dev_id;

	if( sys_storage_open(BDVD_DRIVE, &dev_id) != 0) {
		print_load("Blu-Ray drive not detected...");
		return FAILED;
	}
	
	if(eject)
	{
		memset(atapi_cmnd, 0, sizeof(atapi_cmnd2));
		atapi_cmnd[0x00] = 0x1b; // OPERATION CODE (1Bh)
		atapi_cmnd[0x01] = 0x01; // IMMED (Immediate) bit
		atapi_cmnd[0x04] = 0x02; // LOEJ (2) + START (0) = Eject Disc
		atapi_cmnd[0x23] = 0x0c;

		//Eject disc
		device_command(dev_id, atapi_cmnd, 56);
		
		if(insert) sleep(2);
	}

	if(insert)
	{
		memset(atapi_cmnd, 0, sizeof(atapi_cmnd2));
		atapi_cmnd[0x00] = 0x1b; // OPERATION CODE (1Bh)
		atapi_cmnd[0x01] = 0x01; // IMMED (Immediate) bit
		atapi_cmnd[0x04] = 0x03; // LOEJ (2) + START (1) = Load Disc
		atapi_cmnd[0x23] = 0x0c;

		//Eject disc
		device_command(dev_id, atapi_cmnd, 56);
	}
	
	sys_storage_close(dev_id);
	
	return SUCCESS;
}

u8 bdvd_eject(u8 fake)
{
	if( fake ) return fake_eject_event(BDVD_DRIVE);
	return eject_insert(1, 0);
}

u8 bdvd_insert(u8 fake)
{
	if( fake ) return fake_insert_event(BDVD_DRIVE, DEVICE_TYPE_PS3_BD);
	return eject_insert(0, 1);
}

//*************
// device TEST
//*************

void DumpDevicesInfo()
{
	int ret = -1;
	uint64_t i, size;
	sys_fs_mount_info *info;
	
	ret = sys_fs_get_mount_info_size(&size);
	if (ret != 0) {
		print_load("Error : sys_fs_get_mount_info_size FAILED ! %X", ret);
		return;
	}
	
	info = malloc(size*sizeof(sys_fs_mount_info));
	memset(info, 0, size*sizeof(sys_fs_mount_info));
	ret = sys_fs_get_mount_info(info, size, &size);
	if (ret != 0)
	{
		//print_load("Error : sys_fs_get_mount_info FAILED ! %X", ret);
		free(info);
		return;
	}	
	for (i = 0; i < size; i++)
	{
		char temp[64];
		if(strcmp(info[i].mount_point, "/")==0) strcpy(temp, "/dev_hdd0/tmp/mount_info_root.bin");
		else sprintf(temp, "/dev_hdd0/tmp/mount_info_%s.bin", &info[i].mount_point[1]);
		
		FILE *f;
		f = fopen(temp, "wb");
		if(f!=NULL) {
			fwrite(&info[i], 1, sizeof(info[i]), f);
			fclose(f);
		}
		
		u64 device_id = get_device(info[i].deviceName);
		if(device_id != FAILED) {
			device_info_t device_info;
			memset(&device_info, 0, sizeof(device_info));
			sys_storage_get_device_info(device_id, &device_info);
			
			if(strcmp(info[i].mount_point, "/")==0) strcpy(temp, "/dev_hdd0/tmp/device_info_root.bin");
			else sprintf(temp, "/dev_hdd0/tmp/device_info_%s.bin", &info[i].mount_point[1]);
			
			f = fopen(temp, "wb");
			if(f!=NULL) {
				fwrite(&device_info, 1, sizeof(device_info), f);
				fclose(f);
			}
		}
	}
	free(info);
}

void DumpDevicesData()
{
	print_head("DumpDevicesData");
	
	int ret=-1;
	
	u64 i, size;
	sys_fs_mount_info *info;
		
	print_load("sys_fs_get_mount_info_size");
	
	ret = sys_fs_get_mount_info_size(&size);
	if (ret != 0) {
		print_load("Error : sys_fs_get_mount_info_size FAILED ! %X", ret);
		return;
	}
	
	print_load("malloc");
	
	info = malloc(size*sizeof(sys_fs_mount_info));
	memset(info, 0, size*sizeof(sys_fs_mount_info));
	
	print_load("sys_fs_get_mount_info");
	
	ret = sys_fs_get_mount_info(info, size, &size);
	if (ret != 0)
	{
		print_load("Error : DumpDevicesData sys_fs_get_mount_info FAILED ! %X", ret);
		free(info);
		return;
	}
	
	print_load("loop");
	for (i = 0; i < size; i++)
	{
		print_load("get device : %s", info[i].deviceName);
		
		u64 device_id = get_device(info[i].deviceName);
		if(device_id == FAILED) {
			//print_load("Error : DumpDevicesData get_device %s = FAILED !", info[i].deviceName);
			continue;
		}
		
		
		print_load("sys_storage_get_device_info %s : %016llX",info[i].deviceName, device_id);
		
		device_info_t device_info;
		memset(&device_info, 0, sizeof(device_info));
		ret = sys_storage_get_device_info(device_id, &device_info);
		if( ret != 0 ) {
			print_load("Error : DumpDevicesData sys_storage_get_device_info FAILED ! %X", ret);
			continue;
		}
		print_load("return %d", ret);
		
		continue;
		
		int source;
		u32 read;
	
		print_load("sys_storage_open");
		
		ret = sys_storage_open(device_id, &source );
		if( ret != 0 ) {
			//print_load("Error : DumpDevicesData sys_storage_open FAILED ! %X", ret);
			continue;
		}
		
		print_load("malloc sector");
		
		u8 *sector = (u8 *) malloc(device_info.sector_size+1);
		if(sector==NULL) {
			print_load("Error : DumpDevicesData malloc FAILED ! %X", ret);
			continue;
		}
		
		char temp[128];
		if(strcmp(info[i].mount_point, "/")==0) strcpy(temp, "/dev_hdd0/tmp/rawdata_root.bin");
		else sprintf(temp, "/dev_hdd0/tmp/rawdata_%s.bin", &info[i].mount_point[1]);	
		
		
		print_load("fopen %s", temp);
		
		FILE *f;
		f = fopen(temp, "wb");
		if(f==NULL) {
			free(sector);
			print_load("Error : DumpDevicesData fopen FAILED ! %s", temp);
			continue;
		}
		
		u64 flag = 0;
		u64 count = device_info.sector_count;
		
		if(0x100000 < count) count=0x100000; else
		if(0x10000 < count) count=0x10000; else 
		if(0x1000 < count) count=0x100; else
		if(0x100 < count) count=0x100; else 
		if(0x10 < count) count=0x10; else
		count=1;
		
		print_load("count");
		
		if(strncmp(info[i].mount_point, "/dev_flash", 10) ==0) flag = 0x22;
		
		print_load("loop2");
		int j;
		for(j=0; j<count; j++) {
			memset(sector, 0, device_info.sector_size);
			sys_storage_read(source, j, 1, sector, &read, flag);
			fwrite(sector, device_info.sector_size, 1, f);
		}
		print_load("fclose");
		fclose(f);
		sys_storage_close(source);		
		free(sector);
	}
	
	free(info);
}


// ****************************
// HDD0 UNLOCK RESERVED SPACE
// ****************************
#define UFS2_MAGIC	0x19540119ULL

static uint64_t get_ufs_sb_addr(void)
{
	u64 LV2_START = 0x8000000000600000ULL;
	u64 LV2_END = 0x8000000000500000ULL;
	
	u64 addr = (u64) (LV2_START - 0xA8ULL);

// fast
	while(addr > LV2_END) {
		if(lv2peek(addr) == UFS2_MAGIC)
			return (uint64_t)(addr - 0x558ULL);
		addr -= 0x800ULL;
	}
	
	LV2_START = 0x8000000000800000ULL;
	LV2_END   = 0x8000000000000000ULL;
	addr = (u64) (LV2_START - 0xA8ULL);
	
// slow
	while(addr > LV2_END) {
		if(lv2peek(addr) == UFS2_MAGIC)
			return (uint64_t)(addr - 0x558ULL);
		addr -= 0x100ULL;
	}
	
	return 0ULL;
}

u8 hdd0_is_unlocked()
{
	if( lv2peek32(UFS_SB_ADDR + 0x3C) == 1) return YES;
	
	return NO;
}

void hdd0_unlock(u8 state)
{
	if( state ) {
		lv2poke32(UFS_SB_ADDR + 0x3C, 1);
  		lv2poke32(UFS_SB_ADDR + 0x80, 1);
	} else {
		lv2poke32(UFS_SB_ADDR + 0x3C, 8);
  		lv2poke32(UFS_SB_ADDR + 0x80, 0);
	}
	sys_fs_unmount("/dev_hdd0");
	sys_fs_mount("CELL_FS_UTILITY:HDD0", "CELL_FS_UFS", "/dev_hdd0", 0);
	usleep(1000);
}

// ****************************
// HDD0 UNLOCK RESERVED SPACE
// ****************************

u32 u8_to_u32(u8* arr)
{
	return (0x1000000*arr[0] + 0x10000*arr[1] + 0x100*arr[2] + arr[3]);
}

void reset_iv(unsigned char* iv, unsigned int j)
{
  memset(iv, 0, 12);

  iv[12] = (j & 0xFF000000)>>24;
  iv[13] = (j & 0x00FF0000)>>16;
  iv[14] = (j & 0x0000FF00)>> 8;
  iv[15] = (j & 0x000000FF)>> 0;
}

FILE *openPUP(char *path, u64 *offset, char *mode)
{
	FILE *pup=NULL;
	
	char *ext = get_ext(path);
	
	if( strcmp(ext, _ISO_PS3) && strcmp(ext, _JB_PS3) && strcmp(ext, _BDVD) && strcasecmp(ext, ".pup")) return NULL;
	
	if(!strcasecmp(ext, ".pup")) {
		pup = fopen(path, mode);
		if(pup==NULL) {
			SetPerms(path);
			pup = fopen(path, mode);
			if(pup==NULL) return NULL;
		}
		*offset=0;
		return pup;
	} else
	if(!strcmp(ext, _ISO_PS3)) {
		pup = fopen(path, mode);
		if(pup==NULL) {
			SetPerms(path);
			pup = fopen(path, mode);
			if(pup==NULL) return NULL;
		}
		
		u64 file_offset=0;
		u8 ret=0;
		int file_size=0;
		ret = get_FileOffset(pup, "/PS3_UPDATE/PS3UPDAT.PUP",  &file_offset,  (u32 *) &file_size);
		if(file_offset==0 || file_size==0 || ret == FAILED) {fclose(pup); return NULL;}
		
		if( is_splitted_iso(path)) {
			FCLOSE(pup);
			
			
			char iso_path[255];
			char temp[255];
			int i;
			
			strcpy(iso_path, path);
			
			int l= strlen(iso_path);
			iso_path[l-1]=0;

			for(i=0; i<100; i++) {
				sprintf(temp , "%s%d" , iso_path, i);
				u64 fsize = get_size(temp);		
				if( fsize == 0) return NULL;
				
				if( fsize < file_offset ) file_offset -= fsize;
				else break;
			}
			
			pup = fopen(temp, mode);
			if(pup==NULL) {
				SetPerms(temp);
				pup = fopen(temp, mode);
				if(pup==NULL) return NULL;
			}
		}
		
		*offset=file_offset;
		
		return pup;	
	} else
	if(!strcmp(ext, _JB_PS3) || !strcmp(ext, _BDVD)) {
		char PUP_path[255];
		sprintf(PUP_path, "%s/PS3_UPDATE/PS3UPDAT.PUP", path);
		
		pup = fopen(PUP_path, mode);
		if(pup==NULL) {
			SetPerms(PUP_path);
			pup = fopen(PUP_path, mode);
			if(pup==NULL) return NULL;
		}
		
		*offset=0;
		return pup;
	}
	return NULL;
}

u8 Get_PUPVersion(char *source, char *UpdateVersion)
{
	strcpy(UpdateVersion, "0000");
	u64 pup_offset=0;
	u16 offset;
	if( strncmp(source, "/dev_bdvd", 9) == 0) {
		// remove remap of webMAN MOD
		sys_map_path("/dev_bdvd/PS3_UPDATE", NULL);
	}
	FILE *f = openPUP(source, &pup_offset, "rb");
	if(f==NULL) return FAILED;
	fseek(f, pup_offset+0x3E, SEEK_SET);
	fread(&offset, sizeof(u16), 1, f);
	fseek(f, pup_offset+offset, SEEK_SET);
	fread(UpdateVersion, sizeof(char), 4, f);
	fclose(f);
	return SUCCESS;
}

ird_t *IRD_new(char *source)
{
	int ret=FAILED;
	
	print_debug("IRD_new init");
	ird_t *ird=MALLOC_IRD();
	if(ird==NULL) return NULL;
	
	strcpy(ird->MAGIC, MAGIC_IRD);
	ird->Version = 9;
	ird->UniqueIdentifier = 0;
	ird->ExtraConfig = 0;
	ird->Attachments = 0;
	
	char value[255] = {0};
	
	print_debug("IRD_new TITLE");
	memset(value, 0, 255);
	ret = GetParamSFO("TITLE", value, source);
	if(ret==FAILED) {
		print_load("Error : ird_new failed to get TITLE");
		goto error;
	}
	ird->GameName_length = (u8) strlen(value);	
	ird->GameName = (char *) malloc(ird->GameName_length + 1);
	memset(ird->GameName, 0, ird->GameName_length + 1);
	memcpy(ird->GameName, value, ird->GameName_length);
	

	print_debug("IRD_new TITLE_ID");
	memset(value, 0, 255);
	memset(ird->GameId, 0, 10);
	ret = GetParamSFO("TITLE_ID", value, source);
	if(ret==FAILED) {
		print_load("Error : ird_new failed to get TITLE_ID");
		goto error;
	}
	memcpy(ird->GameId, value, 9);
	
	print_debug("IRD_new VERSION");
	
	memset(ird->GameVersion, 0, 6);
	memset(value, 0, 255);
	ret = GetParamSFO("VERSION", value, source);
	if(ret==FAILED) print_load("Error : ird_new failed to get VERSION");
	else memcpy(ird->GameVersion, value, 5);

	print_debug("IRD_new APP_VER");
	memset(ird->AppVersion, 0, 6);
	memset(value, 0, 255);
	ret = GetParamSFO("APP_VER", value, source);
	if(ret==FAILED) print_load("ird_new failed to get APP_VER");
	else memcpy(ird->AppVersion, value, 5);
	
	
	
	print_debug("IRD_new PUP_VER");
	memset(ird->UpdateVersion, 0, 5);
	ret = Get_PUPVersion(source, ird->UpdateVersion);
	if(ret==FAILED) {
		print_load("Can't get PUP_VERSION, looking for PS3_SYSTEM_VERS");
		memset(value, 0, 255);
		ret = GetParamSFO("PS3_SYSTEM_VER", value, source);
		if(ret==FAILED) {
			print_load("failed to get SYSTEM_VERS");
			strcpy(ird->UpdateVersion, "0000\0");
		} else {
			memcpy(ird->UpdateVersion, &value[1], 4);
		}
	}
	
	ret = SUCCESS;
error:
	
	if(ret==FAILED)	FREE_IRD(ird);
	
	return ird;
}

/*	
The goal of IRD_meta_sig is to get a 'fast and trustable' way to get unique signature of an ird/backup.
I wanted to be able to calculate this signature from IRD, ISO and JB.
I decided to use several value from the param.sfo which are also used in the ird.
IRD_meta_sig is the CRC2 of these values :
-TITLE_ID
-PS3_SYSTEM_VER
-VERSION
-APP_VER

I didn't include the TITLE because sometimes it's modified by the user.
The value PS3_SYSTEM_VER from param.sfo is used if PS3UPDAT.PUP doesn't exist.
Otherwise, it will get the version from the PUP like it's done by 3k3y tools.

IRD_files_sig is used when mgz check md5 of file,
It won't download 2 ird with the same IRD_meta_sig+IRD_file_sig
IRD_file_sig is the CRC of 
-FileSector+FileMD5

IRD_extra_sig is be used when mgz check an iso only.
IRD_extra_sig is the CRC of
-Header (decompressed)
-Footer (decompressed)

IRD_keys_sig is never used by mgz, it's just to be sure it have an unique file name per ird.
IRD_keys_sig is the CRC of
-Data1
-PIC

Data2 is a per-disc key (disc_id), even if the last 4 bytes are patched, I'd rather to not use this data.

IRD files are named with the following pattern [IRD_META_SIG]_[IRD_FILES_SIG]_[IRD_EXTRA_SIG]_[IRD_KEYS_SIG].ird

This unique file name allows me to manage the uploads/download in/from the server without too much duplicates.
*/

u32 IRD_keys_sig(ird_t *ird)
{
	u32 crc = crc32(0L, Z_NULL, 0);
	crc = crc32(crc,  (const unsigned char*) ird->Data1 , 0x10);
	crc = crc32(crc,  (const unsigned char*) ird->PIC   , 0x73);
	return crc;
}

u32 IRD_extra_sig(ird_t *ird)
{
	char TempDir[512];
	char header_path[512];
	char footer_path[512];
	
	sprintf(TempDir, "/dev_hdd0/game/%s/USRDIR/sys/temp", ManaGunZ_id);
	mkdir(TempDir, 0777);
	
	sprintf(header_path, "%s/%s.header.bin", TempDir, ird->GameId);
	Delete(header_path);
	sprintf(footer_path, "%s/%s.footer.bin", TempDir, ird->GameId);
	Delete(footer_path);
	
	u32 crc = crc32(0L, Z_NULL, 0);
	
	print_debug("Decompress header");
	int ret = GZ_decompress7((char *) ird->Header, ird->HeaderLength, header_path);
	if( ret != Z_OK) {
		print_load("Error : IRD_extra_sig failed to extract (%d) : %s", ret, header_path);
		goto error;
	}
	
	print_debug("Decompress footer");
	ret = GZ_decompress7((char *) ird->Footer, ird->FooterLength, footer_path);
	if( ret != Z_OK) {
		print_load("Error : IRD_extra_sig failed to extract (%d) : %s", ret, footer_path);
		goto error;
	}
		
	crc = crc_file2(header_path, crc);
	if( crc == 0 ) {
		print_load("Error : IRD_extra_sig failed to get crc of %s", ret, header_path);
		goto error;
	}
	
	crc = crc_file2(footer_path, crc);
	if( crc == 0 ) {
		print_load("Error : IRD_extra_sig failed to get crc of %s", ret, footer_path);
		goto error;
	}
	
error :
	Delete(header_path);
	Delete(footer_path);
	
	return crc;
}

u32 IRD_files_sig(ird_t *ird)
{
	u32 crc = crc32(0L, Z_NULL, 0);
	int i;
	for(i=0; i<ird->FileHashesNumber; i++) {
		crc = crc32(crc,  (const unsigned char*) &ird->FileHashes[i].Sector , 0x8);
		crc = crc32(crc,  (const unsigned char*) ird->FileHashes[i].FileHash , 0x10);
	}
	
	return crc;
}

u32 IRD_meta_sig2(char *TITLE_ID, char *PS3_SYSTEM_VER, char *GAME_VERSION, char *APP_VER)
{
	u32 crc = crc32(0L, Z_NULL, 0);
	
	crc = crc32(crc,  (const unsigned char*) TITLE_ID                , 9);
	crc = crc32(crc,  (const unsigned char*) PS3_SYSTEM_VER          , 4);
	crc = crc32(crc,  (const unsigned char*) GAME_VERSION            , 5);
	crc = crc32(crc,  (const unsigned char*) APP_VER                 , 5);
	
	return crc;
}

u32 IRD_meta_sig3(ird_t *ird)
{
	return IRD_meta_sig2(ird->GameId, ird->UpdateVersion, ird->GameVersion, ird->AppVersion);
}

u32 IRD_meta_sig(char *source)
{
	u32 crc = crc32(0L, Z_NULL, 0);
	
	char *mem=NULL;
	ird_t *ird=NULL;
	
	char *ext = get_ext(source);
	
	if( strcmp(ext, _ISO_PS3) && strcmp(ext, _JB_PS3) && strcmp(ext, _BDVD) && strcasecmp(ext, ".ird")) return 0;
	
	if( !strcasecmp(ext, ".ird") ) {
		int ret = GZ_decompress8(source, &mem, 1024);
		if(  ret != Z_OK) {
			print_load("Error : GZ_decompress6 error %d", ret);
			goto error;
		}
		
		u8 GameName_length=0;
		memcpy(&GameName_length, mem + 4 + 1 + 9, 1);
		
		crc = crc32(crc,  (const unsigned char*) mem + 4 + 1                          , 9);
		crc = crc32(crc,  (const unsigned char*) mem + 4 + 1 + 9 + 1 + GameName_length, 4 + 5 + 5);
	} else {
		ird = IRD_new(source);
		
		crc = IRD_meta_sig3(ird);
	}
	
error:
	
	FREE(ird);
	FREE(mem);
	
	return crc;
}

char *IRD_sig2(ird_t *ird)
{	
	u32 meta_sig = IRD_meta_sig3(ird);
	u32 files_sig = IRD_files_sig(ird);
	u32 extra_sig = IRD_extra_sig(ird);
	u32 keys_sig = IRD_keys_sig(ird);
	
	if( !meta_sig || !files_sig || !extra_sig || !keys_sig) {
		print_load("Error : failed to get IRD signatures");
		return NULL;
	}
	
	return sprintf_malloc("%08X_%08X_%08X_%08X\0", meta_sig, files_sig, extra_sig, keys_sig);
}

char *IRD_sig(char *ird_path)
{
	print_debug("IRD_load");
	ird_t *ird = IRD_load(ird_path);
	if(ird==NULL) return NULL;
	
	print_debug("IRD_sig2");
	char *sig = IRD_sig2(ird);
	
	print_load("IRD_sig %s", sig);
	
	print_debug("FREE_IRD");
	FREE_IRD(ird);
	
	return sig;
}

#define MAX_UPLOAD_TRY 10
u8 IRD_DB_upload(char *IRD_PATH, char *IRD_SIG)
{
	char URL[128]={0};
	sprintf(URL, IRD_SCRIPT "?ird=%s&mgz=%05.2f", IRD_SIG, Get_MgzVersion());
	
	print_head("Uploading...");
	int try = 0;
retry:
	try++;
	
	int ret = upload(URL, IRD_PATH, HTTP_METHOD_POST);
	if( ret == 200) {
		print_load("Success");
		return SUCCESS;
	}
	
	if(ret == 409 && try <= MAX_UPLOAD_TRY) {
		print_load("Failed to upload, retry... %d/%d", try, MAX_UPLOAD_TRY);
		goto retry;
	}
	
	print_load("Failed to upload...");
	
	return FAILED; 
}

u8 IRD_DB_exist(char *IRD_SIG)
{
	// sanity
	int l = strlen(IRD_SIG);
	if( l != 35 ) {
		print_load("Error : strlen(IRD_SIG) = %d != 35", l);
		return YES;
	}
	if(IRD_SIG[8]!='_' || IRD_SIG[17]!='_' || IRD_SIG[26]!='_') {
		print_load("Error : error sanity");
		return YES;
	}
	
	char URL[128]={0};
	sprintf(URL, IRD_SCRIPT "?ird=%s", IRD_SIG);	
	
	print_debug("http_exist");
	
	int httpCode = http_response(URL);
	
	if(httpCode == HTTP_STATUS_CODE_OK) { // 200
		return YES;
	}
	
	if(httpCode == HTTP_STATUS_CODE_Not_Found) { // 404
		return NO;
	}
	
	return NET_ERROR;	
}

u8 IRD_WS_upload(char *JSON_PATH)
{
	int ret = upload(IRD_WEB_API_NEW, JSON_PATH, HTTP_METHOD_POST);
	if( ret != 200) {
		print_load("Error : IRD_WS_upload %d", ret);
		return FAILED;
	}
	Delete(JSON_PATH);
	return SUCCESS;
}

u32 Get_Unique_PS3ID()
{
	if( dump_3Dump() == FAILED ) return 0;
	
	return crc_file("/dev_hdd0/tmp/3Dump.bin");
}

u8 IRD_WS_trust(char *MGZ_SIG)
{
	u32 Unique_PS3ID = Get_Unique_PS3ID();
	if( Unique_PS3ID == 0) return FAILED;
	
	char JSON_DATA[512];
	char JSON_PATH[512];
	
	if( UPLOADER[0] == 0) {
		sprintf(JSON_DATA, "{\"MgzSignature\":\"%s\",\"Contributor\":\"Anonymous\",\"UniquePS3Id\":\"%08X\"}", MGZ_SIG, Unique_PS3ID);
	} else {
		sprintf(JSON_DATA, "{\"MgzSignature\":\"%s\",\"Contributor\":\"%s\",\"UniquePS3Id\":\"%08X\"}", MGZ_SIG, UPLOADER, Unique_PS3ID);
	}
	sprintf(JSON_PATH, "/dev_hdd0/tmp/%s.json", MGZ_SIG);
	
	FILE *f = fopen(JSON_PATH, "wb");
	if(f==NULL) return FAILED;
	fputs(JSON_DATA, f);
	FCLOSE(f);
	
	int ret = upload(IRD_WEB_API_TRUST, JSON_PATH, HTTP_METHOD_POST);
	if( ret != 200) {
		print_load("Error : IRD_WS_trust %d", ret);
		return FAILED;
	}
	Delete(JSON_PATH);
	return SUCCESS;
}

// Zefie header https://github.com/zefie/getkey_gameos_zefie
#define EncryptedZefieISO			"Encrypted 3K RIP"

// cobra headers
// dump
#define EncryptedCobraISO			"Encr. COBRA ISO "
#define DecryptedCobraISO			"Decr. COBRA ISO "

// build
#define EncryptedCobraBuild			"Encr. COBRA IRD "
#define DecryptedCobraBuild			"Decr. COBRA IRD "

// 3k3y headers
// dump
#define Encrypted3KISO				"Encrypted 3K ISO"
#define Decrypted3KISO				"Decrypted 3K ISO"

// build
#define Encrypted3KBuild			"Encrypted 3K BLD"
#define Decrypted3KBuild			"Decrypted 3K BLD"
#define Encrypted3KHomebrew			"Encrypted 3K BLH"
#define Decrypted3KHomebrew			"Decrypted 3K BLH"
#define Encrypted3KFailedBuild		"Encrypted 3K BLF"
#define Decrypted3KFailedBuild		"Decrypted 3K BLF"

// manager
#define Encrypted3KManager			"Encrypted 3K MNU"
#define Decrypted3KManager			"Decrypted 3K MNU"

#define BDVD_BUFF_SEC_NB		0x400
#define BDVD_BUFFSIZE			0x800 * BDVD_BUFF_SEC_NB
#define MAX_SPLIT_SECTOR		0x1FFFFF // 4GB MAX (0xFFFFFFFF / 0x800)

// it's sys_storage_read with several attempt if it fail
u8 DUMPER_read(int source, u64 current_sector, u64 sector_nb, const void* buff, u32 *read, u8 *corrupt)
{
	int try;
	u8 old_corrupt = *corrupt;
	
	for(try=0; try<=DUMPER_MAX_TRY; try++) {
		memset((char *) buff, 0, BDVD_BUFFSIZE);
		if( sys_storage_read(source, current_sector, sector_nb, buff, read, 0) == 0) return SUCCESS;
		
		if(copy_cancel || cancel) return FAILED;
		
		print_load("Failed to read the block of sectors %X, size %X, try %d/%d", current_sector,  sector_nb, try+1, DUMPER_MAX_TRY); 
		
		if(try+1==DUMPER_MAX_TRY) {
			*corrupt=YES;
			if( !IGNORE_ERR ) return FAILED;
		}
	}
	
	*corrupt = old_corrupt;
	print_load("Warning : Now, it's trying to read sector per sector inside the corrupted area...");
	int n;
	for(n=0; n<sector_nb; n++) {
		for(try=0; try<=DUMPER_MAX_TRY; try++) {
			memset((char *) buff, 0, BDVD_BUFFSIZE);
			if( sys_storage_read(source, current_sector+n, 1, buff+n*0x800, read, 0) == 0) {
				print_load("Succeeded to read sector %X", current_sector+n);
				break;
			}
			
			if(copy_cancel || cancel) return FAILED;
			print_load("Failed to read sector %X try %d/%d", current_sector+n, try+1, DUMPER_MAX_TRY); 
			
			if(try+1==DUMPER_MAX_TRY) {
				*corrupt=YES;
				if( !IGNORE_ERR ) return FAILED;
			}
		}
	}
	
	return SUCCESS;
}

u8 dump_enc_bdvd(char *outdir, char *result_log)
{
	char ISO_PATH[512];
	char SPLIT_ISO_PATH[512]={0};
	char TITLE_ID[10];
	FILE *f=NULL;
	int source = 0;
	char *DATE = NULL;
	int ret = FAILED;
	u8 *buff=NULL;
	u8 split = NO;
	u32 N_SPLIT_ISO = 0; 
	u8 corrupt=NO;
	
	char result_str[512]={0};
	FILE *rlog=NULL;
	rlog =  fopen(result_log, "wb");
	if(rlog) {
		fputs("**** Result of the dump ****\n\n", rlog);
		fputs("Type : Encrypted Blu-Ray (RAW)", rlog);
		if( with_3k3y_header ) {
			fputs("with 3k3y header\n", rlog);
		} else {
			fputs("\n", rlog);
		}
	}
	
	DATE = get_date();
	if(DATE == NULL) {
		ret=FAILED;
		goto error;
	}
	
	if(rlog) {
		sprintf(result_str, "Started at %c%c:%c%c\n", DATE[9], DATE[10], DATE[11], DATE[12]); fputs(result_str, rlog);
	}
	
	print_debug("GetParamSFO");
	if( GetParamSFO("TITLE_ID", TITLE_ID, "/dev_bdvd") == FAILED) return FAILED;
	TITLE_ID[9]=0;
	
	if(rlog) {
		sprintf(result_str, "Title ID : %s\n", TITLE_ID); fputs(result_str, rlog);
	}
	
	print_debug("sys_storage_get_device_info");
	device_info_t device_info;
	memset(&device_info, 0, sizeof(device_info));
	ret = sys_storage_get_device_info(BDVD_DRIVE, &device_info);
	if( ret != 0 ) {
		print_load("Error : dump_enc_bdvd sys_storage_get_device_info FAILED ! %X", ret);
		ret = FAILED;
		goto error;
	}
	
	print_debug("sys_storage_open");
	ret = sys_storage_open(BDVD_DRIVE, &source);
	if( ret != 0) {
		print_load("Error : sys_storage_open");
		ret=FAILED;
		goto error;
	}
	
	print_debug("malloc");
	buff = (u8 *) malloc(BDVD_BUFFSIZE);
	if(buff==NULL) {
		print_load("Error : dump_enc_bdvd malloc FAILED !");
		ret=FAILED;
		goto error;
	}
	
	u64 count = device_info.sector_count;
	u32 read;
	u64 current_sector=0;
	u64 sector_nb = BDVD_BUFF_SEC_NB;
	
	if( MAX_SPLIT_SECTOR < count )  split = is_FAT32(outdir);
	
	if(split) {
		sprintf(ISO_PATH, "%s/%s_%s.enc.iso.%d%c", outdir, TITLE_ID, DATE, N_SPLIT_ISO, '\0');	
	} else {
		sprintf(ISO_PATH, "%s/%s_%s.enc.iso%c", outdir, TITLE_ID, DATE, '\0');
	}
	
	print_debug("mkdir");
	MGZ_mkdir_recursive(outdir);
	
	print_debug("fopen %s", ISO_PATH);
	f = fopen(ISO_PATH, "wb");
	if(f==NULL) {
		print_load("Error : dump_enc_bdvd fopen FAILED ! %s");
		ret=FAILED;
		goto error;
	}
	
	if(rlog) {
		sprintf(result_str, "Path : %s\n\n", ISO_PATH); fputs(result_str, rlog);
	}
	
	strcpy( copy_src, "/dev_bdvd");
	strcpy( copy_dst, ISO_PATH);

	gathering_nb_file = -1;
	gathering_nb_directory = -1;
	
	gathering_total_size = (u64) count * 0x800ULL;
	
	if( GetFreeSpace(ISO_PATH) < gathering_total_size ) {
		print_load("Error : Not enough space.");
		goto error;
	}
	
	ret = FAILED;
	while( current_sector < count ) {
		memset(buff, 0, BDVD_BUFFSIZE);
		
		if(count < current_sector + BDVD_BUFF_SEC_NB) sector_nb = count - current_sector;
		else sector_nb = BDVD_BUFF_SEC_NB;
		
		if( DUMPER_read(source, current_sector, sector_nb, buff, &read, &corrupt) == FAILED) {
			goto error;
		}

		if(current_sector==0 && with_3k3y_header) {
			u8 d1[0x10];
			u8 d2[0x20];
			u8 pic[0x73];
			
			if( get_keys(d1, d2, pic) == SUCCESS ) {
				memcpy((u8 *) buff+0xF70, Encrypted3KISO, 0x10);
				memcpy((u8 *) buff+0xF80, d1, 0x10);
				memcpy((u8 *) buff+0xF90, d2, 0x10);
				memcpy((u8 *) buff+0xFA0, pic, 0x73);
			}
		}
		
		if(copy_cancel || cancel) goto error;
		
		if( split ) {
			u32 split_current_sector = current_sector - N_SPLIT_ISO * MAX_SPLIT_SECTOR;
				
			if( split_current_sector + sector_nb <= MAX_SPLIT_SECTOR ) {
				fwrite(buff, sector_nb, 0x800, f);
			} else {
				u32 last_sectors = MAX_SPLIT_SECTOR - split_current_sector;
				fwrite(buff, last_sectors, 0x800, f);
				
				FCLOSE(f);
				
				if( SPLIT_ISO_PATH[0] != 0) SetPerms(SPLIT_ISO_PATH);
				memset(SPLIT_ISO_PATH, 0, 512);
				
				N_SPLIT_ISO++;
				
				sprintf(SPLIT_ISO_PATH, "%s/%s_%s.enc.iso.%d%c", outdir, TITLE_ID, DATE, N_SPLIT_ISO, '\0');	
				
				print_debug("fopen %s", SPLIT_ISO_PATH);
				f = fopen(SPLIT_ISO_PATH, "wb");
				if(f==NULL) {
					print_load("Error : SPLIT_ISO_PATH fopen %s", SPLIT_ISO_PATH);
					goto error;
				}
				
				u32 sectors_left = sector_nb - last_sectors;
				fwrite(buff, sectors_left, 0x800, f);
			}
		} else {
			fwrite(buff, sector_nb, 0x800, f);
		}
		
		current_sector += sector_nb;

		copy_current_size += (u64) sector_nb * 0x800ULL;	
		
		if(copy_cancel || cancel) goto error;
	}
	
	SetPerms(ISO_PATH);
	
	ret = SUCCESS;
error:

	if(ret==FAILED) {
		if( split ) {
			int i;
			for(i=0; i<N_SPLIT_ISO; i++) {
				sprintf(SPLIT_ISO_PATH, "%s/%s_%s.enc.iso.%d%c", outdir, TITLE_ID, DATE, i, '\0');
				Delete(SPLIT_ISO_PATH);
			}
		} else {
			Delete(ISO_PATH);
		}
	}
	
	FCLOSE(f);
	if(source != 0) sys_storage_close(source);
	FREE(buff);
	FREE(DATE);
	
	if(rlog) {
		if(ret==FAILED) {
			if( copy_cancel || cancel ) {
					fputs("RESULT: The user canceled.\n", rlog);
			} else {
				fputs("RESULT: Something went wrong: '", rlog);
				fputs(loading_log[0], rlog);
				fputs("'\n", rlog);
					
			}
		} else
		if(ret==SUCCESS) {
			if( corrupt && IGNORE_ERR ) {
				fputs("RESULT: The dump is probably corrupted.", rlog);
			} else {
				fputs("RESULT: Everything went well!", rlog);
			}
		}
		
		DATE = get_date();
		sprintf(result_str, "\nFinished at %c%c:%c%c\n", DATE[9], DATE[10], DATE[11], DATE[12]); fputs(result_str, rlog);
		FREE(DATE);
	}
	FCLOSE(rlog);
	
	return ret;
}

FILE *fopen_seek_split(char *ISO_PATH, u64 offset, int *N_SPLIT_ISO)
{
	FILE *f=NULL;
	
	u8 split = is_splitted_iso(ISO_PATH);
	u64 size = get_size(ISO_PATH);
	
	if( !split || offset < size ) {
		f = fopen(ISO_PATH, "rb");
		if(f==NULL) {
			print_load("Error: fseek_split failed to open %s", ISO_PATH);
			return NULL;
		}
		fseek(f, offset, SEEK_SET);
		*N_SPLIT_ISO=0;
		return f;
	} else {		
		int i;
		char SPLIT_ISO_PATH[512];
		int len = strlen(ISO_PATH);
		ISO_PATH[len-1]=0;
		for(i=0; i<32; i++)
		{
			memset(SPLIT_ISO_PATH, 0, 512);
			sprintf(SPLIT_ISO_PATH, "%s%d%c", ISO_PATH, i, '\0');
			u64 fsize = get_size(SPLIT_ISO_PATH);
			if( offset < size + fsize ) {
				f = fopen(SPLIT_ISO_PATH, "rb");
				if(f==NULL) {
					print_load("Error: fseek_split failed to open %s", SPLIT_ISO_PATH);
					return NULL;
				}
				fseek(f, offset-size, SEEK_SET);
				ISO_PATH[len-1]='0';
				*N_SPLIT_ISO = i;
				return f;
			}
			size += fsize;
		}
		ISO_PATH[len-1]='0';
	}
	
	return NULL;
}

u8 md5_from_offsets(char *ISO_PATH, u64 start_offset, u64 end_offset, u8 out[0x10])
{
	u8 ret = FAILED;
	memset(out, 0, 0x10);
	
	int N_SPLIT_ISO=0;
	FILE *f = fopen_seek_split(ISO_PATH, start_offset, &N_SPLIT_ISO);
	if(f == NULL) return FAILED;
	
	u8 split = is_splitted_iso(ISO_PATH);
	
	print_debug("malloc BDVD_BUFFSIZE");
	u8 *buff = (u8 *) malloc(BDVD_BUFFSIZE);
	if(buff==NULL) {
		print_load("Error : malloc BDVD_BUFFSIZE");
		goto error;
	}
	
	char SPLIT_ISO_PATH[512]={0};
	
	md5_context ctx;
	md5_starts( &ctx );
	
	u32 current_sector = start_offset/0x800;
	u32 region_last_sector = end_offset/0x800;
	while( current_sector < region_last_sector ) {
		memset(buff, 0, BDVD_BUFFSIZE);
		
		u32 sector_nb=0;
		if(region_last_sector < current_sector + BDVD_BUFF_SEC_NB) sector_nb = region_last_sector - current_sector;
		else sector_nb = BDVD_BUFF_SEC_NB;
		
		if(copy_cancel) goto error;
			
		if( split ) {
			u32 split_current_sector = current_sector - N_SPLIT_ISO * MAX_SPLIT_SECTOR;
				
			if( split_current_sector + sector_nb <= MAX_SPLIT_SECTOR ) {
				fread(buff, sector_nb, 0x800, f);
			} else {
				u32 last_sectors = MAX_SPLIT_SECTOR - split_current_sector;
				fread(buff, last_sectors, 0x800, f);
					
				FCLOSE(f);
				
				memset(SPLIT_ISO_PATH, 0, 512);
				
				N_SPLIT_ISO++;
				int len = strlen(ISO_PATH);
				ISO_PATH[len-1]=0;
				sprintf(SPLIT_ISO_PATH, "%s%d%c", ISO_PATH, N_SPLIT_ISO, '\0');	
				ISO_PATH[len-1]='0';
				
				print_debug("fopen %s", SPLIT_ISO_PATH);
				f = fopen(SPLIT_ISO_PATH, "rb");
				if(f==NULL) {
					print_load("Error : fopen %s", SPLIT_ISO_PATH);
					goto error;
				}
				
				u32 sectors_left = sector_nb - last_sectors;
				fread(buff, sectors_left, 0x800, f);
			}
		} else {
			fread(buff, sector_nb, 0x800, f);
		}
		
		md5_update(&ctx, buff, 0x800*sector_nb);
		
		current_sector += sector_nb;
		
		if(copy_cancel) goto error;
	}
	md5_finish(&ctx, out);

	ret=SUCCESS;
error:
	FREE(buff);
	FCLOSE(f);
	return ret;
}

u8 IRD_FixRegionMD5(char *ISO_PATH, ird_t *ird, u64 header_lenght, u64 footer_offset)
{
	if( IRD_GetRegionBoundaries(ISO_PATH, ird)== FAILED) {
		print_load("Error: failed to IRD_GetRegionBoundaries");
		return FAILED;
	}
	
	if( md5_from_offsets(ISO_PATH, header_lenght, (u64) (ird->RegionHashes[0].End+1)*0x800ULL, ird->RegionHashes[0].RegionHash) == FAILED) {
		print_load("Error: failed to md5_file_offsets (1st)");
		return FAILED;
	}
	
	if( md5_from_offsets(ISO_PATH, (u64) ird->RegionHashes[ird->RegionHashesNumber-1].Start*0x800ULL, footer_offset, ird->RegionHashes[ird->RegionHashesNumber-1].RegionHash) == FAILED) {
		print_load("Error: failed to md5_file_offsets (1st)");
		return FAILED;
	}
	
	return SUCCESS;
}

u8 Build_JSON(ird_t *ird, char *JSON_PATH, char *MGZ_SIG)
{
	char msg[512];
	
	FILE *json=fopen(JSON_PATH, "wb");
	if(json==NULL) {
		printf("Error : failed to open %s", JSON_PATH);
		return FAILED;
	}
	
	fputs("{\n", json);
	sprintf(msg, "\t\"MgzSignature\" : \"%s\",\n", MGZ_SIG);fputs(msg, json);
	sprintf(msg, "\t\"TitleID\" : \"%s\",\n", ird->GameId);fputs(msg, json);
	sprintf(msg, "\t\"GameName\" : \"%s\",\n", ird->GameName);fputs(msg, json);
	sprintf(msg, "\t\"GameVersion\" : \"%s\",\n", ird->GameVersion);fputs(msg, json);
	sprintf(msg, "\t\"AppVersion\" : \"%s\",\n", ird->AppVersion);fputs(msg, json);
	sprintf(msg, "\t\"UpdateVersion\" : \"%s\",\n", ird->UpdateVersion);fputs(msg, json);
	if( UPLOADER[0] == 0 )  {
		fputs("\t\"Contributor\" : \"Anonymous\",\n", json);
	} else {
		sprintf(msg, "\t\"Contributor\" : \"%s\",\n", UPLOADER);fputs(msg, json);
	}
	sprintf(msg, "\t\"UniquePS3Id\" : \"%08X\",\n", Get_Unique_PS3ID()); fputs(msg, json);
	sprintf(msg, "\t\"MgzVersion\" : \"%05.2f\"\n", Get_MgzVersion()); fputs(msg, json);
	fputs("}\n", json);
	
	FCLOSE(json);
	
	return SUCCESS;
}

u8 dump_dec_bdvd(char *outdir, char *result_log)
{
	print_head("Initialization...");
	u8 ret=FAILED;
	u8 *iv=NULL;
	FILE *f=NULL;
	int source=0;
	u32 read;
	u8 *buff=NULL;
	ird_t *ird=NULL;
	char ISO_PATH[512];
	char IRD_PATH[512];
	char SPLIT_ISO_PATH[512]={0};
	char *IRD_NAME = NULL;
	char *DATE=NULL;	
	u8 *sec0sec1=NULL;
	u8 corrupt=NO;
	u8 try;
	u32 i;
	u8 iso_done = NO;
	u8 split = NO;
	u32 N_SPLIT_ISO = 0;
	
	char result_str[512]={0};
	FILE *rlog=NULL;
	rlog =  fopen(result_log, "wb");
	if(rlog) {
		fputs("**** Result of the dump ****\n\n", rlog);
		fputs("Type : Decrypted Blu-Ray", rlog);
		if( with_3k3y_header ) {
			fputs("with 3k3y header\n", rlog);
		} else {
			fputs("\n", rlog);
		}
	}
	
	print_debug("Get current date");
	DATE = get_date();
	if( DATE == NULL) {
		print_load("Error : dump_bdvd, failed to get_date");
		goto error;
	}
	
	if(rlog) {
		sprintf(result_str, "Started at %c%c:%c%c\n", DATE[9], DATE[10], DATE[11], DATE[12]); fputs(result_str, rlog);
	}
	
	print_debug("IRD_new");
	ird = IRD_new("/dev_bdvd");
	if(ird==NULL) {
		print_load("Error : failed to IRD_new");
		goto error;
	}
	
	if(rlog) {
		sprintf(result_str, "Title ID : %s\n", ird->GameId); fputs(result_str, rlog);
	}

	print_debug("Get decryption key");
	if( get_keys(ird->Data1, ird->Data2, ird->PIC)==FAILED) {
		print_load("Error : failed to get_keys");
		goto error;
	}
	
	u8 key[0x10];
	memcpy(key, ird->Data1, 0x10);
	enc_d1(key);
	
	print_debug("Decryption key (d1) :");
	hex_print_load((char *) key, 16);

	print_debug("sys_storage_open BDVD_DRIVE");
	if(sys_storage_open(BDVD_DRIVE, &source) != 0) {
		print_load("Error : sys_storage_open");
		goto error;
	}

	print_debug("malloc BDVD_BUFFSIZE");
	buff = (u8 *) malloc(BDVD_BUFFSIZE);
	if(buff==NULL) {
		print_load("Error : malloc BDVD_BUFFSIZE");
		goto error;
	}
	
	print_debug("init aes");
	aes_context aes;
	if( aes_setkey_dec(&aes, key, 128 )!=0 ) {
		print_load(" Error : aes_setkey_dec ");
		goto error;
	}
	
	print_debug("malloc iv");
	iv = (u8 *) malloc(0x10);
	if( iv == NULL ) {
		print_load(" Error : malloc iv ");
		goto error;
	}
	
	print_debug("malloc sec0sec1");
	sec0sec1 = (u8 *) malloc( 0x800 * 2 );
	if( sec0sec1 == NULL ) {
		print_load(" Error : malloc sec0sec1 ");
		goto error;
	}
	
	print_debug("sys_storage_read sec0sec1");
	for(try=0; try<DUMPER_MAX_TRY; try++) {
		memset(sec0sec1, 0, 0x800*2);
		if( sys_storage_read(source, 0, 2, sec0sec1, &read, 0) == 0) break;
		
		if(copy_cancel || cancel) goto error;
		print_load("Failed to read sector 0 size 2, try %d/%d", try+1, DUMPER_MAX_TRY); 
		
		if(try+1==DUMPER_MAX_TRY) corrupt=YES;
	}
	
	u32 regions=(u8_to_u32(sec0sec1)*2)-1;
	u32 total_sectors=1+u8_to_u32(sec0sec1+12+((regions-1)*4));
	
	print_debug("Gathering data");	
	gathering_nb_file = -1;
	gathering_nb_directory = -1;
	gathering_total_size = (u64) total_sectors * 0x800ULL;
	
	if( MAX_SPLIT_SECTOR < total_sectors )  split = is_FAT32(outdir);
	
	sprintf(IRD_PATH, "%s/%s_%s.ird%c", outdir, ird->GameId, DATE, '\0');
	if(split) {
		sprintf(ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
	} else {
		sprintf(ISO_PATH, "%s/%s_%s.iso%c", outdir, ird->GameId, DATE, '\0');
	}
	
	if( GetFreeSpace(ISO_PATH) < gathering_total_size ) {
		print_load("Error : Not enough space.");
		goto error;
	}
	
	MGZ_mkdir_recursive(outdir);
	
	print_debug("fopen %s", ISO_PATH);
	f = fopen(ISO_PATH, "wb");
	if(f==NULL) {
		print_load("Error : fopen");
		goto error;
	}
	
	strcpy( copy_src, "/dev_bdvd");
	strcpy( copy_dst, ISO_PATH);
	
	u64 current_sector=0;
	u64 sector_nb;
	u8 plain = YES;
	
	print_debug("regions :  0x%X\n", regions);
	print_debug("total_sectors :  0x%X\n", total_sectors);
	print_debug("gathering_total_size :  0x%llX\n", gathering_total_size);
	
	ird->RegionHashesNumber=regions;
	ird->RegionHashes = (RegionHash_t *) malloc(ird->RegionHashesNumber * sizeof(RegionHash_t));
	if(ird->RegionHashes == NULL)  {
		print_load("Error : dump_dec Failed to malloc region hashes");
		goto error;
	}
	
	if(rlog) {
		sprintf(result_str, "Path : %s\n\n", ISO_PATH); fputs(result_str, rlog);
	}
	
	ret=FAILED;
	print_head("Dumping...");
	i=0;
	while(i<regions)
	{	
		u32 region_last_sector=u8_to_u32(sec0sec1+12+(i*4)) + 1;	
		
		print_debug("Region #%02d", i);
		
		if( plain == YES ) {
			print_debug("Copying offset 0x%llX to 0x%llX", 
						(unsigned long long int) current_sector*0x800, (unsigned long long int)  region_last_sector*0x800);
		} else {
			region_last_sector -= 1;
			print_debug("Decrypting offset 0x%llX to 0x%llX\n", 
						(unsigned long long int) current_sector*0x800, (unsigned long long int)  region_last_sector*0x800);
		}
		
		md5_context ctx;
		
		md5_starts( &ctx );
		
		while( current_sector < region_last_sector ) {
		
			memset(buff, 0, BDVD_BUFFSIZE);
			
			if(region_last_sector < current_sector + BDVD_BUFF_SEC_NB) sector_nb = region_last_sector - current_sector;
			else sector_nb = BDVD_BUFF_SEC_NB;
			
			if( DUMPER_read(source, current_sector, sector_nb, buff, &read, &corrupt) == FAILED) {
				goto error;
			}
			
			if(copy_cancel) goto error;
			
			md5_update(&ctx, buff, 0x800*sector_nb);
			
			if( plain == NO ) {
				u32 k;
				for(k=0;k<sector_nb;++k) {
					reset_iv(iv, current_sector+k);
					if(aes_crypt_cbc(&aes, AES_DECRYPT, 0x800, iv, buff+0x800*k , buff+0x800*k )!=0) {
						printf("Error : aes_crypt_cbc ");
						goto error;
					}
				}
			}
			
			if(copy_cancel) goto error;
			
			if( split ) {	
				u32 split_current_sector = current_sector - N_SPLIT_ISO * MAX_SPLIT_SECTOR;
				
				if( split_current_sector + sector_nb <= MAX_SPLIT_SECTOR ) {
					fwrite(buff, sector_nb, 0x800, f);
				} else {
					u32 last_sectors = MAX_SPLIT_SECTOR - split_current_sector;
					fwrite(buff, last_sectors, 0x800, f);
					
					FCLOSE(f);
					
					if( SPLIT_ISO_PATH[0] != 0) SetPerms(SPLIT_ISO_PATH);
					memset(SPLIT_ISO_PATH, 0, 512);
					
					N_SPLIT_ISO++;
					
					sprintf(SPLIT_ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
										
					print_debug("fopen %s", SPLIT_ISO_PATH);
					f = fopen(SPLIT_ISO_PATH, "wb");
					if(f==NULL) {
						print_load("Error : fopen");
						goto error;
					}
					
					u32 sectors_left = sector_nb - last_sectors;
					fwrite(buff, sectors_left, 0x800, f);
				}
			} else {
				fwrite(buff, sector_nb, 0x800, f);
			}
			
			current_sector += sector_nb;
			
			copy_current_size += sector_nb*0x800;
		
			if(copy_cancel) goto error;
		}
		
		md5_finish(&ctx, ird->RegionHashes[i].RegionHash);
		
		plain = !plain;
		++i;
	}
	FCLOSE(f);
	
	SetPerms(ISO_PATH);
	
	iso_done = YES;
	if( corrupt == YES) {
		print_load("Skip IRD building because the iso is probably corrupted.");
		goto error;
	}
	
	print_head("Building IRD...");
	u64 footer_offset = 0;
	u64 header_lenght = 0;
	
	strcpy( copy_src, ISO_PATH);
	strcpy( copy_dst, IRD_PATH);
	print_debug("Gathering data...");
	if( IRD_FilesInfo(ISO_PATH, &gathering_nb_file, &gathering_total_size) == FAILED) {
		print_load("Error : failed to IRD_FilesInfo");
		goto error;
	}
	
	if(copy_cancel) goto error;
	
	copy_current_size=0;
	task_Init(gathering_total_size);
	print_debug("Calculating files' MD5...");
	if( IRD_FilesHashes(ISO_PATH, ird, &header_lenght, &footer_offset, YES) == FAILED) {
		print_load("Error : failed to get file-hashes");
		goto error;
	}
	task_End();
	
	if(header_lenght==0 || footer_offset==0 || ((u64) total_sectors * 0x800ULL) < footer_offset) goto error;
	
	/**
	For every region the Ripp3r application processes, the md5 hash is calculated. The next part of the
	file contains the md5 hash for every complete region in the file. There are two exceptions for this
	calculation. The first region starts it’s calculation at the start sector of the first file. The last regions
	ends with the end of the last file (PS3UPDAT.PUP).
	**/
	// I forgot to remove header and footer from region MD5... ugly fix :s
	IRD_FixRegionMD5(ISO_PATH, ird, header_lenght, footer_offset);
	
	if(copy_cancel) goto error;
	
	u64 footer_lenght = (u64) total_sectors * 0x800ULL - footer_offset;
	
	print_debug("Compressing header...");
	gathering_nb_file = -1;
	f = fopen(ISO_PATH, "rb");
	if(f==NULL) {
		print_load("Error : failed to fopen ISO to load footer and header");
		goto error;
	}
	
	if( GZ_compress2(f, (int) header_lenght, (char **) &ird->Header, (int *) &ird->HeaderLength) != Z_OK) {
		print_load("Error : failed to compress header");
		goto error;
	}
	
	if(copy_cancel) goto error;
		
	if( ird->Header == NULL || ird->HeaderLength==0) {
		print_load("Error : failed to get a proper compressed header");
		goto error;
	}
	
	print_debug("Compressing footer...");
	if( split ) {
		FCLOSE(f);
		f = fopen(SPLIT_ISO_PATH, "rb");
		if(f==NULL) {
			print_load("Error : fopen %s", SPLIT_ISO_PATH);
			goto error;
		}
		fseek(f, footer_offset - N_SPLIT_ISO * MAX_SPLIT_SECTOR, SEEK_SET);
	} else {
		fseek(f, footer_offset, SEEK_SET);
	}
	copy_current_size =0;
	gathering_total_size = footer_lenght;
	if( GZ_compress2(f, (int) footer_lenght, (char **) &ird->Footer, (int *) &ird->FooterLength) != Z_OK) {
		print_load("Error : failed to compress footer");
		goto error;
	}
	FCLOSE(f);
	
	if(copy_cancel) goto error;
	
	if( ird->Footer == NULL || ird->FooterLength==0) {
		print_load("Error : failed to get a proper compressed footer");
		goto error;
	}
	
	copy_current_size = 0;
	gathering_total_size = SIZEOF_IRD(ird);
	
	if( GetFreeSpace(IRD_PATH) < gathering_total_size ) {
		print_load("Error : Not enough space.");
		goto error;
	}
	
	print_debug("Saving IRD");
	if(IRD_save(IRD_PATH, ird)==FAILED) {
		print_load("Error : failed to save IRD");
		goto error;
	}
	SetPerms(IRD_PATH);
	
	if(copy_cancel) goto error;
	
	print_head("Uploading IRD");

	print_debug("Getting ird signature");
	IRD_NAME = IRD_sig2(ird);
	if(IRD_NAME == NULL) {
		print_load("Error : failed  to get IRD_sig");
		goto error;
	}
	
	if(copy_cancel) goto error;
	
	print_debug("Check if ird exist");
	ret = IRD_DB_exist(IRD_NAME); 
	if( ret == NET_ERROR) {
		ret = FAILED;
		goto error;
	} else
	if( ret == YES ) {
		print_debug("The ird already exists in DB");
		if( IRD_WS_trust(IRD_NAME) == FAILED ) {
			print_load("Error : failed to increase trust level.");
		}
	} else 
	if( ret == NO ) {	
		print_debug("Uploading the ird");
		if( IRD_DB_upload(IRD_PATH, IRD_NAME) == FAILED ) {
			print_load("Error : failed to upload IRD");
			ret = FAILED;
			goto error;
		}
		char JSON_PATH[512];
		sprintf(JSON_PATH, "/dev_hdd0/tmp/%s.json", IRD_NAME);
		if( Build_JSON(ird, JSON_PATH, IRD_NAME) == FAILED ) {
			print_load("Error : failed to build JSON");
			ret = FAILED;
			goto error;
		}
		if( IRD_WS_upload(JSON_PATH) == FAILED ) {
			print_load("Error : failed to upload json to website");
			ret = FAILED;
			goto error;
		}
	}

	ret=SUCCESS;
error:
	
	if( iso_done ) {
		if(with_3k3y_header) {
			FCLOSE(f);
			
			f = fopen(ISO_PATH, "rb+");
			if(f) {
				fseek(f, 0xF70, SEEK_SET);
				fputs(Decrypted3KISO, f);
				fwrite(ird->Data1, 0x10, 1, f);
				fwrite(ird->Data2, 0x10, 1, f);
				fwrite(ird->PIC  , 0x73, 1, f);
				FCLOSE(f);
			}
			
		}
	} else {
		if( split ) {
			int i;
			for(i=0; i<N_SPLIT_ISO; i++) {
				sprintf(SPLIT_ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
				Delete(SPLIT_ISO_PATH);
			}
		} else {
			Delete(ISO_PATH);
		}
	}
	
	if( copy_cancel || cancel ) ret=FAILED;
	
	if(!source) sys_storage_close(source);
	FCLOSE(f);
	FREE(DATE);
	FREE(IRD_NAME);
	FREE_IRD(ird);
	FREE(buff);
	FREE(iv);
	FREE(sec0sec1);
	
	if(rlog) {
		if(ret==FAILED) {
			if( copy_cancel || cancel ) {
				fputs("RESULT: The user canceled.\n", rlog);
			} else {
				fputs("RESULT: Something went wrong: '", rlog);
				fputs(loading_log[0], rlog);
				fputs("'\n", rlog);
			}
		} else
		if(ret==SUCCESS) {
			if( corrupt && IGNORE_ERR ) {
				fputs("RESULT: The dump is probably corrupted.", rlog);
			} else {
				fputs("RESULT: Everything went well!", rlog);
			}
		}
		
		DATE = get_date();
		sprintf(result_str, "\nFinished at %c%c:%c%c\n", DATE[9], DATE[10], DATE[11], DATE[12]); fputs(result_str, rlog);
		FREE(DATE);
	}
	FCLOSE(rlog);
	
	if( iso_done ) {
		add_GAMELIST(ISO_PATH);
		sort_GAMELIST();
		init_Load_GAMEPIC();
		read_fav();
	}
	
	return ret;
}

u8 dump_3k3y_header(char *outfile)
{	
	u8 d1[0x10];
	u8 d2[0x20];
	u8 pic[0x73];
	
	if( get_keys(d1, d2, pic) == FAILED ) return FAILED;
	
	FILE *f = fopen(outfile, "wb");
	if(f==NULL) {
		print_load("Error : failed to fopen %s", outfile);
		return FAILED;
	}
	fputs(Encrypted3KISO, f);
	fwrite(&d1, 1, 0x10, f);
	fwrite(&d2, 1, 0x10, f);
	fwrite(&pic, 1, 0x73, f);
	fclose(f);
	
	return SUCCESS;
}

u8 build_bdvd_iso(char *outdir, char *result_log)
{
	print_head("Initialization...");
	u8 ret=FAILED;
	char f1_path[512]={0};
	FILE *f1=NULL;
	FILE *f=NULL;
	int source=0;
	u32 read;
	u8 *buff=NULL;
	ird_t *ird=NULL;
	char ISO_PATH[512];
	char IRD_PATH[512];
	char SPLIT_ISO_PATH[512]={0};
	char *IRD_NAME = NULL;
	char *DATE=NULL;	
	u8 *sec0sec1=NULL;
	u8 corrupt=NO;
	u8 try;
	u64 n;
	u8 split = NO;
	u32 N_SPLIT_ISO = 0;
		
	char result_str[512]={0};
	FILE *rlog=NULL;
	rlog =  fopen(result_log, "wb");
	if(rlog) {
		fputs("**** Result of the build ****\n\n", rlog);
		fputs("Type : Build ISO from files with original header and footer", rlog);
		fputs("\n", rlog);
	}
	
	print_debug("Get current date");
	DATE = get_date();
	if( DATE == NULL) {
		print_load("Error : dump_bdvd, failed to get_date");
		goto error;
	}
	
	print_debug("IRD_new");
	ird = IRD_new("/dev_bdvd");
	if(ird==NULL) {
		print_load("Error : failed to IRD_new");
		goto error;
	}
	
	if(rlog) {
		sprintf(result_str, "Started at %c%c:%c%c\n", DATE[9], DATE[10], DATE[11], DATE[12]); fputs(result_str, rlog);
		sprintf(result_str, "Title ID : %s\n", ird->GameId); fputs(result_str, rlog);
	}

	print_debug("sys_storage_open BDVD_DRIVE");
	if(sys_storage_open(BDVD_DRIVE, &source) != 0) {
		print_load("Error : sys_storage_open");
		goto error;
	}

	print_debug("malloc BDVD_BUFFSIZE");
	buff = (u8 *) malloc(BDVD_BUFFSIZE);
	if(buff==NULL) {
		print_load("Error : malloc BDVD_BUFFSIZE");
		goto error;
	}

	print_debug("malloc sec0sec1");
	sec0sec1 = (u8 *) malloc( 0x800 * 2 );
	if( sec0sec1 == NULL ) {
		print_load(" Error : malloc sec0sec1 ");
		goto error;
	}
	
	print_debug("sys_storage_read sec0sec1");
	for(try=0; try<DUMPER_MAX_TRY; try++) {
		memset(sec0sec1, 0, 0x800*2);
		if( sys_storage_read(source, 0, 2, sec0sec1, &read, 0) == 0) break;
		
		if(copy_cancel || cancel) goto error;
		print_load("Failed to read sector 0 size 2, try %d/%d", try+1, DUMPER_MAX_TRY); 
		
		if(try+1==DUMPER_MAX_TRY) {
			corrupt=YES;
			if( !IGNORE_ERR ) goto error;
		}
	}
	
	u32 regions=(u8_to_u32(sec0sec1)*2)-1;
	u32 total_sectors=1+u8_to_u32(sec0sec1+12+((regions-1)*4));
	
	print_debug("Gathering data");	
	gathering_nb_file = -1;
	gathering_nb_directory = -1;
	gathering_total_size = (u64) total_sectors * 0x800ULL;
	
	if( MAX_SPLIT_SECTOR < total_sectors )  split = is_FAT32(outdir);
	
	sprintf(IRD_PATH, "%s/%s_%s.ird%c", outdir, ird->GameId, DATE, '\0');
	if(split) {
		sprintf(ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
	} else {
		sprintf(ISO_PATH, "%s/%s_%s.iso%c", outdir, ird->GameId, DATE, '\0');
	}
	
	if( GetFreeSpace(ISO_PATH) < gathering_total_size ) {
		print_load("Error : Not enough space.");
		goto error;
	}
	
	MGZ_mkdir_recursive(outdir);
	
	print_debug("fopen %s", ISO_PATH);
	f = fopen(ISO_PATH, "wb");
	if(f==NULL) {
		print_load("Error : fopen");
		goto error;
	}
	
	strcpy( copy_src, "/dev_bdvd");
	strcpy( copy_dst, ISO_PATH);
	
	u64 current_sector=0;
	u64 sector_nb;
	
	print_debug("regions :  0x%X\n", regions);
	print_debug("total_sectors :  0x%X\n", total_sectors);
	print_debug("gathering_total_size :  0x%llX\n", gathering_total_size);
	
	if(rlog) {
		sprintf(result_str, "Path : %s\n\n", ISO_PATH); fputs(result_str, rlog);
	}
	
	ret=FAILED;
	print_head("Building the ISO...");
	
	print_debug("Writing first region (plain) with header");
	u32 region_last_sector=u8_to_u32(sec0sec1+12) + 1;
	
	while( current_sector < region_last_sector ) {
			
		memset(buff, 0, BDVD_BUFFSIZE);
		if(region_last_sector < current_sector + BDVD_BUFF_SEC_NB) sector_nb = region_last_sector - current_sector;
		else sector_nb = BDVD_BUFF_SEC_NB;
		
		if( DUMPER_read(source, current_sector, sector_nb, buff, &read, &corrupt) == FAILED) {
			goto error;
		}
		
		if(copy_cancel) goto error;
		
		// It's probably useless here the 1st region is probably always too small to be splitted.
		if( split ) {	
			u32 split_current_sector = current_sector - N_SPLIT_ISO * MAX_SPLIT_SECTOR;
			
			if( split_current_sector + sector_nb <= MAX_SPLIT_SECTOR ) {
				fwrite(buff, sector_nb, 0x800, f);
			} else {
				u32 last_sectors = MAX_SPLIT_SECTOR - split_current_sector;
				fwrite(buff, last_sectors, 0x800, f);
				
				FCLOSE(f);
				
				if( SPLIT_ISO_PATH[0] != 0) SetPerms(SPLIT_ISO_PATH);
				memset(SPLIT_ISO_PATH, 0, 512);
				
				N_SPLIT_ISO++;
				
				sprintf(SPLIT_ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
									
				print_debug("fopen %s", SPLIT_ISO_PATH);
				f = fopen(SPLIT_ISO_PATH, "wb");
				if(f==NULL) {
					print_load("Error : fopen");
					goto error;
				}
				
				u32 sectors_left = sector_nb - last_sectors;
				fwrite(buff, sectors_left, 0x800, f);
			}
		} else {
			fwrite(buff, sector_nb, 0x800, f);
		}
		
		if(copy_cancel) goto error;
		
		current_sector += sector_nb;
	}
	
	FCLOSE(f);
	
	print_debug("Get files path and sectors from header");
	IRD_FilesHashes(ISO_PATH, ird, NULL, NULL, NO);
	
	print_debug("Loop: write files in iso");
	if(0 < N_SPLIT_ISO) {
		f = fopen(SPLIT_ISO_PATH, "ab");
	} else {
		f = fopen(ISO_PATH, "ab");
	}
	
	for(n=0; n<ird->FileHashesNumber-1; n++) {
		if( ird->FileHashes[n].Sector < current_sector ) continue;
		
		
		if( ird->FileHashes[n].Sector == current_sector ) {
						
			print_debug("Current file: %s", ird->FileHashes[n].FilePath);
			
			sprintf(f1_path, "/dev_bdvd%s%c", ird->FileHashes[n].FilePath, '\0');
			f1 = fopen(ird->FileHashes[n].FilePath, "rb");
			
			while( current_sector < ird->FileHashes[n+1].Sector ) {	
				memset(buff, 0, BDVD_BUFFSIZE);
				if(ird->FileHashes[n+1].Sector < current_sector + BDVD_BUFF_SEC_NB) sector_nb = ird->FileHashes[n+1].Sector - current_sector;
				else sector_nb = BDVD_BUFF_SEC_NB;
				
				fread(buff, sector_nb, 0x800, f1);
				
				fwrite(buff, sector_nb, 0x800, f);
				
				current_sector += sector_nb;
			}
		}
	}
	
	print_debug("Writing last region (plain): PS3UPDAT.PUP + footer");
	region_last_sector=total_sectors;
	while( current_sector < region_last_sector ) {
			
		memset(buff, 0, BDVD_BUFFSIZE);
		if(region_last_sector < current_sector + BDVD_BUFF_SEC_NB) sector_nb = region_last_sector - current_sector;
		else sector_nb = BDVD_BUFF_SEC_NB;
					
		if( DUMPER_read(source, current_sector, sector_nb, buff, &read, &corrupt) == FAILED) {
			goto error;
		}
		
		if(copy_cancel) goto error;
		
		if( split ) {	
			u32 split_current_sector = current_sector - N_SPLIT_ISO * MAX_SPLIT_SECTOR;
			
			if( split_current_sector + sector_nb <= MAX_SPLIT_SECTOR ) {
				fwrite(buff, sector_nb, 0x800, f);
			} else {
				u32 last_sectors = MAX_SPLIT_SECTOR - split_current_sector;
				fwrite(buff, last_sectors, 0x800, f);
				
				FCLOSE(f);
				
				if( SPLIT_ISO_PATH[0] != 0) SetPerms(SPLIT_ISO_PATH);
				memset(SPLIT_ISO_PATH, 0, 512);
				
				N_SPLIT_ISO++;
				
				sprintf(SPLIT_ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
									
				print_debug("fopen %s", SPLIT_ISO_PATH);
				f = fopen(SPLIT_ISO_PATH, "wb");
				if(f==NULL) {
					print_load("Error : fopen");
					goto error;
				}
				
				u32 sectors_left = sector_nb - last_sectors;
				fwrite(buff, sectors_left, 0x800, f);
			}
		} else {
			fwrite(buff, sector_nb, 0x800, f);
		}
		
		if(copy_cancel) goto error;
			
		current_sector += sector_nb;
	}
	
	ret = SUCCESS;
error:
	
	if( copy_cancel || cancel ) ret=FAILED;
	
	if( ret == FAILED ) {
		if( split ) {
			int i;
			for(i=0; i<N_SPLIT_ISO; i++) {
				sprintf(SPLIT_ISO_PATH, "%s/%s_%s.iso.%d%c", outdir, ird->GameId, DATE, N_SPLIT_ISO, '\0');	
				Delete(SPLIT_ISO_PATH);
			}
		} else {
			Delete(ISO_PATH);
		}
	}
	
	if( copy_cancel || cancel ) ret=FAILED;
	
	if(!source) sys_storage_close(source);
	FCLOSE(f);
	FCLOSE(f1);
	FREE(DATE);
	FREE(IRD_NAME);
	FREE_IRD(ird);
	FREE(buff);
	FREE(sec0sec1);
	
	if(rlog) {
		if(ret==FAILED) {
			if( copy_cancel || cancel ) {
				fputs("RESULT: The user canceled.\n", rlog);
			} else {
				fputs("RESULT: Something went wrong: '", rlog);
				fputs(loading_log[0], rlog);
				fputs("'\n", rlog);
			}
		} else
		if(ret==SUCCESS) {
			if( corrupt && IGNORE_ERR ) {
				fputs("RESULT: The dump is probably corrupted.", rlog);
			} else {
				fputs("RESULT: Everything went well!", rlog);
			}
		}
		
		DATE = get_date();
		sprintf(result_str, "\nFinished at %c%c:%c%c\n", DATE[9], DATE[10], DATE[11], DATE[12]); fputs(result_str, rlog);
		FREE(DATE);
		
		FCLOSE(rlog);
	}
	
	return ret;
}

u8 GetPVD(char *ISO, u8 *PVD)
{
    memset(PVD, 0, 0x60);
    
    FILE *f = fopen(ISO, "rb");
    if(f==NULL) return FAILED;
    
    fseek(f, 0x8320, SEEK_SET);
    fread(PVD, 0x60, 1, f);
    fclose(f);
    
    return SUCCESS;
}

//*******************************************************
// RAR
//*******************************************************

u8 ExtractRar(const char* RarFile, char *dstPath)
{
	
	HANDLE hArcData; //Archive Handle
	struct RAROpenArchiveDataEx rarOpenArchiveData;
    struct RARHeaderDataEx rarHeaderData;
    memset(&rarOpenArchiveData, 0, sizeof(rarOpenArchiveData));
    memset(&rarHeaderData, 0, sizeof(rarHeaderData));

    rarOpenArchiveData.ArcName = (char*) RarFile;
    rarOpenArchiveData.CmtBuf = NULL;
    rarOpenArchiveData.CmtBufSize = 0;
    rarOpenArchiveData.OpenMode = RAR_OM_EXTRACT;
    hArcData = RAROpenArchiveEx(&rarOpenArchiveData);
    
    print_load("UnRAR [%s]", RarFile);
     
    if(rarOpenArchiveData.OpenResult != ERAR_SUCCESS) {   
        print_load("OpenArchive '%s' Failed!", rarOpenArchiveData.ArcName);
        return FAILED;   
    }   
      
    while (RARReadHeaderEx(hArcData, &rarHeaderData) == ERAR_SUCCESS) {   
        print_load("Extracting '%s' (%ld) ...", rarHeaderData.FileName, rarHeaderData.UnpSize + (((uint64_t)rarHeaderData.UnpSizeHigh) << 32));
		
        if (RARProcessFile(hArcData, RAR_EXTRACT, dstPath, NULL) != ERAR_SUCCESS) {   
            print_load("ERROR: UnRAR Extract Failed!");
            return FAILED;
        }   
    }

    RARCloseArchive(hArcData);
	
	return SUCCESS;
}

//*******************************************************
// ZIP
//*******************************************************

u8 ExtractZip(char* ZipFile, char *dstFolder)
{
	char FileOUT[255];

	int err=0;
	struct zip *f_zip=NULL;
	
	mkdir(dstFolder, 0777);
	
	f_zip = zip_open(ZipFile, ZIP_CHECKCONS, &err);
	if(err != ZIP_ER_OK || f_zip==NULL)
	{
		print_load("Error : zip_open");
		return FAILED;
	}

	int count = zip_get_num_files(f_zip);
	if(count==-1)
	{
		print_load("Error : zip_get_num_files");
		zip_close(f_zip);
		return FAILED;
	}
	
	prog_bar1_value = 0;
	int i;
	for(i=0; i<count; i++)
	{
		prog_bar1_value = (i*100)/count;
		
		struct zip_stat file_stat;
		struct zip_file* file_zip=NULL;
		
		zip_stat_index(f_zip, i, 0, &file_stat);
		
		if(zip_stat(f_zip, file_stat.name, 0, &file_stat) == -1)
		{
			print_load("Error : zip_stat");
			zip_close(f_zip);
			return FAILED;
		}
		
		print_load((char*)file_stat.name);
		
		sprintf(FileOUT, "%s/%s", dstFolder, file_stat.name);
		
		if(FileOUT[strlen(FileOUT)-1]=='/') {
			FileOUT[strlen(FileOUT)-1]=0;
			mkdir(FileOUT, 0777);
			continue;
		}
		
		file_zip=zip_fopen(f_zip, file_stat.name, ZIP_FL_UNCHANGED);
		if(!file_zip)
		{
			print_load("Error : zip_fopen");
			zip_close(f_zip);
			return FAILED;
		}
		
		u64 pos = 0ULL;
		u64 read = 0, writed = 0;
		FILE* f;
		
		prog_bar2_value=0;
		
		f = fopen(FileOUT, "wb");
		if(f==NULL) {
			zip_fclose(file_zip);
			zip_close(f_zip);
			return FAILED;
		}

		SetFilePerms(FileOUT);

		int mem_size = 0x1000;
		char *mem = malloc(mem_size);

		while(pos < file_stat.size) {
			
			if(cancel==YES) {
				zip_fclose(file_zip);
				zip_close(f_zip);
				fclose(f);
				free(mem);
				return FAILED;
			}
			
			read = file_stat.size - pos; if(read > mem_size) read = mem_size;
			
			writed = zip_fread(file_zip, mem, (size_t) read);
			if(writed<0) {
				zip_fclose(file_zip);
				zip_close(f_zip);
				fclose(f);
				free(mem);
				return FAILED;
			}
			
			if(copy_cancel==YES) {
				zip_fclose(file_zip);
				zip_close(f_zip);
				fclose(f);
				free(mem);
				return FAILED;
			}
			
			if(read != writed) {
				zip_fclose(file_zip);
				zip_close(f_zip);
				fclose(f);
				free(mem);
				return FAILED;
			}
			
			writed = fwrite(mem, 1, read, f);
			if(writed<0) {
				zip_fclose(file_zip);
				zip_close(f_zip);
				fclose(f);
				free(mem);
				return FAILED;
			}
			
			if(read != writed) {
				zip_fclose(file_zip);
				zip_close(f_zip);
				fclose(f);
				free(mem);
				return FAILED;
			}
			
			pos += read;
			
			prog_bar2_value=pos*100/file_stat.size;
		}
		fclose(f);
		zip_fclose(file_zip);
		
		free(mem);
		
	}
		
	prog_bar1_value = -1;
	prog_bar2_value = -1;
	
	zip_close(f_zip);

	return SUCCESS;
}

u8 ExtractZipFile(char* ZipFile, char* File, char* out)
{

	int id = 0;
	struct zip *f_zip=NULL;
	int err=0;

	f_zip=zip_open(ZipFile, ZIP_CHECKCONS, &err);
	/* s'il y a des erreurs */
	if(err != ZIP_ER_OK || f_zip==NULL)
	{
		print_load("Error : zip_open");
		return FAILED;
	}

	id=zip_name_locate(f_zip,File,0);
	if (id==-1)
	{
		zip_close(f_zip);
		return FAILED;
	}

	
	struct zip_stat file_stat;
	struct zip_file* file_zip=NULL;
	zip_stat_index(f_zip, id, 0, &file_stat);

	if(zip_stat(f_zip, file_stat.name, 0, &file_stat) == -1)
	{
		print_load("Error : zip_stat");
		zip_close(f_zip);
		return FAILED;
	}

	file_zip=zip_fopen(f_zip, file_stat.name, ZIP_FL_UNCHANGED);

	if(!file_zip)
	{
		print_load("Error : zip_fopen");
		zip_close(f_zip);
		return FAILED;
	}

	char *data=NULL;
	data = malloc((size_t)(file_stat.size+1));
	memset(data, 0, (size_t)(file_stat.size+1));
	if(data == NULL)
	{
		print_load("Error : malloc");
		zip_fclose(file_zip);
		zip_close(f_zip);
		return FAILED;
	}

	if(zip_fread(file_zip, data, (size_t)(file_stat.size)) != file_stat.size)
	{
		print_load("Error : zip_fread");
		free(data);
		zip_fclose(file_zip);
		zip_close(f_zip);
		return FAILED;
	}
	zip_fclose(file_zip);
	zip_close(f_zip);

	if( SaveFile(out, data, file_stat.size) == FAILED ) {
		print_load("Error : SaveFile");
		free(data);
		return FAILED;
	}
	free(data);
	
	return SUCCESS;
}

//*******************************************************
// 7Z
//*******************************************************

void Callback_7z(const char* fileName, unsigned long fileSize, unsigned fileNum, unsigned numFiles)
{
    print_load("[%d/%d] File: %s Size: %ld\n", fileNum, numFiles, fileName, fileSize);
}

u8 Extract7z(char *src, char *dst)
{
	if( Extract7zFileEx(src, dst, &Callback_7z, DEFAULT_IN_BUF_SIZE) == 0) return SUCCESS;
	
	return FAILED;
}

//*******************************************************
// ARCHIVE
//*******************************************************

u8 is_archive(char *ext)
{
	if(	!strcasecmp(ext, ".zip") ) return YES;
	if( !strcasecmp(ext, ".rar") ) return YES;
	if( !strcasecmp(ext, ".7z") ) return YES;
	if( !strcasecmp(ext, ".tar.bz2") ) return YES;
	if( !strcasecmp(ext, ".tar.gz") ) return YES;
	if( !strcasecmp(ext, ".tgz") ) return YES;
	if( !strcasecmp(ext, ".tar") ) return YES;
	
	return NO;
}

u8 ExtractArchive(char *ArchFile)
{
	char *ext = GetExtension(ArchFile);
	
	char DirName[255];
	
	strcpy(DirName, ArchFile);
	RemoveExtension(DirName);
	mkdir(DirName, 0777);
	
	if(	!strcasecmp(ext, ".zip") ) return ExtractZip(ArchFile, DirName);
	if( !strcasecmp(ext, ".rar") ) return ExtractRar(ArchFile, DirName);
	if( !strcasecmp(ext, ".7z") ) return Extract7z(ArchFile, DirName);
	if( !strcasecmp(ext, ".tar.bz2") ) return !untar_bz2(ArchFile, DirName);
	if( !strcasecmp(ext, ".tar.gz") ) return !untar_gz(ArchFile, DirName);
	if( !strcasecmp(ext, ".tgz") ) return !untar_gz(ArchFile, DirName);
	if( !strcasecmp(ext, ".tar") ) return !untar(ArchFile, DirName);
	
	return FAILED;
}


//*******************************************************
//NTFS
//*******************************************************

ntfs_md *mounts;
int mountCount;

int NTFS_Test_Device(char *name)
{
	int i;

	for (i = 0; i < mountCount; i++) {
		if(!strncmp(mounts[i].name, name, 5 - 1 *( name[0] == 'e'))) 
			return (mounts[i].interface->ioType & 0xff) - '0';
	}

	return -1;
	
}

void NTFS_mount_all()
{
	u8 i;
	for (i = 0; i < mountCount; i++) ntfsUnmount(mounts[i].name, 1);
	
	mounts = NULL;
	mountCount = 0;
	mountCount = ntfsMountAll(&mounts, NTFS_SU | NTFS_FORCE);
	if(mountCount < 0) print_load("Error : ntfsMountAll failed	%d", mountCount);

}

//*******************************************************
// Game OPTION
//*******************************************************

volatile u8 dialog_action = 0;

void my_dialog(msgButton button, void *userdata)
{
	switch(button)
	{
		case MSG_DIALOG_BTN_YES:
			dialog_action = 2;
			break;
		case MSG_DIALOG_BTN_NO:
		case MSG_DIALOG_BTN_ESCAPE:
		case MSG_DIALOG_BTN_NONE:
			dialog_action = 1;
			break;
		default:
			break;
	}
}

void wait_dialog()
{
	while(!dialog_action)
	{
		sysUtilCheckCallback();
		if(!loading && !copy_flag && !gathering) tiny3d_Flip();
	}

	msgDialogAbort();
	usleep(100000);
}

u8 DrawDialogYesNo(char * str)
{
	dialog_action = 0;

	msgDialogOpen2(MSG_DIALOG_NORMAL | MSG_DIALOG_BTN_TYPE_YESNO, str, my_dialog, (void*)	0x0000aaaa, NULL );

	wait_dialog();
	
	return (dialog_action-1);
}

u8 DrawDialogOK(char * str)
{
	dialog_action = 0;

	msgDialogOpen2(MSG_DIALOG_NORMAL | MSG_DIALOG_BTN_TYPE_OK | MSG_DIALOG_BKG_INVISIBLE, str, my_dialog, (void*)	0x0000aaaa, NULL );

	wait_dialog();
	
	return (dialog_action-1);
}

//*******************************************************
// HASH
//*******************************************************

u8 sha1_file(char *path, unsigned char output[20] )
{
    FILE *f;
    size_t n;
    sha1_context ctx;
    unsigned char buf[1024];
	uint64_t read=0;
	uint64_t file_size;
	
    f = fopen( path, "rb");
    if( f == NULL ) {
		print_load("Error : sha1_file, failed to open file");
		return FAILED;
	}

    sha1_starts( &ctx );
	
	print_head("Calculating SHA1...");
	prog_bar1_value=0;
	
	fseek (f , 0 , SEEK_END);
	file_size = ftell (f);
	fseek(f, 0, SEEK_SET);
	
    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 ) {
		read+=n;
		prog_bar1_value=(read*100)/file_size;
		sha1_update( &ctx, buf, (int) n );
		if(cancel==YES) break;
	}

    sha1_finish( &ctx, output );

    memset( &ctx, 0, sizeof( sha1_context ) );

    fclose(f);
	
	if(cancel==YES) {
		memset(output, 0, sizeof(output));
		return FAILED;
	}
	
    return SUCCESS;
}

#define MD5_BUFFER_SIZE		0x100000
u8 md5_file(char *path, unsigned char output[16])
{
    FILE *f;
    md5_context ctx;
    u64 file_size;
	u64 read=0;
	u64 n;
	
	u8 *buf = (u8 *) malloc(MD5_BUFFER_SIZE);
	if(buf == NULL) {
		return FAILED;
	}
	
	f = fopen( path, "rb");
    if( f == NULL ) {
		//print_load("Error : md5_file, failed to open file");
		FREE(buf);
		return FAILED;
	}
	
	print_head("Calculating MD5...");
	
	print_load("%s : %s", STR_FILE, &strrchr(path, '/')[1]);
	
	fseek (f , 0 , SEEK_END);
	file_size = (u64) ftell (f);
	fseek(f, 0, SEEK_SET);
	
	task_Init(file_size);
	
	md5_starts( &ctx );	
	
	while(read < file_size) {
		if( read + MD5_BUFFER_SIZE > file_size) n = file_size-read;
		else n = MD5_BUFFER_SIZE;
		
		fread(buf, sizeof(u8), n, f);
		read += n;
		
		task_Update(n);
		
		md5_update(&ctx, buf, n);
		
		if(cancel) break;
	}
	
    md5_finish( &ctx, output );

    memset( &ctx, 0, sizeof( md5_context ) );

	FREE(buf);
    fclose(f);
	
	task_End();
	
	if(cancel) {
		memset(output, 0, sizeof(output));
		return FAILED;
	}
	
    return SUCCESS;
}

u32 crc_file2(char *path, u32 current_crc)
{
	FILE *f;
    u32 crc=current_crc;
    u64 file_size;
	u64 read=0;
	u64 n;
	
	u8 *buf = (u8 *) malloc(MD5_BUFFER_SIZE);
	if(buf == NULL) {
		return 0;
	}
	
	f = fopen( path, "rb");
    if( f == NULL ) {
		FREE(buf);
		return 0;
	}
	
	fseek (f , 0 , SEEK_END);
	file_size = (u64) ftell (f);
	fseek(f, 0, SEEK_SET);
	
	task_Init(file_size);
	
	while(read < file_size) {
		if( read + MD5_BUFFER_SIZE > file_size) n = file_size-read;
		else n = MD5_BUFFER_SIZE;
		
		fread(buf, sizeof(u8), n, f);
		read += n;
		
		task_Update(n);
		
		crc = crc32(crc, (const unsigned char*) buf, n);
		
		if(cancel) {
			crc = 0;
			break;
		}
	}
	FREE(buf);
    FCLOSE(f);
	
	task_End();
	
    return crc;
}

u32 crc_file(char *path)
{
	u32 crc = crc32(0L, Z_NULL, 0);
	crc = crc_file2(path, crc);
    return crc;
}

//*******************************************************
// Game OPTION
//*******************************************************

void get_hash(FILE* log, int hash_type, char *path)
{
	u8 info = path_info(path);
	char str[255];
	
	if( info == _NOT_EXIST) return; else
	if( info == _FILE) {
		
		print_load(&strrchr(path, '/')[1]);
		if(hash_type == MD5_HASH) {
			u64 res[2];
			md5_file(path, (u8 *) res);	
			sprintf(str, "%016llX%016llX  %s\n", (long long unsigned int) res[0], (long long unsigned int) res[1], &strrchr(path, '/')[1]);
			fputs(str, log);
			return;
		} else
		if(hash_type == SHA1_HASH) {
			u32 res[5];
			sha1_file(path, (u8 *) res);
			sprintf(str, "%08lX%08lX%08lX%08lX%08lX  %s\n",
			(long unsigned int) res[0],(long unsigned int) res[1],(long unsigned int) res[2],
			(long unsigned int) res[3],(long unsigned int) res[4], &strrchr(path, '/')[1]);
			fputs(str, log);
			return;
		}
	}
	
	sprintf(str, "\nPath : %s\n", path);
	fputs(str, log);
	
	char temp[255];
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(path);
	if(d==NULL) return;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		sprintf(temp, "%s/%s", path, dir->d_name);
	
		if(cancel==YES) break;
		
		get_hash(log, hash_type, temp);
	}
	closedir(d);
	
}

void HashFolder(int hash_type, char *dir)
{
	FILE* log;
	char log_path[255];
	char str[255];
	
	if(hash_type == MD5_HASH) {
		sprintf(log_path, "%s/content.md5", dir);
	} else
	if(hash_type == SHA1_HASH) {
		sprintf(log_path, "%s/content.sha1", dir);
	}
	
	log = fopen(log_path, "wb");
	if(log==NULL){
		print_load("Error : failed to create %s", log_path);
		return;
	}
	
	print_head("Calculating hash...");
	sprintf(str, "Path : %s\n", dir);
	print_load(str);
	
	get_hash(log, hash_type, dir);
	
	fclose(log);
	
	if(cancel == YES) {
		Delete(log_path);
	}
}

u64 get_size(char *path)
{
	struct stat s;
	
	if(stat(path, &s) != 0) {
		print_debug("%s doesn't exist", path);
		return 0;
	} else 
	if(!S_ISDIR(s.st_mode)) { //FILE
		if(gathering) {
			++gathering_nb_file;
			gathering_total_size+=s.st_size;
		}
		return s.st_size;
	}
	
	if(gathering_cancel==YES) return 0;
	
	if(gathering) ++gathering_nb_directory;
	
	u64 dir_size=0;
	DIR *d;
	struct dirent *dir;
	
	d = opendir(path);
	if(d==NULL) return 0;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		char temp[255];
		sprintf(temp, "%s/%s", path, dir->d_name);
		
		if(gathering_cancel==YES) return 0;
		
		dir_size += get_size(temp);		
	}
	closedir(d);
	
	return dir_size;
}

void Delete(char* path)
{
	if(path==NULL) return;
	
	DIR *d;
	struct dirent *dir;
	
	u8 info_file = path_info(path);
	
	if(info_file == _NOT_EXIST) return; else
	if(info_file == _FILE) {
		unlink(path);
		return;
	} else if(info_file == _DIRECTORY) {
		rmdir(path);
	}
	
	d = opendir(path);
	if(d==NULL) return;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
	
		char newpath[0x440];

		strcpy(newpath, path);
		strcat(newpath, "/");
		strcat(newpath, dir->d_name);
		
		Delete(newpath);
		
	}
	closedir(d);
	rmdir(path);
	
}

int Delete_Game(char *path, int position)
{
	int i;
	char temp[512];
	char game_path[512];
	
	if(path != NULL) {
		strcpy(game_path, path);
	} else strcpy(game_path, list_game_path[position]);
	
	print_load("Deleting %s", game_path);

	u8 split666 = is_66600(game_path);
	if( is_splitted_iso(game_path) || split666) {
			
		int l= strlen(game_path);
		game_path[l-1]=0;
		if(split666) game_path[l-2]=0;

		for(i=0; i<100; i++) {
			if(split666) sprintf(temp , "%s%02d" , game_path, i);
			else sprintf(temp , "%s%d" , game_path, i);
			Delete(temp);
		}
	} 
	else {
		Delete(game_path);
	}
		
	if(path != NULL) {
		if(path_info(path) != _NOT_EXIST) return FAILED; else
		return SUCCESS;
	} else
	if(path_info(list_game_path[position]) != _NOT_EXIST ) return FAILED;

	
	print_load("Removing game from list");
	char setPath[128];
	if(iso) sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[ISO]%s.bin", ManaGunZ_id, list_game_title[position]);
	else	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[JB]%s.bin" , ManaGunZ_id, list_game_title[position]);
	Delete(setPath);
	
	remove_GAMELIST(position);
		
	print_load("Update Favorite");
	read_fav();
	
	if(position>game_number) position=game_number;
	
	return SUCCESS;
}

void Get_Game_Size(char *path)
{
	u8 split666 = is_66600(path);
	if( is_splitted_iso(path) || split666) {
		char iso_path[255];
		char temp[255];
		int i;
		
		strcpy(iso_path, path);
		
		int l= strlen(iso_path);
		iso_path[l-1]=0;
		if(split666) iso_path[l-2]=0;

		for(i=0; i<100; i++) {
			if(split666) sprintf(temp , "%s%02d" , iso_path, i);
			else sprintf(temp , "%s%d" , iso_path, i);
			if( get_size(temp) == 0 ) break;
			print_load("%s : %d", iso_path, gathering_total_size);
		}
	} 
	else {
		get_size(path);
	}
}

char *get_unit(u64 nb)
{
	char *str =(char*) malloc(sizeof(char)*16);

	char unit[3];
	
	float size = 0.00;
	
	if(nb >= 1073741824) {
		size = (float) nb / 1073741824;
		sprintf(unit, " Gi%c", STR_UNIT[0]);
	}
	else
	if(nb >= 1048576) {
		size = (float) nb / 1048576;
		sprintf(unit, " Mi%c", STR_UNIT[0]);
	}
	else
	if(nb >= 1024) {
		size = (float) nb / 1024;
		sprintf(unit, " Ki%c", STR_UNIT[0]);
	} 
	else {
		size = (float) nb;
		sprintf(unit, "  %c", STR_UNIT[0]);
	}
  
	float decimal = (int)(100*(size - (int)size));
	if(decimal !=0) {
		char s[10];
		sprintf(s, "%.2g", decimal/100);
		sprintf(str, "%d%s", (int) size , &s[1]);
	} else sprintf(str, "%d", (int) size);
	
	strcat(str, unit);
	
	return str;
	
}

char *GetTimeStr(u64 secTime)
{
	u64 loc_secTime = secTime;
	
	u64 hr = loc_secTime / 3600ULL;
	loc_secTime = loc_secTime - 3600ULL * hr;
	u64 min = loc_secTime / 60ULL;
	loc_secTime = loc_secTime - 60ULL * min;
	u64 sec = loc_secTime;
	
	return sprintf_malloc("%02d:%02d:%02d", hr, min, sec);
}

static sys_ppu_thread_t Copy_id;

void Draw_Copy_screen(void *unused)
{
	int i;
	
	u8 shutdown = NO;
	copy_current_size=0;
	copy_cancel=NO;
	
	u8 show_log = YES;
	u8 is_dir = NO;
	if(path_info(copy_src) == _DIRECTORY) is_dir=YES;
	
	u64 previous_size=0;
	
	for(i=0; i<=20; i++){
		strcpy(loading_log[i], "\0");
	}
	
	char speed_STR[32];
	char elapsed_STR[32];
	char remaining_STR[32];
	
	init_timer(4);
	start_timer(4);
	
	u64 start_copy = sTime();
	
	float bar_w = 600;
	
	while(copy_flag) {
		
		cls();
		
		Draw_BGS();
		Draw_Notification();
		int x=50, y=40;
		
		FontSize(20);
		
		FontColor(COLOR_4);
		
		DrawString(x , y, head_title);
		
		FontColor(COLOR_1);
		
		y+=new_line(1);
		
		DrawFormatString(x , y, "%s :", STR_FROM);
		DrawString(120, y, copy_src);
		
		y+=new_line(1);
		
		DrawFormatString(x , y, "%s :", STR_TO);
		DrawString(120, y, copy_dst);
		
		y+=new_line(1);
		
		if(gathering_cancel==YES) {
			DrawFormatString(x , y, "%s : %s", STR_FILES, STR_UNKNOWN);
		} else 
		if( 0 < gathering_nb_file ) {
			DrawFormatString(x , y, "%s : %d", STR_FILES, gathering_nb_file);
		}
		y+=new_line(1);
		
		if(is_dir) {
			if(gathering_cancel==YES) {
				DrawFormatString(x , y, "%s : %s", STR_DIRS, STR_UNKNOWN);
			} else 
			if( 0 <= gathering_nb_directory ) {
				DrawFormatString(x , y, "%s : %d", STR_DIRS, gathering_nb_directory);
			}
			y+=new_line(1);
		}
		
		if( get_time(4) > 1000 ) {
			s64 speed = copy_current_size-previous_size;
			if( speed < 0) speed = 0;
			char *copy_speed = get_unit((u64) speed);
			if(copy_speed) sprintf(speed_STR, "%s/s", copy_speed);
			FREE(copy_speed);
			
			previous_size = copy_current_size;
			start_timer(4);
			
			u64 ElapsedTime = sTime() - start_copy;
			u64 RemainingTime = ElapsedTime * gathering_total_size / copy_current_size - ElapsedTime;
			
			char *ElapsedTime_STR = GetTimeStr(ElapsedTime);
			if(ElapsedTime_STR) sprintf(elapsed_STR,  "%s : %s", STR_ELAPSED, ElapsedTime_STR);
			FREE(ElapsedTime_STR);	
			
			if( gathering_total_size != 0 && gathering_cancel == NO) {
				char *RemainingTime_STR = GetTimeStr(RemainingTime);
				if(RemainingTime_STR) sprintf(remaining_STR,  "%s : %s", STR_REMAINING, RemainingTime_STR);
				FREE(RemainingTime_STR);				
			}
		}
		
		DrawFormatString(x, y, elapsed_STR);
		y+=new_line(1);
			
		if( gathering_total_size != 0 && gathering_cancel == NO) {
			DrawFormatString(x, y, remaining_STR);
			y+=new_line(1);
		}
		
		char *size_current = get_unit(copy_current_size);
		if(size_current) DrawString(x, y, size_current);
		FREE(size_current);
		
		if(gathering_cancel==YES) DrawString(x+bar_w-WidthFromStr(STR_UNKNOWN), y, STR_UNKNOWN); 
		else {
			char *size_tot = get_unit(gathering_total_size);
			if(size_tot) DrawString(x+bar_w-WidthFromStr(size_tot), y, size_tot);
			FREE(size_tot);
		}
		
		DrawStringFromCenterX(x+bar_w/2, y, speed_STR);
		
		y+=new_line(1);

		if(gathering_total_size != 0 && gathering_cancel==NO) {
			Draw_Progress_Bar_Advanced(x, y, 0, 0, bar_w, 4, 1, WHITE, BLACK, GREEN,  gathering_total_size, copy_current_size);
		}
		
		y+=15;
		if(1 < gathering_nb_file) {
			Draw_Progress_Bar_Advanced(x, y, 0, 0, bar_w, 4, 1, WHITE, BLACK, GREEN, 100, copy_file_prog_bar);
			y+=20;
			DrawFormatString(x, y, "%s : %s", STR_FILE, copy_file);
		}
		y+=20;
		
		FontSize(17);
		
		if(SHOW_LOG || DEBUG ) {
			if( loading_log[0][0] ) {
				if(show_log) {
					for(i=0; i<=20; i++){
						if(strstr(loading_log[i], "Error")) FontColor(RED);
						else if(strstr(loading_log[i], "Warning")) FontColor(ORANGE);
						else FontColor(COLOR_1);
						
						DrawFormatString(x , y, loading_log[i]);
						y+=20;
						if(y>450) break;
					}
				}
			}
		}
		
		x=INPUT_X;
		y=INPUT_Y;
		FontColor(COLOR_1);
		SetFontZ(0);
	
		x=DrawButton(x, y, STR_CANCEL, BUTTON_CIRCLE);
		
		x=DrawButton(x, y, STR_TURNOFF, BUTTON_L1);
		x=Draw_checkbox(x-3, y, 0, "", shutdown, NO);
		
		if(SHOW_LOG || DEBUG) {
			if(loading_log[0][0] ) {	
				if(show_log) x=DrawButton(x, y, STR_HIDELOGS, BUTTON_SELECT);
						else x=DrawButton(x, y, STR_SHOWLOGS, BUTTON_SELECT);
			}
		}

		tiny3d_Flip();
		//ScreenShot();
		ps3pad_read();
		
		if(NewPad(BUTTON_L1)) {
			shutdown = !shutdown;
		}
		if( loading_log[0][0] ) {	
			if(NewPad(BUTTON_SELECT)) {
				show_log = !show_log;
			}
		}
		if(NewPad(BUTTON_CIRCLE)) {
			copy_cancel = YES;
			show_msg(STR_CANCELLED);
		}
	}
	
	print_debug("end_of 'Draw_Copy_screen'");
	
	if(shutdown) {
		Delete("/dev_hdd0/tmp/turnoff");
		lv2syscall4(379,0x1100,0,0,0);
	}
	
	memset(copy_src, 0, sizeof(copy_src));
	memset(copy_dst, 0, sizeof(copy_dst));
	
	copy_current_size=0;
	copy_cancel=NO;
	
	reset_gathering();
	
	for(i=0; i<=20; i++){
		strcpy(loading_log[i], "\0");
	}
	
	print_debug("sysThreadExit");
	
	copy_flag = -1;
	sysThreadExit(0);
}

void start_copy_loading()
{
	print_head(STR_COPYING);
	if( copy_flag==NO) {
		copy_flag=YES;
		print_debug("start of copy_loading thread");
		sysThreadCreate(&Copy_id, Draw_Copy_screen, NULL, 999, 0x2000, THREAD_JOINABLE, "Thread_CopyScreen");	
	}
}

void end_copy_loading()
{
	if(copy_flag==YES) {
		u64 ret;
		copy_flag=NO;
		print_debug("end of copy_loading thread");
		while(copy_flag==NO) usleep(1000);
		sysThreadJoin(Copy_id, &ret);
		copy_flag=NO;
	}
}

void initAIO()
{

#ifdef RPCS3
	sysFsAioInit("/dev_hdd0");
	sysFsAioInit("/dev_hdd1");
	sysFsAioInit("/dev_usb000");
	sysFsAioInit("/dev_flash");
	return;
#endif
	
	char mount_point[32];

	DIR *d;
	struct dirent *dir;
	d = opendir("/");		
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		if(strncmp(dir->d_name, "dev_", 4)==0) {
			sprintf(mount_point, "/%s", dir->d_name);
			if(sysFsAioInit(mount_point) != 0) {
				print_load("Warning : failed to sysFsAioInit(%s)", mount_point);
			}
		}
	}
	closedir(d);

}

#define BUFFNUMBER 4
#define AIONUMBER  2
// FAILED 0
#define READY 1
#define BUSY  2
#define DATA_EMPTY 0
#define DATA_FULL  1

u64 BUFFSIZE=0x200000ULL;

static sysFSAio aio_read[AIONUMBER];
static sysFSAio aio_write[AIONUMBER];

u8 reading_statut[AIONUMBER];
u8 writing_statut[AIONUMBER];
	
u8 buffer_statut[BUFFNUMBER] = {DATA_EMPTY};
u8 buffer_to_write;
u8 buffer_to_read;
u64 reading_pos;
u64 writing_pos;
u64 writed;

static void reading_callback(sysFSAio *xaio, s32 error, s32 xid, u64 size)
{
	int i = xaio->usrdata;

	char tmp[128];
    if(error != 0) {
		reading_statut[i] = FAILED;
		sprintf(tmp, "Error : reading error %X", (unsigned int) error); print_load(tmp);
	} else 
	if(size != xaio->size) {
		reading_statut[i] = FAILED;
		sprintf(tmp, "Error : reading size %X / %X", (unsigned int) size, (unsigned int) xaio->size); print_load(tmp);
	} else {
		buffer_statut[buffer_to_read] = DATA_FULL;
		buffer_to_read++;
		if(buffer_to_read==BUFFNUMBER) buffer_to_read=0;
		reading_statut[i] = READY;
	}		
}

static void writing_callback(sysFSAio *xaio, s32 error, s32 xid, u64 size)
{

	int i = xaio->usrdata;
	
	char tmp[128];
	if(error != 0) {
		writing_statut[i] = FAILED;
		sprintf(tmp, "Error : writing error %X", (unsigned int) error); print_load(tmp);
	} else 
	if(size != xaio->size) {
		writing_statut[i] = FAILED;
		sprintf(tmp, "Error : writing size %X / %X", (unsigned int) size, (unsigned int) xaio->size); print_load(tmp);
	} else {
		buffer_statut[buffer_to_write] = DATA_EMPTY;
		buffer_to_write++;
		if(buffer_to_write==BUFFNUMBER) buffer_to_write=0;
		writing_statut[i] = READY;
		copy_current_size+=size;
		writed+=size;
	}		
}

// Asynchronous Copy - include <lv2/sysfs.h>
// sysFsAioInit - sysFsOpen - sysFsAioRead - sysFsAioWrite - sysFsAioFinish - sysFsAioCancel
int CopyFile_async(char *src, char *dst)
{
    
    int fdr, fdw;
    static int id_r[2] = {-1, -1};
	static int id_w[2] = {-1, -1};
	int i;
	
	struct stat s;
	if(stat(src, &s) != 0) return FAILED; 
	if(S_ISDIR(s.st_mode)) return FAILED;
	u64 size = s.st_size;
		
/*	if(sysFsAioInit(src)!= 0) {
		print_load("Error : failed to copy_async / sysFsAioInit(src)");
		return FAILED;
	}
*/
	if(sysFsOpen(src, SYS_O_RDONLY, &fdr, 0,0) != 0) {
		//sysFsAioFinish(src);
		print_load("Error : failed to copy_async / sysFsOpen(src)");
		return FAILED;
	}
/*
    if(sysFsAioInit(dst)!= 0)  {
		sysFsAioFinish(src);
		sysFsClose(fdr);
		print_load("Error : failed to copy_async / sysFsAioInit(dst)");
		return FAILED;
	}
*/
	if(sysFsOpen(dst, SYS_O_CREAT | SYS_O_TRUNC | SYS_O_WRONLY, &fdw, 0, 0) != 0) {
		//sysFsAioFinish(src);
		//sysFsAioFinish(dst);
		sysFsClose(fdr);
		print_load("Error : failed to copy_async / sysFsOpen(src)");
		return FAILED;
	}

	char *mem = (char *) malloc(BUFFNUMBER * BUFFSIZE);
	if(mem == NULL) {
		print_load("Error : failed to copy_async / malloc");
		return FAILED;
	}
	
	for(i=0; i<BUFFNUMBER; i++)	buffer_statut[i] = DATA_EMPTY;
	for(i=0; i<AIONUMBER; i++) {
		aio_read[i].fd  = -1;
		aio_write[i].fd = -1;
		reading_statut[i]=READY;
		writing_statut[i]=READY;
	}

	reading_pos=0ULL;
	writing_pos=0ULL;		
	buffer_to_write=0;
	buffer_to_read=0;
	writed=0;
	
    while(writed<size) {
		
        if(cancel) goto error;
		
		for(i=0; i<AIONUMBER; i++) {
		
			if(reading_statut[i] == READY) {
				
				if(buffer_statut[buffer_to_read] == DATA_EMPTY) {			
				
					if( reading_pos < size) {
						aio_read[i].fd = fdr;
						aio_read[i].offset = reading_pos;
						aio_read[i].buffer_addr = (u32) (u64) &mem[buffer_to_read * BUFFSIZE];
						aio_read[i].size = size - reading_pos;
						if(aio_read[i].size > BUFFSIZE) aio_read[i].size = BUFFSIZE;
						aio_read[i].usrdata = i;
										
						reading_statut[i] = BUSY;
						
						reading_pos+=aio_read[i].size;
						
						if(sysFsAioRead(&aio_read[i], &id_r[i], reading_callback) != 0) {
							print_load("Error : failed to copy_async / sysFsAioRead");
							goto error;
						}
					}
				}
            }
        
		
			if(reading_statut[i] == FAILED) {
				print_load("Error : failed to copy_async / reading_statut = FAILED !");
				goto error;
			}
			
			if(writing_statut[i] == READY) {

				if(buffer_statut[buffer_to_write] == DATA_FULL) {
					if( writing_pos < size) {
						aio_write[i].fd = fdw;
						aio_write[i].offset = writing_pos;
						aio_write[i].buffer_addr = (u32) (u64) &mem[buffer_to_write * BUFFSIZE];
						aio_write[i].size = size - writing_pos;
						if(aio_write[i].size > BUFFSIZE) aio_write[i].size = BUFFSIZE;
						aio_write[i].usrdata = i;
									
						writing_statut[i] = BUSY;
						
						writing_pos += aio_write[i].size;
						
						if(sysFsAioWrite(&aio_write[i], &id_w[i], writing_callback) != 0) {
							print_load("Error : failed to copy_async / sysFsAioWrite");
							goto error;
						}
					} 
				}
			}
			
			if(writing_statut[i] == FAILED) {
				print_load("Error : failed to copy_async / writing_statut = FAILED !");
				goto error;
			}
			
			copy_file_prog_bar=writed*100/size;
			
		}
    }
	
	for(i=0; i<AIONUMBER; i++) {
		sysFsClose(aio_read[i].fd);
		sysFsClose(aio_write[i].fd);
	}
//  sysFsAioFinish(src);
//	sysFsAioFinish(dst);
    free(mem);
	SetFilePerms(dst);
	
    return SUCCESS;

error:
	for(i=0; i<AIONUMBER; i++) {
		sysFsAioCancel(id_r[i]);
		sysFsAioCancel(id_w[i]);
	}
	for(i=0; i<AIONUMBER; i++) {
		sysFsClose(aio_read[i].fd);
		sysFsClose(aio_write[i].fd);
	}
	
	
//  sysFsAioFinish(src);
//	sysFsAioFinish(dst);
    free(mem);
   
    return FAILED;
}

// sysFs Copy - include <lv2/sysfs.h>
// sysLv2FsOpen - sysLv2FsRead - sysLv2FsWrite - sysLv2FsClose
u8 CopyFile_sysFs(char* src, char* dst)
{
	u8 ret = SUCCESS;
	u64 lenght = 0LL;
	char *mem = NULL;
	u64 pos = 0ULL;
	u64 read = 0, writed = 0;
	int f1;
	int f2;
	
	copy_file_prog_bar=0;

	struct stat s;
	if(stat(src, &s) != 0) return FAILED; 
	if(S_ISDIR(s.st_mode)) return FAILED;
	lenght = s.st_size;
	
	ret = sysFsOpen(src, SYS_O_RDONLY, &f1, NULL, 0);
	if(ret) return FAILED;
	
	ret = sysFsOpen(dst, SYS_O_WRONLY | SYS_O_CREAT | SYS_O_TRUNC, &f2, NULL, 0);
	if(ret) {sysFsClose(f1);return FAILED;}
	
	mem = malloc(BUFFSIZE);
	if(mem == NULL) {
		sysFsClose(f1);
		sysFsClose(f2);
		return FAILED;
	}
	
	while(pos < lenght)
	{
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		read = lenght - pos; 
		if(read > BUFFSIZE) read = BUFFSIZE;
		
		ret=sysFsRead(f1, mem, read, &writed);
		if(ret!=0) {ret = FAILED; goto skip;}
		if(read != writed) {ret = FAILED; goto skip;}
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		ret=sysFsWrite(f2, mem, read, &writed);
		if(ret!=0) {ret = FAILED; goto skip;}
		if(read != writed) {ret = FAILED; goto skip;}

		pos += read;
		
		copy_file_prog_bar=pos*100/lenght;
		copy_current_size+=read;
	}

skip:

	copy_file_prog_bar=0;
	
	if(mem) free(mem);
	if(f1) sysFsClose(f1);
	if(f2) sysFsClose(f2);
	
	return ret;
}

// sysLv2Fs Copy - include <sys/file.h>
// sysLv2FsOpen - sysLv2FsRead - sysLv2FsWrite - sysLv2FsClose
u8 CopyFile_sysFsLv2(char* src, char* dst)
{
	u8 ret = SUCCESS;
	u64 lenght = 0LL;
	char *mem = NULL;
	u64 pos = 0ULL;
	u64 read = 0, writed = 0;
	s32 fd = -1;
	s32 fd2 = -1;
	
	copy_file_prog_bar=0;

	struct stat s;
	if(stat(src, &s) != 0) return FAILED; 
	if(S_ISDIR(s.st_mode)) return FAILED;
	lenght = s.st_size;
	
	ret = sysLv2FsOpen(src, 0, &fd, S_IRWXU | S_IRWXG | S_IRWXO, NULL, 0);
	if(ret) return FAILED;

	ret = sysLv2FsOpen(dst, SYS_O_WRONLY | SYS_O_CREAT | SYS_O_TRUNC, &fd2, 0777, NULL, 0);
	if(ret) {sysLv2FsClose(fd); return FAILED;}
	
	mem = malloc(BUFFSIZE);
	if(mem == NULL) return FAILED;

	while(pos < lenght)
	{
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		read = lenght - pos; 
		if(read > BUFFSIZE) read = BUFFSIZE;
		
		ret=sysLv2FsRead(fd, mem, read, &writed);
		if(ret!=0) {ret = FAILED; goto skip;}
		if(read != writed) {ret = FAILED; goto skip;}
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		ret=sysLv2FsWrite(fd2, mem, read, &writed);
		if(ret!=0) {ret = FAILED; goto skip;}
		if(read != writed) {ret = FAILED; goto skip;}

		pos += read;
		
		copy_file_prog_bar=pos*100/lenght;
		copy_current_size+=read;
	}

skip:

	copy_file_prog_bar=0;
	
	if(mem) free(mem);
	if(fd >=0) sysLv2FsClose(fd);
	if(fd2>=0) sysLv2FsClose(fd2);
	if(ret) return ret;
	
	return ret;

}

// ps3_ntfs COPY - include <ntfs.h>
// ps3_ntfs_open/ps3_ntfs_read/ps3_ntfs_write/ps3_ntfs_close
u8 CopyFile_ps3ntfs(char* src, char* dst)
{
	u8 ret = SUCCESS;
	u64 lenght = 0LL;
	char *mem = NULL;
	u64 pos = 0ULL;
	u64 read = 0, writed = 0;
	int f1=-1;
	int f2=-1;
	u8 join=NO;
	u8 split=NO;
	u8 cur_file=0;
	char temp[1024];
	char source[1024];
	char destination[1024];
	
	u64 SPLITSIZE = 0xFFFFFFFFULL;
	
	strcpy(source, src);
	strcpy(destination, dst);
	if(strcmp(src, dst)==0) {
		RemoveExtension(destination);
		char *temp_str = strcpy_malloc(destination);
		int o;
		for(o=0; o<1000; o++) {
			sprintf(destination, "%s_%03d%s", temp_str, o, GetExtension(dst));
			if(path_info(destination) == _NOT_EXIST) break;
		}
		free(temp_str);
	}
	
	copy_file_prog_bar=0;
	
	struct stat s;
	if(stat(src, &s) != 0) return FAILED; 
	if(S_ISDIR(s.st_mode)) return FAILED;
	lenght = s.st_size;
	
	if(lenght>SPLITSIZE) {
		if(strncmp(dst, "/dev_usb", 8)==0) split=YES;
	}
	if(is_66600(src)==YES && is_66600(dst)==NO) join = YES;
	
	mem = malloc(BUFFSIZE);
	if(mem == NULL) return FAILED;
	
next_file:
	
	if(split) {
		sprintf(destination, "%s.666%02d", dst, cur_file);
	}
	if(f2<0) f2 = ps3ntfs_open(destination, O_WRONLY | O_CREAT | O_TRUNC, 0777);
	if(f2<0) {split=NO; goto skip;}

	if(join) {
		strcpy(temp, src);
		temp[strlen(temp)-2]=0;
		sprintf(source, "%s%02d", temp, cur_file);	
		
		if(0<cur_file) {
			if(stat(source, &s) != 0) {join=NO; goto skip;}
			lenght = s.st_size;
			pos=0;
		}
	}
	
	if(f1<0) f1 = ps3ntfs_open(source, O_RDONLY, 0766);
	if(f1<0) {join=NO; goto skip;}

	while(pos < lenght)
	{
		if(split && pos == SPLITSIZE*(cur_file+1) ) break;
		
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		read = lenght - pos;
		if(split) {
			if(lenght > SPLITSIZE*(cur_file+1))
				read = SPLITSIZE*(cur_file+1) - pos;
		}
		if(read > BUFFSIZE) read = BUFFSIZE;
		
		writed=ps3ntfs_read(f1, mem, read);
		if(read != writed) {ret = FAILED; goto skip;}
		
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		writed=ps3ntfs_write(f2, mem, read);
		if(read != writed) {ret = FAILED; goto skip;}

		pos += read;
		
		copy_file_prog_bar=pos*100/lenght;
		copy_current_size+=read;
	}
	
	if(join) {
		if(f1>=0) {
			ps3ntfs_close(f1);
			f1=-1;
		}
		cur_file++; 
		goto next_file; 
	}
	if(split) {
		if(pos==lenght) goto skip;
		if(f2>=0) {
			ps3ntfs_close(f2);
			f2=-1;
			SetFilePerms(destination);
		}
		cur_file++; 
		goto next_file; 
	}
	
skip:

	copy_file_prog_bar=0;
	
	if(mem) FREE(mem);
	
	if(f1>=0) {
		ps3ntfs_close(f1);
		f1=-1;
	}
	if(f2>=0) {
		ps3ntfs_close(f2);
		f2=-1;
	}
	
	SetFilePerms(destination);
	
	return ret;
}

// fcntl COPY - include <fcntl.h>
// open/read/write/close
u8 CopyFile_fcntl(char* src, char* dst)
{
	u8 ret = SUCCESS;
	u64 lenght = 0LL;
	char *mem = NULL;
	u64 pos = 0ULL;
	u64 rd = 0, writed = 0;
	int f1=-1;
	int f2=-1;
	
	copy_file_prog_bar=0;
	
	struct stat s;
	if(stat(src, &s) != 0) return FAILED; 
	if(S_ISDIR(s.st_mode)) return FAILED;
	lenght = s.st_size;
	
	f1 = open(src, O_RDONLY, 0766);
	if(f1<0) goto skip;

	f2 = open(dst, O_WRONLY | O_CREAT | O_TRUNC, 0777);
	if(f2<0) {close(f1);goto skip;}
	
	mem = malloc(BUFFSIZE);
	if(mem == NULL) return FAILED;

	while(pos < lenght)
	{
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		rd = lenght - pos; 
		if(rd > BUFFSIZE) rd = BUFFSIZE;
		
		writed=read(f1, mem, rd);
		if(rd != writed) {ret = FAILED; goto skip;}
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		writed=write(f2, mem, rd);
		if(rd != writed) {ret = FAILED; goto skip;}

		pos += rd;
		
		copy_file_prog_bar=pos*100/lenght;
		copy_current_size+=rd;
	}

skip:

	copy_file_prog_bar=0;
	
	if(mem) free(mem);
	if(f1) close(f1);
	if(f2) close(f2);

	return ret;
}

// Standard I/O - include <stdio.h>
// fopen/fread/fwrite/fclose
// see mgz_io.h

u8 CopyFile_stdio(char* src, char* dst)
{
	u8 ret = SUCCESS;
	u64 lenght = 0LL;
	char *mem = NULL;
	u64 pos = 0ULL;
	u64 read = 0, writed = 0;
	u8 do_join=NO;
	u8 do_split=NO;
	u8 cur_file=0;
	char temp[1024];
	char source[1024];
	char destination[1024];
	
	FILE* f1=NULL;
	FILE* f2=NULL;
	
	u64 SPLITSIZE = 0xFFFFFFFFULL;
	
	print_debug("start of Copy_stdio");
	
	strcpy(source, src);
	strcpy(destination, dst);
	// create a duplicate instead of erase if it's the same path
	if(strcmp(src, dst)==0) {
		RemoveExtension(destination);
		char *temp_str = strcpy_malloc(destination);
		int o;
		for(o=0; o<1000; o++) {
			sprintf(destination, "%s_%03d%s", temp_str, o, GetExtension(dst));
			if(path_info(destination) == _NOT_EXIST) break;
		}
		free(temp_str);
	} else 
	// OVERWRITE setting
	if( path_info(destination) == _FILE) {
		if( OVERWRITE == OVERWRITE_NEVER ) {
			return SUCCESS;
		} else 
		if( OVERWRITE == OVERWRITE_DUPLICATE) {
			char *temp_str = strcpy_malloc(destination);
			int o;
			for(o=0; o<1000; o++) {
				sprintf(destination, "%s_%03d%s", temp_str, o, GetExtension(dst));
				if(path_info(destination) == _NOT_EXIST) break;
			}
			free(temp_str);
		} else
		if( OVERWRITE == OVERWRITE_ASK ) {
			char question[2048];
			sprintf(question, "%s\n%s: %s", STR_ASK_TO_OVERWRITE, STR_PATH, destination);
			if( DrawDialogYesNo(question) == NO) return SUCCESS;
		}
	}
	
	print_debug("Copy_stdio STAT");
	copy_file_prog_bar=0;
	
	struct stat s;
	if(stat(src, &s) != 0) return FAILED; 
	if(S_ISDIR(s.st_mode)) return FAILED;
	lenght = s.st_size;
	
	if(lenght>SPLITSIZE) do_split = is_FAT32(dst);
	
	if(is_66600(src) && !is_66600(dst)) do_join=YES;
	if(is_splitted_iso(src) && !is_splitted_iso(dst)) do_join=YES;
	
	mem = malloc(BUFFSIZE);
	if(mem == NULL) return FAILED;

next_file:
	
	if(do_split) sprintf(destination, "%s.666%02d", dst, cur_file);
	
	if(do_join) {
		strcpy(temp, src);
		temp[strlen(temp)-2]=0;
		if(is_66600(src)) {
			sprintf(source, "%s%02d", temp, cur_file);	
		} else
		if(is_splitted_iso(src)) {
			sprintf(source, "%s.%d", temp, cur_file);	
		}
		
		if(0<cur_file) {
			if(stat(source, &s) != 0) {
				do_join=NO; 
				goto skip;
			}
			lenght = s.st_size;
			pos=0;
		}
	}
	
	if(f1==NULL) f1 = fopen(source, "rb");
	if(f1==NULL) goto skip;
	
	if(f2==NULL) f2 = fopen(destination, "wb");
	if(f2==NULL) goto skip;
	
	while(pos < lenght) {
		
		if(do_split && pos == SPLITSIZE*(cur_file+1) ) break;
		
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		read = lenght - pos; 
		if(do_split) {
			if(lenght > SPLITSIZE*(cur_file+1))
				read = SPLITSIZE*(cur_file+1) - pos;
		}
		if(read > BUFFSIZE) read = BUFFSIZE;
		
		writed = fread(mem, 1, read, f1);
		if(writed<0) {ret = FAILED; goto skip;}
		
		if(copy_cancel==YES) {ret = FAILED; goto skip;}
		
		if(read != writed) {ret = FAILED; goto skip;}
		
		writed = fwrite(mem, 1, read, f2);

		if(read != writed) {ret = FAILED; goto skip;}
		
		pos += read;
		
		copy_file_prog_bar=pos*100/lenght;
		
		copy_current_size+=read;
	}
	
	if(do_join) {
		FCLOSE(f1);
		cur_file++; 
		goto next_file; 
	}
	
	if(do_split) {
		if(pos==lenght) goto skip;
		FCLOSE(f2);
		SetFilePerms(destination);
		cur_file++; 
		goto next_file; 
	}

skip:
	
	copy_file_prog_bar=0;
	
	FREE(mem);
	FCLOSE(f1);
	FCLOSE(f2);
	
	SetFilePerms(destination);
	
	return ret;
}

void TestCopy(char *src, char *dst, int i)
{
	if(i==0) CopyFile_stdio(src, dst); else
	if(i==1) CopyFile_fcntl(src, dst); else
	if(i==2) CopyFile_sysFs(src, dst); else
	if(i==3) CopyFile_sysFsLv2(src, dst); else
	if(i==4) CopyFile_ps3ntfs(src, dst); else
	if(i==5) CopyFile_async(src, dst);
}

#define CopyFile CopyFile_stdio

void SpeedTest()
{

	char *TestFile = "/dev_hdd0/TEST.BIN";
	
	char dst[128];
	char dst2[128];
	char dst3[128];
	char tmp[128];
	time_t time_start;
	
	u64 previous_size=0;
	
	if(path_info(TestFile) == _NOT_EXIST) return;
	char *copy_speed=NULL;
	
	init_timer(3);
	
	FILE* f=NULL;
	
	f = fopen("/dev_hdd0/speed_test.txt", "wb");
	if(f==NULL) return;
	
	gathering_cancel=YES;
	
	int i,j;
	copy_speed = get_unit(BUFFSIZE);
	sprintf(tmp, "BUFFSIZE = %s\n", copy_speed); fputs(tmp,f); 
	if(copy_speed) free(copy_speed);
	
	for(j=4; j<6; j++) {		
		
		if(j==0) {strcpy(tmp, "*** CopyFile_stdio ***\n"); fputs(tmp,f);} else
		if(j==1) {strcpy(tmp, "\n*** CopyFile_fcntl ***\n"); fputs(tmp,f);} else
		if(j==2) {strcpy(tmp, "\n*** CopyFile_sysFs ***\n"); fputs(tmp,f);} else
		if(j==3) {strcpy(tmp, "\n*** CopyFile_sysFsLv2 ***\n"); fputs(tmp,f);} else
		if(j==4) {strcpy(tmp, "\n*** CopyFile_ps3_ntfs ***\n"); fputs(tmp,f);} else
		if(j==5) {strcpy(tmp, "\n*** CopyFile_async ***\n"); fputs(tmp,f);}		 

		strcpy(tmp, "HDD0 to HDD0"); fputs(tmp,f); 
		
		strcpy(dst, "/dev_hdd0/tmp/DST.BIN");
		
		start_timer(3);
		time_start = time(NULL);
		TestCopy(TestFile, dst, j);
		copy_speed = get_unit((copy_current_size-previous_size)*1000/get_time(3));
		sprintf(tmp, " = %s/s\n", copy_speed); fputs(tmp,f); 
		sprintf(tmp, "temps : %ds\n", (int)(time(NULL)-time_start)); fputs(tmp,f); 
		if(copy_speed) free(copy_speed);
		previous_size=copy_current_size;
		
		Delete(dst);
		
		strcpy(tmp, "HDD0 to HDD1"); fputs(tmp,f); 
		
		strcpy(dst, "/dev_hdd1/DST.BIN");
		
		start_timer(3);
		time_start = time(NULL);
		TestCopy(TestFile, dst, j);
		copy_speed = get_unit((copy_current_size-previous_size)*1000/get_time(3));
		sprintf(tmp, " = %s/s\n", copy_speed); fputs(tmp,f);
		sprintf(tmp, "temps : %ds\n", (int)(time(NULL)-time_start)); fputs(tmp,f); 
		if(copy_speed) free(copy_speed);
		previous_size=copy_current_size;
		
		Delete(dst);
		
		for(i=0; i<=device_number; i++) {
			if(strstr(list_device[i], "dev_hdd0") != NULL) continue;
			
			sprintf(tmp, "HDD0 to %s", list_device[i]); fputs(tmp,f); 
			
			sprintf(dst, "/%s/DST.BIN", list_device[i]);
			
			start_timer(3);
			time_start = time(NULL);
			TestCopy(TestFile, dst, j);
			copy_speed = get_unit((copy_current_size-previous_size)*1000/get_time(3));
			sprintf(tmp, " = %s/s\n", copy_speed); fputs(tmp,f);
			sprintf(tmp, "temps : %ds\n", (int)(time(NULL)-time_start)); fputs(tmp,f);
			if(copy_speed) free(copy_speed);
			previous_size=copy_current_size;
			
			sprintf(tmp, "%s to HDD0", list_device[i]); fputs(tmp,f); 
			
			strcpy(dst2, "/dev_hdd0/tmp/DST.BIN");
			
			start_timer(3);
			time_start = time(NULL);
			TestCopy(dst, dst2, j);
			copy_speed = get_unit((copy_current_size-previous_size)*1000/get_time(3));
			sprintf(tmp, " = %s/s\n", copy_speed); fputs(tmp,f);
			sprintf(tmp, "temps : %ds\n", (int)(time(NULL)-time_start)); fputs(tmp,f);
			if(copy_speed) free(copy_speed);
			previous_size=copy_current_size;
			
			sprintf(tmp, "%s to %s", list_device[i], list_device[i]); fputs(tmp,f); 
			
			sprintf(dst3, "/%s/DST2.BIN", list_device[i]);
			
			start_timer(3);
			time_start = time(NULL);
			TestCopy(dst, dst3, j);
			copy_speed = get_unit((copy_current_size-previous_size)*1000/get_time(3));
			sprintf(tmp, " = %s/s\n", copy_speed); fputs(tmp,f);
			sprintf(tmp, "temps : %ds\n", (int)(time(NULL)-time_start)); fputs(tmp,f);
			if(copy_speed) free(copy_speed);
			previous_size=copy_current_size;
			
			Delete(dst);
			Delete(dst2);
			Delete(dst3);
		}
	}
	if(f) {fclose(f); f=NULL;}
}

u8 JOIN = NO;
u8 Copy(char *src, char *dst)
{
	
	if(copy_cancel) return FAILED;
	
	u8 info_file = path_info(src);
	
	if(info_file == _NOT_EXIST) return FAILED; else
	if(info_file == _FILE) {
		char *tmp;
		tmp = strrchr(src,'/');
		tmp = &tmp[1];
		strcpy(copy_file, tmp);
		
		if( JOIN ) {
			if(is_FAT32(dst)==NO) {
				if(is_666XX(src) || is_splitted_iso_X(src) ) return SUCCESS;
				
				if(is_66600(src) && is_66600(dst)) dst[strlen(dst)-6]=0;
				if(is_splitted_iso(src) && is_splitted_iso(dst)) dst[strlen(dst)-2]=0;
			}
		}
		
		return CopyFile(src, dst);
	}

	char temp_src[255];
	char temp_dst[255];
	
	print_debug("Copy MGZ_mkdir_recursive");
	MGZ_mkdir_recursive(dst);
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(src);
	if(d==NULL) return FAILED;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		sprintf(temp_src, "%s/%s", src, dir->d_name);
		sprintf(temp_dst, "%s/%s", dst, dir->d_name);
		
		if(dir->d_type & DT_DIR) mkdir(temp_dst, 0777);
		
		if( Copy(temp_src, temp_dst) == FAILED) {closedir(d); return FAILED;}
		
		if(copy_cancel==YES) break;
		
	}
	closedir(d);
	
	if(copy_cancel==YES) return FAILED;
	
	return SUCCESS;
	
}

u8 CopyJoin(char *src, char *dst)
{
	JOIN = YES;
	u8 ret = Copy(src, dst);
	JOIN = NO;
	return ret;
}

u8 Move(char *src, char *dst)
{
	if( copy_cancel ) return FAILED;
	
	char dev_src[30];
	char dev_dst[30];
	
	memcpy(dev_src, src, 29);
	memcpy(dev_dst, dst, 29);
	
	if(dev_src[0]=='/') strtok(&dev_src[1], "/");
	else strtok(dev_src, "/");
	if(dev_dst[0]=='/') strtok(&dev_dst[1], "/");
	else strtok(dev_dst, "/");

	if(strcmp(dev_src, dev_dst) == 0) {
		if( rename(src, dst) != 0) return FAILED;
	} else {
		if(Copy(src, dst) == FAILED) return FAILED;
		Delete(src);
	}
	
	return SUCCESS;
}

//*********************************************
// GAME LIST
//*********************************************

void free_GAMELIST()
{
	s64 i;
	for(i=0; i<=game_number; i++) {
		FREE(list_game_path[i]);
		FREE(list_game_title[i]);
		FREE(list_game_ID[i]);
	}
	
	FREE(list_game_path);
	FREE(list_game_title);
	FREE(list_game_ID);
	FREE(list_game_platform);
	FREE(list_game_havepic);
}

void sort_GAMELIST()
{
	print_load("Sorting the game list");
	
	int min; 
	char ta[512], tb[512];
	u8 t;
	int i, j;
	for (i = 0; i<game_number; i++) { 
		min = i;
		for (j = i+1; j <= game_number; j++) { 
			strcpy(ta , list_game_title[j]);
			strcpy(tb, list_game_title[min]);
			if(ta[0]>=97 && ta[0]<=123) ta[0]-=32;
			if(tb[0]>=97 && tb[0]<=123) tb[0]-=32;
			
			if (strcmp(ta, tb) < 0) min = j;
		}
		if(min==i) continue;
		
		strcpy(ta , list_game_title[min]);
		
		FREE(list_game_title[min]);
		list_game_title[min] = strcpy_malloc(list_game_title[i]);
		
		FREE(list_game_title[i]);
		list_game_title[i] = strcpy_malloc(ta); 
		
		strcpy(tb, list_game_path[min]);
		
		FREE(list_game_path[min]);
		list_game_path[min] = strcpy_malloc(list_game_path[i]);
		
		FREE(list_game_path[i]);
		list_game_path[i] = strcpy_malloc(tb);
		
		strcpy(tb, list_game_ID[min]);
		
		FREE(list_game_ID[min]);
		list_game_ID[min] = strcpy_malloc(list_game_ID[i]);
		
		FREE(list_game_ID[i]);
		list_game_ID[i] = strcpy_malloc(tb);
		
		t = list_game_platform[min];
		list_game_platform[min] = list_game_platform[i];
		list_game_platform[i] = t;
		
		t = list_game_havepic[min];
		list_game_havepic[min] = list_game_havepic[i];
		list_game_havepic[i] = t;
	}
	
}

void add_GAMELIST(char *path)
{
	u8 plat = get_platform(path);
	
	if( plat != BDVD    &&
		plat != JB_PS3  &&
		plat != JB_PS2  &&
		plat != JB_PS1  &&
		plat != JB_PSP  &&
		plat != ISO_PS3 &&
		plat != ISO_PS2 &&
		plat != ISO_PS1 &&
		plat != ISO_PSP 
	  ) return;	
	
	game_number++;
	list_game_path = (char **) realloc(list_game_path, (game_number+1) * sizeof(char *));
	list_game_title = (char **) realloc(list_game_title, (game_number+1) * sizeof(char *));
	list_game_ID = (char **) realloc(list_game_ID, (game_number+1) * sizeof(char *));
	list_game_platform = (u8 *) realloc(list_game_platform, (game_number+1) * sizeof(u8) );
	list_game_havepic = (u8 *) realloc(list_game_havepic, (game_number+1) * sizeof(u8) );
	
	list_game_path[game_number] = strcpy_malloc(path);
	list_game_platform[game_number] = plat;
	
	char title[512];
	memset(title, 0, 512);
	strcpy(title, &strrchr(path, '/')[1]);
	RemoveExtension(title);
	
	if(plat == ISO_PS3 || plat == JB_PS3 || plat == ISO_PSP || plat == JB_PSP || plat == BDVD) {
		if( GetParamSFO("TITLE", title, list_game_path[game_number]) == FAILED) {
			print_debug("Error : failed to get TITLE from %s", list_game_path[game_number]);	
		}
	}
	list_game_title[game_number] = strcpy_malloc(title);
	
	char ID[20]={0};
	if( Get_ID(list_game_path[game_number], list_game_platform[game_number], ID) == SUCCESS) {
		list_game_ID[game_number] = strcpy_malloc(ID);
	} else {
		list_game_ID[game_number] = strcpy_malloc("MGZ_ERROR.404");
	}
	
	//list_game_havepic[game_number] = Have_GAMEPIC(game_number); 
	list_game_havepic[game_number] = GAMEPIC_NONE;
}

void remove_GAMELIST(s64 pos)
{
	if(pos>game_number) return;
	
	s64 i;
	for(i=pos; i<game_number; i++) {
		FREE(list_game_path[i]);
		list_game_path[i] = strcpy_malloc(list_game_path[i+1]);
		
		FREE(list_game_title[i]);
		list_game_title[i] = strcpy_malloc(list_game_title[i+1]);
		
		FREE(list_game_ID[i]);
		list_game_ID[i] = strcpy_malloc(list_game_ID[i+1]);
		
		list_game_platform[i] = list_game_platform[i+1];
		
		list_game_havepic[i] = list_game_havepic[i+1];
	}
	
	FREE(list_game_title[game_number]);
	FREE(list_game_path[game_number]);
	FREE(list_game_ID[game_number]);
	
	if(position == pos ) position++;
	
	game_number--;
	if(position > game_number) position = game_number;
	
	for(i=0; i<GAMEPIC_MAX; i++) {
		if( GAMEPIC_SLOT_POS[i] == pos ) {
			GAMEPIC_SLOT_POS[i] = -1;
			GAMEPIC_offset[i]=0;
			break;
		}
	}
	for(i=0; i<GAMEPIC_MAX; i++) {
		if( pos < GAMEPIC_SLOT_POS[i] ) {
			GAMEPIC_SLOT_POS[i]--;
		}
	}
}

void get_GAMELIST(char *scan_path)
{
	print_load("Scanning : %s", scan_path);
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(scan_path);
	if(d==NULL) return;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;

		print_head("[%03d] %s", game_number+1, dir->d_name);
				
		if(game_number+2==MAX_GAME) {
			print_load("Warning : too many games !");
			break;
		}
		
		char temp[512];
		sprintf(temp, "%s/%s" , scan_path, dir->d_name);
		
		char *ext = get_ext(temp);
		
		if( strcmp(ext, _SDIR) == 0) {
			get_GAMELIST(temp);
		} else {
			add_GAMELIST(temp);
		}
	}
	closedir(d);
}

void remove_SCANDIR(char *scan_path)
{
	char temp[128];
	int i, j;
	for(i=0; i<=device_number; i++) {
		
		memset(temp, 0, sizeof(temp));
		sprintf(temp, "/%s/%s", list_device[i], scan_path);
		
		for(j=0; j<=game_number;  j++) {
			if(strncmp(temp, list_game_path[j], strlen(temp))==0) {
				remove_GAMELIST(j);
			}
		}
	}
}

void add_SCANDIR(char *scan_path)
{
	char temp[128];
	int i;
	for(i=0; i<=device_number; i++) {
		
		memset(temp, 0, sizeof(temp));
		sprintf(temp, "/%s/%s", list_device[i], scan_path);
		
		get_GAMELIST(temp);
	}
	
	sort_GAMELIST();
}

int GetPosition_GAMELIST(char *path)
{
	int j;
	int len = strlen(path);
	for(j=0; j<=game_number;  j++) {
		if(strncmp(path, list_game_path[j], len)==0) {
			return j;
		}
	}
	return -1;
}

void Load_GAMELIST()
{
	free_GAMELIST();
	game_number=-1;
	
	if( path_info("/dev_bdvd") != _NOT_EXIST ) add_GAMELIST("/dev_bdvd");
	
	//if( path_info("/dev_ps2dvd") != _NOT_EXIST ) add_GAMELIST("/dev_ps2dvd");
	
	int i, j;
	char scan_path[128];
	//get game list
	for(j=0; j<=scan_dir_number; j++) {
		for(i=0; i<=device_number; i++) {
		
			memset(scan_path,0, sizeof(scan_path));
			sprintf(scan_path, "/%s/%s", list_device[i], scan_dir[j]);
			
			get_GAMELIST(scan_path);
		}
	}
	
	sort_GAMELIST();
}

void Copy_Game(char *src, char *dst)
{	
	strcpy(copy_src, src);
	strcpy(copy_dst, dst);
	
	mkdir(copy_dst, 0777);
	
	if( strcmp(src, "/dev_bdvd") == 0) {
		char DstDirName[255]={0};
		
		if( strcmp(src, list_game_path[position]) == 0) {
			sprintf(DstDirName, "%s [%s]", list_game_title[position], list_game_ID[position]);
		} else {
			char title[512]={0};
			if( GetParamSFO("TITLE", title, src) == FAILED) {
				start_loading();
				print_load("Error : failed to get TITLE from %s", src);	
				end_loading();
				return;
			}
			char ID[20]={0};
			if( GetParamSFO("TITLE_ID", ID, src) == FAILED) {
				start_loading();
				print_load("Error : failed to get TITLE_ID from %s", src);	
				end_loading();
				return;
			}
			sprintf(DstDirName, "%s [%s]", title, ID);
		}
		
		if(Get_OSK_String(STR_RENAME, DstDirName, 255) == SUCCESS) {
			if(DstDirName[0] != 0) {
				strcat(copy_dst, "/");
				strcat(copy_dst, DstDirName);
			} else {
				start_loading();
				print_load("Error : failed to get DstDirName");
				end_loading();
				return;
			}
		} else {
			show_msg(STR_CANCELLED);
			return;
		}
	} else {
		char *tmp = strrchr(copy_src, '/');
		strcat(copy_dst, tmp);
	}
	
	start_gathering();
	Get_Game_Size(copy_src);
	end_gathering();
	
	if( gathering_cancel == NO ) {
		if( GetFreeSpace(copy_dst) < gathering_total_size ) {
			show_msg("Not enough space!");
			reset_gathering();
			return;
		}
	}
	
	start_copy_loading();
	CopyJoin(copy_src, copy_dst);

	//if(ret==SUCCESS) 
	if( (gathering_total_size <= copy_current_size && copy_current_size != 0) 
	||	(gathering_cancel == YES && copy_cancel==NO && copy_current_size > 0) ) {
	
		add_GAMELIST(copy_dst);
		sort_GAMELIST();
		init_Load_GAMEPIC();
		read_fav();
			
		show_msg(STR_DONE);
	} else {
		Delete_Game(copy_dst, -1);
		
		if(copy_cancel==YES) show_msg(STR_CANCELLED); else 
		show_msg(STR_FAILED);
	}
	
	end_copy_loading();

}

void Draw_GameProperties()
{
	char *tot_size = get_unit(gathering_total_size);
	char sys_vers[64];
	memset(sys_vers, 0, 64);
	if(list_game_platform[position] == JB_PS3 || list_game_platform[position] == ISO_PS3 || list_game_platform[position] == BDVD) {
		char tmp[10];
		if(GetParamSFO("PS3_SYSTEM_VER", tmp, list_game_path[position])==SUCCESS) {
			float f;
			sscanf(tmp, "%f", &f);
			sprintf(sys_vers, "%.2f", f);
		} else strcpy(sys_vers, STR_UNKNOWN);
	}
	
	char *Ext = GetExtension(list_game_path[position]);
	char format_type[32]={0};
	
	if( !strncasecmp(Ext, ".iso", 4) )	{
		strcpy(format_type, "ISO");
	} else	
	if( !strncasecmp(Ext, ".bin", 4) )	{
		strcpy(format_type, "BIN");
	} else
	if( !strncasecmp(Ext, ".mdf", 4) )	{
		strcpy(format_type, "MDF");
	} else
	if( !strncasecmp(Ext, ".img", 4) )	{
		strcpy(format_type, "IMG");
	} else
	if( !strncasecmp(Ext, ".cso", 4) )  {
		strcpy(format_type, "CSO");
	} else
	if( list_game_platform[position]==BDVD) {
		strcpy(format_type, "BLU-RAY");
	} else {
		strcpy(format_type, "JB");			
	}
	
	u8 LoopBreak=1;
	while(LoopBreak) {
		
		cls();
		
		Draw_BGS();
		Draw_GAMEPIC(position, GAMEPIC_ICON0 | GAMEPIC_COVER2D, 630, 30, 100, 141.3, 0, NO, WHITE);
		
		int x1=50, y=40;
		int xt;
		
		Draw_Box(x1+5, y+4, 0, 0, 8, 8, COLOR_3, NO);
		FontColor(COLOR_3);
		FontSize(18);
		xt=DrawString(x1+20, y, STR_GAME_PROP);
		y+=new_line(1);
		Draw_Box(x1, y, 0, 0, xt-x1, 2, COLOR_3, NO);

		y+=new_line(2);
		
		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_GAME_TITLE);
		FontColor(COLOR_1);
		DrawTXTinLineBox(xt+10, y, 0, X_MAX-xt-10, list_game_title[position], 0, COLOR_1);
		
		y+=new_line(1);
		
		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_GAME_PATH);
		FontColor(COLOR_1);
		DrawString(xt+10 , y,  list_game_path[position]);
		
		y+=new_line(1);
		
		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_GAME_PLATFORM);
		FontColor(COLOR_1);
		if(list_game_platform[position] == BDVD || list_game_platform[position] == JB_PS3 || list_game_platform[position] == ISO_PS3) {
			DrawString(xt+10 , y,  "PlayStation 3");
		} else
		if(list_game_platform[position] == JB_PS2 || list_game_platform[position] == ISO_PS2) {
			DrawString(xt+10 , y,  "PlayStation 2");
		} else
		if(list_game_platform[position] == JB_PS1 || list_game_platform[position] == ISO_PS1) {
			DrawString(xt+10 , y,  "PlayStation");
		} else
		if(list_game_platform[position] == JB_PSP || list_game_platform[position] == ISO_PSP) {
			DrawString(xt+10 , y,  "PlayStation Portable");
		} else DrawString(xt+10 , y,  STR_UNKNOWN);
		
		y+=new_line(1);
		
		
		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_GAME_FORMAT);
		FontColor(COLOR_1);
		DrawString(xt+10 , y, format_type);
		
		y+=new_line(1);
		
		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_GAME_SIZE);
		FontColor(COLOR_1);
		DrawString(xt+10 , y, tot_size);
		
		y+=new_line(1);
		
		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_FILES);
		FontColor(COLOR_1);
		DrawFormatString(xt+10 , y,  "%d", gathering_nb_file);
		
		y+=new_line(1);
		
		if(iso==NO) {
			FontColor(COLOR_3);
			xt=DrawFormatString(x1 , y, "%s :", STR_DIRS);
			FontColor(COLOR_1);
			DrawFormatString(xt+10 , y,  "%d", gathering_nb_directory);
			
			y+=new_line(1);
		}
		
		
		if(list_game_platform[position] == BDVD || list_game_platform[position] == JB_PS3 || list_game_platform[position] == ISO_PS3) {
			FontColor(COLOR_3);
			xt=DrawFormatString(x1 , y, "%s :", STR_SYSVERS);
			FontColor(COLOR_1);
			DrawString(xt+10 , y, sys_vers);
			
			y+=new_line(1);
		}

		FontColor(COLOR_3);
		xt=DrawFormatString(x1 , y, "%s :", STR_GAMEID);
		FontColor(COLOR_1);
		DrawString(xt+10 , y, list_game_ID[position]);
		
		y+=new_line(1);
		
		if(list_game_platform[position] == ISO_PS2) {
		
			
			FontColor(COLOR_3);
			xt=DrawFormatString(x1 , y, "%s :", STR_ELFCRC);
			FontColor(COLOR_1);
			DrawFormatString(xt+10 , y,  "%08X", PS2CRC);
			
			y+=new_line(1);
			
			if(PS2CRC != PS2ORICRC) {
				FontColor(COLOR_3);
				xt=DrawFormatString(x1 , y, "%s :", STR_ELFCRCO);
				FontColor(COLOR_1);
				DrawFormatString(xt+10 , y,  "%08X",PS2ORICRC);
				
				y+=new_line(1);
			}
			
		}
		
		x1=INPUT_X;
		y=INPUT_Y;
		FontColor(COLOR_1);
		SetFontZ(0);
		
		x1=DrawButton(x1, y, STR_BACK , BUTTON_CIRCLE);
		
		tiny3d_Flip();
		ScreenShot();
		ps3pad_read();
		
		if(NewPad(BUTTON_CIRCLE)) {
			LoopBreak = 0;
			return;
		}
	}
	reset_gathering();
}

#define DUMPER_BUFFSIZE		0x10000

void dump_lv1(char *path)
{
	FILE* f=NULL;
	u64 i, j;
	char temp[512];
		
	char *date = get_date();
	if( date == NULL) {
		print_load("Error : failed to get_date");
		return;
	}
	
	sprintf(temp, "%s/%s_%X_LV1.BIN", path, date, firmware);
	
	FREE(date);
	remove(temp);
	
	f=fopen(temp, "wb");
	if(f==NULL) {
		print_load("Error : cannot fopen %s", temp);
		return;
	}
	
	prog_bar1_value = 0;
	
	u64 data[DUMPER_BUFFSIZE];
	
	for(i=0x0ULL ; i < 0x1000000ULL; i+= 0x8 * DUMPER_BUFFSIZE ) {
		memset(data, 0, DUMPER_BUFFSIZE*8);
		
		for( j = 0; j < DUMPER_BUFFSIZE; j++) {
			data[j]=lv1peek(i+j*0x8);
		}
		
		fwrite(&data, sizeof(u64), DUMPER_BUFFSIZE, f);
		
		prog_bar1_value = ((i+j)*100)/0x1000000ULL;
		if(cancel==YES) break;
	}
	fclose(f);
	
	if(cancel==YES) {
		Delete(temp);
		cancel=NO;
	}
}


void dump_lv2(char *path)
{
	FILE* f=NULL;
	u64 i, j;
	char temp[512];
		
	char *date = get_date();
	if( date == NULL) {
		print_load("Error : failed to get_date");
		return;
	}
	
	sprintf(temp, "%s/%s_%X_LV2.BIN", path, date, firmware);
	
	FREE(date);
	remove(temp);
	
	f=fopen(temp, "wb");
	if(f==NULL) {
		print_load("Error : cannot fopen %s", temp);
		return;
	}
	
	prog_bar1_value = 0;
	
	u64 data[DUMPER_BUFFSIZE];
	
	for(i=0 ; i < 0x800000ULL; i+= 0x8 * DUMPER_BUFFSIZE ) {
		memset(data, 0, DUMPER_BUFFSIZE*8);
		
		for( j = 0; j < DUMPER_BUFFSIZE; j++) {
			data[j]=lv2peek(0x8000000000000000ULL + i+j*0x8);
		}
		fwrite(&data, sizeof(u64), DUMPER_BUFFSIZE, f);
		
		
		prog_bar1_value = ((i+j)*100)/0x800000;
		if(cancel==YES) break;
	}
	fclose(f);
	
	if(cancel==YES) {
		Delete(temp);
		cancel=NO;
	}
}

void dump_flash(char *path)
{
	FILE* f;
	
	int source=0;
	u32 read;
	u64 sector[0x40];
	int ret = -1;
	u64 i;
	u64 size_dump;
	u64 flash_id;
	u32 mode;
	char temp[255];
	u32 offset;
	
	ret = sys_storage_open( FLASH_NOR, &source );
    if( ret == 0 ) {
		flash_id = FLASH_NOR;
		offset = 0x178;
		size_dump=0x8000;
	} else {
		sys_storage_close( source );
		ret = sys_storage_open( FLASH_NAND, &source);
		if( ret != 0 ) return;
		flash_id = FLASH_NAND;
		size_dump=0x77E00;
		offset = 0x204;
	}
	
	sys_storage_read(source, offset, 0x1, sector, &read, 0x22 );
	
	if(0x0000000100820000 <= sector[0x0E] && sector[0x0E] < 0x0000000100830000) {
		mode = 0xD;
	} else {
		mode = 0xC;	
	}
	
	if( flash_id == FLASH_NOR ) {
		sprintf(temp, "%s/%XEX-FLASH.NOR.BIN", path, mode);
	} else {
		sprintf(temp, "%s/%XEX-FLASH.NAND.BIN", path, mode);
	}
	
	f = fopen(temp, "wb");
	if(f==NULL) {
		print_load("Error: failed to open %s", temp);
		goto error;
	}
	
	task_Init(size_dump * 0x200ULL);
	for(i=0x0; i < size_dump; i+=0x1) {
		sys_storage_read( source, i, 0x1, sector, &read, 0x22 );
		fwrite(sector, 0x200, 1, f);
		task_Update(0x200ULL);
		if(cancel) break;
	}
	task_End();
	
error:

	FCLOSE(f);
	if(source) sys_storage_close(source);
	
	if(cancel) Delete(temp);
}

u8 *Load_from_device(u32 start_offset, u32 size, u32 device_id, u32 sector_size)
{
	int source;
	if( sys_storage_open( device_id, &source) != 0) {
		print_load("Error : Load_from_device sys_storage_open");
		return NULL;
	}
	
	u8 *data = (u8 *) malloc(size);
	if(data==NULL) {
		print_load("Error : Load_from_device malloc");
		sys_storage_close(source);
		return NULL;
	}
	
	u32 read;
	u32 dumped = 0;
	u8 buffer[ sector_size ];
	
	u32 sector_id = start_offset / sector_size;
	
	u32 start_sector_offset = start_offset - (sector_id * sector_size);
		
	u32 end_offset = start_offset + size;
	
	u32 end_sector_id = end_offset / sector_size ;
	u32 end_sector_offset = end_offset - (end_sector_id * sector_size);
	
	
	u32 start = start_sector_offset;
	
	while(sector_id <= end_sector_id ) {
		
		memset(buffer, 0, 0x200);

		sys_storage_read( source, sector_id, 1,  buffer, &read, 0x22 );
		
		u32 cpy_size = sector_size - start;
		
		if(sector_id == end_sector_id ) cpy_size = end_sector_offset - start;
		
		memcpy(data + dumped, &buffer[start], cpy_size);
		
		dumped += cpy_size;
		
		start = 0;
		sector_id++;
	}
	
	if( dumped != size ) {
		print_load("Error : Load_from_device dumped != size");
		FREE(data);
		sys_storage_close(source);
		return NULL;
	}
	
	sys_storage_close(source);
	
	return data;
}

// https://www.psdevwiki.com/ps3/Flash

#define FLASH_SECTOR_SIZE	0x200

u8 *Load_from_flash(u64 start_offset, u16 size, int source)
{
	u8 *data = (u8 *) malloc(size);
	if(data==NULL) {
		print_load("Error : load_from_flash malloc");
		return NULL;
	}
	
	u32 read;
	u32 dumped = 0;
	u8 buffer[ FLASH_SECTOR_SIZE ]={0};
	
	u32 sector_id = start_offset / FLASH_SECTOR_SIZE;
	u32 start_sector_offset = start_offset - (sector_id * FLASH_SECTOR_SIZE);
	u32 end_offset = start_offset + size;
	u32 end_sector_id = end_offset / FLASH_SECTOR_SIZE ;
	u32 end_sector_offset = end_offset - (end_sector_id * FLASH_SECTOR_SIZE);
	u32 start = start_sector_offset;
	
	while(sector_id <= end_sector_id ) {
		
		memset(buffer, 0, FLASH_SECTOR_SIZE);
		
		int ret = sys_storage_read( source, sector_id, 1, buffer, &read, 0x22 );
		if( ret != 0 ) {
			print_load("Error : sys_storage_read failed");
			FREE(data);
			return NULL;
		}
		u32 cpy_size = FLASH_SECTOR_SIZE - start;
		
		if(sector_id == end_sector_id ) cpy_size = end_sector_offset - start;
		
		memcpy(data + dumped, &buffer[start], cpy_size);
		
		dumped += cpy_size;
		
		start = 0;
		sector_id++;
	}
	
	if( dumped != size ) {
		print_load("Error : load_from_flash dumped != size");
		FREE(data);
		return NULL;
	}
	
	return data;
}

u8 *get_eid4()
{	
	int source;
	u64 offset;
    
    int ret = 1;

    ret = sys_storage_open( FLASH_NOR, &source );
    if( ret == 0 ) {
		offset = 0x303A0ULL;
	} else {
		offset = 0x81BA0ULL - 0x40000ULL; //without bootldr
		sys_storage_close( source );
		sys_storage_open( FLASH_NAND, &source );
	}
	
    u8 *eid4 = Load_from_flash(offset, 0x30, source);
	
	sys_storage_close( source );
	
	return eid4;
	
	
}
#define Path_3Dump	"/dev_hdd0/tmp/3Dump.bin"
#define Path_ERK	"/dev_hdd0/tmp/eid_root_key"

u8 dump_3Dump()
{
	if( path_info( Path_3Dump ) == _FILE ) {
		print_debug("* 3Dump.bin found");
		return SUCCESS;
	}
	
	if( path_info( Path_ERK ) == _FILE ) {
		// todo : check it  !
	} else {
		if( dump_eid_root_key(Path_ERK) == FAILED) {
			print_load("Error : dump_eid_root_key failed");
			return FAILED;
		}
	}
	
	int size;
	char *erk = LoadFile(Path_ERK, &size);
	if( erk == NULL) {
		print_load("Error : dump_3Dump, load eid_root_key");
		return FAILED;
	}
	
	u8 *eid4 = get_eid4();
	if( eid4 == NULL) {
		print_load("Error : get_eid4 failed");
		FREE(erk);
		return FAILED;
	}
	
	mkdir("/dev_hdd0/tmp", 0777);
	
	FILE *f;
	
	f=fopen(Path_3Dump, "wb");
	if(f==NULL) {
		print_load("Error : dump_3Dump, fopen 3Dump.bin");
		FREE(erk);
		FREE(eid4);
		return FAILED;
	}
	
	fwrite(eid4, 0x30, 1,  f);
	fwrite(erk, 0x30, 1, f);
	fclose(f);
	
	SetFilePerms(Path_3Dump);
	
	return SUCCESS;
}

u8 *Load_3Dump()
{
	if( dump_3Dump() == FAILED )  {
		print_load("Error : dump_3Dump failed");
		return NULL;
	}
	
	int size;
	
	return (u8 *) LoadFile(Path_3Dump, &size);
}

u8 SetFilePerms(char *path)
{
	if(is_ntfs(path)) return SUCCESS;
	if(is_exFAT(path)) return !f_chmod(path, 0, AM_RDO | AM_ARC | AM_SYS | AM_HID);
	if(sysLv2FsChmod(path, FS_S_IFMT | 0777)==0 && sys_fs_chown(path, NO_UID, NO_GID)==0) return SUCCESS;
	
	return FAILED;
}

u8 SetDirPerms(char *path)
{
	if(is_ntfs(path)) return SUCCESS;
	if(is_exFAT(path)) return !f_chmod(path, 0, AM_RDO | AM_ARC | AM_SYS | AM_HID);
	if(sysLv2FsChmod(path, FS_S_IFDIR | 0777)==0 && sys_fs_chown(path, NO_UID, NO_GID)==0) return SUCCESS;
	
	return FAILED;
}

u8 SetPerms(char* path)
{
	if(is_ntfs(path)) return SUCCESS;
	
	u8 f_info = path_info(path);
	
	if(f_info == _FILE) return SetFilePerms(path);
	else if(f_info == _NOT_EXIST) return FAILED;
	
	SetDirPerms(path);
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(path);
	if(d==NULL) {
		print_load("Error: Cannot open dir %s",  path);
		return FAILED;
	}
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
	
		char newpath[0x440];
		sprintf(newpath, "%s/%s", path, dir->d_name);
		
		if(cancel==YES) {
			cancel=NO;
			closedir(d);
			return FAILED;
		}
		
		if (dir->d_type & DT_DIR) {
			print_load("Fix permissions dir = %s", dir->d_name);
			if(SetPerms(newpath) == FAILED) {
				closedir(d);
				return FAILED;
			}
		}
		else {
			print_load("Fix permissions file = %s", dir->d_name);
			SetFilePerms(newpath);
		}
	}
	closedir(d);
	
	return SUCCESS;
}

uint32_t reverse32(uint32_t val)
{
   return ((val>>24)&0x000000FF) | ((val>>8)&0x0000FF00) | ((val<<8)&0x00FF0000) | ((val<<24)&0xFF000000);
}

uint16_t reverse16(uint16_t val)
{
   return (((val>>8)&0x00FF) | ((val<<8)&0xFF00));
}

uint32_t convert32(char * bytes) {
	return (uint32_t) bytes[0] <<24 | (uint32_t) bytes[1]<<16 |  (uint32_t) bytes[2]<<8 | (uint32_t) bytes[3];
}

uint16_t convert16(char * bytes) {
	return (uint16_t) bytes[0]<<8 | (uint16_t) bytes[1];
}

FILE* openSFO(char *path, u32 *start_offset, u32 *size, char *mode)
{
	FILE* sfo=NULL;
	
	char *ext = get_ext(path);
	
	if( strcmp(ext, _ISO_PS3) && strcmp(ext, _ISO_PSP) && strcmp(ext, _JB_PS3) && strcmp(ext, _BDVD) && strcmp(ext, _JB_PSP) && strcasecmp(ext, ".sfo")) return NULL;
	
	if(!strcasecmp(ext, ".sfo")) {
		sfo = fopen(path, mode);
		if(sfo==NULL) {
			SetPerms(path);
			sfo = fopen(path, mode);
		}
		if(sfo==NULL) return NULL;
		
		fseek(sfo , 0 , SEEK_END);
		*size = ftell (sfo);
		fseek(sfo, 0, SEEK_SET);
		
		*start_offset=0;
		
		return sfo;
	} else 
	if(!strcmp(ext, _ISO_PS3)) {
		sfo = fopen(path, mode);
		if(sfo==NULL) {
			SetPerms(path);
			sfo = fopen(path, mode);
			if(sfo == NULL) return NULL;
		}
		u64 file_offset=0;
		u8 ret=0;
		int file_size=0;
		
		ret = get_FileOffset(sfo, "/PS3_GAME/PARAM.SFO", &file_offset,  (u32 *) &file_size);
	
		if(file_offset==0 || file_size==0 || ret == FAILED) {fclose(sfo); return NULL;}
		
		*start_offset=file_offset;
		*size=file_size;
		
		return sfo;
	} else
	if(!strcmp(ext, _ISO_PSP)) {
		sfo = fopen(path, mode);
		if(sfo==NULL) {
			SetPerms(path);
			sfo = fopen(path, mode);
			if(sfo == NULL) return NULL;
		}
		u64 file_offset=0;
		u8 ret=0;
		int file_size=0;
		
		ret = get_FileOffset(sfo, "/PSP_GAME/PARAM.SFO", &file_offset,  (u32 *) &file_size);
	
		if(file_offset==0 || file_size==0 || ret == FAILED) {fclose(sfo); return NULL;}
		
		*start_offset=file_offset;
		*size=file_size;
		
		return sfo;
	} else
	if(!strcmp(ext, _JB_PS3) || !strcmp(ext, _BDVD)) {
	
		char SFO_path[255];
		
		sprintf(SFO_path, "%s/PS3_GAME/PARAM.SFO", path);
		if(path_info(SFO_path) == _NOT_EXIST) return NULL;
		
		sfo = fopen(SFO_path, mode);
		if(sfo==NULL) {
			SetPerms(SFO_path);
			sfo = fopen(SFO_path, mode);
		}
		if(sfo == NULL) return NULL;		
		
		fseek(sfo , 0 , SEEK_END);
		*size = ftell (sfo);
		fseek(sfo, 0, SEEK_SET);
		
		*start_offset=0;
		
		return sfo;
	} else
	if(!strcmp(ext, _JB_PSP)) {
		char SFO_path[255];
		
		sprintf(SFO_path, "%s/PSP_GAME/PARAM.SFO", path);
		
		sfo = fopen(SFO_path, mode);
		if(sfo==NULL) {
			SetPerms(SFO_path);
			sfo = fopen(SFO_path, mode);
		}
		if(sfo==NULL) return NULL;
		
		fseek(sfo , 0 , SEEK_END);
		*size = ftell (sfo);
		fseek(sfo, 0, SEEK_SET);
		
		*start_offset=0;
		
		return sfo;
	}
	
	return NULL;
}

u8 SetParamSFO(const char *name, char *value, char *path)
{	
	uint32_t key_start;
	uint32_t data_start;
	uint32_t key_name = 0;
	uint32_t data_name = 0;
	uint32_t maxlen_name = 0;
	
	uint32_t temp32 = 0;
	uint16_t temp16 = 0;
	int c, i;
	
	FILE* sfo=NULL;
	u32 sfo_start=0;
	u32 sfo_size=0;
	
	if(path==NULL) return FAILED;
	
	sfo = openSFO(path, &sfo_start, &sfo_size, "rb+");
	if(sfo==NULL) return FAILED;
	
	fseek(sfo, 0x8 + sfo_start, SEEK_SET); 
	fread(&key_start, sizeof(uint32_t), 1, sfo);
	fread(&data_start, sizeof(uint32_t), 1, sfo);
	key_start=reverse32(key_start);
	data_start=reverse32(data_start);
	fseek(sfo, key_start + sfo_start, SEEK_SET);

	do {
		c=fgetc(sfo);
		for(i=0; i <=strlen(name)-1 ; i++) {
			if(c == name[i]) {
				if (i==strlen(name)-1) {
					key_name = ftell(sfo) - strlen(name) - sfo_start;
					goto out;
				}
				c=fgetc(sfo);
			} else break;
		}
	} while (ftell(sfo) - sfo_start < sfo_size);
	
out:
	if(key_name==0) {fclose(sfo); return FAILED;}
	key_name -= key_start;
	fseek(sfo, 0x14 + sfo_start, SEEK_SET );
	
	while(temp16 < key_name) {
		fread(&temp16, sizeof(uint16_t), 1, sfo);
		temp16=reverse16(temp16);
		if(key_name == temp16) break;
		fseek(sfo, 0xE, SEEK_CUR);
	}
	if(temp16 > key_name) {fclose(sfo); return FAILED;}
	
	fseek(sfo, 0x2, SEEK_CUR);
	
	temp32 = reverse32(strlen(value)+1);
	if(strcmp(name, "ITEM_PRIORITY") == 0) temp32 = 0x04000000;
	fwrite(&temp32, sizeof(uint32_t), 1, sfo);
	
	fread(&temp32, sizeof(uint32_t), 1, sfo);
	maxlen_name = reverse32(temp32);

	fread(&temp32, sizeof(uint32_t), 1, sfo);
	temp32 = reverse32(temp32);
	data_name = data_start + temp32;
	
	fseek(sfo, data_name + sfo_start, SEEK_SET);
	
	if(strcmp(name, "ITEM_PRIORITY") == 0) {
		temp32 = 0;
		if(*(u8 *) value==1) temp32=0xFFFFFF7F;
		fwrite(&temp32, sizeof(u32), 1, sfo);
		fclose(sfo);
		return SUCCESS;
	}
	
	char *temp = (char *) malloc(maxlen_name);
	if(temp==NULL) {
		print_load("Error : Failed to malloc");
		fclose(sfo);
		return FAILED;
	}
	memset(temp, 0, maxlen_name);
	memcpy(temp, value, strlen(value));
	fwrite(temp, 1, maxlen_name, sfo);
	fclose(sfo);
	free(temp);
	
	return SUCCESS;
}

FILE* openEBOOT(char *path, u32 *start_offset, char *mode) 
{
	FILE* eboot=NULL;
	
	char *ext = get_ext(path);
	
	if( strcmp(ext, _ISO_PS3) && strcmp(ext, _JB_PS3) && strcmp(ext, _BDVD) && strcmp(ext, _EBOOT_BIN)) return NULL;
	
	if(!strcmp(ext, _EBOOT_BIN)) {
		eboot = fopen(path, mode);
		if(eboot==NULL) {
			SetPerms(path);
			eboot = fopen(path, mode);
			if(eboot==NULL) return NULL;
		}
		*start_offset=0;
		
		return eboot;
	
	} else 
	if(!strcmp(ext, _ISO_PS3))
	{
		eboot = fopen(path, mode);
		if(eboot==NULL) {
			SetPerms(path);
			eboot = fopen(path, mode);
			if(eboot==NULL) return NULL;
		}
		u64 file_offset=0;
		u8 ret=0;
		int file_size=0;
		ret = get_FileOffset(eboot, "/PS3_GAME/USRDIR/EBOOT.BIN", &file_offset, (u32 *) &file_size);
	
		if(file_offset==0 || file_size==0 || ret == FAILED) {fclose(eboot); return NULL;}
		
		*start_offset=file_offset;

		return eboot;
	} else
	if(!strcmp(ext, _JB_PS3) || !strcmp(ext, _BDVD)) {
		char EBOOT_path[255];
		sprintf(EBOOT_path, "%s/PS3_GAME/USRDIR/EBOOT.BIN", path);
		
		eboot = fopen(EBOOT_path, mode);
		if(eboot==NULL) {
			SetPerms(EBOOT_path);
			eboot = fopen(EBOOT_path, mode);
			if(eboot==NULL) return NULL;
		}
		*start_offset=0;
		
		return eboot;
	}
	
	return NULL;
}

u8 patch_EBOOT(char *path)
{
	FILE* eboot=NULL;
	u32 fw_in_eboot;
	u32 start_offset=0;
	//u32 cur_fw = (u32) (c_firmware*10000);
	
	eboot = openEBOOT(path, &start_offset, "rb+");
	if(eboot==NULL) return FAILED;
	
	fseek(eboot, 0x40C+start_offset, SEEK_SET);
	fread(&fw_in_eboot, sizeof(u32), 1, eboot);
	
	if(fw_in_eboot > 99900) {
		fseek(eboot, 0x42C+start_offset, SEEK_SET);
		fread(&fw_in_eboot, sizeof(u32), 1, eboot);
		if(fw_in_eboot > 99900) return FAILED;
		fseek(eboot, 0x42C+start_offset, SEEK_SET);
	} else fseek(eboot, 0x40C+start_offset, SEEK_SET);
	
	//if(cur_fw >= fw_in_eboot) return SUCCESS; //useless to patch it.
	
	u32 firmware_421 = 42100;
	fwrite(&firmware_421, sizeof(u32), 1, eboot);
	
	fclose(eboot);
	
	if(SetParamSFO("PS3_SYSTEM_VER", "04.2100", list_game_path[position]) == FAILED) return FAILED;
	
	return SUCCESS;
}

//====================================|
// DigiCert High Assurance EV Root CA |
//====================================|
static char github_cert[] __attribute__((aligned(64))) =
	"-----BEGIN CERTIFICATE-----\n"
	"MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs\n"
	"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n"
	"d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j\n"
	"ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL\n"
	"MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3\n"
	"LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug\n"
	"RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm\n"
	"+9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW\n"
	"PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM\n"
	"xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB\n"
	"Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3\n"
	"hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg\n"
	"EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF\n"
	"MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA\n"
	"FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec\n"
	"nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z\n"
	"eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF\n"
	"hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2\n"
	"Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe\n"
	"vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep\n"
	"+OkuE6N36B9K\n"
	"-----END CERTIFICATE-----\n";
	
#define HTTP_BUFFSIZE 1024
static char getBuffer[HTTP_BUFFSIZE];

int download(char *url, char *dst)
{
	int ret = 0, httpCode = 0;
	s32 cert_size=0;
	httpUri uri;
	httpClientId httpClient = 0;
	httpTransId httpTrans = 0;
	FILE* fp=NULL;
	s32 nRecv = -1;
	s32 size = 0;
	u64 dl=0;
	uint64_t length = 0;
	void *http_pool = NULL;
	void *uri_pool = NULL;
	void *ssl_pool = NULL;
	void *cert_buffer = NULL;
	httpsData *caList=NULL;
	
	u8 module_https_loaded=NO;
	u8 module_http_loaded=NO;
	u8 module_net_loaded=NO;
	u8 module_ssl_loaded=NO;
	
	u8 https_init=NO;
	u8 http_init=NO;
	u8 net_init=NO;
	u8 ssl_init=NO;

	//init
	ret = sysModuleLoad(SYSMODULE_NET);
	if (ret < 0) {
		print_load("Error : sysModuleLoad(SYSMODULE_NET) failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else module_net_loaded=YES;

	ret = netInitialize();
	if (ret < 0) {
		print_load("Error : netInitialize failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else net_init=YES;

	ret = sysModuleLoad(SYSMODULE_HTTP);
	if (ret < 0) {
		print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else module_http_loaded=YES;

	http_pool = malloc(0x10000);
	if (http_pool == NULL) {
		print_load("Error : out of memory (http_pool)");
		ret=FAILED;
		goto end;
	}

	ret = httpInit(http_pool, 0x10000);
	if (ret < 0) {
		print_load("Error : httpInit failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else http_init=YES;

	// init SSL
	if(strstr(url, "https")) {
		ret = sysModuleLoad(SYSMODULE_HTTPS);
		if (ret < 0) {
			print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else module_https_loaded=YES;

		ret = sysModuleLoad(SYSMODULE_SSL);
		if (ret < 0) {
			print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else module_ssl_loaded=YES;

		ssl_pool = malloc(0x40000);
		if (ret < 0) {
			print_load("Error : out of memory (http_pool)");
			ret=FAILED;
			goto end;
		}

		ret = sslInit(ssl_pool, 0x40000);
		if (ret < 0) {
			print_load("Error : sslInit failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else ssl_init=YES;

		caList = (httpsData *)malloc(sizeof(httpsData));
		ret = sslCertificateLoader(SSL_LOAD_CERT_ALL, NULL, 0, &cert_size);
		if (ret < 0) {
			print_load("Error : sslCertificateLoader failed (%x)", ret);
			ret=FAILED;
			goto end;
		}

		cert_buffer = malloc(cert_size);
		if (cert_buffer==NULL) {
			print_load("Error : out of memory (cert_buffer)");
			ret=FAILED;
			goto end;
		}

		ret = sslCertificateLoader(SSL_LOAD_CERT_ALL, cert_buffer, cert_size, NULL);
		if (ret < 0) {
			print_load("Error : sslCertificateLoader failed (%x)", ret);
			ret=FAILED;
			goto end;
		}

		(&caList[0])->ptr = cert_buffer;
		(&caList[0])->size = cert_size;
		
		(&caList[1])->ptr = github_cert;
		(&caList[1])->size = sizeof(github_cert);

		ret = httpsInit(2, (httpsData *) caList);
		if (ret < 0) {
			print_load("Error : httpsInit failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else https_init=YES;

	}
	// END of SSL
	httpClient = 0;
	httpTrans = 0;
 
	ret = httpCreateClient(&httpClient);
	if (ret < 0) {
		print_load("Error : httpCreateClient failed (%x)", ret);
		ret=FAILED;
		goto end;
	}
	// End of init

	//URI
	ret = httpUtilParseUri(&uri, url, NULL, 0, &size);
	if (ret < 0) {
		print_load("Error : httpUtilParseUri() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}

	uri_pool = malloc(size);
	if (uri_pool == NULL) {
		print_load("Error : out of memory (uri_pool)");
		ret=FAILED;
		goto end;
	}

	ret = httpUtilParseUri(&uri, url, uri_pool, size, 0);
	if (ret < 0) {
		print_load("Error : httpUtilParseUri() failed (%x), %s", ret, url);
		ret=FAILED;
		goto end;
	}
	//END of URI	

	//SEND REQUEST
	ret = httpCreateTransaction(&httpTrans, httpClient, HTTP_METHOD_GET, &uri);
	if (ret < 0) {
		print_load("Error : httpCreateTransaction() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}
	/*
	if(strstr(url, "gamecovers.ezyro.com") != NULL) {
		httpHeader headerCookie = { (const char*) "Cookie", (const char*) "__test=8f82a74fa6f891b017602f64b6aa7942" };
		httpRequestAddHeader(httpTrans, &headerCookie);
	}
	*/
	ret = httpSendRequest(httpTrans, NULL, 0, NULL);
	if (ret < 0) {
		print_load("Error : httpSendRequest() failed (%x), %s", ret, url);
		ret=FAILED;
		goto end;
	}
	
	//GET SIZE
	httpResponseGetContentLength(httpTrans, &length);

	ret = httpResponseGetStatusCode(httpTrans, &httpCode);
	if (ret < 0) {
		print_load("Error : cellHttpResponseGetStatusCode() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}

	if(httpCode != HTTP_STATUS_CODE_OK && httpCode >= 400 ) {
		//print_load("Error : Status code (%d)", httpCode);
		ret=FAILED;
		goto end;
	}
	
//TRANSFERT
	fp=NULL;
	fp = fopen(dst, "wb");
	if(fp == NULL) {
		print_load("Error : fopen() failed : %s", dst);
		ret=FAILED;
		goto end;
	}
	
	if(length != 0) {
		if(prog_bar1_value!=-1) prog_bar2_value=0;
		else prog_bar1_value=0;
	}
	
	while(nRecv != 0) {
		if(httpRecvResponse(httpTrans, (void*) getBuffer, sizeof(getBuffer)-1, &nRecv) > 0) break;
		if(nRecv == 0)	break;
		fwrite((char*) getBuffer, nRecv, 1, fp);
		if(cancel==YES) break;
		dl+=nRecv;
		if(length != 0) {
			if(prog_bar2_value!=-1) prog_bar2_value=(dl*100)/length;
			else prog_bar1_value = (dl*100)/length;
		}
	}
	fclose(fp);
		
	if(prog_bar2_value!=-1) prog_bar2_value=-1;
	else prog_bar1_value=-1;
	
//END of TRANSFERT

	ret=SUCCESS;
	
	if(cancel==YES) {
		Delete(dst);
		ret=FAILED;
		cancel=NO;
	}
	
end:
	if(caList) free(caList);
	if(httpTrans) httpDestroyTransaction(httpTrans);
	if(httpClient) httpDestroyClient(httpClient);
	if(https_init) httpsEnd();
	if(ssl_init) sslEnd();
	if(http_init) httpEnd();
	if(net_init) netDeinitialize();
	
	if(module_http_loaded) sysModuleUnload(SYSMODULE_HTTP);
	if(module_https_loaded) sysModuleUnload(SYSMODULE_HTTPS);
	if(module_net_loaded) sysModuleUnload(SYSMODULE_NET);
	if(module_ssl_loaded) sysModuleUnload(SYSMODULE_SSL);
	
	if(uri_pool) free(uri_pool);
	if(http_pool) free(http_pool);
	if(ssl_pool) free(ssl_pool);
	if(cert_buffer) free(cert_buffer);
	
	return ret;
}

int http_response(char *url)
{
	int ret = 0, httpCode = 0;
	s32 cert_size=0;
	httpUri uri;
	httpClientId httpClient = 0;
	httpTransId httpTrans = 0;
	s32 size = 0;
	void *http_pool = NULL;
	void *uri_pool = NULL;
	void *ssl_pool = NULL;
	void *cert_buffer = NULL;
	httpsData *caList=NULL;
	
	u8 module_https_loaded=NO;
	u8 module_http_loaded=NO;
	u8 module_net_loaded=NO;
	u8 module_ssl_loaded=NO;
	
	u8 https_init=NO;
	u8 http_init=NO;
	u8 net_init=NO;
	u8 ssl_init=NO;

	//init
	ret = sysModuleLoad(SYSMODULE_NET);
	if (ret < 0) {
		print_load("Error : sysModuleLoad(SYSMODULE_NET) failed (%x)", ret);
		goto end;
	} else module_net_loaded=YES;

	ret = netInitialize();
	if (ret < 0) {
		print_load("Error : netInitialize failed (%x)", ret);
		goto end;
	} else net_init=YES;

	ret = sysModuleLoad(SYSMODULE_HTTP);
	if (ret < 0) {
		print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
		goto end;
	} else module_http_loaded=YES;

	http_pool = malloc(0x10000);
	if (http_pool == NULL) {
		print_load("Error : out of memory (http_pool)");
		goto end;
	}

	ret = httpInit(http_pool, 0x10000);
	if (ret < 0) {
		print_load("Error : httpInit failed (%x)", ret);
		goto end;
	} else http_init=YES;

	// init SSL
	if(strstr(url, "https")) {
		ret = sysModuleLoad(SYSMODULE_HTTPS);
		if (ret < 0) {
			print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
			goto end;
		} else module_https_loaded=YES;

		ret = sysModuleLoad(SYSMODULE_SSL);
		if (ret < 0) {
			print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
			goto end;
		} else module_ssl_loaded=YES;

		ssl_pool = malloc(0x40000);
		if (ret < 0) {
			print_load("Error : out of memory (http_pool)");
			goto end;
		}

		ret = sslInit(ssl_pool, 0x40000);
		if (ret < 0) {
			print_load("Error : sslInit failed (%x)", ret);
			goto end;
		} else ssl_init=YES;

		caList = (httpsData *)malloc(sizeof(httpsData));
		ret = sslCertificateLoader(SSL_LOAD_CERT_ALL, NULL, 0, &cert_size);
		if (ret < 0) {
			print_load("Error : sslCertificateLoader failed (%x)", ret);
			goto end;
		}

		cert_buffer = malloc(cert_size);
		if (cert_buffer==NULL) {
			print_load("Error : out of memory (cert_buffer)");
				goto end;
		}

		ret = sslCertificateLoader(SSL_LOAD_CERT_ALL, cert_buffer, cert_size, NULL);
		if (ret < 0) {
			print_load("Error : sslCertificateLoader failed (%x)", ret);
				goto end;
		}

		(&caList[0])->ptr = cert_buffer;
		(&caList[0])->size = cert_size;
		
		(&caList[1])->ptr = github_cert;
		(&caList[1])->size = sizeof(github_cert);

		ret = httpsInit(2, (httpsData *) caList);
		if (ret < 0) {
			print_load("Error : httpsInit failed (%x)", ret);
				goto end;
		} else https_init=YES;

	}
	// END of SSL
	httpClient = 0;
	httpTrans = 0;
 
	ret = httpCreateClient(&httpClient);
	if (ret < 0) {
		print_load("Error : httpCreateClient failed (%x)", ret);
		goto end;
	}
	// End of init

	//URI
	ret = httpUtilParseUri(&uri, url, NULL, 0, &size);
	if (ret < 0) {
		print_load("Error : httpUtilParseUri() failed (%x)", ret);
		goto end;
	}

	uri_pool = malloc(size);
	if (uri_pool == NULL) {
		print_load("Error : out of memory (uri_pool)");
		goto end;
	}

	ret = httpUtilParseUri(&uri, url, uri_pool, size, 0);
	if (ret < 0) {
		print_load("Error : httpUtilParseUri() failed (%x)", ret);
		goto end;
	}
	//END of URI	

	//SEND REQUEST
	ret = httpCreateTransaction(&httpTrans, httpClient, HTTP_METHOD_GET, &uri);
	if (ret < 0) {
		print_load("Error : httpCreateTransaction() failed (%x)", ret);
		goto end;
	}
	
	print_debug("httpSendRequest");
	ret = httpSendRequest(httpTrans, NULL, 0, NULL);
	if (ret < 0) {
		print_load("Error : httpSendRequest() failed (%x), %s", ret, url);
		goto end;
	}
	
	print_debug("httpResponseGetStatusCode");
	ret = httpResponseGetStatusCode(httpTrans, &httpCode);
	if (ret < 0) {
		print_load("Error : cellHttpResponseGetStatusCode() failed (%x)", ret);
		goto end;
	}
	
	ret = httpCode;
	
end:
	if(caList) free(caList);
	if(httpTrans) httpDestroyTransaction(httpTrans);
	if(httpClient) httpDestroyClient(httpClient);
	if(https_init) httpsEnd();
	if(ssl_init) sslEnd();
	if(http_init) httpEnd();
	if(net_init) netDeinitialize();
	
	if(module_http_loaded) sysModuleUnload(SYSMODULE_HTTP);
	if(module_https_loaded) sysModuleUnload(SYSMODULE_HTTPS);
	if(module_net_loaded) sysModuleUnload(SYSMODULE_NET);
	if(module_ssl_loaded) sysModuleUnload(SYSMODULE_SSL);
	
	if(uri_pool) free(uri_pool);
	if(http_pool) free(http_pool);
	if(ssl_pool) free(ssl_pool);
	if(cert_buffer) free(cert_buffer);
	
	return ret;
}

int upload(char *url, char *src, const char *method)
{
	int ret = 0;
	int httpCode = 0;
	s32 cert_size=0;
	httpUri uri;
	httpClientId httpClient = 0;
	httpTransId httpTrans = 0;
	FILE* fp=NULL;
	s64 toSend=-1;
	s32 nSent=-1;
	s32 size = 0;
	u64 ul=0;
	u64 length = 0;
	void *http_pool = NULL;
	void *uri_pool = NULL;
	void *ssl_pool = NULL;
	void *cert_buffer = NULL;
	httpsData *caList=NULL;
	
	u8 module_https_loaded=NO;
	u8 module_http_loaded=NO;
	u8 module_net_loaded=NO;
	u8 module_ssl_loaded=NO;
	
	u8 https_init=NO;
	u8 http_init=NO;
	u8 net_init=NO;
	u8 ssl_init=NO;

	//init
	ret = sysModuleLoad(SYSMODULE_NET);
	if (ret < 0) {
		print_load("Error : sysModuleLoad(SYSMODULE_NET) failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else module_net_loaded=YES;

	ret = netInitialize();
	if (ret < 0) {
		print_load("Error : netInitialize failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else net_init=YES;

	ret = sysModuleLoad(SYSMODULE_HTTP);
	if (ret < 0) {
		print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else module_http_loaded=YES;

	http_pool = malloc(0x10000);
	if (http_pool == NULL) {
		print_load("Error : out of memory (http_pool)");
		ret=FAILED;
		goto end;
	}

	ret = httpInit(http_pool, 0x10000);
	if (ret < 0) {
		print_load("Error : httpInit failed (%x)", ret);
		ret=FAILED;
		goto end;
	} else http_init=YES;

	// init SSL
	if(strstr(url, "https")) {
		ret = sysModuleLoad(SYSMODULE_HTTPS);
		if (ret < 0) {
			print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else module_https_loaded=YES;

		ret = sysModuleLoad(SYSMODULE_SSL);
		if (ret < 0) {
			print_load("Error : sysModuleLoad(SYSMODULE_HTTP) failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else module_ssl_loaded=YES;

		ssl_pool = malloc(0x40000);
		if (ret < 0) {
			print_load("Error : out of memory (http_pool)");
			ret=FAILED;
			goto end;
		}

		ret = sslInit(ssl_pool, 0x40000);
		if (ret < 0) {
			print_load("Error : sslInit failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else ssl_init=YES;

		caList = (httpsData *)malloc(sizeof(httpsData));
		ret = sslCertificateLoader(SSL_LOAD_CERT_ALL, NULL, 0, &cert_size);
		if (ret < 0) {
			print_load("Error : sslCertificateLoader failed (%x)", ret);
			ret=FAILED;
			goto end;
		}

		cert_buffer = malloc(cert_size);
		if (cert_buffer==NULL) {
			print_load("Error : out of memory (cert_buffer)");
			ret=FAILED;
			goto end;
		}

		ret = sslCertificateLoader(SSL_LOAD_CERT_ALL, cert_buffer, cert_size, NULL);
		if (ret < 0) {
			print_load("Error : sslCertificateLoader failed (%x)", ret);
			ret=FAILED;
			goto end;
		}

		(&caList[0])->ptr = cert_buffer;
		(&caList[0])->size = cert_size;
		
		(&caList[1])->ptr = github_cert;
		(&caList[1])->size = sizeof(github_cert);

		ret = httpsInit(2, (httpsData *) caList);
		if (ret < 0) {
			print_load("Error : httpsInit failed (%x)", ret);
			ret=FAILED;
			goto end;
		} else https_init=YES;

	}
	// END of SSL
	httpClient = 0;
	httpTrans = 0;
 
	ret = httpCreateClient(&httpClient);
	if (ret < 0) {
		print_load("Error : httpCreateClient failed (%x)", ret);
		ret=FAILED;
		goto end;
	}
	// End of init

	//URI
	ret = httpUtilParseUri(&uri, url, NULL, 0, &size);
	if (ret < 0) {
		print_load("Error : httpUtilParseUri() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}

	uri_pool = malloc(size);
	if (uri_pool == NULL) {
		print_load("Error : out of memory (uri_pool)");
		ret=FAILED;
		goto end;
	}

	ret = httpUtilParseUri(&uri, url, uri_pool, size, 0);
	if (ret < 0) {
		print_load("Error : httpUtilParseUri() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}
	//END of URI	

	//SEND REQUEST
	ret = httpCreateTransaction(&httpTrans, httpClient, method, &uri);
	if (ret < 0) {
		print_load("Error : httpCreateTransaction() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}

// FILE UPLOAD
	length = get_size(src);
	
	print_debug("httpRequestSetContentLength");
	ret = httpRequestSetContentLength(httpTrans, length);
	if( ret < 0) {
		print_load("Error : httpRequestSetContentLength() failed (%x)", ret);
		ret=FAILED;
		goto end;
	}
	
	char *ext = GetExtension(src);
	if( strcasecmp(ext, ".json") == 0) {
		httpHeader headerCookie = { (const char*) "Content-Type", (const char*) "application/json; charset=utf-8" };
		httpRequestAddHeader(httpTrans, &headerCookie);
	}
	
	fp=fopen(src, "rb");
	if(fp==NULL) {
		print_load("Error : fopen() failed : %s", src);
		ret=FAILED;
		goto end;
	}
	task_Init(length);
	
	print_debug("Sending data...");
	while(nSent != 0 ) {
		toSend = HTTP_BUFFSIZE; 
		if(length < ul + toSend) toSend = length - ul;
		
		fread((char *) getBuffer, toSend, 1, fp);
		ret = httpSendRequest(httpTrans, (void*) getBuffer, toSend, &nSent);
		if( ret < 0) {
			print_load(" Error : httpSendRequest %X", ret);
			break;
		}
		
		ul+=toSend;
		
		task_Update(toSend);
		
		if(length <= ul ) break;
		if(cancel==YES) break;
		if(nSent == 0)	break;
		if(nSent != toSend) print_load(" Warning : nSent != toSend | %d != %d", toSend, nSent);
		
		if(length != 0) {
			if(prog_bar2_value!=-1) prog_bar2_value=(ul*100)/length;
			else prog_bar1_value = (ul*100)/length;
		}
	}
	fclose(fp);
	
	task_End();
	
	if(length != ul) {
		print_load("Error : length != ul");
		ret = FAILED;
	}
	
	print_debug("httpResponseGetStatusCode");
	ret = httpResponseGetStatusCode(httpTrans, &httpCode);
	if (ret < 0) {
		print_load("Error : cellHttpResponseGetStatusCode() failed (%x)", ret);
		goto end;
	}
	
	ret = httpCode;
	
//END of TRANSFERT
end:
	if(cancel) {
		ret=FAILED;
		cancel=NO;
	}
	
	if(caList) free(caList);
	if(httpTrans) httpDestroyTransaction(httpTrans);
	if(httpClient) httpDestroyClient(httpClient);
	if(https_init) httpsEnd();
	if(ssl_init) sslEnd();
	if(http_init) httpEnd();
	if(net_init) netDeinitialize();
	
	if(module_http_loaded) sysModuleUnload(SYSMODULE_HTTP);
	if(module_https_loaded) sysModuleUnload(SYSMODULE_HTTPS);
	if(module_net_loaded) sysModuleUnload(SYSMODULE_NET);
	if(module_ssl_loaded) sysModuleUnload(SYSMODULE_SSL);
	
	if(uri_pool) free(uri_pool);
	if(http_pool) free(http_pool);
	if(ssl_pool) free(ssl_pool);
	if(cert_buffer) free(cert_buffer);
	
	return ret;
}

int read_scan_dir() 
{

	FILE* fp=NULL;
	char scanPath[128];
	char temp[128];
	
	scan_dir_number=-1;
	memset(scan_dir, 0, sizeof(scan_dir));
	
	sprintf(scanPath, "/dev_hdd0/game/%s/USRDIR/setting/scan_dir.txt", ManaGunZ_id);
	
	fp=fopen(scanPath, "rb");
	if(fp==NULL){
		print_load("Error : failed to open SCAN_DIR.");
		return FAILED;
	}
	while(fgets(temp, 128, fp) != NULL) {
		//print_load("fgets %s", temp);
		if(strstr(temp, "\n") != NULL ) strtok(temp, "\n");
		if(strstr(temp, "\r") != NULL ) strtok(temp, "\r");
		scan_dir_number++;
		strcpy(scan_dir[scan_dir_number], temp);
	}
	
	fclose(fp);
	
	if(scan_dir_number != -1) return SUCCESS; else return FAILED;

}

void write_scan_dir()
{
	FILE* fp=NULL;
	char scanPath[128];
	int i;
	
	sprintf(scanPath, "/dev_hdd0/game/%s/USRDIR/setting/scan_dir.txt", ManaGunZ_id);
	
	fp=fopen(scanPath, "wb");
	if(fp==NULL)return;
	
	for(i=0; i<=scan_dir_number; i++) {
		fputs(scan_dir[i], fp);
		fputs("\n", fp);
	}
	fclose(fp);
	
}

//*******************************************************
// Memory Monitor
//*******************************************************

typedef struct {
    uint32_t total;
    uint32_t avail;
} sysMemoryInfo_t;

s32 sysMemoryGetUserMemorySize(sysMemoryInfo_t * MemInfo)
{
    lv2syscall1(SYSCALL_MEMORY_GET_USER_MEMORY_SIZE, (uint64_t) MemInfo);
    return_to_user_prog(s32);
}

static sys_ppu_thread_t MemMonitor_id;
u8 MemMonitor = NO;
sysMemoryInfo_t MemInfo;

void Draw_MemMonitor()
{
	if(MemMonitor==NO) return;
	
	int i;
	
	float x=30;
	float y=20;
	float w=800;
	float h=10;
	float e=4;
	
	Draw_Box(0, y-10, 0, 0, X_MAX, h*2+2*e+20*2+20, GREY, NO);
		
	float MemUsed = MemInfo.total - MemInfo.avail ;
	
	float w2 = (MemUsed * w) / MemInfo.total;
	
	Draw_Box(x-e, y-e, 0, 0, w+2*e, h+2*e, WHITE, NO);
	Draw_Box(x, y, 0, 0, w, h, BLACK, NO);
	Draw_Box(x, y, 0, 0, w2, h, GREEN, NO);
	
	char *MemUsed_u = get_unit(MemUsed);
	char *MemTot_u = get_unit(MemInfo.total);
	
	y+=h+2*e;
	
	FontColor(WHITE);
	FontSize(15);
	float val = (float) ((MemUsed * 100) / MemInfo.total);
	DrawFormatString(x, y, "RAM %.1f%% - %s/%s", val, MemUsed_u,  MemTot_u);
	
	free(MemUsed_u);
	free(MemTot_u);
	
	y+=20;

//FONT
	float w_font_max = (float) ( ( _Mo(TEXTURE_FONT_SIZE_MAX) * w) / _Mo(TEXTURE_SIZE_MAX));
	float w_font =  (float) ( ( _Mo(TEXTURE_FONT_SIZE) * w_font_max) / _Mo(TEXTURE_FONT_SIZE_MAX));
	Draw_Box(x-e, y-e, 0, 0, w_font_max+e, h+2*e, BLUE, NO);
	Draw_Box(x, y, 0, 0, w_font_max , h, BLACK, NO);
	Draw_Box(x, y, 0, 0, w_font , h, GREEN, NO);
	FontColor(BLUE);
	
	float x1 = DrawString(x, y+h+2*e, "FONT") + 10;
	
	x+=w_font_max;
	
// THEME
	
	float w_theme_max = (float) ( ( _Mo(TEXTURE_THEME_SIZE_MAX) * w) / _Mo(TEXTURE_SIZE_MAX));
	float w_theme =  (float) ( ( _Mo(TEXTURE_THEME_SIZE) * w_theme_max) / _Mo(TEXTURE_THEME_SIZE_MAX));
	Draw_Box(x, y-e, 0, 0, w_theme_max, h+2*e, ORANGE, NO);
	Draw_Box(x, y, 0, 0, w_theme_max , h, BLACK, NO);
	Draw_Box(x, y, 0, 0, w_theme , h, GREEN, NO);
	
	
	FontColor(ORANGE);
	if(x > x1) x1=x; 
	x1 = DrawString(x1, y+h+2*e, "THEME")+ 10;
	
//GAMEPIC
	x+= w_theme_max;
	float w_gamepic_max = (float) ( ( _Mo(TEXTURE_GAMEPIC_TOT_SIZE_MAX) * w) / _Mo(TEXTURE_SIZE_MAX));
	float w_gamepic_slot_max = (float) ((float) w_gamepic_max / (float) GAMEPIC_MAX);
	Draw_Box(x, y-e, 0, 0, w_gamepic_max, h+2*e, PURPLE, NO);
	for(i=0; i<GAMEPIC_MAX; i++) {
		//float w_gamepic_slot = (float) ( (float)((float) ( _Mo(TEXTURE_GAMEPIC_SIZE(i))) * w_gamepic_slot_max) / ((float)(_Mo(TEXTURE_GAMEPIC_SIZE_MAX))));
		float w_gamepic_slot = w_gamepic_slot_max;
		if( GAMEPIC_SLOT_POS[i] == -1 ) Draw_Box(x+w_gamepic_slot_max*i, y, 0, 0, w_gamepic_slot_max , h, BLACK, NO); else
		if( GAMEPIC_SLOT_POS[i] == -2 ) Draw_Box(x+w_gamepic_slot_max*i, y, 0, 0, w_gamepic_slot_max , h, ORANGE, NO); else
		Draw_Box(x+w_gamepic_slot_max*i, y, 0, 0, w_gamepic_slot , h, GREEN, NO);
	}
	for(i=0; i<=GAMEPIC_MAX; i++) {
		Draw_Line(x + w_gamepic_slot_max*i, y-e, x + w_gamepic_slot_max*i, y+h+e, 0, BLACK);
	}
	if(x > x1) x1=x;
	FontColor(PURPLE);
	x1 = DrawFormatString(x1, y+h+2*e, "GAMEPIC : %d/%d slots", VRAM_GetSlotUsed(),  GAMEPIC_MAX) + 10;
	
// COVER
	x+= w_gamepic_max;
	float w_cover_max = (float) ( ( _Mo(TEXTURE_COVER_SIZE_MAX) * w) / _Mo(TEXTURE_SIZE_MAX));
	float w_cover =  (float) ( ( _Mo(TEXTURE_COVER_SIZE) * w_cover_max) / _Mo(TEXTURE_COVER_SIZE_MAX));
	Draw_Box(x, y-e, 0, 0, w_cover_max, h+2*e, PINK, NO);
	Draw_Box(x, y, 0, 0, w_cover_max , h, BLACK, NO);
	Draw_Box(x, y, 0, 0, w_cover , h, GREEN, NO);
	if(x > x1) x1=x;
	FontColor(PINK);
	x1 = DrawString(x1, y+h+2*e, "COVER") + 10;
	
	x+= w_cover_max;
	float w_tmp_max = (float) ( ( _Mo(TEXTURE_TMP_SIZE_MAX) * w) / _Mo(TEXTURE_SIZE_MAX));
	float w_tmp =  (float) ( ( _Mo(TEXTURE_TMP_SIZE) * w_tmp_max) / _Mo(TEXTURE_TMP_SIZE_MAX));
	Draw_Box(x, y-e, 0, 0, w_tmp_max+e, h+2*e, YELLOW, NO);
	Draw_Box(x, y, 0, 0, w_tmp_max , h, BLACK, NO);
	Draw_Box(x, y, 0, 0, w_tmp , h, GREEN, NO);
	if(x > x1) x1=x;
	FontColor(YELLOW);
	x1 = DrawString(x1, y+h+2*e, "TEMP") + 10;
	
	FontColor(WHITE);
	
	Draw_Box(0, y+h+2*e+20 , 0, 0, X_MAX, 20, GREY, NO);
	DrawString(30, y+h+2*e+20, GAMEPIC_LOG);
	
	Draw_Box(30, y+h+2*e+40, 0, 0, X_MAX-30*2, 2, WHITE, NO);
	float x_gpos = (position*(X_MAX-30*2)) / game_number;
	Draw_Box(30+x_gpos, y+h+2*e+40-2, 0, 0, 2, 6, GREEN, NO);
}

void MemMonitor_thread(void *unused)
{
	
	while(MemMonitor) {
		sysMemoryGetUserMemorySize(&MemInfo);
		sleep(1);
	}
	MemMonitor=-1;
	sysThreadExit(0);
}

void start_MemMonitor()
{
	if(MemMonitor==NO) {
		MemMonitor=YES;
		sysThreadCreate(&MemMonitor_id, MemMonitor_thread, NULL, 999, 0x2000, THREAD_JOINABLE, "MemMonitor");
	}
}

void end_MemMonitor()
{
	if(MemMonitor==YES) {
		u64 ret;
		MemMonitor = NO;
		while(MemMonitor==NO) usleep(1000);
		sysThreadJoin(MemMonitor_id, &ret);
		MemMonitor=NO;
	}
}


//*******************************************************
// DEVICE
//*******************************************************

void getDevices()
{
	print_debug("ntfs_mount_all");
	NTFS_mount_all();
	print_debug("exFAT_mount_all");
	exFAT_mount_all();
	
	print_load("Get devices");

	char temp[128];
	
	device_number=-1;
	
	int r, i;
	for(i = 0; i < 8 ; i++) {
		r = -1;
		sprintf(temp, "ntfs%c", 48+i);
		r = NTFS_Test_Device(temp);
		if(r>=0) {
			device_number++;
			sprintf(list_device[device_number], "ntfs%c:", 48+i);
		}
	}
	
	for(i=0; i < MAXFDS; i++) {
		if( exFAT_is_mounted(i) ) {
			device_number++;
			sprintf(list_device[device_number], "exFAT%d:", i);
		}
	}
	
	DIR *d;
	struct dirent *dir;
	d = opendir("/");		
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		if(	strstr(dir->d_name, "dev_usb")
		||  strstr(dir->d_name, "dev_hdd0")
		||  strstr(dir->d_name, "dev_sd")
		||  strstr(dir->d_name, "dev_ms")
		||  strstr(dir->d_name, "dev_cf")
		  ) 
		{
			device_number++;
			strcpy(list_device[device_number], dir->d_name);
		}
	}
	closedir(d);

}


//*******************************************************
// PlugAndPlay
//*******************************************************

// it's used for the notifications only
#define DEVICE_USB(x) 			x
#define DEVICE_MEMORY_STICK		128
#define DEVICE_COMPACT_FLASH	129
#define DEVICE_SD_CARD			130
#define DEVICE_BDVD_DRIVE		131
#define DEVICE_NUMBER			132

u8 PluggedDevices[DEVICE_NUMBER] = {[0 ... DEVICE_NUMBER-1] = -1};

u64 GetDeviceNumber()
{
	u64 Number=0;
	int r, i;
	device_info_t device_info;
	char temp_msg[128]={0};
	char msg[128] = {0};
	
// USB 0 -> 127
	for(i=0; i< 128; i++) {
		memset(&device_info, 0, sizeof(device_info));
		r = sys_storage_get_device_info(USB_MASS_STORAGE(i), &device_info);
		if(r<0) {
			if(PluggedDevices[DEVICE_USB(i)] == YES) {
				sprintf(temp_msg, "USB device %03d is unplugged.\n", i);
				strcat(msg, temp_msg);
			}
			PluggedDevices[DEVICE_USB(i)] = NO;
		} else {
			Number++;
			if(PluggedDevices[DEVICE_USB(i)] == NO) {
				sprintf(temp_msg, "USB device %03d is plugged.\n", i);
				strcat(msg, temp_msg);
			}
			PluggedDevices[DEVICE_USB(i)] = YES;
		}
	}
	
// COMPACT_FLASH
	memset(&device_info, 0, sizeof(device_info));
	r = sys_storage_get_device_info(COMPACT_FLASH, &device_info);
	if(r<0) {
		if(PluggedDevices[DEVICE_COMPACT_FLASH] == YES) {
			strcat(msg, "Compact flash device is plugged.\n");
		}
		PluggedDevices[DEVICE_COMPACT_FLASH] = NO;
	} else {
		if(PluggedDevices[DEVICE_COMPACT_FLASH] == NO) {
			strcat(msg, "Compact flash device is plugged.\n");
		}
		PluggedDevices[DEVICE_COMPACT_FLASH] = YES;
		Number++;
	}
	
// MEMORY_STICK
	memset(&device_info, 0, sizeof(device_info));
	r = sys_storage_get_device_info(MEMORY_STICK, &device_info);
	if(r<0) {
		if(PluggedDevices[DEVICE_MEMORY_STICK] == YES) {
			strcat(msg, "Memory stick device is plugged.\n");
		}
		PluggedDevices[DEVICE_MEMORY_STICK] = NO;
	} else {
		if(PluggedDevices[DEVICE_MEMORY_STICK] == NO) {
			strcat(msg, "Memory stick device is plugged.\n");
		}
		PluggedDevices[DEVICE_MEMORY_STICK] = YES;
		Number++;
	}

// SD_CARD
	memset(&device_info, 0, sizeof(device_info));
	r = sys_storage_get_device_info(SD_CARD, &device_info);
	if(r<0) {
		if(PluggedDevices[DEVICE_SD_CARD] == YES) {
			strcat(msg, "SD card device is plugged.\n");
		}
		PluggedDevices[DEVICE_SD_CARD] = NO;
	} else {
		if(PluggedDevices[DEVICE_SD_CARD] == NO) {
			strcat(msg, "SD card device is plugged.\n");
		}
		PluggedDevices[DEVICE_SD_CARD] = YES;
		Number++;
	}
	
// BDVD_DRIVE
	// The BR reader is always connected, so, sys_storage_get_device_info always return 0. 
	// Also, device_info isn't updated when we eject the disc.
	// So, I'm checking the mount point "/dev_bdvd".
	
	r = path_info("/dev_bdvd");
	if(r == _NOT_EXIST) {
		if(PluggedDevices[DEVICE_BDVD_DRIVE] == YES) {
			strcat(msg, "Disc is ejected.\n");
		}
		PluggedDevices[DEVICE_BDVD_DRIVE] = NO;
	} else {
		if(PluggedDevices[DEVICE_BDVD_DRIVE] == NO) {
			strcat(msg, "Disc is inserted.\n");
		}
		PluggedDevices[DEVICE_BDVD_DRIVE] = YES;
		Number++;
	}
	
	if(msg[0] != 0) show_msg(msg);
	
	return Number;
}

u8 do_Refresh=NO;
u8 PlugAndPlay=NO;
u8 RefreshRetry=NO;

static sys_ppu_thread_t PlugAndPlay_id;
void PlugAndPlay_thread(void *unused)
{
	u64 Old_NumberOfDevice = 0;
	
	Old_NumberOfDevice = GetDeviceNumber();
	
	while(PlugAndPlay) {
	
		u64 NumberOfDevice = GetDeviceNumber();
		
		if ( Old_NumberOfDevice != NumberOfDevice) {
			
			do_Refresh=YES;
						
			if( Old_NumberOfDevice < NumberOfDevice && RefreshRetry == YES) {
				// refresh several times because some devices takes times to be mounted
				sleep(2);
				if(do_Refresh==NO) do_Refresh = YES;
				sleep(3);
				if(do_Refresh==NO) do_Refresh = YES;
				sleep(4);
				if(do_Refresh==NO) do_Refresh = YES;
			}
			Old_NumberOfDevice = NumberOfDevice;
		}
		
		sleep(1);
	}
	PlugAndPlay=-1;
	sysThreadExit(0);
}

void start_PlugAndPlay()
{
	if(PlugAndPlay==NO) {
		PlugAndPlay = YES;
		sysThreadCreate(&PlugAndPlay_id, PlugAndPlay_thread, NULL, 999, 0x2000, THREAD_JOINABLE, "PlugAndPlay");
	}
}

void end_PlugAndPlay()
{
	if(PlugAndPlay==YES) {
		u64 ret;
		PlugAndPlay = NO;
		while(PlugAndPlay==NO) usleep(1000);
		sysThreadJoin(PlugAndPlay_id, &ret);
		PlugAndPlay=NO;
	}
}

void AutoRefresh_GAMELIST()
{
#ifdef RPCS3
	return;
#endif

	if(PlugAndPlay==NO) { start_PlugAndPlay(); return; }
	if(do_Refresh == NO) return;
	
	do_Refresh = NO;
	
	start_loading();
	
	int bdvd_position = GetPosition_GAMELIST("/dev_bdvd");
	
	//if( path_info("/dev_bdvd") == _NOT_EXIST) 
	if( PluggedDevices[DEVICE_BDVD_DRIVE] == NO)
	{
		if( 0 <= bdvd_position) {
			remove_GAMELIST(bdvd_position);
			end_loading();
			return;
		}
	} else {
		if( bdvd_position < 0 ) {
			add_GAMELIST("/dev_bdvd");
			sort_GAMELIST();
			init_Load_GAMEPIC();
			read_fav();
			end_loading();
			return;
		}
	}
	
	int i=0, j=0, k;
	char scan_path[128], temp[128];
	
	char list_device_OLD[32][32]={{0}};
	int8_t device_number_OLD=-1;
	
	memcpy(list_device_OLD, list_device, sizeof(list_device));
	device_number_OLD = device_number;
	
	getDevices();
	
	s64 old_game_number = game_number;
	
	RefreshRetry = NO; // It retry from here...
	
	if( device_number == device_number_OLD) {
		print_load("Please wait...");
		sleep(2);
		getDevices();
		if( device_number == device_number_OLD) {
			print_load("Please wait even more...");
			sleep(4);
			getDevices();
		}
	}
	
	if(device_number < device_number_OLD) { // *** unplug device ***
		
		u8 unplugged_devices = device_number_OLD - device_number;
		char path_unplug[32][32]={{0}};
		
		k=0;
		
		for(i=0; i<=device_number_OLD; i++) {
			for(j=0;j<=device_number;j++) {
				if(strcmp(list_device[j], list_device_OLD[i]) == 0) break;
				if(j==device_number) {
					strcpy(path_unplug[k], list_device_OLD[i]);
					k++;
				}
			}
			if(k==unplugged_devices) break;
		}
		
		k=0;
		for(k=0; k < unplugged_devices ; k++) {
			print_load("%s unplugged", path_unplug[k]);
			
			if(strncmp(path_unplug[k], "dev_", 4)==0) {
				char mount_point[20];
				sprintf(mount_point, "/%s", path_unplug[k]);
				sysFsAioFinish(mount_point);
			} 
										
			int l = strlen(path_unplug[k]);
			for(i=0; i<=game_number; i++) {
				if(strncmp(&list_game_path[i][1], path_unplug[k], l) == 0) {
					remove_GAMELIST(i);
					//i--;
				}
			}
		}
	} else
	if(device_number > device_number_OLD) { // *** plug device ***
		
		u8 plugged_devices = device_number - device_number_OLD;
		char path_plug[32][32]={{0}};
		
		k=0;
		
		for(i=0; i<=device_number; i++) {
			for(j=0;j<=device_number_OLD;j++) {
				if(strcmp(list_device_OLD[j], list_device[i]) == 0) break;
				if(j==device_number_OLD) {
					strcpy(path_plug[k], list_device[i]);
					k++;
				}
			}
			if(k==plugged_devices) break;
		}
		
		for(k=0; k < plugged_devices; k++) {
			
			print_load("%s plugged", path_plug[k]);
			
			if(strncmp(path_plug[k], "dev_", 4)==0) {
				char mount_point[20];
				sprintf(mount_point, "/%s", path_plug[k]);
				if(sysFsAioInit(mount_point) != 0)
					print_load("Warning :  failed to sysFsAioInit(%s)", mount_point);
			} 
						
			print_load( "Get directory names from scan_dir.txt");
			//get scan dir
			if(read_scan_dir()==FAILED) {
				do_Refresh = NO;
				end_loading();
				return;
			}
			
			sprintf(temp, "/%s", path_plug[k]);
			move_bdemubackup_to_origin(temp);
			
			//get game list
			for(j=0; j<=scan_dir_number; j++) {
				sprintf(scan_path, "/%s/%s", path_plug[k], scan_dir[j]);
			
				get_GAMELIST(scan_path);
			}	
		}
	}	
	
	
	if(game_number != old_game_number) {
		print_load("Reloading...");
	
		sort_GAMELIST();
		init_Load_GAMEPIC();
		
		GetThemes();
		read_fav();
	}
	
	end_loading();
}

//*******************************************************
// MD5 from redump.org to check PS1 and PS2
//*******************************************************

u8 Download_MD5(char *gameID)
{
	char url[255];
	char dst[255];
	char redumpID[20];
	
	strcpy(redumpID, gameID);
	redumpID[4]='-';
	redumpID[8]=redumpID[9];
	redumpID[9]=redumpID[10];
	redumpID[10]=0;
	
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/sys/Check", ManaGunZ_id);
	mkdir(dst, 0777);
	
	// it's better to http_set_autoredirect=false and then get header.value of "Location" header...
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/sys/Check/temp.txt", ManaGunZ_id);
	sprintf(url, "http://redump.org/discs/quicksearch/%s/", redumpID);
	
	if( download(url, dst) == FAILED) {
		print_load("Error : failed to download result");
		Delete(dst);
		return FAILED;
	}

	int size;
	char *buff = LoadFile(dst, &size);
	
	Delete(dst);
	
	if(buff==NULL) {
		print_load("Error : failed to load result");
		return FAILED;
	}
	
	char pageID[10];
	if(strstr(buff, "/disc/") == NULL) {
		print_load("Error : md5 not found");
		free(buff);
		return FAILED;
	}
	memcpy(pageID, strstr(buff, "/disc/") + 6, 9);
	strtok(pageID, "/");
	free(buff);
	
	sprintf(url, "http://redump.org/disc/%s/md5/", pageID);
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/sys/Check/%s.md5", ManaGunZ_id, gameID);

	if( download(url, dst) == FAILED) {
		print_load("Error : failed to download md5");
		Delete(dst);
		return FAILED;
	}

	return SUCCESS;
}

u8 CheckMD5(char *path)
{
	char MD5_redump[255];
	long long unsigned int MD5_local[2];
	char MD5_local_STR[33];
	char gameID[20];
	char MD5_DB[128];
	char MD5_FILE[25];
	
	print_head("Checking MD5...");
	
	u8 platform = get_platform(path);
	
	if(platform != ISO_PS2 && platform != ISO_PS1) {
		print_load("Error : this platform isn't supported");
		return FAILED;
	}
	
	if( Get_ID(path, platform, gameID) == FAILED ) {
		print_load("Error : failed to get game ID");
		return FAILED;
	}
	
	sprintf(MD5_redump, "/dev_hdd0/game/%s/USRDIR/sys/Check/%s.md5", ManaGunZ_id, gameID);
	sprintf(MD5_DB, "/dev_hdd0/game/%s/USRDIR/sys/Check.zip", ManaGunZ_id);
	sprintf(MD5_FILE, "%s.md5", gameID);
	
	ExtractZipFile(MD5_DB, MD5_FILE, MD5_redump);
	
	if( path_info(MD5_redump) == _NOT_EXIST )
	if( Download_MD5(gameID) == FAILED ) {
		print_load("Error : redump MD5 not found");
		return FAILED;
	}
	
	if( md5_file(path, (u8 *) MD5_local) == FAILED ) {
		print_load("Error : failed to get MD5");
		return FAILED;
	}
	if(cancel == YES) return FAILED;
	
	sprintf(MD5_local_STR, "%016llX%016llX", MD5_local[0], MD5_local[1]);
	
	int size;
	char *MD5_buff =  LoadFile(MD5_redump, &size);
	if(MD5_buff == NULL) {
		print_load("Error : failed to load MD5 redump");
		return FAILED;
	}
	
	char dst[255];
	strcpy(dst, path);
	dst[strlen(dst)-4]=0;
	strcat(dst, "_CHECK.md5");
	
	FILE* f;
	
	f = fopen(dst, "wb");
	if(f == NULL) {
		print_load("Error : cannot create CHECK.md5");
		free(MD5_buff);
		return FAILED;
	}
	
	fputs("*** MD5 from redump.org ***\n\n", f);
	fwrite(MD5_buff, size, 1, f);
	fputs("\n*** real MD5 ***\n\n", f);
	fputs(MD5_local_STR, f);
	fputs(" ", f);
	fputs(&strrchr(path, '/')[1], f);
	
	fputs("\n\n*** RESULT ***\n\n", f);
	
	if(strcasestr(MD5_buff, MD5_local_STR) != NULL) {
		fputs("VALID", f);
	} else fputs("NOT VALID", f);
	
	fclose(f);
	
	free(MD5_buff);
	
	return SUCCESS;
	
}

u32 GetRenaCRC32(char *path)
{
	char game_ID[20];
	char link[128];
	u32 renaCRC = 0;
	
	if( Get_ID(path, ISO_PSP, game_ID) == FAILED) return 0;
	
	sprintf(link, "http://renascene.com/?target=search1&srchser=1&srch=%s", game_ID);
	Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
	if(download(link, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
		char *data;
		int file_size;
		char tmp[255];
		data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
		char *pch = strstr(data, "http://renascene.com/info/umd/");
		if(pch != NULL) {
			strncpy(tmp, pch, 40);
			if( strstr(tmp, "'") != NULL) strtok(tmp, "'");
			if(download(tmp, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
				free(data);
				data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
				Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
				char *pch2 = strstr(data, "CRC32</td><td class=\"infRightTd\">");
				if(pch2 != NULL) {
					strncpy(tmp, pch2+33, 255);
					if( strstr(tmp, "<") != NULL) strtok(tmp, "<");
					sscanf(tmp, "%X", &renaCRC);
					return renaCRC;
				}
			}
		}
		free(data);
	}
	
	return 0;
}

u32 GetPSPCRC32(char *path)
{
	char game_ID[20];
	unsigned int CRC = 0;
	char CRC_DB[128];
	
	if( Get_ID(path, ISO_PSP, game_ID) == FAILED) return 0;
	
	sprintf(CRC_DB, "/dev_hdd0/game/%s/USRDIR/sys/PSP_CRC.txt", ManaGunZ_id);
	
	FILE* f;
	
	f = fopen(CRC_DB, "r");
	if(f==NULL) return 0;
	
	char line[128];
	
	while(fgets(line, 128, f) != NULL) {
		if(strstr(line, game_ID) != NULL) {
			sscanf(line, "%*s %X", &CRC);
			break;
		}
	}
	
	fclose(f);
	
	return (u32) CRC;

}

u8 CheckCRC32(char *path)
{
	u32 renaCRC = 0;
	
	renaCRC = GetPSPCRC32(path);
	
	if(renaCRC == 0) renaCRC = GetRenaCRC32(path);
	
	if(renaCRC == 0) return FAILED;
	
	print_load("CRC from renascene : %X", renaCRC);
	
	print_head("Getting CRC32");
	
	u32 crc = crc_file(path);
	
	char dst[255];
	strcpy(dst, path);
	dst[strlen(dst)-4]=0;
	strcat(dst, "_CHECK.crc");
	
	char renaPS2CRC_STR[10];
	sprintf(renaPS2CRC_STR, "%X", renaCRC);
	char realPS2CRC_STR[10];
	sprintf(realPS2CRC_STR, "%X", crc);
	
	FILE *f = fopen(dst, "wb");
	if(f == NULL) {
		print_load("Error : cannot create CHECK.crc");
		return FAILED;
	}
	
	fputs("*** CRC from renascene.com ***\n\n", f);
	fputs(renaPS2CRC_STR, f);
	fputs("\n\n*** real CRC ***\n\n", f);
	fputs(realPS2CRC_STR, f);
	fputs(" ", f);
	fputs(&strrchr(path, '/')[1], f);
	
	fputs("\n\n*** RESULT ***\n\n", f);
	
	if(crc == renaCRC) fputs("VALID", f);
	else fputs("NOT VALID", f);
	
	fclose(f);
	
	return SUCCESS;
}

//*******************************************************
// PS2 emu
//*******************************************************

uint8_t PS2emu_is_patched()
{
	struct stat s;
	if(stat("/dev_flash/ps2emu/ps2gxemu_stage2.bin", &s) == 0)
	if(stat("/dev_flash/ps2emu/ps2hwemu_stage2.bin", &s) == 0)	return YES;
	return NO;
}

u32 getCRC(char *self)
{
	u32 memsize=0x1000;
	
	FILE *f = fopen(self, "rb");
	if(f==NULL) return 0;
	u8 *mem=malloc(memsize);
	if(mem==NULL) return 0;
	fread(mem, memsize, 1, f);
	fclose(f);
	u32 crc = crc32(0L, Z_NULL, 0);
	crc = crc32(crc, (const unsigned char*) mem, memsize);
	free(mem);
	
	return crc;
}

uint8_t patch_PS2()
{	
	if( HEN )  return SUCCESS;
	
	if( PS2emu_is_patched() == YES ) return SUCCESS;
	
	uint8_t *ps2gxemu_stage1;
	uint32_t ps2gxemu_stage1_size;
	uint8_t *ps2gxemu_stage2;
	uint32_t ps2gxemu_stage2_size;
	
	uint8_t *ps2hwemu_stage1;
	uint32_t ps2hwemu_stage1_size;
	uint8_t *ps2hwemu_stage2;
	uint32_t ps2hwemu_stage2_size;
	
	uint8_t *ps2netemu_stage2;
	uint32_t ps2netemu_stage2_size;
	
	u32 crc;
	FILE* f;
	
	char tmp_dir[128];
	char tmp_hw[128];
	char tmp_gx[128];
	char tmp_net[128];
	
	sprintf(tmp_dir, "/dev_hdd0/game/%s/USRDIR/temp", ManaGunZ_id);
	sprintf(tmp_hw, "/dev_hdd0/game/%s/USRDIR/temp/ps2_emu.self", ManaGunZ_id);
	sprintf(tmp_gx, "/dev_hdd0/game/%s/USRDIR/temp/ps2_gxemu.self", ManaGunZ_id);
	sprintf(tmp_net, "/dev_hdd0/game/%s/USRDIR/temp/ps2_netemu.self", ManaGunZ_id);
	
	Delete(tmp_dir);
	mkdir(tmp_dir, 0777);
	
	crc = getCRC("/dev_flash/ps2emu/ps2_gxemu.self");
	
	if( get_gxemu(crc, &ps2gxemu_stage1, &ps2gxemu_stage1_size, &ps2gxemu_stage2, &ps2gxemu_stage2_size)==FAILED) {
		print_load("Error: Failed to load_gxemu");
		return FAILED;
	}
	
	if( ps2gen("/dev_flash/ps2emu/ps2_gxemu.self", tmp_gx, ps2gxemu_stage1, ps2gxemu_stage1_size) == FAILED) {
		return FAILED;
	}
	
	crc = getCRC("/dev_flash/ps2emu/ps2_emu.self");
	
	if( get_hwemu(crc, &ps2hwemu_stage1, &ps2hwemu_stage1_size, &ps2hwemu_stage2, &ps2hwemu_stage2_size)==FAILED) {
		print_load("Error: Failed to load_hwemu");
		return FAILED;
	}
	
	if ( ps2gen("/dev_flash/ps2emu/ps2_emu.self", tmp_hw, ps2hwemu_stage1, ps2hwemu_stage1_size) == FAILED) {
		return FAILED;
	}
	
	crc = getCRC("/dev_flash/ps2emu/ps2_netemu.self");
	
	if( get_netemu(crc, &ps2netemu_stage2, &ps2netemu_stage2_size)==FAILED) {
		print_load("Error: Failed to load_gxemu");
		return FAILED;
	}
	
	if( ps2gen("/dev_flash/ps2emu/ps2_netemu.self", tmp_net, ps2netemu_stage2, ps2netemu_stage2_size) == FAILED) {
		return FAILED;
	}
	
	if(path_info("/dev_blind") == _NOT_EXIST) {
		sys_fs_mount("CELL_FS_IOS:BUILTIN_FLSH1", "CELL_FS_FAT", "/dev_blind", 0);
		usleep(1000);
	}
	
	/*
	print_load("Saving Original files...")
	char bak[128];
	sprintf(bak, "/dev_hdd0/game/%s/USRDIR/PS2BAK", ManaGunZ_id);
	Delete(bak);
	if ( Copy("/dev_blind/ps2emu", bak) == FAILED ) {
		print_load("Error : failed to copy original files");
		return FAILED;
	}
	*/
	
	if( path_info("/dev_blind") == _NOT_EXIST) {
		print_load("Error : failed to mount dev_blind");
		return FAILED;
	}
	
	Delete("/dev_blind/ps2emu");
	
	if( Copy(tmp_dir, "/dev_blind/ps2emu") == FAILED ) {
		print_load("Error : failed to copy patched emu files");
		return FAILED;
	}
	
	f = fopen("/dev_blind/ps2emu/ps2hwemu_stage2.bin", "wb");
	if(f==NULL) {
		print_load("Error : failed to create ps2hwemu_stage2.bin");
		return FAILED;
	}
	fwrite(ps2hwemu_stage2, ps2hwemu_stage2_size, 1, f);
	fclose(f);
	
	f = fopen("/dev_blind/ps2emu/ps2gxemu_stage2.bin", "wb");
	if(f==NULL)  {
		print_load("Error : failed to create ps2gxemu_stage2.bin");
		return FAILED;
	}
	fwrite(ps2gxemu_stage2, ps2gxemu_stage2_size, 1, f);
	fclose(f);
	
	return SUCCESS;
}

//*******************************************************
// IRD
//*******************************************************

u8 md5_FromISO_WithFileOffset(char *iso_path, u64 file_offset, u32 file_size, unsigned char output[16])
{
	FILE* f;
	f = fopen(iso_path, "rb");	
	if(f==NULL) {
		memset(output, 0, sizeof(output));
		return FAILED;
	}
	
	u8 split666 = is_66600(iso_path);
	if(is_splitted_iso(iso_path)==YES || split666) {
		
		char iso_path[128];
		char temp[128];
		u64 fsize=0;
		int i;
		int l = strlen(iso_path);
		
		strcpy(iso_path, iso_path);
		iso_path[l-1]=0;
		if(split666) iso_path[l-2]=0;
		strcpy(temp, iso_path);
		
		for(i=0; i<32; i++) {
			if(split666) sprintf(iso_path, "%s%02d", temp, i);
			else sprintf(iso_path, "%s%d", temp, i);
			
			fsize = get_size(iso_path);
			
			if(file_offset<fsize) {
				if(i!=0) {					 
					fclose(f);
					f = fopen(iso_path, "rb");	
					if(f==NULL) return FAILED;
				}
				break;
			}
			file_offset -= fsize;
		}
	}
	
	u64 val64;
	fseek(f, file_offset-0x14, SEEK_SET);
	fread(&val64, sizeof(u64), 1, f);
	
	u8 is_bin=NO;
	if(val64==0xFFFFFFFFFFFFFF00) is_bin=YES;
	
	fseek(f, file_offset, SEEK_SET);
	
    md5_context ctx;
	u32 wrlen = 2048;
    unsigned char buf[wrlen];
	u64 read = 0;
	
	prog_bar1_value=0;
	
	md5_starts( &ctx );	
	
	while(read < file_size) {
		if(read+wrlen > file_size) wrlen = (u32)file_size-read;
		fread(buf, sizeof(u8), wrlen, f);
		if(is_bin) fseek(f, 0x130, SEEK_CUR);
		read += wrlen;
		prog_bar1_value = (read*100)/file_size;
		md5_update(&ctx, buf, wrlen);
		if(cancel) break;
	}
	
	prog_bar1_value=-1;
	
    md5_finish(&ctx, output);

    memset(&ctx, 0, sizeof(md5_context));
	
	if(cancel==YES) {
		memset(output, 0, sizeof(output));
		return FAILED;
	}

	fclose(f);
	
	return SUCCESS;
}

u8 md5_FromStreamISO_WithFileOffset(FILE *f, u64 file_offset, u32 file_size, unsigned char output[16])
{	
	u64 val64;
	fseek(f, file_offset-0x14, SEEK_SET);
	fread(&val64, sizeof(u64), 1, f);
	
	u8 is_bin=NO;
	if(val64==0xFFFFFFFFFFFFFF00) is_bin=YES;
	
	fseek(f, file_offset, SEEK_SET);
	
    md5_context ctx;
	u32 wrlen = 2048;
    unsigned char buf[wrlen];
	u64 read = 0;
	
	prog_bar1_value=0;
	
	md5_starts( &ctx );	
	
	while(read < file_size) {
		if(read+wrlen > file_size) wrlen = (u32)file_size-read;
		fread(buf, sizeof(u8), wrlen, f);
		if(is_bin) fseek(f, 0x130, SEEK_CUR);
		read += wrlen;
		prog_bar1_value = (read*100)/file_size;
		md5_update(&ctx, buf, wrlen);
		if(cancel) break;
	}
	
	prog_bar1_value=-1;
	
    md5_finish(&ctx, output);

    memset(&ctx, 0, sizeof(md5_context));
	
	if(cancel==YES) {
		memset(output, 0, sizeof(output));
		return FAILED;
	}
	
    return SUCCESS;
}

u8 md5_FromISO_WithFileName(char *iso_path, char *filename, unsigned char output[16])
{	
	
	FILE* f;
	f = fopen(iso_path, "rb");	
	if(f==NULL) {
		memset(output, 0, sizeof(output));
		return FAILED;
	}
	
	u64 file_offset=0;
	u8 ret=0;
	u32 file_size=0;

	ret = get_FileOffset(f, filename, &file_offset, (u32 *) &file_size);
	//print_load("Warning : %s offset %llX, size %llX, ret %d", filename, file_offset, file_size, ret);
	
	if(file_offset==0 || file_size==0 || ret == FAILED) {fclose(f);return FAILED;}
	
	fclose(f);
	
	return md5_FromISO_WithFileOffset(iso_path, file_offset, file_size, output);
}

void IRD_addfile(char *filepath, u32 meta_sig, u32 **files_sigs, char ***IRD_Path, u32 *IRD_nPath)
{
	ird_t *ird_c = IRD_load(filepath);
	if(ird_c==NULL) return;
	
	print_debug("IRD_meta_sig3");
	u32 cur_meta_sig = IRD_meta_sig3(ird_c);
	print_debug("cur_meta_sig %X", cur_meta_sig);
	
	print_debug("cur_files_sig");
	
	u32 cur_files_sig = IRD_files_sig(ird_c);
	print_debug("cur_files_sig %X", cur_files_sig);
	
	print_debug("FREE_IRD");
	FREE_IRD(ird_c);
	
	print_debug("cur_meta_sig==meta_sig");
	if(cur_meta_sig!=meta_sig) return;
	
	print_debug("OK");
	int j;
	for(j=0; j<*IRD_nPath; j++) {
		if(*files_sigs[j]==cur_files_sig) return;
	}
	*IRD_nPath = *IRD_nPath + 1;
	print_debug("realloc");
	*IRD_Path = (char **) realloc(*IRD_Path, *IRD_nPath * sizeof(char*));
	print_debug("strcpy_malloc");
	*IRD_Path[*IRD_nPath-1] = strcpy_malloc(filepath);
	*files_sigs[*IRD_nPath-1]=cur_files_sig;
	
}

void IRD_search(ird_t *ird, u32 meta_sig, char *g_path, char ***IRD_Path, u32 *IRD_nPath)
{
	print_head("Searching IRD...");
	char IRD_dir[512]={0};
	char meta_sig_str[8];
	char filepath[512]={0};
	int i;
	
	u32 *files_sigs=(u32 * ) malloc(128 * sizeof(u32));
	memset(files_sigs, 0, 128 * sizeof(u32));
	
	if( files_sigs==NULL) {
		print_load("Error : malloc files_sigs");
		return;
	}
	
	sprintf(meta_sig_str, "%08X", meta_sig);
	print_debug("meta sig %X", meta_sig);
	
	for(i=-1; i<=device_number; i++) {
		memset(IRD_dir, 0, 512);
		
		if( i == -1 ) {
			sprintf(IRD_dir, "/dev_hdd0/game/%s/USRDIR/sys/Check", ManaGunZ_id);
		} else
		if(strstr(list_device[i], "dev_usb")) {
			sprintf(IRD_dir, "/%s/IRD", list_device[i]);
		}
		
		DIR *d;
		struct dirent *dir;
		
		d = opendir(IRD_dir);
		if(d==NULL) continue;
		
		while ((dir = readdir(d))) {
			if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
			if(dir->d_type & DT_DIR) continue;
				
			memset(filepath, 0, 512);
			sprintf(filepath, "%s/%s", IRD_dir, dir->d_name);
			print_debug(filepath);
			
			char *ext = GetExtension(filepath);
			if( strcasecmp(ext, ".ird") != 0) continue;
			if( strncmp(meta_sig_str, dir->d_name, 8) != 0 && strncmp(ird->GameId, dir->d_name, 9) != 0) continue;			
			
			IRD_addfile(filepath, meta_sig, &files_sigs, IRD_Path, IRD_nPath);
			
		}
		closedir(d);
	}
	
	strcpy(filepath, g_path);
	RemoveExtension(filepath);
	strcat(filepath, ".ird");
	if( path_info(filepath) == _FILE) IRD_addfile(filepath, meta_sig, &files_sigs, IRD_Path, IRD_nPath);
	
	FREE(files_sigs);
	
	print_debug("End of search IRD");
}

void IRD_download2(ird_t *ird, u32 meta_sig, char ***IRD_Path, u32 *IRD_nPath)
{
	
	print_head("Downloading IRD ...");
	FILE* f;
	char url[512]= "http://jonnysp.bplaced.net/data.php?";
	
	strcat(url, "columns%5B"  "0"  "%5D%5Bdata%5D="  "id"            "&columns%5B" "0"  "%5D%5Bsearchable%5D=true&columns%5B" "0" "%5D%5Bsearch%5D%5Bvalue%5D=");
	strcat(url, ird->GameId);
	strcat(url, "&columns%5B" "1"  "%5D%5Bdata%5D="  "app_version"   "&columns%5B" "1"  "%5D%5Bsearchable%5D=true&columns%5B" "1" "%5D%5Bsearch%5D%5Bvalue%5D=");
	strcat(url, ird->AppVersion);
	strcat(url, "&columns%5B" "2"  "%5D%5Bdata%5D="  "game_version"  "&columns%5B" "2"  "%5D%5Bsearchable%5D=true&columns%5B" "2" "%5D%5Bsearch%5D%5Bvalue%5D=");
	strcat(url, ird->GameVersion);
	strcat(url, "&columns%5B" "3"  "%5D%5Bdata%5D="  "update_version" "&columns%5B" "3"  "%5D%5Bsearchable%5D=true&columns%5B" "3" "%5D%5Bsearch%5D%5Bvalue%5D=");
	strcat(url, ird->UpdateVersion);
	
	
	if( download(url, "/dev_hdd0/tmp/ird.tmp") == FAILED ) {
		return;
	}
	
	f = fopen("/dev_hdd0/tmp/ird.tmp", "rb");
	if(f == NULL) {
		print_load("Error : ird.tmp not found");
		return;
	}
	fseek (f , 0 , SEEK_END);
	u32 size = ftell (f);
	fseek(f, 0, SEEK_SET);
	
	char *mem = (char *) malloc(size);
	if(mem==NULL) return;
	fread(mem,1,size, f);
	fclose(f);
	Delete("/dev_hdd0/tmp/ird.tmp");
	
	char IRD_url[128];
	char IRD_dst[128];
	int n;
	strcpy(IRD_url, "http://jonnysp.bplaced.net/ird/");
	
	for(n=0; n<size ; n++) {
		if(!memcmp((char *) &mem[n], (char *) ird->GameId, 9)) {
			if( mem[n+9] == '-' ) {
				strncat(IRD_url, &mem[n], 46);
				break;
			}
		}
	}
	free(mem);
	
	sprintf(IRD_dst, "/dev_hdd0/game/%s/USRDIR/sys/Check", ManaGunZ_id);
	mkdir(IRD_dst, 0777);
	char *date = get_date();
	if(date==NULL) {
		print_debug("Error : can't get the date");
		return;
	}
	sprintf(IRD_dst, "/dev_hdd0/game/%s/USRDIR/sys/Check/%s_%08X.ird", ManaGunZ_id, date, meta_sig);
	free(date);
	
	
	if( download(IRD_url, IRD_dst) == FAILED) {
		Delete(IRD_dst);
		return;
	}
	
	u32 sig = IRD_meta_sig(IRD_dst);
				
	if(sig==meta_sig) {
		char *full_sig = IRD_sig(IRD_dst);
		if(full_sig == NULL) {
			print_debug("Error : couldn't get full_sig ird_download2");
			return;
		}
		char filename[512];
		sprintf(filename, "/dev_hdd0/game/%s/USRDIR/sys/Check/%s.ird", ManaGunZ_id, full_sig);
		free(full_sig);
		
		if(path_info(filename) == _FILE) return;
		
		rename(IRD_dst, filename);
		
		*IRD_nPath = *IRD_nPath + 1;
		*IRD_Path = (char **) realloc(*IRD_Path, *IRD_nPath * sizeof(char*));
		*IRD_Path[*IRD_nPath-1] = strcpy_malloc(filename);
	}
}

void IRD_download(ird_t *ird, u32 meta_sig, char ***IRD_Path, u32 *IRD_nPath)
{
	print_head("Downloading IRD ...");
	char line[255]={0};
	char filepath[512]={0};
	char URL[512]={0};
	char tmp[512]={0};
	
	char IRD_dir[512]={0};
	sprintf(IRD_dir, "/dev_hdd0/game/%s/USRDIR/sys/Check", ManaGunZ_id);
	
	sprintf(URL, IRD_SCRIPT "?ird=%08X", meta_sig);
	
	sprintf(tmp, "/dev_hdd0/game/%s/USRDIR/temp", ManaGunZ_id);
	mkdir(tmp, 0777);
	sprintf(tmp, "/dev_hdd0/game/%s/USRDIR/temp/%08X.txt", ManaGunZ_id, meta_sig);
	
	if( download(URL, tmp)==FAILED) return;
	
	FILE *f = fopen(tmp, "rb");
	if(f==NULL) return;
	
	while(fgets(line, 255, f) != NULL) {
		if(line[0]=='\r' || line[0]=='\n') continue;
		if(strstr(line, "\r") != NULL) strtok(line, "\r");
		if(strstr(line, "\n") != NULL) strtok(line, "\n");
		
		sprintf(URL, IRD_SERVER "/%s", line);
		sprintf(filepath, "%s/%s", IRD_dir, line); 
		
		if( download(URL, filepath) == SUCCESS) {
			
			u32 sig = IRD_meta_sig(filepath);
				
			if(sig==meta_sig) {
				*IRD_nPath = *IRD_nPath + 1;
				*IRD_Path = (char **) realloc(*IRD_Path, *IRD_nPath * sizeof(char*));
				*IRD_Path[*IRD_nPath-1] = strcpy_malloc(filepath);
			}
		}
		memset(line, 0, 255);
	}
	fclose(f);
	Delete(tmp);	
}

u8 IRD_check(char *G_PATH)
{
	char **IRD_Path=NULL;
	u32 IRD_nPath=0;
	u32 meta_sig = 0;
	
// SEARCH with TITLE_ID
	ird_t *ird = IRD_new(G_PATH);
	if(ird == NULL) {
		print_load("Error : failed to get struct ird_t");
		return FAILED;
	}
	
	meta_sig = IRD_meta_sig3(ird);
	
	IRD_search(ird, meta_sig, G_PATH, &IRD_Path, &IRD_nPath); 
	if( IRD_nPath != 0 ) goto check;
	
// SEARCH
	IRD_download(ird, meta_sig, &IRD_Path, &IRD_nPath);
	//IRD_download2(ird, meta_sig, &IRD_Path, &IRD_nPath);
	if( IRD_nPath != 0 ) goto check;
	
	print_load("Error : IRD not found !");
	
	FREE_IRD(ird);
	
	return FAILED;
	
check:
	print_head("Checking MD5...");
	print_load("%d IRD file(s) found", IRD_nPath);
	
	IRD_check_md5(G_PATH, IRD_Path, IRD_nPath);
	
	print_debug("FREE_IRD");
	sleep(3);
	
	FREE_IRD(ird);
	
	print_debug("end of IRD_check");
	
	if(cancel == YES) return FAILED;
	
	return SUCCESS;
}

//*******************************************************
// Covers
//*******************************************************

u8 Get_ID(char *gpath, u8 platform, char *game_ID)
{
	if(platform == ISO_PS3 || platform == JB_PS3 || platform == BDVD) {
		return GetParamSFO("TITLE_ID", game_ID, gpath);	
	} else
	if(platform == ISO_PSP || platform == JB_PSP) {
		return GetParamSFO("DISC_ID", game_ID, gpath);
	} else
	if(platform == ISO_PS2 || platform == ISO_PS1) {
		char *mem = NULL;
		int size;
		mem = LoadFileFromISO(NO, gpath, "SYSTEM.CNF", &size);
		if(mem==NULL) return FAILED;
		if( strstr(mem, ";") != NULL) strtok(mem, ";");
		if( strstr(mem, "\\") != NULL) strcpy(game_ID, &strrchr(mem, '\\')[1]); else
		if( strstr(mem, ":") != NULL) strcpy(game_ID, &strrchr(mem, ':')[1]);
		free(mem);
	} else
	if(platform == JB_PS2 || platform == JB_PS1) {
		char temp[255];
		sprintf(temp, "%s/SYSTEM.CNF", gpath);
		char *mem = NULL;
		int size;
		mem = LoadFile(temp, &size);
		if(mem==NULL) return FAILED;
		if( strstr(mem, ";") != NULL) strtok(mem, ";");
		if( strstr(mem, "\\") != NULL) strcpy(game_ID, &strrchr(mem, '\\')[1]); else
		if( strstr(mem, ":") != NULL) strcpy(game_ID, &strrchr(mem, ':')[1]);
		free(mem);
	} 
	else return FAILED;
	
	return SUCCESS;
	
}

char lowit(char in){
	if('A'<=in && in<='Z') 
		return in-('Z'-'z');
	return in;
} 

char upit(char in){
	if('a'<=in && in<='z') 
		return in+('Z'-'z');
	return in;
} 

u32 Download_covers()
{
	int i;
	char game_ID[20];
	char link[255];
	char out[255];
	
	u32 nb_dl = 0;
	
	print_head("Downloading covers");
	
	for(i=0; i<=game_number; i++) {
		prog_bar1_value = (i*100)/game_number;
		
		if(cancel==YES) break;
		
		memset(game_ID, 0, sizeof(game_ID));
		memset(link, 0, sizeof(link));
		
		strcpy(game_ID, list_game_ID[i]);
		
		int j;
		for(j=0; j < strlen(game_ID); j++) game_ID[j] = upit(game_ID[j]);
		
		if(list_game_platform[i] == BDVD || list_game_platform[i] == JB_PS3 || list_game_platform[i] == ISO_PS3)
		if(strstr(game_ID, "NP") != NULL) continue;
		
		sprintf(out, "/dev_hdd0/game/%s/USRDIR/covers/%s.JPG", ManaGunZ_id, game_ID);
		
		if(path_info(out)==_FILE) {print_load("OK : %s", list_game_title[i]); continue;}
		
		sprintf(link, "http://gamecovers.free.fr/download.php?file=%s.jpg", game_ID);

		if(download(link, out) == SUCCESS) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
		
		/*	
		
		// PS3
		http://www.gametdb.com/PS3/BCES00001
		
		// PS2/PSP/PS3
		http://sce.scene7.com/is/image/playstation/bljs10332_jacket
		http://sce.scene7.com/is/image/playstation/sles51800_jacket
		sles51800
		SLES-51800
		
		// PS2/PS2/PSX/PSP
		http://www.gameswave.com/media/PS3/BCES-00001/pics/_source.png
		http://www.gameswave.com/media/PS2/SCES-50000/pics/_source.png
		http://www.gameswave.com/media/PSX/SCES-00001/pics/_source.png
		http://www.gameswave.com/media/PSP/UCES-00001/pics/_source.png 
		
		// PSP/PS3
		http://renascene.com
		
		// PS2
		http://opl.sksapps.com
		
		// PSX/PS2/PSP
		http://psxdatacenter.com
		
		// PSX
		http://playstationmuseum.com/product-codes/slus-00870/
		
		http://www.play-asia.com
		http://www.suruga-ya.jp	
		http://www.jeuxactu.com
		http://www.jeuxvideo.com
		
		
		u8 found = NO;
		int n,k;
		if(list_game_platform[i] == JB_PS3 || list_game_platform[i] == ISO_PS3) {
			//sprintf(link, "http://damox.net/images/covers/PS3/%s.JPG", game_ID);
			
			//if(download(link, out) == SUCCESS) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}

			char region[17][4] = {"US","EN","FR","ES","DE","IT","AU","NL","PT","SE","DK","NO","FI","TR","KO","RU","JA"};
			for (n = 0; n < 17; n++) {
				sprintf(link, "http://art.gametdb.com/ps3/cover/%s/%s.jpg", &region[n][0], game_ID);
				if(download(link, out) == SUCCESS) {found=YES; break;} 
			}
			if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			
			char lowID[10];
			strcpy(lowID, game_ID);
			lowID[0]=lowit(lowID[0]);
			lowID[1]=lowit(lowID[1]);
			lowID[2]=lowit(lowID[2]);
			lowID[3]=lowit(lowID[3]);
			sprintf(link, "http://sce.scene7.com/is/image/playstation/%s_jacket", lowID);
			if(download(link, out) == SUCCESS) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			
			sprintf(link, "http://renascene.com/ps3/?target=search&srchser=1&srch=%s", game_ID);
			if(download(link, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
				char *data;
				int file_size;
				char tmp[255];
				data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
				Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
				char *pch = strstr(data, "http://renascene.com/ps3/info/");
				if(pch != NULL) {
					strncpy(tmp, pch, 40);
					if( strstr(tmp, "\"") != NULL) strtok(tmp, "\"");
					if(download(tmp, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
						free(data);
						data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
						Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
						char *pch2 = strstr(data, "http://renascene.com/pics/ps3/poster/");
						if(pch2 != NULL) {
							strncpy(tmp, pch2, 255);
							if( strstr(tmp, ">") != NULL) strtok(tmp, ">");
							if(download(tmp, out)==SUCCESS) found=YES;
						}
					}
				}
				free(data);
			}
			
			if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			print_load("FAILED : %s", list_game_title[i]); 
		} else
		if(list_game_platform[i] == JB_PS2 || list_game_platform[i] == ISO_PS2) {
			
			//sprintf(link, "http://opl.sksapps.com/art/%s_COV.jpg", game_ID);
			//if( download(link, out) == SUCCESS) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			
			sprintf(link, "http://oplmanager.no-ip.info/site/?gamedetails&game=%s", game_ID);
			if(download(link, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
				char *data;
				int file_size;
				char tmp[128];
				data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
				char *pch = strstr(data, "/files/COV/");
				if(pch != NULL) {
					strncpy(tmp, pch, 127);
					if( strstr(tmp, "'") != NULL) strtok(tmp, "'");
					sprintf(link, "http://oplmanager.no-ip.info%s", tmp);
					if(download(link, out)==SUCCESS) found=YES; 
				}
				Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
				free(data);
			}
			
			if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			
			char region[3] = {'U','P','J'};
			char letter[27][4];
			strcpy(letter[0], "0-9"); for(n=0; n < 26; n++) sprintf(letter[1+n], "%c", 65+n);
			
			char ID[20];				
			strcpy(ID, game_ID);
			ID[4]='-';
			ID[8]=ID[9];
			ID[9]=ID[10];
			ID[10]=0;
			
			n=-1;
			
			if(ID[2]=='U') n = 0; else
			if(ID[2]=='E') n = 1; else
			if(ID[2]=='P') n = 2;
				
			if(n != -1) {
				for(k=0; k<27; k++) {
					sprintf(link, "http://psxdatacenter.com/psx2/images2/covers/%c/%s/%s.jpg", region[n], letter[k], ID);
					if(download(link, out)==SUCCESS) {found=YES; break;} 
				}
			} else {
				u8 found = NO;
				for(n=0; n<3; n++) {
					for(k=0; k<27; k++) {
						sprintf(link, "http://psxdatacenter.com/psx2/images2/covers/%c/%s/%s.jpg", region[n], letter[k], ID);
						if(download(link, out)==SUCCESS) {found = YES; break;}
					}
					if(found==YES) break;
				}
			}
			if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
						
			print_load("FAILED : %s", list_game_title[i]); 
		} else
		if(list_game_platform[i] == JB_PS1 || list_game_platform[i] == ISO_PS1) {
			
			//see http://playstationmuseum.com/product-codes/%s
			
			char region[3] = {'U','P','J'};
			char letter[27][4];
			strcpy(letter[0], "0-9"); for(n=0; n < 26; n++) sprintf(letter[1+n], "%c", 65+n);
			
			char ID[20];				
			strcpy(ID, game_ID);
			ID[4]='-';
			ID[8]=ID[9];
			ID[9]=ID[10];
			ID[10]=0;
				
			n=-1;
			
			if(ID[2]=='U') n = 0; else
			if(ID[2]=='E') n = 1; else
			if(ID[2]=='P') n = 2;
			
			if(n != -1) {
				for(k=0; k<27; k++) {
					sprintf(link, "http://psxdatacenter.com/images/covers/%c/%s/%s.jpg", region[n], letter[k], ID);
					if(download(link, out)==SUCCESS) {found=YES; break;}
				}
			} else {
				for(n=0; n<3; n++) {
					for(k=0; k<27; k++) {
						sprintf(link, "http://psxdatacenter.com/images/covers/%c/%s/%s.jpg", region[n], letter[k], ID);
						if(download(link, out)==SUCCESS)  {found = YES; break;}
					}
					if(found==YES) break;
				}
			}
			
			if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			else print_load("FAILED : %s", list_game_title[i]); 
		} else
		if(list_game_platform[i] == JB_PSP || list_game_platform[i] == ISO_PSP) {
			
			//sprintf(link, "http://damox.net/images/covers/PSP/%s.jpg", game_ID);
			//if(download(link, out) == SUCCESS) found=YES;
			
			//if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			
			char lowID[10];
			strcpy(lowID, game_ID);
			lowID[0]=lowit(lowID[0]);
			lowID[0]=lowit(lowID[1]);
			lowID[0]=lowit(lowID[2]);
			lowID[0]=lowit(lowID[3]);
			sprintf(link, "http://sce.scene7.com/is/image/playstation/%s_jacket", lowID);
			if(download(link, out) == SUCCESS) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
			
			sprintf(link, "http://renascene.com/?target=search1&srchser=1&srch=%s", game_ID);
			if(download(link, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
				char *data;
				int file_size;
				char tmp[255];
				data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
				Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
				char *pch = strstr(data, "http://renascene.com/info/umd/");
				if(pch != NULL) {
					strncpy(tmp, pch, 40);
					if( strstr(tmp, "'") != NULL) strtok(tmp, "'");
					if(download(tmp, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp")==SUCCESS) {
						free(data);
						data = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", &file_size);
						Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
						char *pch2 = strstr(data, "http://renascene.com/pics/poster/Norm/");
						if(pch2 != NULL) {
							strncpy(tmp, pch2, 255);
							if( strstr(tmp, ">") != NULL) strtok(tmp, ">");
							if(download(tmp, out)==SUCCESS) found=YES;
						}
					}
				}
				free(data);
			}
			
			if(found==YES) {print_load("OK : %s", list_game_title[i]); nb_dl++; continue;}
		}
		*/
		
		print_load("FAILED : %s", list_game_title[i]); 
		
	}
	
	return nb_dl;
}

//*******************************************************
//Remove P&P
//*******************************************************

void remove_cfw_syscalls()
{
	u64 syscall_not_impl ;
	
	syscall_not_impl = lv2peek(SYSCALL_TABLE);
	
	lv2poke(SYSCALL_TABLE + (8*6), syscall_not_impl);
	lv2poke(SYSCALL_TABLE + (8*8), syscall_not_impl);
	lv2poke(SYSCALL_TABLE + (8*9), syscall_not_impl);
	lv2poke(SYSCALL_TABLE + (8*10), syscall_not_impl);
	lv2poke(SYSCALL_TABLE + (8*35), syscall_not_impl);
	lv2poke(SYSCALL_TABLE + (8*36), syscall_not_impl);
	lv2poke(SYSCALL_TABLE + (8*7), syscall_not_impl);
	
	if(lv2peek(0x8000000000003000ULL)==0xFFFFFFFF80010003ULL) {
		lv2syscall3(392, 0x1004, 0xa, 0x1b6); //buzzer
		return;
	}
	
	u64 sc_not_impl_pt = lv2peek(syscall_not_impl);
	u64 sc6 = lv2peek(SYSCALL_TABLE + (8*6));
	//u64 sc8 = lv2peek(SYSCALL_TABLE + (8*8));
	u64 sc9 = lv2peek(SYSCALL_TABLE + (8*9));
	u64 sc10 = lv2peek(SYSCALL_TABLE + (8*10));
	u64 sc35 = lv2peek(SYSCALL_TABLE + (8*35));
	u64 sc36 = lv2peek(SYSCALL_TABLE + (8*36));
	u64 sc7 = lv2peek(SYSCALL_TABLE + (8*7));
	
	if(sc6!=syscall_not_impl) lv2poke(sc6, sc_not_impl_pt);
	//if(sc8!=syscall_not_impl) lv2poke(sc8, sc_not_impl_pt);
	if(sc9!=syscall_not_impl) lv2poke(sc9, sc_not_impl_pt);
	if(sc10!=syscall_not_impl) lv2poke(sc10, sc_not_impl_pt);
	if(sc35!=syscall_not_impl) lv2poke(sc35, sc_not_impl_pt);
	if(sc36!=syscall_not_impl) lv2poke(sc36, sc_not_impl_pt);
	if(sc7!=syscall_not_impl) lv2poke(sc7, sc_not_impl_pt);
	
	if(lv2peek(0x8000000000003000ULL)==0xFFFFFFFF80010003ULL) {
		lv2syscall3(392, 0x1004, 0xa, 0x1b6);
	}
	
}

//*******************************************************
// Signed ELF
//*******************************************************

int make_EBOOT_NPDRM(char *in, char *out, char *content_id)
{
	_template = NULL;
	_file_type = NULL;
	_compress_data = NULL;
	_skip_sections = NULL;
	_key_rev = NULL;
	_meta_info = NULL;
	_keyset = NULL;
	_auth_id = NULL;
	_vendor_id = NULL;
	_self_type = NULL;
	_app_version = NULL;
	_fw_version = NULL;
	_add_shdrs = NULL;
	_ctrl_flags = NULL;
	_cap_flags = NULL;
	#ifdef CONFIG_CUSTOM_INDIV_SEED
	_indiv_seed = NULL;
	#endif
	_license_type = NULL;
	_app_type = NULL;
	_content_id = NULL;
	_klicensee = NULL;
	_real_fname = NULL;
	_add_sig = NULL;
	
	_decrypt_file = FALSE;
	_encrypt_file = FALSE;
	
	_file_type=(char*) "SELF";
	_compress_data=(char*) "TRUE";
	_skip_sections =(char*) "TRUE";
	_key_rev=(char*) "1C"; 
	_auth_id=(char*) "1010000001000003";
	_vendor_id=(char*) "01000002";
	_app_version=(char*) "0001000000000000";
	_fw_version=(char*) "0004002100000000";
	_add_shdrs=(char*) "TRUE";
	_license_type=(char*) "FREE";
	_app_type=(char*) "EXEC";
	_self_type=(char*) "NPDRM";
	_content_id = (char*) content_id;
	_real_fname=(char*) "EBOOT.BIN";
	_ctrl_flags = "4000000000000000000000000000000000000000000000000000000000000002";
	_cap_flags = "00000000000000000000000000000000000000000000007B0000000100000000";
	_encrypt_file = TRUE;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/keys", ManaGunZ_id);
	if(keys_load(temp_buffer) == FALSE) return NOK;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/ldr_curves", ManaGunZ_id);
	if(curves_load(temp_buffer) == FALSE) return NOK;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/vsh_curves", ManaGunZ_id);
	if(vsh_curves_load(temp_buffer) == FALSE) return NOK;
	
	if(frontend_encrypt(in, out) != 0) return NOK;

	return OK;
}

int Sign_PRX(char *in, char *out)
{
	_template = NULL;
	_file_type = NULL;
	_compress_data = NULL;
	_skip_sections = NULL;
	_key_rev = NULL;
	_meta_info = NULL;
	_keyset = NULL;
	_auth_id = NULL;
	_vendor_id = NULL;
	_self_type = NULL;
	_app_version = NULL;
	_fw_version = NULL;
	_add_shdrs = NULL;
	_ctrl_flags = NULL;
	_cap_flags = NULL;
	#ifdef CONFIG_CUSTOM_INDIV_SEED
	_indiv_seed = NULL;
	#endif
	_license_type = NULL;
	_app_type = NULL;
	_content_id = NULL;
	_klicensee = NULL;
	_real_fname = NULL;
	_add_sig = NULL;

	
	_file_type=(char*) "SELF";
	_compress_data=(char*) "TRUE";
	_skip_sections =(char*) "FALSE";
	_key_rev=(char*) "1C"; 
	_auth_id=(char*) "1010000001000003";
	_vendor_id=(char*) "01000002";
	_app_version=(char*) "0001000000000000";
	_fw_version=(char*) "0004002100000000";
	_add_shdrs=(char*) "TRUE";
	_self_type=(char*) "APP";
	_encrypt_file = TRUE;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/keys", ManaGunZ_id);
	if(keys_load(temp_buffer) == FALSE) return NOK;

	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/ldr_curves", ManaGunZ_id);
	if(curves_load(temp_buffer) == FALSE) return NOK;

	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/vsh_curves", ManaGunZ_id);
	if(vsh_curves_load(temp_buffer) == FALSE) return NOK;

	if(frontend_encrypt(in, out)) return NOK;

	return OK;

}

int Sign_ELF(char *in, char *out)
{
	_template = NULL;
	_file_type = NULL;
	_compress_data = NULL;
	_skip_sections = NULL;
	_key_rev = NULL;
	_meta_info = NULL;
	_keyset = NULL;
	_auth_id = NULL;
	_vendor_id = NULL;
	_self_type = NULL;
	_app_version = NULL;
	_fw_version = NULL;
	_add_shdrs = NULL;
	_ctrl_flags = NULL;
	_cap_flags = NULL;
	#ifdef CONFIG_CUSTOM_INDIV_SEED
	_indiv_seed = NULL;
	#endif
	_license_type = NULL;
	_app_type = NULL;
	_content_id = NULL;
	_klicensee = NULL;
	_real_fname = NULL;
	_add_sig = NULL;

	_file_type=(char*) "SELF";
	_compress_data=(char*) "TRUE";
	_key_rev=(char*) "1C"; 
	_auth_id=(char*) "1010000001000003";
	_vendor_id=(char*) "01000002";
	_app_version=(char*) "0001000000000000";
	_fw_version=(char*) "0004002100000000";
	_license_type=(char*) "FREE";
	_app_type=(char*) "EXEC";
	_self_type=(char*) "APP";
	_ctrl_flags = "4000000000000000000000000000000000000000000000000000000000000002";
	_cap_flags = "00000000000000000000000000000000000000000000007B0000000100000000";
	_encrypt_file = TRUE;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/keys", ManaGunZ_id);
	if(keys_load(temp_buffer) == FALSE) return NOK;

	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/ldr_curves", ManaGunZ_id);
	if(curves_load(temp_buffer) == FALSE) return NOK;

	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/vsh_curves", ManaGunZ_id);
	if(vsh_curves_load(temp_buffer) == FALSE) return NOK;

	if(frontend_encrypt(in, out)) return NOK;

	return OK;

}

int Sign_EBOOT(char *in, char *out)
{
	_template = NULL;
	_file_type = NULL;
	_compress_data = NULL;
	_skip_sections = NULL;
	_key_rev = NULL;
	_meta_info = NULL;
	_keyset = NULL;
	_auth_id = NULL;
	_vendor_id = NULL;
	_self_type = NULL;
	_app_version = NULL;
	_fw_version = NULL;
	_add_shdrs = NULL;
	_ctrl_flags = NULL;
	_cap_flags = NULL;
	#ifdef CONFIG_CUSTOM_INDIV_SEED
	_indiv_seed = NULL;
	#endif
	_license_type = NULL;
	_app_type = NULL;
	_content_id = NULL;
	_klicensee = NULL;
	_real_fname = NULL;
	_add_sig = NULL;
	
	_decrypt_file = FALSE;
	_encrypt_file = FALSE;
	
	_file_type=(char*) "SELF";
	_compress_data=(char*) "TRUE";
	_skip_sections =(char*) "TRUE";
	_key_rev=(char*) "1C"; 
	_auth_id=(char*) "1010000001000003";
	_vendor_id=(char*) "01000002";
	_app_version=(char*) "0001000000000000";
	_fw_version=(char*) "0004002100000000";
	_add_shdrs=(char*) "TRUE";
	_app_type=(char*) "EXEC";
	_self_type=(char*) "APP";
	_real_fname=(char*) "EBOOT.BIN";
	_ctrl_flags = "4000000000000000000000000000000000000000000000000000000000000002";
	_cap_flags = "00000000000000000000000000000000000000000000007B0000000100000000";
	_encrypt_file = TRUE;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/keys", ManaGunZ_id);
	if(keys_load(temp_buffer) == FALSE) return NOK;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/ldr_curves", ManaGunZ_id);
	if(curves_load(temp_buffer) == FALSE) return NOK;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/vsh_curves", ManaGunZ_id);
	if(vsh_curves_load(temp_buffer) == FALSE) return NOK;
	
	if(frontend_encrypt(in, out) != 0) return NOK;

	return OK;
}

int Sign_PS2ELF(char *in, char *out)
{
	_template = NULL;
	_file_type = NULL;
	_compress_data = NULL;
	_skip_sections = NULL;
	_key_rev = NULL;
	_meta_info = NULL;
	_keyset = NULL;
	_auth_id = NULL;
	_vendor_id = NULL;
	_self_type = NULL;
	_app_version = NULL;
	_fw_version = NULL;
	_add_shdrs = NULL;
	_ctrl_flags = NULL;
	_cap_flags = NULL;
	#ifdef CONFIG_CUSTOM_INDIV_SEED
	_indiv_seed = NULL;
	#endif
	_license_type = NULL;
	_app_type = NULL;
	_content_id = NULL;
	_klicensee = NULL;
	_real_fname = NULL;
	_add_sig = NULL;

	_file_type=(char*) "SELF";
	_compress_data=(char*) "TRUE";
	_skip_sections =(char*) "FALSE";
	_auth_id=(char*) "1020000401000001";
	_add_shdrs=(char*) "TRUE";
	_vendor_id=(char*) "02000003";
	_self_type=(char*) "LV2";
	_key_rev=(char*) "0";
	_fw_version=(char*) "0004002100000000";
	_app_version=(char*) "0004002100000000";
	_encrypt_file = TRUE;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/keys", ManaGunZ_id);
	if(keys_load(temp_buffer) == FALSE) return NOK;

	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/ldr_curves", ManaGunZ_id);
	if(curves_load(temp_buffer) == FALSE) return NOK;

	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/vsh_curves", ManaGunZ_id);
	if(vsh_curves_load(temp_buffer) == FALSE) return NOK;

	if(frontend_encrypt(in, out)) return NOK;

	return OK;

}

int Extract_SELF(char *in, char *out, u8 *rif)
{
	_template = NULL;
	_file_type = NULL;
	_compress_data = NULL;
	_skip_sections = NULL;
	_key_rev = NULL;
	_meta_info = NULL;
	_keyset = NULL;
	_auth_id = NULL;
	_vendor_id = NULL;
	_self_type = NULL;
	_app_version = NULL;
	_fw_version = NULL;
	_add_shdrs = NULL;
	_ctrl_flags = NULL;
	_cap_flags = NULL;
	#ifdef CONFIG_CUSTOM_INDIV_SEED
	_indiv_seed = NULL;
	#endif
	_license_type = NULL;
	_app_type = NULL;
	_content_id = NULL;
	_klicensee = NULL;
	_real_fname = NULL;
	_add_sig = NULL;
	
	_decrypt_file = FALSE;
	_encrypt_file = FALSE;
	
	_file_type=(char*) "SELF";
	_decrypt_file = TRUE;
	
	if(rif) np_set_klicensee(rif);
	
	print_head("Extracting %s", in);
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/keys", ManaGunZ_id);
	if(keys_load(temp_buffer) == FALSE) return NOK;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/ldr_curves", ManaGunZ_id);
	if(curves_load(temp_buffer) == FALSE) return NOK;
	
	memset(temp_buffer, 0, sizeof(temp_buffer));
	sprintf(temp_buffer, "/dev_hdd0/game/%s/USRDIR/sys/data/vsh_curves", ManaGunZ_id);
	if(vsh_curves_load(temp_buffer) == FALSE) return NOK;
	
	if(frontend_decrypt(in, out)) return NOK;

	return OK;

}

u8 re_sign_EBOOT(char *path)
{
	print_load("Re-signing EBOOT.BIN");
	
	char elf[128];
	char bak[128];
	
	char local_path[128]; //faster in local if file is in usb
	
	sprintf(local_path, "/dev_hdd0/game/%s/USRDIR/sys/EBOOT.BIN", ManaGunZ_id);

	if(CopyFile(path, local_path) != SUCCESS){
		print_load("Error : Failed to copy EBOOT.BIN to the local path");
		return FAILED;
	}
	
	strcpy(elf, local_path);	
	RemoveExtension(elf);
	strcat(elf, ".elf");
	
	if(Extract_SELF(local_path, elf, NULL)==FAILED) {
		print_load("Error : Failed extract EBOOT.BIN");
		return FAILED;
	}
	
	Delete(local_path);
	
	if(Sign_EBOOT(elf, local_path)==FAILED) {
		print_load("Error : Failed sign EBOOT.BIN");
		return FAILED;
	}
	
	strcpy(bak, path);
	strcat(bak, ".MGZBAK");
	
	rename(path, bak);
	
	if(CopyFile(local_path, path) != SUCCESS) {
		print_load("Error : Failed to copy re-signed EBOOT.BIN to the original path");
		rename(bak, path);
		return FAILED;
	}
	
	Delete(local_path);
	Delete(elf);
	
	return SUCCESS;
}

u8 re_sign_SELF(char *path)
{	
	char elf[128];
	char bak[128];
	char local_path[128]; //faster in hdd0
	char *filename;
	
	filename=strrchr(path, '/');
	filename=&filename[1];
	
	print_load("Re-signing %s", filename);
	
	sprintf(local_path, "/dev_hdd0/game/%s/USRDIR/sys/%s", ManaGunZ_id, filename);

	if(CopyFile(path, local_path) != SUCCESS){
		print_load("Error : Failed to copy %s to the local path", filename);
		return FAILED;
	}
	
	strcpy(elf, local_path);	
	RemoveExtension(elf);
	strcat(elf, ".elf");
	
	if(Extract_SELF(local_path, elf, NULL)==FAILED) {
		print_load("Error : Failed extract %s", filename);
		return FAILED;
	}
	
	Delete(local_path);
	
	if(Sign_ELF(elf, local_path)==FAILED) {
		print_load("Error : Failed sign %s", filename);
		return FAILED;
	}
	
	strcpy(bak, path);
	strcat(bak, ".MGZBAK");
	
	rename(path, bak);
	
	if(CopyFile(local_path, path) != SUCCESS) {
		print_load("Error : Failed to copy re-signed %s to the original path", filename);
		rename(bak, path);
		return FAILED;
	}
	
	Delete(local_path);
	Delete(elf);
	
	return SUCCESS;
}

u8 re_sign_SPRX(char *path)
{	
	char prx[128];
	char bak[128];
	char local_path[128]; //faster in local if file is in usb
	char *filename;
	
	filename=strrchr(path, '/');
	filename=&filename[1];
	
	print_load("Re-signing %s", filename);
	
	sprintf(local_path, "/dev_hdd0/game/%s/USRDIR/sys/%s", ManaGunZ_id, filename);
	
	if(CopyFile(local_path, path) != SUCCESS) {
		print_load("Error : Failed to copy %s to the local path", filename);
		return FAILED;
	}
	
	strcpy(prx, local_path);	
	RemoveExtension(prx);
	strcat(prx, ".prx");
	
	if(Extract_SELF(local_path, prx, NULL)==FAILED) {
		print_load("Error : Failed extract %s", filename);
		return FAILED;
	}
	
	Delete(local_path);
	
	if(Sign_PRX(prx, local_path)==FAILED) {
		print_load("Error : Failed sign %s", filename);
		return FAILED;
	}
	
	strcpy(bak, path);
	strcat(bak, ".MGZBAK");
	
	rename(path, bak);
	
	if(CopyFile(local_path, path) != SUCCESS) {
		print_load("Error : Failed to copy re-signed %s to the original path", filename);
		rename(bak, path);
		return FAILED;
	}
	
	Delete(local_path);
	Delete(prx);
	
	return SUCCESS;
	
}

u8 is_resigned_GAME(char *path)
{
	char temp[255];
	
	sprintf(temp, "%s/PS3_GAME/USRDIR/EBOOT.BIN.MGZBAK", path);
	
	if(path_info(temp) == _FILE) return YES;
	
	return NO;

}

u8 restore_GAME(char *path)
{
	char temp[255];
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(path);
	if(d==NULL) return FAILED;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		sprintf(temp, "%s/%s", path, dir->d_name);
		
		if(dir->d_type & DT_DIR) {
			restore_GAME(temp);
		}
		else if (strcmp(&temp[strlen(temp)-7], ".MGZBAK")==0) {
			char temp2[255];
			strcpy(temp2, temp);
			temp2[strlen(temp2)-7]= 0;
			if(unlink(temp2) == 0) {
				rename(temp, temp2);
			}	
		}
	}
	closedir(d);

	return SUCCESS;

}

u8 re_sign_GAME(char *path)
{	
	char temp[255];
	
	DIR *d;
	struct dirent *dir;
	
	d = opendir(path);
	if(d==NULL) return FAILED;
	
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		
		sprintf(temp, "%s/%s", path, dir->d_name);
		
		if(dir->d_type & DT_DIR) {
			re_sign_GAME(temp);
		}
		else if(strcmp(dir->d_name, "EBOOT.BIN")==0)	{
			if(re_sign_EBOOT(temp)==FAILED) {closedir(d); return FAILED;}
		}
		else if (strcmp(&dir->d_name[strlen(dir->d_name)-5], ".sprx")==0) {
			if(re_sign_SPRX(temp)==FAILED) {closedir(d); return FAILED;}
		}
		else if (strcmp(&dir->d_name[strlen(dir->d_name)-5], ".self")==0) {
			if(re_sign_SELF(temp)==FAILED) {closedir(d); return FAILED;}
		}
	}
	closedir(d);
	
	char param_mgzbak[512]={0};
	char param[512]={0};
	
	sprintf(param_mgzbak, "%s/PS3_GAME/PARAM.SFO.MGZBAK", list_game_path[position]);
	sprintf(param, "%s/PS3_GAME/PARAM.SFO", list_game_path[position]);
	
	if(CopyFile(param, param_mgzbak) != SUCCESS) {
		print_load("Error : failed to save original param.sfo");
		return FAILED;
	}
		
	if(SetParamSFO("PS3_SYSTEM_VER", "04.2100", param) == FAILED) return FAILED;

	return SUCCESS;
}

//*******************************************************
// NPDATA (EDAT SDAT)
//*******************************************************



//*******************************************************
// Common Mount stuff
//*******************************************************

void remove_lv2_protection()
{
	lv1poke(HV_START_OFFSET +  0, 0x0000000000000001ULL);
	lv1poke(HV_START_OFFSET +  8, 0xe0d251b556c59f05ULL);
	lv1poke(HV_START_OFFSET + 16, 0xc232fcad552c80d7ULL);
	lv1poke(HV_START_OFFSET + 24, 0x65140cd200000000ULL); 
}

void fix_error()
{
	if (OFFSET_FIX_3C != 0)
	{
		_poke	(OFFSET_FIX_3C				, 0x386000007C6307B4); // error 3C
		_poke32	(OFFSET_FIX_3C + 0x8		, 0x4E800020		); // error 3C
	}
	
	if (OFFSET_FIX != 0)
	{
		_poke	(OFFSET_FIX					, 0x63FF003D60000000); // error 3D
		_poke	(OFFSET_FIX + 0xC8  		, 0x3BE000004BFFFF0C); // error 3E + unk
		_poke32	(OFFSET_FIX + 0x74		   	, 0x60000000); // unk
		_poke32	(OFFSET_FIX + 0x74 + 0x8   	, 0x48000098); // unk
	}
	
	if (OFFSET_2_FIX != 0)
	{
		_poke32	(OFFSET_2_FIX		   		, 0x60000000); // error 09
		_poke32	(OFFSET_2_FIX + 0x14  		, 0x60000000); // error 19
	}
	
	if (OFFSET_FIX_LIC != 0) _poke	(OFFSET_FIX_LIC				, 0x386000012F830000ULL ); // ignore LIC.DAT check
	if (OFFSET_FIX_2B17 != 0) _poke	(OFFSET_FIX_2B17			, 0x38600000F8690000ULL ); // error 2B and 17
	
	
}

char list_to_unplug[15][15];

u8 need_unplug()
{
	u8 i=0;
	memset(list_to_unplug, 0, sizeof(list_to_unplug));
	
	DIR *d;
	struct dirent *dir;
	d = opendir("/");
	while ((dir = readdir(d))) {
		if(strstr(dir->d_name, "dev_usb")) {
			if(strstr(GamPath, dir->d_name) == NULL) {
				strcpy(list_to_unplug[i], dir->d_name);
				i++;
			}	
		}
	}
	closedir(d);
	
	if(i>0) return YES; else return NO;
}

void unplug_device()
{
	if(need_unplug()==YES) {
		end_loading();
		while(need_unplug()==YES) {
			int i;
			cls();
		
			Draw_BGS();
			int x=50, y=40;
			
			FontSize(20);
			FontColor(COLOR_1);
			
			DrawFormatString(x, y, "%s :", STR_UNPLUG);
			for(i=0; i<15; i++){
				y+=20;
				DrawString(x, y, list_to_unplug[i]);
			}
		
			tiny3d_Flip();
			ScreenShot();
			//ps3pad_read();
			
		}
		sleep(1);
		start_loading();
	}
}

void SetPrimaryUSB()
{
	if(strstr(GamPath, "/dev_usb") && path_info(GamPath) != _NOT_EXIST) {
		
		if(need_unplug()==NO) return;
		
		u8 f0;
		int indx=0;
		
		print_load("Disconnecting all USB device");
		for(f0=0; f0<128; f0++) fake_eject_event(USB_MASS_STORAGE(f0));
		
		sleep(1);

		if(strstr(GamPath, "/dev_usb00")) indx=GamPath[10]-0x30;
		
		print_load("Setting primary USB device: /dev_usb00%i", indx);
		fake_insert_event(USB_MASS_STORAGE(indx), DEVICE_TYPE_USB);

		sleep(3);
		
		for(f0=0; f0<8; f0++) {
			if(f0!=indx) {
				fake_insert_event(USB_MASS_STORAGE(f0), DEVICE_TYPE_USB);
			}
		}

	}
}

char *LoadFileProg(char *path, int *file_size)
{
	*file_size = 0;
	
	SetFilePerms(path);
	
	struct stat s;
	if(stat(path, &s) != 0) return NULL;  
	if(S_ISDIR(s.st_mode)) return NULL;
	
	*file_size = s.st_size;
	int size = s.st_size;
	
	char *mem = malloc(*file_size);
	if(mem==NULL) return NULL;
	
	FILE *f1 = fopen(path, "rb");
	if(f1==NULL) return NULL;
	
	prog_bar1_value = 0;
	int read = 0;
	while(read < size) {
		int wrlen = 1024;
		if(read+wrlen > size) wrlen = size-read;
		fread(mem+read, sizeof(char), wrlen, f1);
		read += wrlen;
		prog_bar1_value = (read*100) / size;
	}
	prog_bar1_value = -1;
	
	fclose(f1);
	
	if(read != *file_size) {
		free(mem); 
		*file_size=0;
		return NULL;
	}
	
	return mem;
}

char *LoadFile(char *path, int *file_size)
{
	*file_size = 0;
	
	SetFilePerms(path);
	
	struct stat s;
	if(stat(path, &s) != 0) return NULL;  
	if(S_ISDIR(s.st_mode)) return NULL;
	
	char *mem = malloc(s.st_size);
	if(mem==NULL) return NULL;
	memset(mem, 0, s.st_size);

	FILE *f1 = fopen(path, "rb");
	if(f1==NULL) return NULL;
	
	u64 read = fread(mem, sizeof(char), s.st_size, f1);
	
	fclose(f1);
	
	if(read != s.st_size) {
		free(mem); 
		return NULL;
	}
	
	*file_size = s.st_size;
	
	return mem;
}

u8 SaveFileProg(char *path, char *mem, int file_size)
{
	FILE *f = fopen(path, "wb");
	if(f==NULL) {return FAILED;}
	
	prog_bar1_value = 0;
	int write = 0;
	while(write < file_size) {
		int wrlen = 1024;
		if(write+wrlen > file_size) wrlen = file_size-write;
		fwrite(mem+write, wrlen, 1, f);
		write += wrlen;
		prog_bar1_value = (write*100) / file_size;
	}
	prog_bar1_value = -1;
	
	fclose(f);

	SetFilePerms(path);

	return SUCCESS;
}

int SaveFile(char *path, char *mem, int file_size)
{
	FILE *f = fopen(path, "wb");
	if(f==NULL) {return FAILED;}
	
	fwrite((void *) mem, sizeof(char), file_size, f);
	
	fclose(f);

	SetFilePerms(path);;

	return SUCCESS;
}

// ps3ntfs functions
//
//char *LoadFileProg(char *path, int *file_size)
//{
//	*file_size = 0;
//	
//	SetFilePerms(path);
//	
//	struct stat s;
//	if(stat(path, &s) != 0) return NULL;  
//	if(S_ISDIR(s.st_mode)) return NULL;
//	
//	*file_size = s.st_size;
//	int size = s.st_size;
//	
//	char *mem = malloc(*file_size);
//	if(mem==NULL) return NULL;
//	
//	int f1 = ps3ntfs_open(path, O_RDONLY, 0766);
//	if(f1<0) return NULL;
//	
//	prog_bar1_value = 0;
//	int read = 0;
//	while(read < size) {
//		int wrlen = 1024;
//		if(read+wrlen > size) wrlen = size-read;
//		ps3ntfs_read(f1, mem+read, wrlen);
//		read += wrlen;
//		prog_bar1_value = (read*100) / size;
//	}
//	prog_bar1_value = -1;
//		
//	ps3ntfs_close(f1);
//	
//	if(read != *file_size) {
//		free(mem); 
//		*file_size=0;
//		return NULL;
//	}
//	
//	return mem;
//}
//
//char *LoadFile(char *path, int *file_size)
//{
//	*file_size = 0;
//	
//	SetFilePerms(path);
//	
//	struct stat s;
//	if(stat(path, &s) != 0) return NULL;  
//	if(S_ISDIR(s.st_mode)) return NULL;
//	
//	*file_size = s.st_size;
//	
//	char *mem = malloc(*file_size);
//	if(mem==NULL) return NULL;
//	memset(mem, 0, s.st_size);
//
//	int f1 = ps3ntfs_open(path, O_RDONLY, 0766);
//	if(f1<0) return NULL;
//	
//	u64 read = ps3ntfs_read(f1, mem, *file_size);
//		
//	ps3ntfs_close(f1);
//	
//	if(read != *file_size) {
//		free(mem); 
//		*file_size=0;
//		return NULL;
//	}
//	
//	return mem;
//}
//
//u8 SaveFileProg(char *path, char *mem, int file_size)
//{
//	int fd;
//	
//	fd = ps3ntfs_open(path, O_WRONLY | O_CREAT | O_TRUNC, 0777);
//	if(fd<0) {return FAILED;}
//	
//	prog_bar1_value = 0;
//	int write = 0;
//	while(write < file_size) {
//		int wrlen = 1024;
//		if(write+wrlen > file_size) wrlen = file_size-write;
//		ps3ntfs_write(fd, mem+write, wrlen);
//		write += wrlen;
//		prog_bar1_value = (write*100) / file_size;
//	}
//	prog_bar1_value = -1;
//	
//	ps3ntfs_close(fd);
//
//	SetFilePerms(path);
//
//	return SUCCESS;
//}
//
//int SaveFile(char *path, char *mem, int file_size)
//{
//	int fd;
//	
//	fd = ps3ntfs_open(path, O_WRONLY | O_CREAT | O_TRUNC, 0777);
//	if(fd<0) {return FAILED;}
//	
//	ps3ntfs_write(fd, (void *) mem, file_size);
//	
//	ps3ntfs_close(fd);
//
//	SetFilePerms(path);;
//
//	return SUCCESS;
//}


int move_origin_to_bdemubackup(char *path)
{
	int ret=0;
	memset(temp_buffer, 0, sizeof(temp_buffer));
	
	if(strncmp(path, "/dev_usb00", 10) && strncmp(path, "/dev_hdd0", 9)) return 1;

	sprintf(temp_buffer, "%s/PS3_GAME/PS3PATH.BUP", path);
	sprintf(temp_buffer + 1024, "%s/PS3_GAME", path);

	if(SaveFile(temp_buffer, temp_buffer + 1024, strlen(temp_buffer + 1024)) == FAILED) return -1;

	if(!strncmp(temp_buffer, "/dev_hdd0", 9))	strncpy(temp_buffer + 9, "/PS3_GAME", 16); 
	else	strncpy(temp_buffer + 11, "/PS3_GAME", 16);
	
	ret=rename(temp_buffer  + 1024, temp_buffer);
	
	if(ret != 0)	return -1;

	// PS3_GM01

	sprintf(temp_buffer, "%s/PS3_GM01/PS3PATH2.BUP", path);
	sprintf(temp_buffer + 1024, "%s/PS3_GM01", path);

	if(path_info(temp_buffer + 1024) == _NOT_EXIST) {
		
		sprintf(temp_buffer, "%s/PS3_GAME/PS3PATH.BUP", path);
		if(!strncmp(temp_buffer, "/dev_hdd0", 9)) strncpy(temp_buffer + 9, "/PS3_GAME", 16);
		else	strncpy(temp_buffer + 11, "/PS3_GAME", 16);
		
		return 0;
	}

	if(SaveFile(temp_buffer, temp_buffer + 1024, strlen(temp_buffer + 1024)) == FAILED) return -1;

	if(!strncmp(temp_buffer, "/dev_hdd0", 9)) strncpy(temp_buffer + 9, "/PS3_GM01", 16);
	else	strncpy(temp_buffer + 11, "/PS3_GM01", 16);

	if((rename(temp_buffer  + 1024, temp_buffer)) != 0) return -1;

	return 0;
}

int move_bdemubackup_to_origin(char *device_path)
{
	int n;
	memset(temp_buffer, 0, sizeof(temp_buffer));
	
	sprintf(temp_buffer, "%s/PS3_GAME", device_path);
	sprintf(temp_buffer + 256, "%s/PS3_GAME/PS3PATH.BUP", device_path);

	int file_size;
	char *file;
	int ret = 0;

	if(path_info(temp_buffer) == _NOT_EXIST) {ret = -1;goto PS3_GM01;}

	file = LoadFile(temp_buffer + 256, &file_size);

	if(!file) {ret = -1;goto PS3_GM01;}

	memset(temp_buffer + 1024, 0, 0x420);

	if(file_size > 0x400) file_size = 0x400;

	memcpy(temp_buffer + 1024, file, file_size);

	free(file);

	for(n=0; n< 0x400; n++) {
		if(temp_buffer[1024 + n] == 0) break;
		if(((u8)temp_buffer[1024 + n]) < 32) {temp_buffer[1024 + n] = 0; break;}
	}

	if(strncmp(temp_buffer, temp_buffer + 1024, 10))  {ret = -1;goto PS3_GM01;} // if not /dev_usb00x return

	if(!strncmp(temp_buffer, "/dev_hdd0", 9)) {
	} else	memcpy(temp_buffer + 1024, temp_buffer, 11);

	if(rename(temp_buffer, temp_buffer + 1024) != 0)  {ret= -1; goto PS3_GM01;}

	// PS3_GM01
PS3_GM01:

	sprintf(temp_buffer, "%s/PS3_GM01", device_path);
	sprintf(temp_buffer + 256, "%s/PS3_GM01/PS3PATH2.BUP", device_path);
	
	if(path_info(temp_buffer) == _NOT_EXIST) return -1;

	file = LoadFile(temp_buffer + 256, &file_size);
	if(!file) return -1;
	memset(temp_buffer + 1024, 0, 0x420);
	if(file_size > 0x400) file_size = 0x400;
	memcpy(temp_buffer + 1024, file, file_size);
	free(file);

	for(n=0; n< 0x400; n++) {
		if(temp_buffer[1024 + n] == 0) break;
		if(((u8)temp_buffer[1024 + n]) < 32) {temp_buffer[1024 + n] = 0; break;}
	}

	if(strncmp(temp_buffer, temp_buffer + 1024, 10)) return -1; // if not /dev_usb00x return

	if(!strncmp(temp_buffer, "/dev_hdd0", 9)) {
	} else		memcpy(temp_buffer + 1024, temp_buffer, 11);
	
	if(rename(temp_buffer, temp_buffer + 1024) != 0)  return -1;

	return ret;
}

int patch_bdmirror()
{
   	u64 n;
	u64 dat;
	int pos=-1;
	int pos2=-1;
	int device;
	char path_name[512];
	char * mem = temp_buffer;
	u64 dev_bdvd[2]  ={0x2F6465765F626476ULL, 0x6400000000000000ULL};
	//u64 dev_usb[2]	 ={0x006465765F757362ULL, 0x3030300000000000ULL};
	u64 temp_bdvd[2] ={0x2F74656D705F6264ULL, 0x7664000000000000ULL};
	//u64 esp_bdvd[2]  ={0x006573705F626476ULL, 0x6400000000000000ULL};
	int ret;
	
	ret = move_origin_to_bdemubackup(GamPath);
	if(ret!=0) print_load("Error %d: move_origin_to_bdemubackup failed", ret);

	if(strstr(GamPath, "/dev_hdd") != NULL) {
		
		device=-1;
		print_load("mount ps2disc");
		sys_fs_mount("CELL_FS_IOS:BDVD_DRIVE", "CELL_FS_ISO9660", "/dev_ps2disc", 1);
		usleep(1000);
		
		for(n=0; n<10;n++) {
			if(path_info("/dev_ps2disc") != _NOT_EXIST) break;
			sys_fs_mount("CELL_FS_IOS:BDVD_DRIVE", "CELL_FS_ISO9660", "/dev_ps2disc", 1);
			usleep(1000);
		}
	
	} else {

		device = (GamPath[8]-0x30)*100 + (GamPath[9]-0x30)*10 + GamPath[10]-0x30;
		unplug_device();
		sprintf(path_name, "CELL_FS_IOS:USB_MASS_STORAGE%03d", device);
		//dev_usb[1] = GamPath[8]*0x100000000000000 + GamPath[9]*0x1000000000000 + GamPath[10]*0x10000000000 ;
	}
	
	memset(mem, 0, 0x10 * LV2MOUNTADDR_ESIZE);
	
	for(n=0 ; n < 0x10 * LV2MOUNTADDR_ESIZE ; n+=0x8) {
		dat = lv2peek(LV2MOUNTADDR + n);
		memcpy(&mem[n], &dat, sizeof(u64));
	}
	
	for(n = 0; n< 0x116c; n+= LV2MOUNTADDR_ESIZE) {
		if(!memcmp(mem + n, "CELL_FS_IOS:PATA0_BDVD_DRIVE", 29) 
			&& (!memcmp(mem + n + 0x69, "dev_bdvd", 9)) 
			&& mem[n-9]== 1 && mem[n-13]== 1)
		{
			print_load("Patch BDVD");
			lv2poke(LV2MOUNTADDR + n + 0x68		, temp_bdvd[0]);
			lv2poke(LV2MOUNTADDR + n + 0x68 + 8	, temp_bdvd[1]);
		}
		else if(device >= 0 
			&& !memcmp(mem + n, path_name, 32) 
			&& mem[n-9]== 1 && mem[n-13]== 1) 
		{	
			print_load("Patch USB");
			lv2poke(LV2MOUNTADDR + n + 0x68		, dev_bdvd[0]);
			lv2poke(LV2MOUNTADDR + n + 0x68	+ 8	, dev_bdvd[1]);
			//lv2poke(LV2MOUNTADDR + n + 0x78		, dev_usb[0]);
			//lv2poke(LV2MOUNTADDR + n + 0x78	+ 8	, dev_usb[1]);
		}
		else if(device==-1 && !memcmp(mem + n, "CELL_FS_IOS:BDVD_DRIVE", 29) 
			&& !memcmp(mem + n + 0x69, "dev_ps2disc", 12) 
			&& mem[n-9]== 1 && mem[n-13]== 1)
		{
			if(pos2 < 0) pos2 = n;
		}
		else if(device==-1 && !memcmp(mem + n, "CELL_FS_UTILITY:HDD0", 21)
			&& !memcmp(mem + n + 0x48, "CELL_FS_UFS", 11)
			&& !memcmp(mem + n + 0x69, "dev_hdd0", 9) 
			&& mem[n-9] == 1 && mem[n-13] == 1) 
		{
			if(pos < 0) pos = n;
		}
	}
	
	if(pos>0 && pos2>0) {
		print_load("Patch HDD");
	
		u64 LV2HDDADDR = 0x80000000007EF000ULL;
		
		for(n=0; n < LV2MOUNTADDR_CSIZE; n+=8) {
			dat = lv2peek(LV2MOUNTADDR + pos2 - 0x10 + n);
			lv2poke(LV2HDDADDR+0x20+n, dat);
		}
		
		dat = LV2MOUNTADDR + (u64) (pos2 - 0x10);
		lv2poke(LV2HDDADDR, dat);
		
		dat = (u64) UMOUNT_SYSCALL_OFFSET;
		lv2poke(LV2HDDADDR+0x8, dat);
		
		lv2poke(LV2HDDADDR+0x10, 0xFBA100E800000000ULL + LV2MOUNTADDR_CSIZE);
		
		for(n=0; n < LV2MOUNTADDR_CSIZE-0x10; n+=8) {
			dat = lv2peek(LV2MOUNTADDR + pos + n);
			lv2poke(LV2MOUNTADDR + pos2 + n, dat);
		}
		
		lv2poke(LV2MOUNTADDR + pos2 + 0x68		, dev_bdvd[0]);
		lv2poke(LV2MOUNTADDR + pos2 + 0x68 + 0x8, dev_bdvd[1]);
		
		//lv2poke(LV2MOUNTADDR + pos2 + 0x78		, esp_bdvd[0]);
		//lv2poke(LV2MOUNTADDR + pos2 + 0x78 + 0x8  , esp_bdvd[1]);
		
		lv2poke(LV2MOUNTADDR + pos2 + 0xA4, 0ULL);
		
		int k;
		for(k= 0; k < 100; k++) {
			PATCH_CALL(UMOUNT_SYSCALL_OFFSET, PAYLOAD_UMOUNT_OFFSET); // UMOUNT ROUTINE PATCH
			usleep(1000);
		}
	}
	else {
		if(device==-1) {
			if(pos==-1) {
				print_load("Error : hdd0 not found");
			}
			if(pos2==-1) {
				print_load("Error : ps2disk not found");
			}
		}
	}
	
	return 0;
}

void unpatch_bdmirror()
{
	u64 dat, n, m;
	
	u64 dev_bdvd[2]  ={0x2F6465765F626476ULL, 0x6400000000000000ULL};
   // u64 dev_hdd1[2]	 ={0x2F6465765F686464ULL, 0x3100000000000000ULL};
	u64 dev_usb[2]	 ={0x2F6465765F757362ULL, 0x3030300000000000ULL};
	
	char * mem = temp_buffer;
	memset(mem, 0, 0x10 * LV2MOUNTADDR_ESIZE);
	
	for(n=0 ; n < 0x10 * LV2MOUNTADDR_ESIZE ; n+=0x8) {
		dat = lv2peek(LV2MOUNTADDR + n);
		memcpy(&mem[n], &dat, sizeof(u64));
	}
	
	for(n = 0; n< 0x116c; n+= LV2MOUNTADDR_ESIZE)
	{
		/*
		if(memcmp(mem + n, "CELL_FS_UTILITY:HDD1", 20) == 0 
		&& memcmp(mem + n + 0x69, "dev_hdd1", 8) != 0 
		//&& mem[n-9 ]==1 
		//&& mem[n-13]==1 
		)
		{
			print_load("Unpatch HDD1");
			lv2poke(LV2MOUNTADDR + n + 0x68		, dev_hdd1[0]);
			lv2poke(LV2MOUNTADDR + n + 0x68 + 8	, dev_hdd1[1]);
			lv2poke(LV2MOUNTADDR + n + 0x78		, 0ULL);
			lv2poke(LV2MOUNTADDR + n + 0x78 + 8	, 0ULL);
		} else
		*/
		if(memcmp(mem + n, "CELL_FS_IOS:PATA0_BDVD_DRIVE", 28) == 0
		&& memcmp(mem + n + 0x69, "dev_bdvd", 8) != 0
		//&& memcmp(mem + n + 0x69, "temp_bdvd", 9) != 0
		//&& mem[n-9 ]==1 
		//&& mem[n-13]==1 
		)
		{
			print_load("Unpatch BDVD");
			lv2poke(LV2MOUNTADDR + n + 0x68		, dev_bdvd[0]);
			lv2poke(LV2MOUNTADDR + n + 0x68 + 8	, dev_bdvd[1]);
			lv2poke(LV2MOUNTADDR + n + 0x78		, 0ULL);
			lv2poke(LV2MOUNTADDR + n + 0x78 + 8	, 0ULL);
		} else 
		if(memcmp(mem + n, "CELL_FS_IOS:USB_MASS_STORAGE", 28)  == 0
		&& memcmp(mem + n + 0x69, "dev_usb", 7) != 0
		//&& mem[n-9 ]==1 
		//&& mem[n-13]==1 
		)
		{
			print_load("Unpatch USB %d", mem[n+30]-0x30);
			dev_usb[1] = mem[n+28]*0x100000000000000 + mem[n+29]*0x1000000000000 +mem[n+30]*0x10000000000 ;
			lv2poke(LV2MOUNTADDR + n + 0x68, dev_usb[0]);
			lv2poke(LV2MOUNTADDR + n + 0x68 + 8, dev_usb[1]);
			lv2poke(LV2MOUNTADDR + n + 0x78		, 0ULL);
			lv2poke(LV2MOUNTADDR + n + 0x78 + 8	, 0ULL);
		} else 
		if(memcmp(mem + n, "CELL_FS_UTILITY:HDD0", 20) == 0
		&& memcmp(mem + n + 0x48, "CELL_FS_UFS", 11) == 0
		&& memcmp(mem + n + 0x69, "dev_hdd0", 8) != 0 
		//&& mem[n-9 ]==1 
		//&& mem[n-13]==1 
		)
		{
			print_load("Unpatch HDD0");
			dat = lv2peek(0x80000000007EF020ULL);
			lv2poke(LV2MOUNTADDR + n - 0x10, dat);
			for(m=0; m < (u64) LV2MOUNTADDR_CSIZE; m+=8) {
				dat = lv2peek(0x80000000007EF030ULL + m);
				lv2poke(LV2MOUNTADDR+n+m, dat);
			}
			
			for(m=0; m < (u64) LV2MOUNTADDR_ESIZE + 0x30; m+=8) {
				lv2poke(0x80000000007EF000ULL + m, 0ULL);
			}
		
		}
	}
	for(n= 0; n < 100; n++) {
		lv2poke32(UMOUNT_SYSCALL_OFFSET, 0xFBA100E8); // UMOUNT RESTORE
		usleep(1000);
	}
	
	lv2poke(0x80000000007EF000ULL, 0ULL);
}

int patch_libfs(int8_t device)
{
	unsigned char compare[16]= {
	/*00*/	0x88,0x09,0x00,0x00,0x7C,0x00,0x07,0x74, 	0x2F,0x80,0x00,0x00, 0x2F,0x00,0x00,0x2F
	};

	unsigned char patch_from_reactPSN[0xA8]= { // -0x68
	/*00*/	0x2B,0x83,0x00,0x01,0x40,0x9D,0x00,0x84,	0x88,0x1F,0x00,0x00,0x2F,0x80,0x00,0x2F,
	/*10*/	0x40,0x9E,0x00,0x78,0x7B,0xDF,0x00,0x20,	0x7F,0xA4,0xEB,0x78,0x7F,0xE3,0xFB,0x78,
	/*20*/	0x48,0x00,0x21,0x75,0xE8,0x41,0x00,0x28,	0x7B,0xC9,0x00,0x20,0x38,0x60,0x00,0x00,
	/*30*/	0x88,0x09,0x00,0x09,0x2F,0x80,0x00,0x2F,	0x40,0x9E,0x00,0x08,0x98,0x69,0x00,0x09,	
	/*40*/	0x88,0x09,0x00,0x0A,0x2F,0x80,0x00,0x2F,	0x40,0x9E,0x00,0x08,0x98,0x69,0x00,0x0A,
	/*50*/	0x88,0x09,0x00,0x0B,0x2F,0x80,0x00,0x2F,	0x40,0x9E,0x00,0x08,0x98,0x69,0x00,0x0B,
	/*60*/	0x88,0x09,0x00,0x07,0x2F,0x80,0x00,0x76,	0x40,0x9E,0x00,0x1C,0x3C,0x60,0x5F,0x75,
	/*70*/	0x60,0x63,0x73,0x62,0x78,0x63,0x00,0x02,	0x64,0x63,0x30,0x30,0x60,0x63,0x30,0x00,
	/*80*/	0xF8,0x69,0x00,0x04,0x39,0x20,0x00,0x00,	0x60,0x00,0x00,0x00,0x60,0x00,0x00,0x00,			
	/*90*/	0x60,0x00,0x00,0x00,0x60,0x00,0x00,0x00,	0x60,0x00,0x00,0x00,0x60,0x00,0x00,0x00,
	/*A0*/	0x60,0x00,0x00,0x00,0x60,0x00,0x00,0x00
	};

	unsigned char patch_from_iris[0xB4] = { //-0x20
	/*00*/	0x7C,0x1E,0xEA,0x14,0x78,0x09,0x00,0x20,	0x88,0x09,0x00,0x06,0x7C,0x00,0x07,0x74,
	/*10*/	0x2F,0x80,0x00,0x6D,0x41,0x9E,0x00,0x18,	0x2F,0x80,0x00,0x76,0x41,0x9E,0x00,0x10,
	/*20*/	0x2F,0x80,0x00,0x62,0x41,0x9E,0x00,0x2C,	0x48,0x00,0x00,0x48,0x38,0x00,0x00,0x68,
	/*30*/	0x98,0x09,0x00,0x04,0x38,0x00,0x00,0x64,	0x98,0x09,0x00,0x05,0x98,0x09,0x00,0x06,
	/*40*/	0x38,0x00,0x00,0x30,0x98,0x09,0x00,0x07,	0x38,0x00,0x00,0x00,0x98,0x09,0x00,0x08,
	/*50*/	0x38,0x00,0x00,0x00,0x98,0x09,0x00,0x0A,	0x60,0x00,0x00,0x00,0x39,0x20,0x00,0x00,
	/*60*/	0x4B,0xFF,0xFF,0x18,0x38,0x60,0x00,0x00,	0x7C,0x63,0x07,0xB4,0x4E,0x80,0x00,0x20,
	/*70*/	0x2F,0x80,0x00,0x00,0x41,0x9E,0xFF,0xE8,	0x2F,0x80,0x00,0x2F,0x40,0x9E,0x00,0x10,
	/*80*/	0x38,0x00,0x00,0x00,0x98,0x09,0x00,0x06,	0x4B,0xFF,0xFF,0xD4,0x88,0x09,0x00,0x08,
	/*90*/	0x7C,0x00,0x07,0x74,0x2F,0x80,0x00,0x2F,	0x41,0x9E,0xFF,0xB0,0x2F,0x80,0x00,0x00,
	/*A0*/	0x41,0x9E,0xFF,0xBC,0x38,0x00,0x00,0x00,	0x98,0x09,0x00,0x09,0x4B,0xFF,0xFF,0xA4,
	/*B0*/	0x60,0x00,0x00,0x00
	};
	
	unsigned char patch_from_MM[0x84] = { // -0x20
	/*00*/	0x7C,0x1E,0xEA,0x14,0x78,0x09,0x00,0x20,	0x38,0x60,0x00,0x00,0x88,0x09,0x00,0x08,
	/*10*/	0x2F,0x80,0x00,0x2F,0x40,0x9E,0x00,0x08,	0x98,0x69,0x00,0x08,0x88,0x09,0x00,0x09, 
	/*20*/	0x2F,0x80,0x00,0x2F,0x40,0x9E,0x00,0x08,	0x98,0x69,0x00,0x09,0x88,0x09,0x00,0x0A, 
	/*30*/	0x2F,0x80,0x00,0x2F,0x40,0x9E,0x00,0x08,	0x98,0x69,0x00,0x0A,0x88,0x09,0x00,0x06,
	/*40*/	0x2F,0x80,0x00,0x76,0x41,0x9E,0x00,0x0C,	0x2F,0x80,0x00,0x6D,0x40,0x9E,0x00,0x30,
	/*50*/	0x3C,0x60,0x75,0x73,0x60,0x63,0x62,0x30,	0x78,0x63,0xF8,0x00,0x78,0x63,0x08,0x00,
	/*60*/	0x48,0x00,0x00,0x10,0x38,0x60,0x00,0x00,	0x7C,0x63,0x07,0xB4,0x4E,0x80,0x00,0x20,
	/*70*/	0x64,0x63,0x30,0x30,0x60,0x63,0x00,0x00,	0xF8,0x69,0x00,0x04,0x39,0x20,0x00,0x00,
	/*80*/	0x4B,0xFF,0xFE,0xF8
	};
	
	char patched_libfs_from_MM[128];
	char patched_libfs_from_iris[128];
	char patched_libfs_from_reactPSN[128];
	
	sprintf(patched_libfs_from_iris, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_from_iris_%X.sprx", ManaGunZ_id, firmware);
	
	if(device<0) {
		sprintf(patched_libfs_from_MM, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_int_from_MM_%X.sprx", ManaGunZ_id, firmware);
		sprintf(patched_libfs_from_reactPSN, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_int_from_reactPSN_%X.sprx", ManaGunZ_id, firmware);
	}
	else {
		sprintf(patched_libfs_from_MM, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_usb%d_from_MM_%X.sprx", ManaGunZ_id, device, firmware);
		sprintf(patched_libfs_from_reactPSN, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_usb%d_from_reactPSN_%X.sprx", ManaGunZ_id, device, firmware);
	}
	
	if(path_info(patched_libfs_from_MM) == _NOT_EXIST) {
		print_load("Apply MM patch to libfs...");
		char ori_sprx[128];
		char ori_prx[128];
		char patched_prx[128];
		
		sprintf(ori_sprx, "/dev_hdd0/game/%s/USRDIR/sys/original_libfs_%X.sprx", ManaGunZ_id, firmware);
		sprintf(ori_prx, "/dev_hdd0/game/%s/USRDIR/sys/original_libfs_%X.prx", ManaGunZ_id, firmware);
		sprintf(patched_prx, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_from_MM_%X.prx", ManaGunZ_id, firmware);
		
		if(CopyFile("/dev_flash/sys/external/libfs.sprx", ori_sprx) != SUCCESS) {
			print_load("Error : can't copy original sprx");
			return NOK;
		}

		if(Extract_SELF(ori_sprx, ori_prx, NULL)==NOK) {
			return NOK;
		}
		
		int size=0;
		char *data = LoadFile(ori_prx, &size);
		if(data==NULL) {
			print_load("Error : can't read the original libfs");
			return NOK;
		}
		
		//patch
		int m=0, n;
		for(n = 0; n < size - 16; n++) {
			if(!memcmp((char *) &data[n], (char *) compare, 16)) {		
				m=n;
				break;
			}
		}
		if(m==0) {
			print_load("Error : cannot find the flag to apply the patch");
			return FAILED;
		}
		if(device<0) {
			patch_from_MM[0x52]=0x68;
			patch_from_MM[0x53]=0x64;
			patch_from_MM[0x56]=0x64;
			patch_from_MM[0x73]=0x00;
			patch_from_MM[0x72]=0x00;
		} 
		else patch_from_MM[0x73]=0x30+device;
		
		memcpy(&data[n-0x20], patch_from_MM, 0x84);
	
		//write
		u8 ret = SaveFile(patched_prx, data, size);
		free(data);
		if(ret  == FAILED) {
			print_load("Error : cannot create the file");
			return NOK;
		}
		
		if(Sign_PRX(patched_prx, patched_libfs_from_MM) == NOK) {
			print_load("Error : cannot sign the prx\n");
			return NOK;
		}
	
		Delete(ori_sprx);
		Delete(ori_prx);
		Delete(patched_prx);
	}
	
	if(path_info(patched_libfs_from_iris) == _NOT_EXIST) {
		print_load("Apply IRIS patch to libfs...");
		char ori_sprx[128];
		char ori_prx[128];
		char patched_prx[128];
		
		sprintf(ori_sprx, "/dev_hdd0/game/%s/USRDIR/sys/original_libfs_%X.sprx", ManaGunZ_id, firmware);
		sprintf(ori_prx, "/dev_hdd0/game/%s/USRDIR/sys/original_libfs_%X.prx", ManaGunZ_id, firmware);
		sprintf(patched_prx, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_from_iris_%X.prx", ManaGunZ_id, firmware);
		
		if(CopyFile("/dev_flash/sys/external/libfs.sprx", ori_sprx) != SUCCESS) {
			print_load("Error : can't copy original sprx");
			return NOK;
		}

		if(Extract_SELF(ori_sprx, ori_prx, NULL)==NOK) {
			return NOK;
		}
		
		int size=0;
		char *data = LoadFile(ori_prx, &size);
		if(data==NULL) {
			print_load("Error : can't read the original libfs");
			return NOK;
		}
		
		//patch
		int m=0, n;
		for(n = 0; n < size - 16; n++) {
			if(!memcmp((char *) &data[n], (char *) compare, 16)) {		
				m=n;
				break;
			}
		}
		if(m==0) {
			print_load("Error : cannot find the flag to apply the patch");
			return FAILED;
		}
		
		memcpy(&data[n-0x20], patch_from_iris, 0xB4);
		
		// to skip "li	  %r9, 0; b ...."
		// memcpy(&data[m], patch_from_iris, 0x5c);
		// memcpy(&data[m + 0x64], patch_from_iris + 0x64, 0xB4 - 0x64);
		
		//write
		u8 ret = SaveFile(patched_prx, data, size);
		free(data);
		if(ret  == FAILED) {
			print_load("Error : cannot create the %s", patched_prx);
			return NOK;
		}
		
		if(Sign_PRX(patched_prx, patched_libfs_from_iris) == NOK) {
			print_load("Error : cannot sign the prx\n");
			return NOK;
		}
	
		Delete(ori_sprx);
		Delete(ori_prx);
		Delete(patched_prx);
	}
	
	if(path_info(patched_libfs_from_reactPSN) == _NOT_EXIST) {
		print_load("Apply reactPSN patch to libfs...");
		char ori_sprx[128];
		char ori_prx[128];
		char patched_prx[128];

		
		sprintf(ori_sprx, "/dev_hdd0/game/%s/USRDIR/sys/original_libfs_%X.sprx", ManaGunZ_id, firmware);
		sprintf(ori_prx, "/dev_hdd0/game/%s/USRDIR/sys/original_libfs_%X.prx", ManaGunZ_id, firmware);
		sprintf(patched_prx, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_from_reactPSN_%X.prx", ManaGunZ_id, firmware);
		
		if(CopyFile("/dev_flash/sys/external/libfs.sprx", ori_sprx) != SUCCESS) {
			print_load("Error : can't copy original sprx");
			return NOK;
		}

		if(Extract_SELF(ori_sprx, ori_prx, NULL)==NOK) {
			return NOK;
		}
		
		int size=0;
		char *data = LoadFile(ori_prx, &size);
		if(data==NULL) {
			print_load("Error : can't read the original libfs");
			return NOK;
		}
		
		//patch
		int m=0, n;
		for(n = 0; n < size - 16; n++) {
			if(!memcmp((char *) &data[n], (char *) compare, 16)) {		
				m=n;
				break;
			}
		}
		if(m==0) {
			print_load("Error : cannot find the flag to apply the patch");
			return FAILED;
		}
		
		if(device<0) {
			patch_from_reactPSN[0x6F]=0x68;
			patch_from_reactPSN[0x72]=0x64;
			patch_from_reactPSN[0x73]=0x64;
			patch_from_reactPSN[0x7B]=0x00;
			patch_from_reactPSN[0x7E]=0x00;
		}
		else {
			patch_from_reactPSN[0x7E]=0x30+device;
		}
		memcpy(&data[n-0x68], patch_from_reactPSN, 0xA8);
		
		//write
		u8 ret = SaveFile(patched_prx, data, size);
		free(data);
		if(ret  == FAILED) {
			print_load("Error : cannot create the %s", patched_prx);
			return NOK;
		}
		
		if(Sign_PRX(patched_prx, patched_libfs_from_reactPSN) == NOK) {
			print_load("Error : cannot sign the prx\n");
			return NOK;
		}
	
		Delete(ori_sprx);
		Delete(ori_prx);
		Delete(patched_prx);
	}
	
	return OK;
}

char *get_libfs_path() 
{
	int device;
	char *libfs_path = (char*) malloc(sizeof(char)*128);
	
	if(strstr(GamPath, "/dev_usb")) {
		device=(GamPath[8]-0x30)*100 + (GamPath[9]-0x30)*10 + GamPath[10]-0x30;		
	}
	else device=-1;
		
	if(libfs_from == IRIS) {
		sprintf(libfs_path, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_from_iris_%X.sprx", ManaGunZ_id, firmware);
	}
	else if(libfs_from == MM) {
		if(device==-1) {
			sprintf(libfs_path, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_int_from_MM_%X.sprx", ManaGunZ_id, firmware);
		}
		else {
			sprintf(libfs_path, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_usb%d_from_MM_%X.sprx", ManaGunZ_id, device, firmware);
		}
	} else if(libfs_from == REACTPSN) {
		if(device==-1) {
			sprintf(libfs_path, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_int_from_reactPSN_%X.sprx", ManaGunZ_id, firmware);
		}
		else {
			sprintf(libfs_path, "/dev_hdd0/game/%s/USRDIR/sys/patched_libfs_usb%d_from_reactPSN_%X.sprx", ManaGunZ_id, device, firmware);
		}
	}
	
	patch_libfs(device);
	
	return libfs_path;
}

int patch_exp_plug()
{
	char patched_sprx[128];
	
	sprintf(patched_sprx, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
	
	if(path_info(patched_sprx) == _NOT_EXIST) {
		print_load("Patching explore_pluging...");
		char ori_sprx[128];
		char ori_prx[128];
		char patched_prx[128];
		int k;
		
		sprintf(ori_sprx, "/dev_hdd0/game/%s/USRDIR/sys/original_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
		sprintf(ori_prx, "/dev_hdd0/game/%s/USRDIR/sys/original_explore_plugin_%X.prx", ManaGunZ_id, firmware);
		sprintf(patched_prx, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.prx", ManaGunZ_id, firmware);
		
		if(CopyFile("/dev_flash/vsh/module/explore_plugin.sprx", ori_sprx) != SUCCESS) {
			print_load("Error : can't copy original sprx");
			return NOK;
		}

		if(Extract_SELF(ori_sprx, ori_prx, NULL)==NOK) {
			return NOK;
		}
		
		int size=0;
		char *data = LoadFile(ori_prx, &size);
		if(data==NULL) {
			print_load("Error : can't read the original_explore_plugin_%X.prx", firmware);
			return NOK;
		}
		
		//patch
		int n;
		for(n = 0; n < size - 16; n++) {
			if(!memcmp((char *) &data[n], (char *) "/app_home", 9)) {
				memcpy(&data[n], "/dev_bdvd", 9);
				n+=8;
			}
			
			if(!memcmp((char *) &data[n], (char *) "msg_tool_app_home_ps3_game", 27)) {			
				memcpy(&data[n], "msg_playstation3\0\0\0\0\0\0\0\0\0\0", 26);
				//memcpy(&data[n], "msg_playstation3\0", 18);
				
				for(k = n - 256; k < n + 256; k++) {
					if(!memcmp((char *) &data[k], (char *) "tex_album_icon", 15)) {
						memcpy(&data[k], "item_tex_disc_bd", 16);
						memcpy(&data[k+16], "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16); //reactPSN
					}
				}
				n+=27;
			}
		}
		
		//write
		u8 ret = SaveFile(patched_prx, data, size);
		free(data);
		if(ret  == FAILED) {
			print_load("Error : cannot create the %s", patched_prx);
			return NOK;
		}
		
		if(Sign_PRX(patched_prx, patched_sprx) == NOK) {
			print_load("Error : cannot sign the prx\n");
			return NOK;
		}
	
		Delete(ori_sprx);
		Delete(ori_prx);
		Delete(patched_prx);
	}
	
	return OK;
}

char *get_libaudio_path() 
{
	
	print_debug("Start of get_libaudio_path()");
	char *libaudio_path = sprintf_malloc("/dev_hdd0/game/%s/USRDIR/sys/patched_libaudio_%X.sprx", ManaGunZ_id, firmware);
	
	print_debug("path_info...");
	if( path_info(libaudio_path) == _FILE ) return libaudio_path;
	
	char ori_prx[128];
	char patched_prx[128];
	sprintf(ori_prx, "/dev_hdd0/game/%s/USRDIR/sys/libaudio_%X.prx", ManaGunZ_id, firmware);
	sprintf(patched_prx, "/dev_hdd0/game/%s/USRDIR/sys/patched_libaudio_%X.prx", ManaGunZ_id, firmware);
	
	print_debug("Extract_SELF...");
	if( Extract_SELF("/dev_flash/sys/external/libaudio.sprx", ori_prx, NULL) == FAILED ) {
		print_load("Error: failed to extract libaudio.sprx");
		FREE(libaudio_path);
		return NULL;
	}
	
	print_debug("LoadFile...");
	int size=0;
	char *mem = LoadFile(ori_prx, &size);
	if(mem==NULL) {
		print_load("Error : can't read the original_libaudio_%X.prx", firmware);
		FREE(libaudio_path);
		return NULL;
	}
	
	print_debug("Patch loop...");
	//patch
	//https://blog.madnation.net/ps3-bt-usb-audio-passthrough/
	u8 bt_usb_audio_offset_flag[] = {0xE8, 0x03, 0x00, 0x00, 0x2F, 0xA0, 0x00, 0x00, 0x41, 0x9E, 0x00, 0x0C, 0x2F, 0xA0, 0x00, 0x02, 0x40, 0x9E, 0x01, 0x44, 0xE8, 0x7E, 0x00, 0x08, 0x2F, 0xA3, 0x00, 0x02, 0x41, 0x9E, 0x00, 0x1C};
	u8 bt_usb_audio_offset_repl[] = {0x38, 0x00, 0x00, 0x01, 0xF8, 0x1E, 0x00, 0x10, 0xE8, 0x03, 0x00, 0x00, 0x2F, 0xA0, 0x00, 0x00, 0x41, 0x9E, 0x00, 0x28, 0xE8, 0x7E, 0x00, 0x08};
	int n;
	for(n=0; n<size-0x20 ; n++) {
		if(!memcmp((char *) &mem[n], (char *) bt_usb_audio_offset_flag, sizeof(bt_usb_audio_offset_flag))) {
			memcpy(&mem[n], bt_usb_audio_offset_repl, sizeof(bt_usb_audio_offset_repl));
			break;
		}
	}
	
	print_debug("SaveFile...");
	//write
	u8 ret = SaveFile(patched_prx, mem, size);
	FREE(mem);
	if(ret == FAILED) {
		print_load("Error : cannot save patched_libaudio_%X.prx", firmware);
		FREE(libaudio_path);
		return NULL;
	}
	
	print_debug("Sign_PRX...");
	if(Sign_PRX(patched_prx, libaudio_path) == FAILED) {
		print_load("Error : cannot sign prx, patched_libaudio_%X.sprx", firmware);
		FREE(libaudio_path);
		return NULL;
	}
	
	print_debug("Delete prx files");
	Delete(ori_prx);
	Delete(patched_prx);
	
	print_load("End of get_libaudio_path()");
	return libaudio_path;
}

static char *get_blank_iso_path(void)
{
	char *s = malloc(32);
	
	strcpy(s, "/dev_hdd0/");
	s[10] = 'v';
	s[11] = 's';
	s[12] = 'h';
	s[13] = '/';
	s[14] = 't';
	s[15] = 'a';
	s[16] = 's';
	s[17] = 'k';
	s[18] = '.';
	s[19] = 'd';
	s[20] = 'a';
	s[21] = 't';
	s[22] = 0;
	
	return s;
}

static char *build_blank_iso(char *title_id)
{
	uint8_t *buf = malloc(128*1024);
	
	memset(buf, 0, 128*1024);
	
	buf[3] = 2;
	buf[0x17] = 0x3F;
	strcpy((char *)buf+0x800, "PlayStation3");
	memcpy(buf+0x810, title_id, 4);
	buf[0x814] = '-';
	memcpy(buf+0x815, title_id+4, 5);
	memset(buf+0x81A, ' ', 0x16);
	buf[0x8000] = 1;
	strcpy((char *)buf+0x8001, "CD001");
	buf[0x8006] = 1;
	memset(buf+0x8008, ' ', 0x20);
	memcpy(buf+0x8028, "PS3VOLUME", 9);
	memset(buf+0x8031, ' ', 0x17);
	buf[0x8050] = buf[0x8057] = 0x40;
	buf[0x8078] = buf[0x807B] = buf[0x807C] = buf[0x807F] = 1;
	buf[0x8081] = buf[0x8082] = 8;
	buf[0x8084] = buf[0x808B] = 0xA;
	buf[0x808C] = 0x14;
	buf[0x8097] = 0x15;
	buf[0x809C] = 0x22;
	buf[0x809E] = buf[0x80A5] = 0x18;
	buf[0x80A7] = buf[0x80AC] = 8;
	buf[0x80AE] = 0x6F;
	buf[0x80AF] = 7;
	buf[0x80B0] = 0x16;
	buf[0x80B1] = 2;
	buf[0x80B2] = 0x2B;
	buf[0x80B3] = buf[0x80B5] = 2;
	buf[0x80B8] = buf[0x80BB] = buf[0x80BC] = 1;
	memcpy(buf+0x80be, "PS3VOLUME", 9);
	memset(buf+0x80C7, ' ', 0x266);
	strcpy((char *)buf+0x832d, "2011072202451800");
	strcpy((char *)buf+0x833e, "0000000000000000");
	strcpy((char *)buf+0x834f, "0000000000000000");
	strcpy((char *)buf+0x8360, "0000000000000000");
	buf[0x8371] = 1;
	buf[0x8800] = 2;
	strcpy((char *)buf+0x8801, "CD001");
	buf[0x8806] = 1;
	buf[0x8829] = 'P';
	buf[0x882B] = 'S';
	buf[0x882D] = '3';
	buf[0x882F] = 'V';
	buf[0x8831] = 'O';
	buf[0x8833] = 'L';
	buf[0x8835] = 'U';
	buf[0x8837] = 'M';
	buf[0x8839] = 'E';
	buf[0x8850] = buf[0x8857] = 0x40;
	strcpy((char *)buf+0x8858, "%/@");
	buf[0x8878] = buf[0x887B] = buf[0x887C] = buf[0x887F] = 1;
	buf[0x8881] = buf[0x8882] = 8;
	buf[0x8884] = buf[0x888B] = 0xA;
	buf[0x888C] = 0x16;
	buf[0x8897] = 0x17;
	buf[0x889C] = 0x22;
	buf[0x889E] = buf[0x88A5] = 0x19;
	buf[0x88A7] = buf[0x88AC] = 8;
	buf[0x88AE] = 0x6F;
	buf[0x88AF] = 7;
	buf[0x88B0] = 0x16;
	buf[0x88B1] = 2;
	buf[0x88B2] = 0x2B;
	buf[0x88B3] = buf[0x88B5] = 2;
	buf[0x88B8] = buf[0x88BB] = buf[0x88BC] = 1;
	buf[0x88BF] = 'P';
	buf[0x88C1] = 'S';
	buf[0x88C3] = '3';
	buf[0x88C5] = 'V';
	buf[0x88C7] = 'O';
	buf[0x88C9] = 'L';
	buf[0x88CB] = 'U';
	buf[0x88CD] = 'M';
	buf[0x88CF] = 'E';
	
	strcpy((char *)buf+0x8B2D, "2011072202451800");
	strcpy((char *)buf+0x8B3E, "0000000000000000");
	strcpy((char *)buf+0x8B4F, "0000000000000000");
	strcpy((char *)buf+0x8b60, "0000000000000000");
	buf[0x8B71] = 1;
	buf[0x9000] = 0xFF;
	strcpy((char *)buf+0x9001, "CD001");
	buf[0xA000] = 1;
	buf[0xA002] = 0x18;
	buf[0xA006] = 1;
	buf[0xA800] = 1;
	buf[0xA805] = 0x18;
	buf[0xA807] = 1;
	buf[0xB000] = 1;
	buf[0xB002] = 0x19;
	buf[0xB006] = 1;
	buf[0xB800] = 1;
	buf[0xB805] = 0x19;
	buf[0xB807] = 1;
	buf[0xC000] = 0x28;
	buf[0xC002] = buf[0xC009] = 0x18;
	buf[0xC00B] = buf[0xC010] = 8;
	buf[0xC012] = 0x6F;
	buf[0xC013] = 7;
	buf[0xC014] = 0x16;
	buf[0xC015] = 2;
	buf[0xC016] = 0x2B;
	buf[0xC017] = buf[0xC019] = 2;
	buf[0xC01C] = buf[0xC01F] = buf[0xC020] = 1;
	buf[0xC028] = 0x28;
	buf[0xC02A] = buf[0xC031] = 0x18;
	buf[0xC033] = buf[0xC038] = 8;
	buf[0xC03A] = 0x6F;
	buf[0xC03B] = 7;
	buf[0xC03C] = 0x16;
	buf[0xC03D] = 2;
	buf[0xC03E] = 0x2B;
	buf[0xC03F] = buf[0xC041] = 2;
	buf[0xC044] = buf[0xC047] = buf[0xC048] = buf[0xC049] = 1;
	buf[0xC800] = 0x28;
	buf[0xC802] = buf[0xC809] = 0x19;
	buf[0xC80B] = buf[0xC810] = 8;
	buf[0xC812] = 0x6F;
	buf[0xC813] = 7;
	buf[0xC814] = 0x16;
	buf[0xC815] = 2;
	buf[0xC816] = 0x2B;
	buf[0xC817] = buf[0xC819] = 2;
	buf[0xC81C] = buf[0xC81F] = buf[0xC820] = 1;
	buf[0xC828] = 0x28;
	buf[0xC82A] = buf[0xC831] = 0x19;
	buf[0xC833] = buf[0xC838] = 8;
	buf[0xC83A] = 0x6F;
	buf[0xC83B] = 7;
	buf[0xC83C] = 0x16;
	buf[0xC83D] = 2;
	buf[0xC83E] = 0x2B;
	buf[0xC83F] = buf[0xC841] = 2;
	buf[0xC844] = buf[0xC847] = buf[0xC848] = buf[0xC849] = 1;
	
	char *ret = get_blank_iso_path();
	
	FILE* f = fopen(ret, "wb");
	if(f==NULL) {
		free(buf);
		free(ret);
		return NULL;
	}
	if (fwrite(buf, 1, 128*1024, f) != (128*1024))
	{
		fclose(f);
		free(buf);
		free(ret);
		return NULL;
	}
	
	fclose(f);
	free(buf);
	return ret;
}

void mount_fake_BR()
{
	unsigned int real_disctype;

	cobra_get_disc_type(&real_disctype, NULL, NULL);
	
	if (real_disctype == DISC_TYPE_NONE)
	{
		print_load("Mount Fake BR");
		char *files[1];
		char *blank_iso = build_blank_iso(GamID);
		
		if (blank_iso)
		{
			files[0] = blank_iso;			
			cobra_mount_ps3_disc_image(files, 1);
			free(blank_iso);
			
			usleep(25000);
			cobra_send_fake_disc_insert_event();
		}
	}
}

char *ISOtype(char *isoPath)
{
	FILE* f;
	f = fopen(isoPath, "rb");			
	if(f==NULL) {
		print_debug("Error : ISOtype failed to open %s", isoPath);
		return 	NO;
	}
	
	u32 SectSize=0;
	u32 JP=0;
	
	if( get_SectorSize(f, &SectSize, &JP) == FAILED) { 
		fclose(f);
		return _ISO;
	}
	
	char *mem =  (char *) malloc(0x40);
	if(mem==NULL) {
		fclose(f);
		print_debug("Error : ISOtype malloc failed");
		return NO;
	}
	memset(mem, 0, sizeof(mem));
	fseek(f, SectSize*0x10+JP, SEEK_SET);

	fread(mem, 1, 0x40, f);
		
	if(!memcmp((char *) &mem[0x28], (char *) "PS3VOLUME", 0x9)) {
		free(mem);
		fclose(f);
		return _ISO_PS3;
	}
	if(!memcmp((char *) &mem[0x8], (char *) "PSP GAME", 0x8)) {
		free(mem);
		fclose(f);
		return _ISO_PSP;
	}
/* bad idea : bin/cue PS2 exist too..
	if(!memcmp((char *) &mem[0x8], (char *) "PLAYSTATION", 0xB)) {
		free(mem);
		fclose(f);
		if(JP==0) return _ISO_PS2; 
		else	  return _ISO_PS1;
	}
*/
	free(mem);
	fclose(f);
	
	int file_size;
	
	mem = LoadFileFromISO(NO, isoPath, "SYSTEM.CNF", &file_size);
	if( mem != NULL ) {
		if(strstr(mem, "BOOT2") != NULL) {
			free(mem);
			return _ISO_PS2;
		} else
		if(strstr(mem, "BOOT") != NULL) {
			free(mem);
			return _ISO_PS1;
		} else {
			free(mem);
			return _ISO;
		}
	}

	mem = LoadFileFromISO(NO, isoPath, "/PS3_GAME/PARAM.SFO", &file_size);
	if( mem != NULL ) {
		free(mem);
		return _ISO_PS3;
	}
	mem = LoadFileFromISO(NO, isoPath, "/PSP_GAME/PARAM.SFO", &file_size);
	if( mem != NULL ) {
		free(mem);
		return _ISO_PSP;
	}

	if( ExistInISO(isoPath, "AUDIO_TS") ) return _ISO_DVD_VIDEO;
	if( ExistInISO(isoPath, "VIDEO_TS") ) return _ISO_DVD_VIDEO;
	if( ExistInISO(isoPath, "BDMV")     ) return _ISO_BD_VIDEO;	
	
	return _ISO;
	
}

u8 is_folder(char *ext)
{
	if(	   !strcmp(ext, _SDIR)
		|| !strcmp(ext, _BDVD) 
		|| !strcmp(ext, _JB_PS3) 
		|| !strcmp(ext, _JB_PS2)
		|| !strcmp(ext, _JB_PS1)
		|| !strcmp(ext, _JB_PSP)
	) return YES;
	
	return NO;
}

u8 can_read(char *ext)
{
	int i;
	for( i = 0; i < ArrayCount(TXTViewerSupport); i++) {
		if( !strcasecmp(ext, TXTViewerSupport[i]) )  return YES;
	}	
	return NO;
}

u8 can_view(char *ext)
{
	int i;
	for( i = 0; i < ArrayCount(PictureViewerSupport); i++) {
		if(  !strcasecmp(ext, PictureViewerSupport[i]) )  return YES;
	}
	return NO;
}

u8 get_platform_from_ext(char *ext)
{
	if(!strcmp(ext, _BDVD) ) return BDVD;
	if(!strcmp(ext, _JB_PS3)) return JB_PS3;
	if(!strcmp(ext, _JB_PS2)) return JB_PS2;
	if(!strcmp(ext, _JB_PS1)) return JB_PS1;
	if(!strcmp(ext, _JB_PSP)) return JB_PSP;
	
	if(!strcmp(ext, _ISO_PS3)) return ISO_PS3;
	if(!strcmp(ext, _ISO_PS2)) return ISO_PS2;
	if(!strcmp(ext, _ISO_PS1)) return ISO_PS1;
	if(!strcmp(ext, _ISO_PSP)) return ISO_PSP;
	
	if(!strcmp(ext, _ISO_BD_VIDEO)) return ISO_BD_VIDEO;
	if(!strcmp(ext, _ISO_DVD_VIDEO)) return ISO_DVD_VIDEO;
	
	return UNK;
}

u8 get_platform(char *file)
{
	char *ext = get_ext(file);
	
	return get_platform_from_ext(ext);
}

char *get_ext(char *file)
{
	char *file_name;
	
	u8 is_path=NO;
	
	if(strstr(file, "/")) {
		is_path=YES;
		
		if(!strcmp(file, "/dev_bdvd")) return _BDVD;
		
		if(path_info(file) == _DIRECTORY)  {
			char temp[255];
			sprintf(temp, "%s/PS3_GAME/PARAM.SFO", file);
			if(path_info(temp) == _FILE) return _JB_PS3;
			sprintf(temp, "%s/PSP_GAME/PARAM.SFO", file);
			if(path_info(temp) == _FILE) return _JB_PSP;
			sprintf(temp, "%s/SYSTEM.CNF", file);
			if(path_info(temp) == _FILE) {
				FILE* f;
				f=fopen(temp, "rb");
				if(f!=NULL) {
					fgets(temp, 128, f);
					fclose(f);
					
					if( strstr(temp, " =") != NULL) strtok(temp, " =");
					if(!strcmp(temp, "BOOT2")) return _JB_PS2; else
					if(!strcmp(temp, "BOOT")) return _JB_PS1;
				}
			}
			return _SDIR;
		}
		file_name = &strrchr(file, '/')[1];
	} else {
		file_name = file;
	}
	
	char *ext = GetExtension(file_name);
	if(ext==NULL) return _SFILE;
	
	if (!strcmp(file_name, _XREG)) {
		return _XREG;
	} else
	if (!strcasecmp(file_name, _EBOOT_ELF)) {
		return _EBOOT_ELF;
	} else 
	if (!strcasecmp(file_name, _EBOOT_BIN)) {
		return _EBOOT_BIN;
	} else 
	if(is_iso(file)==YES) {
		if(is_path == YES) return ISOtype(file);
		return _ISO;
	}
	
	return ext;
}

//*******************************************************
// HEN
//*******************************************************

int syscall_is_HEN()
{
	lv2syscall1(8, SYSCALL8_OPCODE_IS_HEN);
	return_to_user_prog(int);
}

int HEN_rev()
{
	lv2syscall1(8, SYSCALL8_OPCODE_HEN_REV);
	return_to_user_prog(int);
}

u8 is_HEN()
{
	if( syscall_is_HEN() == SYSCALL8_OPCODE_IS_HEN) return YES;
	return NO;
}

void HEN_game_settings()
{
	payload=SNAKE;
	if( emu==BDEMU ) emu=NONE;
	use_ex_plug=NO;
}

//*******************************************************
// MAP PATHS
//*******************************************************


int MAX_TABLE_ENTRIES=-1;
int TABLE_ENTRIES=-1;
char **OLD_PATH=NULL;
char **NEW_PATH=NULL;
char *FM_OLD_PATH=NULL;

int get_map_path(unsigned int num, char *path, char *new_path) 
{
	lv2syscall4(8, SYSCALL8_OPCODE_HEN_REV, (uint64_t)num, (uint64_t)path, (uint64_t)new_path);
	return_to_user_prog(int);
}

void init_MAP_PATHS_LIST()
{
	MAX_TABLE_ENTRIES = get_map_path(0xFFFF, NULL, NULL);
	
	if( MAX_TABLE_ENTRIES < 0 ) return;
	
	OLD_PATH = (char **) malloc(MAX_TABLE_ENTRIES * sizeof(char *));
	NEW_PATH = (char **) malloc(MAX_TABLE_ENTRIES * sizeof(char *));
	
	int i;
	for(i=0; i < MAX_TABLE_ENTRIES; i++) {
		OLD_PATH[i] = (char *) malloc(512);
		NEW_PATH[i] = (char *) malloc(512);
	}
	
}

void clear_MAP_PATHS_LIST()
{
	int i;
	for(i=0; i < MAX_TABLE_ENTRIES; i++) {
		memset(OLD_PATH[i], 0, 512);
		memset(NEW_PATH[i], 0, 512);
	}
}

void get_map_paths()
{
	clear_MAP_PATHS_LIST();
	
	int i;
	for(i=0; i < MAX_TABLE_ENTRIES; i++) {		
		get_map_path(i, OLD_PATH[i], NEW_PATH[i]);
	}
}

//*******************************************************
//Iris Mount Game
//*******************************************************

void reset_sys8_path_table()
{
	while(ntable > 0) {
		if(table_compare[ntable - 1]) free(table_compare[ntable - 1]);
		if(table_replace[ntable - 1]) free(table_replace[ntable - 1]);
		ntable --;
	}
}

void add_sys8_path_table(char * compare, char * replace)
{
	if(ntable >= 16) return;

	table_compare[ntable] = malloc(strlen(compare) + 1);
	if(!table_compare[ntable]) return;
	strncpy(table_compare[ntable], compare, strlen(compare) + 1);
	
	table_replace[ntable] = malloc(strlen(replace) + 1);
	if(!table_replace[ntable]) return;
	strncpy(table_replace[ntable], replace, strlen(replace) + 1);

	ntable++;

	table_compare[ntable] = NULL;
}

void add_sys8_bdvd(char * bdvd, char * app_home)
{
	static char compare1[]="/dev_bdvd";
	static char compare2[]="/app_home";
	static char replace1[0x420];
	static char replace2[0x420];
	int pos = 17;

	table_compare[pos] = NULL;
	table_compare[pos + 1] = NULL;

	if(bdvd) {
		strncpy(replace1, bdvd, 0x420);
		table_compare[pos] = compare1;
		table_replace[pos] = replace1;
		pos++;
	}
	
	if(app_home) {
		strncpy(replace2, app_home, 0x420);
		table_compare[pos] = compare2;
		table_replace[pos] = replace2;
		pos++;
	}
	
}

void build_sys8_path_table()
{

	path_open_entry *pentries;

	int entries = 0;

	int arena_size = 0;

	int n, m;

	sys8_path_table(0LL);

	if(ntable <= 0 && !table_compare[17] && !table_compare[18]) return;
	if(ntable <= 0) {table_compare[0] = 0; ntable = 0;}

	while(ntable>0 && table_compare[entries] != NULL) entries++;

	// /dev_bdvd & /app_home entries
	if(table_compare[17]) {
		table_compare[entries] = table_compare[17]; 
		table_replace[entries] = table_replace[17];
		entries++;
	}

	if(table_compare[18]) {
		table_compare[entries] = table_compare[18];
		table_replace[entries] = table_replace[18];
		entries++;
	}

	table_compare[entries] = NULL;

	entries = 0;

	while(table_compare[entries] != NULL) {
		int l = strlen(table_compare[entries]);

		arena_size += 0x420;
		for(m = 0x80; m <= 0x420; m += 0x20)
			if(l < m) {arena_size += m;break;}

	entries++;
	}


	if(!entries) return;

	char * datas = memalign(16, arena_size + sizeof(path_open_entry) * (entries + 2));
	
	if(!datas) return;

	u64 dest_table_addr = 0x80000000007FE000ULL - (u64)((arena_size + sizeof(path_open_entry) * (entries + 1) + 15) & ~15);

	u32 arena_offset = (sizeof(path_open_entry) * (entries + 1));

	pentries = (path_open_entry *) datas;

	for(n = 0; n < entries; n++) {
	
		int l = strlen(table_compare[n]);

		int size = 0;
		for(m = 0x80; m <= 0x420; m += 0x20)
			if(l < m) {size += m; break;}

		pentries->compare_addr = dest_table_addr + (u64) (arena_offset);

		pentries->replace_addr = dest_table_addr + (u64) (arena_offset + size);
		

		strncpy(&datas[arena_offset], table_compare[n], size);
		strncpy(&datas[arena_offset + size], table_replace[n], 0x420);

		pentries->compare_len = strlen(&datas[arena_offset]);
		pentries->replace_len = strlen(&datas[arena_offset + size]);

		arena_offset += size + 0x420;
		pentries ++;
	   
	}
	
	pentries->compare_addr = 0ULL;

	sys8_memcpy(dest_table_addr, (u64) datas, (u64) (arena_size + sizeof(path_open_entry) * (entries + 1)));

	free(datas);

	reset_sys8_path_table();

	// set the path table
	sys8_path_table( dest_table_addr);
}

static inline void lv2_memcpy( u64 to, u64 from, size_t sz)
{
	lv2syscall3(NEW_POKE_SYSCALL, to, from, sz);
}

static inline void lv2_memset( u64 dst, const u64 val, size_t sz)
{
	u64 *tmp = memalign(32, (sz*(sizeof(u64))) );
	if(!tmp)
		return;

	memset(tmp, val, sz);
	
	lv2syscall3(NEW_POKE_SYSCALL, dst, (u64) tmp, sz);

	free(tmp);
}

static inline void install_lv2_memcpy()
{
	int n;

	for(n = 0; n < 50; n++) {
	/* install memcpy */
	/* This does not work on some PS3s */
		lv2poke(NEW_POKE_SYSCALL_ADDR, 0x4800000428250000ULL);
		lv2poke(NEW_POKE_SYSCALL_ADDR + 8, 0x4182001438a5ffffULL);
		lv2poke(NEW_POKE_SYSCALL_ADDR + 16, 0x7cc428ae7cc329aeULL);
		lv2poke(NEW_POKE_SYSCALL_ADDR + 24, 0x4bffffec4e800020ULL);
		usleep(5000);
	}
}

static inline void remove_lv2_memcpy()
{
	int n;

	for(n = 0; n < 50; n++) {
	/* restore syscall */
	//remove_new_poke();
  
		lv2poke(NEW_POKE_SYSCALL_ADDR, 0xF821FF017C0802A6ULL);
		lv2poke(NEW_POKE_SYSCALL_ADDR + 8, 0xFBC100F0FBE100F8ULL);
		lv2poke(NEW_POKE_SYSCALL_ADDR + 16, 0xEBC2FEB07C7F1B78ULL);
		lv2poke(NEW_POKE_SYSCALL_ADDR + 24, 0x3860032DFBA100E8ULL);
		usleep(5000);
	}
}

void load_payload()
{

	remove_lv2_protection();

	install_lv2_memcpy();

	/* WARNING!! It supports only payload with a size multiple of 8 */
	lv2_memcpy(0x8000000000000000ULL + (u64) PAYLOAD_OFFSET,
				   (u64) PAYLOAD_SKY, 
				   PAYLOAD_SKY_SIZE);

	lv2_memcpy(0x8000000000000000ULL + (u64) PAYLOAD_UMOUNT_OFFSET, // copy umount routine
					  (u64) UMOUNT, 
					  UMOUNT_SIZE);

	//restore_syscall8[0]= SYSCALL_TABLE + 64ULL; // (8*8)
	//restore_syscall8[1]= lv2peek(restore_syscall8[0]);

	u64 id[2];
	// copy the id
	id[0]= 0x534B314500000000ULL | (u64) PAYLOAD_OFFSET;
	id[1] = SYSCALL_TABLE + 64ULL; // (8*8)
	lv2_memcpy(0x80000000000004f0ULL, (u64) &id[0], 16);

	u64 inst8 =  lv2peek(0x8000000000003000ULL);					 // get TOC
	lv2_memcpy(0x8000000000000000ULL + (u64) (PAYLOAD_OFFSET + 0x28), (u64) &inst8, 8);
	inst8 = 0x8000000000000000ULL + (u64) (PAYLOAD_OFFSET + 0x20); // syscall_8_desc - sys8
	lv2_memcpy(SYSCALL_TABLE + (u64) (8 * 8), (u64) &inst8, 8);
	
	usleep(1000);
	
	remove_lv2_memcpy();

	lv2poke(0x80000000007EF000ULL, 0ULL);// BE Emu mount
	lv2poke(0x80000000007EF220ULL, 0ULL);

	fix_error();
	
	PATCH_JUMP	(OPEN_HOOK + 0x24	, (PAYLOAD_OFFSET+0x30));  // lv2poke32	(OPEN_HOOK + 0x24	, 0x4bd63ae0);
	lv2poke32	(OPEN_HOOK			, 0xF821FF61);
	lv2poke		(OPEN_HOOK + 0x8	, 0xFB810080FBA10088ULL);

	PATCH_JUMP	(PERMS_OFFSET		, (PAYLOAD_OFFSET+0x18));
	
}

void iris_Mount()
{
	int ret;
	
	if(cobra || mamba) {
		if(prim_USB == YES) SetPrimaryUSB();
		mount_fake_BR();
	}
	
	load_payload();
	__asm__("sync");
	sleep(1);
	
	char temp[128];
	
	if(emu==BDMIRROR) {
		print_load("Patching BD-Mirror");
		ret = patch_bdmirror();
		if( ret != 0) print_load("Error %d: failed to patch bdmirroir", ret);
		sleep(1);
		
		sprintf(temp_buffer, "%s/PS3_DISC.SFB", GamPath);
		add_sys8_path_table("/dev_bdvd/PS3_DISC.SFB", temp_buffer);
		
		add_sys8_bdvd(NULL, NULL);
		
	} else
	if(emu == BDEMU) {
		char *libfs_path = get_libfs_path();
		if(path_info(libfs_path) == _FILE)	add_sys8_path_table("/dev_flash/sys/external/libfs.sprx", libfs_path);
		if(libfs_path) free(libfs_path);
		
		add_sys8_bdvd(GamPath, NULL);
	} else 
	if(emu == NONE) {
		add_sys8_bdvd(GamPath, NULL);
	}
	
	if( bt_audio ) {
		char *libaudio_path = get_libaudio_path();
		if(libaudio_path) {
			add_sys8_path_table("/dev_flash/sys/external/libaudio.sprx", libaudio_path);
			FREE(libaudio_path);
		}
	}
	
	if(mount_app_home == YES) {
		if(emu == BDMIRROR) {
			add_sys8_bdvd(NULL, "/dev_bdvd");
		} else {
			add_sys8_bdvd(GamPath, GamPath);
		}
		
		if(use_ex_plug==YES) {
			if(patch_exp_plug() == SUCCESS) {
				sprintf(temp, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
				if(path_info(temp) == _FILE)	add_sys8_path_table( (char*)"/dev_flash/vsh/module/explore_plugin.sprx", temp);
			} else  print_load("Error : cannot patch explore_plugin.sprx");
		}
	}

	if(ext_game_data==YES) {
		int i;
		for(i=0; i<=device_number; i++) {
			sprintf(temp, "/%s", list_device[i]);
			if(strstr(temp, "/dev_usb")) {
				strcat(temp, "/GAMEI");
				if(path_info(temp)==_NOT_EXIST) mkdir(temp, 0777);
				add_sys8_path_table("/dev_hdd0/game", temp);
			}
		}
	}
	
	build_sys8_path_table();
	
}

//*******************************************************
//multiMan Mount
//*******************************************************

void add_to_map(char *path1, char *path2)
{
	u8 n=0;
	if(max_mapped==0) lv2poke(MAP_BASE + 0x00, 0x0000000000000000ULL);

	if(max_mapped<8)
	{
		for(n=0; n<max_mapped; n++)
		{
			if(!strcmp(file_to_map[n].src, path1)) return;
		}
		sprintf(file_to_map[max_mapped].src, "%s", path1);
		sprintf(file_to_map[max_mapped].dst, "%s", path2);
		max_mapped++;
	}
}

void string_to_lv2(char* path, u64 addr)
{
	u16 len=(strlen(path)+8)&0x7f8;
	if(len<8) len=8;
	if(len>384) len=384;
	u16 len2=strlen(path); if(len2>len) len2=len;

	u8 data2[384];
	u8* data = data2;
	memset(data, 0, 384);
	memcpy(data, path, len2);

	u64 val=0x0000000000000000ULL;
	u64 n;
	for(n = 0; n < len; n += 8)
	{
		memcpy(&val, &data[n], 8);
		lv2poke(addr+n, val);
	}
}

void install_MM_payload() 
{
	
	remove_lv2_protection();
	
	fix_error();
	
	u64 sc_600 = lv2peek(SYSCALL_TABLE + (8*600));
	u64 sc_604 = lv2peek(SYSCALL_TABLE + (8*604));
	u64 sc_142 = lv2peek(SYSCALL_TABLE + (8*142));
	
	// restore syscall table  ==> // useless ??
	u64 sc_null = lv2peek(SYSCALL_PTR( 0));
	if(sc_null == lv2peek(SYSCALL_PTR(79)))
	{
		lv2poke(SYSCALL_PTR(  35), sc_null);
		lv2poke(SYSCALL_PTR(  36), sc_null);
		lv2poke(SYSCALL_PTR(  37), sc_null);
		//lv2poke(SYSCALL_PTR(1023), sc_null);

		if(sc_600)
		{
			lv2poke(SYSCALL_PTR(600), sc_600); // sys_storage_open 600
			lv2poke(SYSCALL_PTR(604), sc_604); // sys_storage_send_device_cmd 604
			lv2poke(SYSCALL_PTR(142), sc_142); // sys_timer_sleep 142
		}
	}
	
	// disable mM path table
	lv2poke(0x8000000000000000ULL+MAP_ADDR, 0x0000000000000000ULL);
	lv2poke(0x8000000000000008ULL+MAP_ADDR, 0x0000000000000000ULL);

	// disable Iris path table
	lv2poke(0x80000000007FD000ULL,		   0x0000000000000000ULL);
	
	// restore hook used by all payloads)
	lv2poke(OPEN_HOOK + 0x00, 0xF821FF617C0802A6ULL);
	lv2poke(OPEN_HOOK + 0x08, 0xFB810080FBA10088ULL);
	lv2poke(OPEN_HOOK + 0x10, 0xFBE10098FB410070ULL);
	lv2poke(OPEN_HOOK + 0x18, 0xFB610078F80100B0ULL);
	lv2poke(OPEN_HOOK + 0x20, 0x7C9C23787C7D1B78ULL);
	
	// poke mM payload
	lv2poke(BASE_ADDR + 0x00, 0x7C7D1B783B600001ULL);
	lv2poke(BASE_ADDR + 0x08, 0x7B7BF806637B0000ULL | MAP_ADDR);
	lv2poke(BASE_ADDR + 0x10, 0xEB5B00002C1A0000ULL);
	lv2poke(BASE_ADDR + 0x18, 0x4D820020EBFB0008ULL);
	lv2poke(BASE_ADDR + 0x20, 0xE8BA00002C050000ULL);
	lv2poke(BASE_ADDR + 0x28, 0x418200CC7FA3EB78ULL);
	lv2poke(BASE_ADDR + 0x30, 0xE89A001089640000ULL);
	lv2poke(BASE_ADDR + 0x38, 0x892300005560063EULL);
	lv2poke(BASE_ADDR + 0x40, 0x7F895800409E0040ULL);
	lv2poke(BASE_ADDR + 0x48, 0x2F8000007CA903A6ULL);
	lv2poke(BASE_ADDR + 0x50, 0x409E002448000030ULL);
	lv2poke(BASE_ADDR + 0x58, 0x8964000089230000ULL);
	lv2poke(BASE_ADDR + 0x60, 0x5560063E7F895800ULL);
	lv2poke(BASE_ADDR + 0x68, 0x2F000000409E0018ULL);
	lv2poke(BASE_ADDR + 0x70, 0x419A001438630001ULL);
	lv2poke(BASE_ADDR + 0x78, 0x388400014200FFDCULL);
	lv2poke(BASE_ADDR + 0x80, 0x4800000C3B5A0020ULL);
	lv2poke(BASE_ADDR + 0x88, 0x4BFFFF98E89A0018ULL);
	lv2poke(BASE_ADDR + 0x90, 0x7FE3FB7888040000ULL);
	lv2poke(BASE_ADDR + 0x98, 0x2F80000098030000ULL);
	lv2poke(BASE_ADDR + 0xA0, 0x419E00187C691B78ULL);
	lv2poke(BASE_ADDR + 0xA8, 0x8C0400012F800000ULL);
	lv2poke(BASE_ADDR + 0xB0, 0x9C090001409EFFF4ULL);
	lv2poke(BASE_ADDR + 0xB8, 0xE8BA00087C632A14ULL);
	lv2poke(BASE_ADDR + 0xC0, 0x7FA4EB78E8BA0000ULL);
	lv2poke(BASE_ADDR + 0xC8, 0x7C842A1488040000ULL);
	lv2poke(BASE_ADDR + 0xD0, 0x2F80000098030000ULL);
	lv2poke(BASE_ADDR + 0xD8, 0x419E00187C691B78ULL);
	lv2poke(BASE_ADDR + 0xE0, 0x8C0400012F800000ULL);
	lv2poke(BASE_ADDR + 0xE8, 0x9C090001409EFFF4ULL);
	lv2poke(BASE_ADDR + 0xF0, 0x7FFDFB787FA3EB78ULL);
	lv2poke(BASE_ADDR + 0xF8, 0x4E8000204D4D504CULL); //blr + "MMPL"
	
	lv2poke(MAP_BASE  + 0x00, 0x0000000000000000ULL);
	lv2poke(MAP_BASE  + 0x08, 0x0000000000000000ULL);
	lv2poke(MAP_BASE  + 0x10, 0x8000000000000000ULL);
	lv2poke(MAP_BASE  + 0x18, 0x8000000000000000ULL);

	lv2poke(0x8000000000000000ULL+MAP_ADDR, MAP_BASE);
	lv2poke(0x8000000000000008ULL+MAP_ADDR, 0x80000000007FDBE0ULL);

	lv2poke(OPEN_HOOK + 0x20, (0x7C9C237848000001ULL | (BASE_ADDR-OPEN_HOOK-0x24)));

}

void mm_Mount()
{
	int ret;
	
	if(cobra || mamba) {
		if(prim_USB == YES) SetPrimaryUSB();
		mount_fake_BR();
	}
	
	install_MM_payload();
	
	max_mapped=0;
	
	char path[strlen(GamPath)+4];
	sprintf(path, "%s", GamPath);
	char temp[128];
	
	if(emu == BDMIRROR) {
		print_load("Patching BD-Mirror");
		ret = patch_bdmirror();
		if( ret != 0) print_load("Error %d: patch_bdmirror failed", ret);
		sleep(1);

		sprintf(temp, "%s/PS3_DISC.SFB", GamPath);
		add_to_map("/dev_bdvd/PS3_DISC.SFB", temp);
		
	} else
	if(emu == BDEMU) {
		char *libfs_path = get_libfs_path();
		if(path_info(libfs_path) == _FILE)	add_to_map("/dev_flash/sys/external/libfs.sprx", libfs_path);
		if(libfs_path) free(libfs_path);
		
		add_to_map("/dev_bdvd", path);
	} else 
	if(emu==NONE) {
		add_to_map("/dev_bdvd", path);
	}
	
	if( bt_audio ) {
		char *libaudio_path = get_libaudio_path();
		if(libaudio_path) {
			add_to_map("/dev_flash/sys/external/libaudio.sprx", libaudio_path);
			FREE(libaudio_path);
		}
	}
	
	if(mount_app_home == YES)	{
		if(emu == BDMIRROR) {
			add_to_map("/app_home", "/dev_bdvd");
		} else {
			add_to_map("/app_home", path);
		}
		
		if(use_ex_plug==YES) {
			if(patch_exp_plug() == SUCCESS) {
				sprintf(temp, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
				if(path_info(temp) == _FILE )	add_to_map( (char*)"/dev_flash/vsh/module/explore_plugin.sprx", temp);
			} else  print_load("Error : cannot patch explore_plugin.sprx");
		}
	}

	if(ext_game_data==YES) {
		int i;
		for(i=0; i<=device_number; i++) {
			sprintf(temp, "/%s", list_device[i]);
			if(strstr(temp, "/dev_usb")) {
				strcat(temp, "/GAMEI");
				if(path_info(temp)==_NOT_EXIST) mkdir(temp, 0777);
				add_to_map("/dev_hdd0/game", temp);
			}
		}
	}
	
	u64 map_data  = (MAP_BASE);
	u64 map_paths = (MAP_BASE) + (max_mapped+1) * 0x20;
	u8 n;
	for(n=0; n<32; n++)
	{
		lv2poke(map_data + (n*32) + 0x00, 0);
		lv2poke(map_data + (n*32) + 0x08, 0);
		lv2poke(map_data + (n*32) + 0x10, 0);
		lv2poke(map_data + (n*32) + 0x18, 0);
	}

	if(!max_mapped) return;

	for(n=0; n<max_mapped; n++)
	{
		if(map_paths>0x80000000007FE800ULL) break;
		lv2poke(map_data + (n*32) + 0x10, map_paths);
		string_to_lv2(file_to_map[n].src, map_paths);
		map_paths+= (strlen(file_to_map[n].src)+8)&0x7f8;

		lv2poke(map_data + (n*32) + 0x18, map_paths);
		string_to_lv2(file_to_map[n].dst, map_paths);
		map_paths+= (strlen(file_to_map[n].dst)+8)&0x7f8;

		lv2poke(map_data + (n*32) + 0x08, strlen(file_to_map[n].dst));
		lv2poke(map_data + (n*32) + 0x00, strlen(file_to_map[n].src));
	}
	
	if(path_info("/dev_bdvd") == _NOT_EXIST) sleep(1);

}

//*******************************************************
//Cobra Mount
//*******************************************************

u8 have_syscall35()
{
	u64 syscall_not_impl = lv2peek(SYSCALL_TABLE);
	
	u64 sc35 = lv2peek(SYSCALL_TABLE + (8*35));
	
	if( sc35 == syscall_not_impl ) return NO;
	
	return YES;
}

s32 sys_map_path(char *oldpath, char *newpath)
{
	lv2syscall2(35, (uint64_t)oldpath, (uint64_t)newpath);
	return_to_user_prog(s32);
}

void snake_map(char *oldpath, char* newpath)
{
	//char *old_path[1]={NULL};
	//char *new_path[1]={NULL};
	
	//old_path[0]=oldpath;
	//new_path[0]=newpath;
	
	//sys_map_paths(old_path, new_path, 1);
	sys_map_path(oldpath, newpath);
}

int sys_get_version(u32 *version)
{
	lv2syscall2(8, SYSCALL8_OPCODE_GET_VERSION, (uint64_t)version);
	return_to_user_prog(int);
}

u8 is_cobra(void)
{
	u32 version = 0x99999999;
	if (sys_get_version(&version) < 0)	return 0;
	if (version != 0x99999999 && sys8_mamba() != 0x666)	return 1;
	return 0;
}

u8 is_usb(char *file_name)
{
	if(strstr(file_name, "/dev_usb")) return YES;
	return NO;
}

u8 is_FAT32(char *file_name)
{
	if(strstr(file_name, "/dev_usb")) return YES;
	if(strstr(file_name, "/dev_cf")) return YES;
	if(strstr(file_name, "/dev_sd")) return YES;
	if(strstr(file_name, "/dev_ms")) return YES;
	return NO;
}

u8 is_iso(char *file_name)
{
	char *Ext = GetExtension(file_name);
	
	if( !strncasecmp(Ext, ".iso", 4) )	return YES;
	
	if( !strncasecmp(Ext, ".bin", 4) )	return YES;
	
	if( !strncasecmp(Ext, ".mdf", 4) )	return YES;
	
	if( !strncasecmp(Ext, ".img", 4) )	return YES;
	
	return NO;
}

u8 is_66600(char *file_name)
{
	int l = strlen(file_name);
	
	if( file_name[l-6] == '.'
	&&	file_name[l-5] == '6'
	&&	file_name[l-4] == '6'
	&&	file_name[l-3] == '6'
	&&	file_name[l-2] == '0'
	&&	file_name[l-1] == '0' ) return YES;

	return NO;
}

u8 is_666XX(char *file_name)
{
	if(is_66600(file_name)) return NO;
	
	int l = strlen(file_name);
	
	if( file_name[l-6] == '.'
	&&	file_name[l-5] == '6'
	&&	file_name[l-4] == '6'
	&&	file_name[l-3] == '6') return YES;
	
	return NO;
}

u8 is_splitted_iso(char *file_name)
{
	if(is_iso(file_name) == NO) return NO;
	
	int l = strlen(file_name);
	
	if( file_name[l-2] == '.'
	&&	file_name[l-1] == '0' ) return YES;

	return NO;
}

u8 is_splitted_iso_X(char *file_name)
{
	if(is_iso(file_name) == NO) return NO;
	
	int l = strlen(file_name);
	
	if( file_name[l-2] == '.') {
		if(file_name[l-1] == '0' ) return NO;
		if('0' < file_name[l-1] && file_name[l-1] <= '9') return YES;
	} else 
	if(file_name[l-3] == '.') {
		if('1' <= file_name[l-2] && file_name[l-2] <= '9'
		&& '0' <= file_name[l-1] && file_name[l-1] <= '9') return YES;
	}
	
	return NO;
}
u8 can_mount()
{
	if(cobra) return YES;
	if(mamba) return YES;
	if(PEEKnPOKE) return YES;
	
	return NO;
}

u8 can_be_mounted(u8 platform)
{
	
	if(platform == ISO_PS3
	|| platform == ISO_PS2
	|| platform == ISO_PS1
	|| platform == ISO_PSP) {
		if(cobra) return YES;
		if(mamba) return YES;
		if(PEEKnPOKE) {
			if( MAMBA_SIZE != 0 ) return YES;
		}
		return NO;
	}
	
	if(platform == JB_PS3) {
		if(cobra) return YES;
		if(mamba) return YES;
		
		if(PEEKnPOKE) {
			if(MAMBA_SIZE != 0) return YES;
			if( PAYLOAD_SKY_SIZE != 0 ) return YES;
			if( BASE_ADDR != 0 ) return YES;
		}
	}
	return NO;
}

void cobra_MountISO(char *path, int EMU)
{
	int i;

	u8 ntfs = is_ntfs(path);
	u8 exfat = is_exFAT(path);

	if(ntfs || exfat) {
		uint8_t *plugin_args = malloc(0x20000);
		uint32_t *sections = malloc(MAX_SECTIONS * sizeof(uint32_t));
		uint32_t *sections_size = malloc(MAX_SECTIONS * sizeof(uint32_t));
		rawseciso_args *p_args;  
		memset(sections, 0, MAX_SECTIONS * sizeof(uint32_t));
		memset(sections_size, 0, MAX_SECTIONS * sizeof(uint32_t));
		memset(plugin_args, 0, 0x10000);

		int parts = 0;
		
		if(ntfs) parts = ps3ntfs_file_to_sectors(path, sections, sections_size, MAX_SECTIONS, 1);
		else
		if(exfat) parts = fflib_file_to_sectors(path, sections, sections_size, MAX_SECTIONS, 1);
		
		if(is_splitted_iso(path)==YES) {	   
			int o;
			for (o = 1; o < 32; o++) {
				struct stat s;
				sprintf(temp_buffer + 3072, "%s", path);
				temp_buffer[3072 + strlen(temp_buffer + 3072) - 1] = 0;
				sprintf(temp_buffer + 2048, "%s%i", temp_buffer + 3072, o);
				if(parts >= MAX_SECTIONS) break;
				if(stat(temp_buffer + 2048, &s)!=0) break;
				
				if( ntfs ) parts += ps3ntfs_file_to_sectors(temp_buffer + 2048, sections + parts, sections_size + parts, MAX_SECTIONS - parts, 1);
				else
				if( exfat ) parts += fflib_file_to_sectors(temp_buffer + 2048, sections + parts, sections_size + parts, MAX_SECTIONS - parts, 1);
			}
		}

		if (parts>0 && parts < MAX_SECTIONS) {
			p_args = (rawseciso_args *)plugin_args;
			if( ntfs ) p_args->device = USB_MASS_STORAGE(NTFS_Test_Device(&path[1]));
			else
			if( exfat ) p_args->device = USB_MASS_STORAGE(exFAT_get_idx(path));
			p_args->emu_mode = EMU;
			p_args->num_sections = parts;
			p_args->num_tracks = 0;
			memcpy(plugin_args+sizeof(rawseciso_args), sections, parts*sizeof(uint32_t));
			memcpy(plugin_args+sizeof(rawseciso_args)+(parts*sizeof(uint32_t)), sections_size, parts*sizeof(uint32_t)); 
			cobra_unload_vsh_plugin(0);
			sprintf(temp_buffer + 2048, "/dev_hdd0/game/%s/USRDIR/sys/sprx_iso", ManaGunZ_id);
			if (cobra_load_vsh_plugin(0, temp_buffer + 2048, plugin_args, 0x10000) == 0) return;
		}
	} 
	else {
		char *iso_path[30];
		int nb_iso=0;
		unsigned int effective_disctype, iso_disctype;

		if(is_splitted_iso(path)==YES) {
			int l= strlen(path);
			path[l-1]=0;
			for(i=0; i<32; i++) {
				char temp[255];
				sprintf(temp, "%s%d" , path, i);		
				if(path_info(temp) == _NOT_EXIST) break;
				
				iso_path[i] = strcpy_malloc(temp);
				nb_iso++;
			}
			path[l-1]='0';
		} else {
			iso_path[0] = strcpy_malloc(path);
			nb_iso = 1;
		}
		
		cobra_get_disc_type(NULL, &effective_disctype, &iso_disctype);
		if (effective_disctype != DISC_TYPE_NONE)	{
			cobra_send_fake_disc_eject_event();
			usleep(25000);
		}
		if (iso_disctype != DISC_TYPE_NONE)	{
			cobra_umount_disc_image();
			usleep(25000);
		}
		
		if(EMU == EMU_PS3) {
			cobra_mount_ps3_disc_image(iso_path, nb_iso);
		} else
		if(EMU == EMU_PS2_DVD) {
			TrackDef tracks[1];
			tracks[0].lba = 0;
			tracks[0].is_audio = 0;
			cobra_mount_ps2_disc_image(iso_path, nb_iso, tracks, 1);
		} else 
		if(EMU == EMU_PSX) {
			TrackDef tracks[1];
			tracks[0].lba = 0;
			tracks[0].is_audio = 0;
			cobra_mount_psx_disc_image(iso_path[0], tracks, 1);
		} else
		if(EMU == EMU_PSP) {
			cobra_set_psp_umd2(iso_path[0], NULL, (char*)"/dev_hdd0/tmp/psp_icon.png", 2);
		} else 
		if(EMU == EMU_DVD) {
			cobra_mount_dvd_disc_image(iso_path, nb_iso);
		} else
		if(EMU == EMU_BD) {
			cobra_mount_bd_disc_image(iso_path, nb_iso);
		}
		
		usleep(25000);
		cobra_send_fake_disc_insert_event();
	}
}

void cobra_Mount()
{
	int i;
	char temp[128];
	
	fix_error();
	
	if(iso) {
		if(mount_app_home == YES)	{
			{sys_map_path("/app_home", "/dev_bdvd");}
			
			if(use_ex_plug==YES) {
				if(patch_exp_plug() == SUCCESS) {
					sprintf(temp, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
					if(path_info(temp) != _NOT_EXIST) {sys_map_path("/dev_flash/vsh/module/explore_plugin.sprx", temp);}
				} else  print_load("Error : cannot patch explore_plugin.sprx");
			}
		}
		
		cobra_MountISO(GamPath, EMU_PS3);
	}
	else {
		i=0;	
		int ret;
		
		if(prim_USB == YES) SetPrimaryUSB();
		
		mount_fake_BR();
		
		if(emu == BDMIRROR) {
			print_load("Patching BD-Mirror");
			ret = patch_bdmirror();
			if( ret != 0) print_load("Error %d: patch_bdmirror failed", ret);
			sleep(1);

			sprintf(temp, "%s/PS3_DISC.SFB", GamPath);
			{sys_map_path("/dev_bdvd/PS3_DISC.SFB", temp);}
		} else
		if(emu == BDEMU) {		
			char *libfs_path = get_libfs_path();
			if(path_info(libfs_path) == _FILE)	{sys_map_path("/dev_flash/sys/external/libfs.sprx", libfs_path);}
			if(libfs_path) free(libfs_path);
			
			cobra_map_game(GamPath, (char*) GamID, &i);
		} else 
		if(emu == NONE) {
			cobra_map_game(GamPath, (char*) GamID, &i);
		}
		
		if( bt_audio ) {
			char *libaudio_path = get_libaudio_path();
			if(libaudio_path) {
				{sys_map_path("/dev_flash/sys/external/libaudio.sprx", libaudio_path);}
				FREE(libaudio_path);
			}
		}
		
		if(mount_app_home == YES)	{
			if(emu == BDMIRROR) {
				{sys_map_path("/app_home", "/dev_bdvd");}
			} else {
				{sys_map_path("/app_home", GamPath);}
			}
			
			if(use_ex_plug==YES) {
				if(patch_exp_plug() == SUCCESS) {
					sprintf(temp, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
					if((path_info(temp)==_FILE) )	{sys_map_path("/dev_flash/vsh/module/explore_plugin.sprx", temp);}
				} else  print_load("Error : cannot patch explore_plugin.sprx");
			}
		}
	}
	
	if(ext_game_data==YES) {
		int i;
		for(i=0; i<=device_number; i++) {
			sprintf(temp, "/%s", list_device[i]);
			if(strstr(temp, "/dev_usb")) {
				strcat(temp, "/GAMEI");
				if(path_info(temp)==_NOT_EXIST) mkdir(temp, 0777);
				{sys_map_path("/dev_hdd0/game", temp);}
			}
		}
	}
}

//*******************************************************
// Mamba
//*******************************************************

#define MAMBA_PRX_LOADER_INSTALL_OFFSET				0x80000000007F0000ULL
#define MAMBA_PRX_LOADER_SYSCALL_NUM				1022

#define IS_MAMBA_PRX_LOADER_PAYLOAD 				0x333
#define IS_MAMBA_LOADER_PAYLOAD 					0x222
#define IS_PRX_LOADER_PAYLOAD 						0x111

#define SYSCALL1022_OPCODE_IS_ENABLED				0x7750
#define SYSCALL1022_OPCODE_LOAD_MAMBA				0x7755

int is_mamba()
{
	u32 version = 0x99999999;
	if (sys_get_version(&version) < 0)	return 0;
	if (version != 0x99999999 && sys8_mamba() == 0x666)	return 1;
	return 0;
}

extern int lv1_write_htab_entry(uint64_t vas_id, uint64_t hpte_index, uint64_t hpte_v, uint64_t hpte_r);
void write_htab(void)
{
	if( !PEEKnPOKE ) return;

	uint64_t cont = 0;
	uint64_t reg5, reg6;
	uint32_t val;
	
	// lv1_call -> todo check if syscall 10 exist
	u8 use_syscall_10 = YES; 
	while(cont < 0x80)
	{
		val = (cont << 7);
		reg5 = lv2peek(0x800000000f000000ULL | ((uint64_t) val));
		reg6 = lv2peek(0x800000000f000008ULL | ((uint64_t) val));
		reg6 = (reg6  & 0xff0000ULL) | 0x190ULL;
		if( use_syscall_10 ) {
			lv2syscall8(10, 0, (cont << 3ULL), reg5, reg6, 0, 0, 0, 1);
		} else {
			lv1_write_htab_entry(0, (cont << 3ULL), reg5, reg6);
		}
		cont++;
	}
}

int syscall_mpl_payload_is_enabled()
{
	lv2syscall1(MAMBA_PRX_LOADER_SYSCALL_NUM, SYSCALL1022_OPCODE_IS_ENABLED);
	return_to_user_prog(int);
}

int syscall_load_mamba(char* payload_path)
{
	lv2syscall2(MAMBA_PRX_LOADER_SYSCALL_NUM, SYSCALL1022_OPCODE_LOAD_MAMBA, (uint64_t)payload_path);
	return_to_user_prog(int);
}

int load_mamba()
{
	char mamba_path[255];
	sprintf(mamba_path, "/dev_hdd0/game/%s/USRDIR/sys/mamba_%X.bin", ManaGunZ_id, firmware);
	
	Delete(mamba_path);
	
	u32 size=0;
	u8 *mamba_data = (u8 *) malloc(0x20000);
	if(mamba_data==NULL){
		print_load("Error : failed to malloc");
		return FAILED;
	}
	zlib_decompress((char *) MAMBA, (char *) mamba_data, MAMBA_SIZE, (int *) &size);
	if(size==0) {
		print_load("Error : failed to decompress");
		free(mamba_data);
		return FAILED;
	}
		
	FILE* f;
	f = fopen(mamba_path, "wb");
	if(f==NULL) {
		print_load("Error : failed to create mamba file");
		free(mamba_data);
		return FAILED;
	}
	fwrite(mamba_data, size, 1, f);
	fclose(f);
	free(mamba_data);
	
	switch(syscall_mpl_payload_is_enabled())
	{
		case IS_MAMBA_LOADER_PAYLOAD:
		case IS_MAMBA_PRX_LOADER_PAYLOAD:
			if (syscall_load_mamba(mamba_path) != 0) return FAILED;
			else return SUCCESS;
		break;
		default:
			return FAILED;
		break;
	}
}

int load_mamba_loader()
{
	remove_lv2_protection();

	write_htab();

	uint64_t payload_opd = MAMBA_PRX_LOADER_INSTALL_OFFSET + MAMBA_LOADER_SIZE + 0x10;
	int i;
	for(i=0;i<(MAMBA_LOADER_SIZE/8);i++) lv2poke(MAMBA_PRX_LOADER_INSTALL_OFFSET+(i*8),  MAMBA_LOADER[i]);
	lv2poke(payload_opd, MAMBA_PRX_LOADER_INSTALL_OFFSET);
	lv2poke(SYSCALL_TABLE + (8*MAMBA_PRX_LOADER_SYSCALL_NUM), payload_opd);
	
	lv2poke(0x80000000000004E8ULL, 0);						//Disable the disc-less payload (if it was previously loaded)
	lv2poke(0x8000000000003D90ULL, 0x386000014E800020ULL); //Patch permission 4.xx, usually "fixed" by warez payload

	fix_error();

	switch(syscall_mpl_payload_is_enabled())
	{
		case IS_MAMBA_LOADER_PAYLOAD:
		case IS_PRX_LOADER_PAYLOAD:
		case IS_MAMBA_PRX_LOADER_PAYLOAD:
			return SUCCESS; //MAMBA + PRX LOADER
		break;
		default:
			return FAILED;
		break;
	}
}

u8 install_mamba()
{
	mamba = is_mamba();
	if(mamba) return YES;
	
	if(load_mamba_loader() == FAILED) {
		print_load("Error : failed to install mamba loader");
		return NO;
	}
	
	if(load_mamba() == FAILED) {
		print_load("Error : failed to install mamba");
		return NO;
	}
	
	return YES;
}

void mamba_MountISO(int EMU)
{
	uint8_t *plugin_args = malloc(0x20000);
	
	if(plugin_args==NULL) {
		print_load("Error : failed to malloc plugin_args");
		return;
	}
	
	u8 ntfs = is_ntfs(GamPath);
	u8 exfat = is_exFAT(GamPath);
	
	if(ntfs || exfat) {
		uint8_t *plugin_args = malloc(0x20000);
		uint32_t *sections = malloc(MAX_SECTIONS * sizeof(uint32_t));
		uint32_t *sections_size = malloc(MAX_SECTIONS * sizeof(uint32_t));
		rawseciso_args *p_args;  
		memset(sections, 0, MAX_SECTIONS * sizeof(uint32_t));
		memset(sections_size, 0, MAX_SECTIONS * sizeof(uint32_t));
		memset(plugin_args, 0, 0x10000);

		int parts = 0;
		
		if(ntfs) parts = ps3ntfs_file_to_sectors(GamPath, sections, sections_size, MAX_SECTIONS, 1);
		else
		if(exfat) parts = fflib_file_to_sectors(GamPath, sections, sections_size, MAX_SECTIONS, 1);
		
		if(is_splitted_iso(GamPath)==YES) {	   
			int o;
			for (o = 1; o < 32; o++) {
				struct stat s;
				sprintf(temp_buffer + 3072, "%s", GamPath);
				temp_buffer[3072 + strlen(temp_buffer + 3072) - 1] = 0;
				sprintf(temp_buffer + 2048, "%s%i", temp_buffer + 3072, o);
				if(parts >= MAX_SECTIONS) break;
				if(stat(temp_buffer + 2048, &s)!=0) break;
				
				if( ntfs ) parts += ps3ntfs_file_to_sectors(temp_buffer + 2048, sections + parts, sections_size + parts, MAX_SECTIONS - parts, 1);
				else
				if( exfat ) parts += fflib_file_to_sectors(temp_buffer + 2048, sections + parts, sections_size + parts, MAX_SECTIONS - parts, 1);
			}
		}

		if (parts>0 && parts < MAX_SECTIONS) {
			p_args = (rawseciso_args *)plugin_args;
			if( ntfs ) p_args->device = USB_MASS_STORAGE(NTFS_Test_Device(&GamPath[1]));
			else
			if( exfat ) p_args->device = USB_MASS_STORAGE(exFAT_get_idx(GamPath));
			p_args->emu_mode = EMU;
			p_args->num_sections = parts;
			p_args->num_tracks = 0;
			memcpy(plugin_args+sizeof(rawseciso_args), sections, parts*sizeof(uint32_t));
			memcpy(plugin_args+sizeof(rawseciso_args)+(parts*sizeof(uint32_t)), sections_size, parts*sizeof(uint32_t)); 
			cobra_unload_vsh_plugin(0);
			sprintf(temp_buffer + 2048, "/dev_hdd0/game/%s/USRDIR/sys/sprx_iso", ManaGunZ_id);
			if (cobra_load_vsh_plugin(0, temp_buffer + 2048, plugin_args, 0x10000) == 0) return;
		}
	} 
	else {
		sprintf((char *) plugin_args, "/dev_hdd0/game/%s/USRDIR/sys/sprx_iso", ManaGunZ_id);
		
		if(path_info((char *) plugin_args) == _NOT_EXIST) {free(plugin_args); return;}

		char *sections = malloc(64 * 0x200);
		uint32_t *sections_size = malloc(64 * sizeof(uint32_t));

		if(plugin_args && sections && sections_size) {
			
			rawseciso_args *p_args;

			memset(sections, 0, 64 * 0x200);
			memset(sections_size, 0, 64 * sizeof(uint32_t));
			memset(plugin_args, 0, 0x10000);

			int parts = 0;	
			
			if(is_splitted_iso(GamPath)==YES) {
				int o;				
				for (o = 0; o < 64; o++) {
					struct stat s;
					sprintf(temp_buffer + 3072, "%s", GamPath);
					temp_buffer[3072 + strlen(temp_buffer + 3072) - 1] = 0;
					sprintf(&sections[0x200 * o], "%s%i", temp_buffer + 3072, o);
					if(stat(&sections[0x200 * o], &s) != 0) {memset(&sections[0x200 * o], 0, 0x200); break;}
					sections_size[o] = s.st_size/2048;
					parts++;
				}
			} 
			else {
				struct stat s;
				parts = 1;
				strncpy(&sections[0], GamPath, 0x1ff);
				sections[0x1ff] = 0;
				if(stat(&sections[0], &s) != 0) goto skip_load;
				sections_size[0] = s.st_size/2048;
			}
			
			p_args = (rawseciso_args *)plugin_args;
			p_args->device = USB_MASS_STORAGE(NTFS_Test_Device(&GamPath[1]));
			p_args->emu_mode = EMU | 1024;
			p_args->num_sections = parts;
			p_args->num_tracks = 0;
			
			memcpy(plugin_args+sizeof(rawseciso_args), sections, parts * 0x200);
			memcpy(plugin_args+sizeof(rawseciso_args)+(parts* 0x200), sections_size, parts*sizeof(uint32_t));

			cobra_unload_vsh_plugin(0);

			sprintf(temp_buffer + 2048, "/dev_hdd0/game/%s/USRDIR/sys/sprx_iso", ManaGunZ_id);

			if( cobra_load_vsh_plugin(0, temp_buffer + 2048, plugin_args, 0x10000) != 0) {
				print_load("Error : failed to load plugin");
			}
			sleep(1);
			return; 
		}

		skip_load:
		
		print_load("Error : load skipped");
		
		if(plugin_args) free(plugin_args); plugin_args = NULL;
		if(sections) free(sections);
		if(sections_size) free(sections_size);
	}
	if(plugin_args) free(plugin_args); plugin_args = NULL;
	
}

void mamba_Mount()
{
	mamba = install_mamba();
	
	char temp[128];
		
	if(ext_game_data==YES) {
		int i;
		
		for(i=0; i<=device_number; i++) {
			sprintf(temp, "/%s", list_device[i]);
			if(strstr(temp, "/dev_usb")) {
				strcat(temp, "/GAMEI");
				if(path_info(temp)==_NOT_EXIST) mkdir(temp, 0777);
				{snake_map("/dev_hdd0/game", temp);}
			}
		}
	}
	
	if(iso) {
		mamba_MountISO(EMU_PS3);
		mamba_MountISO(EMU_PS3);
		
		if(mount_app_home == YES)	{
			{snake_map("/app_home", "/dev_bdvd");}
			
			if(use_ex_plug==YES) {
				if(patch_exp_plug() == SUCCESS) {
					sprintf(temp, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
					if(path_info(temp) != _NOT_EXIST)	{snake_map("/dev_flash/vsh/module/explore_plugin.sprx", temp);}
				} else  print_load("Error : cannot patch explore_plugin.sprx");
			}
		}	
	}
	else {

		int ret;
		
		if(prim_USB == YES) SetPrimaryUSB();
		
		mount_fake_BR();
		
		if(emu == BDMIRROR) {
			print_load("Patching BD-Mirror");
			ret = patch_bdmirror();
			if( ret != 0) print_load("Error %d: patch_bdmirror failed", ret);
			sleep(1);

			sprintf(temp, "%s/PS3_DISC.SFB", GamPath);
			{snake_map("/dev_bdvd/PS3_DISC.SFB", temp);}
		} else
		if(emu == BDEMU) {
			char *libfs_path = get_libfs_path();
			if(path_info(libfs_path) == _FILE)	{snake_map("/dev_flash/sys/external/libfs.sprx", libfs_path);}
			if(libfs_path) free(libfs_path);
			
			{snake_map("/dev_bdvd", GamPath);}
			
		} else 
		if(emu == NONE) {
			{snake_map("/dev_bdvd", GamPath);}
		}
		
		if( bt_audio ) {
			char *libaudio_path = get_libaudio_path();
			if(libaudio_path) {
				{snake_map("/dev_flash/sys/external/libaudio.sprx", libaudio_path);}
				FREE(libaudio_path);
			}
		}
		
		
		if(mount_app_home == YES)	{
			if(emu == BDMIRROR) {
				{snake_map("/app_home", "/dev_bdvd");}
			} else {
				{snake_map("/app_home", GamPath);}
			}
			
			if(use_ex_plug==YES) {
				if(patch_exp_plug() == SUCCESS) {
					sprintf(temp, "/dev_hdd0/game/%s/USRDIR/sys/patched_explore_plugin_%X.sprx", ManaGunZ_id, firmware);
					if((path_info(temp) == _FILE) )	{snake_map("/dev_flash/vsh/module/explore_plugin.sprx", temp);}
				} else  print_load("Error : cannot patch explore_plugin.sprx");
			}
		}
	}
}

void MountISO(char *path, u8 EMU)
{
	if(PEEKnPOKE) {
		if(!cobra && !mamba) {
			mamba = install_mamba();
			if(!mamba) {
				print_load("Error : 0x8888888");
				return;
			}
		}
	}
	
	cobra_MountISO(path, EMU);
	cobra_MountISO(path, EMU);
}

u8 MountGame(char *GamePath)
{
	u8 platform = get_platform(GamePath);
	
	if(can_be_mounted(platform)==NO || is_66600(GamePath)) {
		print_load("Error : Cannot be mounted");
		return FAILED;
	}
	
	memset(GamPath, 0, 512);
	memset(GamID, 0, 20);
	
	strcpy(GamPath, GamePath);
	if( 0 <= position ) {
		if(strcmp(list_game_path[position], GamePath) == 0 ) {
			strcpy(GamID, list_game_ID[position]);
		}
	}
	
	iso = is_iso(GamePath);
	
	if(platform == ISO_PS3 || platform == JB_PS3) {
		
		if(GamID[0]==0) Get_ID(GamPath, platform, GamID);
		if(GamID[0]==0) strcpy(GamID, "TEST01234\0");
		
		if(payload == NO_PAYLOAD) {
			print_load("Error : can't be mounted, no payload available");
			return FAILED;
		}
		
		if(PEEKnPOKE) {
			if(payload==IRIS) iris_Mount(); else
			if(payload==MM) mm_Mount(); else
			if(cobra) cobra_Mount(); else 
			mamba_Mount();
			if(change_IDPS) poke_IDPS();	
			if(clean_syscall) remove_cfw_syscalls();
		} else {
			if(cobra) cobra_Mount(); else 
			if(mamba) mamba_Mount();
		}
		
		if(direct_boot) {
			MGZ_exit();
			if(mount_app_home == NO) {
				sysProcessExitSpawn2("/dev_bdvd/PS3_GAME/USRDIR/EBOOT.BIN", NULL, NULL, NULL, 0, 1001, SYS_PROCESS_SPAWN_STACK_SIZE_1M);
			} else {
				sysProcessExitSpawn2("/app_home/PS3_GAME/USRDIR/EBOOT.BIN", NULL, NULL, NULL, 0, 1001, SYS_PROCESS_SPAWN_STACK_SIZE_1M);
			}
		}
	} else 
	if(platform == ISO_PS2 || platform == ISO_PS1 || platform == ISO_PSP) {
		int emul;
		
		if(platform == ISO_PS2) emul = EMU_PS2_DVD;
		if(platform == ISO_PS1) emul = EMU_PSX;
		if(platform == ISO_PSP) emul = EMU_PSP;
		
		if(emul == EMU_PS2_DVD) {
			patch_PS2();
			CONFIG_check(GamePath);
		}
		
		MountISO(GamePath, emul);
	} else {
		print_load("Error : 0x11223344");
		return FAILED;
	}
	
	// todo : check if game mounted...
	
	return SUCCESS;
}

//*******************************************************
// Make PKG
//*******************************************************

#define ntohll(x) (((uint64_t) ntohl (x) ) | (uint64_t) ntohl ((x) ) )
#define htonll(x) (((uint64_t) htonl (x) ) | (uint64_t) htonl ((x) ) )
#define conv_ntohl(x) { x = ntohl(x); }
#define conv_ntohll(x) { x = ntohll(x); }
#define conv_htonl(x) { x = htonl(x); }
#define conv_htonll(x) { x = htonll(x); }

#define HASH_LEN 16
#define BUF_SIZE 4096

#define PKG_HEADER__MAGIC 						0x7f504b47
#define PKG_HEADER__PKG_REVISION_RETAIL 		0x8000
#define PKG_HEADER__PKG_REVISION_DEBUG  		0x0000
#define PKG_HEADER__PKG_TYPE_PS3 				0x0001
#define PKG_HEADER__PKG_TYPE_PSP 				0x0002
#define PKG_HEADER__PKG_INFO_OFFSET 			sizeof(pkg_header)
#define PKG_HEADER__PKG_INFO_COUNT				0x05
#define PKG_HEADER__PKG_INFO_SIZE 				sizeof(pkg_info)

#define PKG_INFO__DRM_TYPE_NETWORK  				1
#define PKG_INFO__DRM_TYPE_LOCAL  					2
#define PKG_INFO__DRM_TYPE_FREE  					3
#define PKG_INFO__DRM_TYPE_FREE2  					0xD
#define PKG_INFO__DRM_TYPE_PSP  					4

#define PKG_INFO__CONTENT_TYPE_GAMEDATA  			4				// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_GAME_EXEC 			5				// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_PS1EMU				6				// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_PSP					7				// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_THEME				9				// /dev_hdd0/theme
#define PKG_INFO__CONTENT_TYPE_WIDGET				0xA				// /dev_hdd0/widget
#define PKG_INFO__CONTENT_TYPE_LICENCE				0xB				// /dev_hdd0/home/<current user>/exdata	
#define PKG_INFO__CONTENT_TYPE_VSH_MODULE			0xC				// /dev_hdd0/vsh/modules/
#define PKG_INFO__CONTENT_TYPE_PSN_AVATAR			0xE				// /dev_hdd0/home/<current user>/psn_avatar
#define PKG_INFO__CONTENT_TYPE_PSPGO				0xF				// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_NEOGEO				0x10			// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_VMC					0x11			// /dev_hdd0/tmp/vmc/
#define PKG_INFO__CONTENT_TYPE_PS2_CLASSIC			0x12			// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_PSP_REMASTERED		0x14			// /dev_hdd0/game/
#define PKG_INFO__CONTENT_TYPE_PSVITA_PSPGD			0x15
#define PKG_INFO__CONTENT_TYPE_PSVITA_PSPAC			0x16
#define PKG_INFO__CONTENT_TYPE_PSVITA_PSPLA			0x17
#define PKG_INFO__CONTENT_TYPE_WT					0x19			// /dev_hdd0/game/

#define PKG_FILE_ENTRY_OVERWRITE 					0x80000000
#define PKG_FILE_ENTRY_NPDRM 						0x0001
#define PKG_FILE_ENTRY_NPDRMEDAT 					0x0002 
#define PKG_FILE_ENTRY_REGULAR 						0x0003
#define PKG_FILE_ENTRY_FOLDER 						0x0004
#define PKG_FILE_ENTRY_SDAT 						0x0009

#define unpack32(x) ((uint32_t) ((uint32_t)*(x) << 24 | \
						(uint32_t)*(x+1) << 16 | 		\
						(uint32_t)*(x+2) << 8 | 		\
						(uint32_t)*(x+3) << 0))

#define unpack64(x) ((uint64_t)unpack32(x) << 32 | (uint64_t)unpack32(x+4))

#define pack32(x, p) 									\
					{									\
						*(x) = (uint8_t)(p >> 24);		\
						*((x)+1) = (uint8_t)(p >> 16);	\
						*((x)+2) = (uint8_t)(p >> 8);	\
						*((x)+3) = (uint8_t)(p >> 0);	\
					}

#define pack64(x, p) { pack32((x + 4), p); pack32((x), p >> 32); }


typedef struct 
{
	uint32_t magic;
	uint32_t pkg_rev_type;
	uint32_t pkg_info_offset;
	uint32_t pkg_info_count;
	uint32_t pkg_info_size;
	uint32_t item_count;
	uint64_t pkg_size;
	uint64_t data_offset;
	uint64_t data_size;
	char content_id[48];
	uint8_t qa_digest[16];
	uint8_t KLicensee[16];
} pkg_header;


#define PKG_HEADER_FROM_BE(x)								   \
  (x).magic = FROM_BE (32, (x).magic);						  \
	 (x).pkg_rev_type = FROM_BE (32, (x).pkg_rev_type);				 \
	 (x).pkg_info_offset = FROM_BE (32, (x).pkg_info_offset);   \
	 (x).pkg_info_count = FROM_BE (32, (x).pkg_info_count);				 \
	 (x).pkg_info_size = FROM_BE (32, (x).pkg_info_size);		   \
	 (x).item_count = FROM_BE (32, (x).item_count);			 \
	 (x).pkg_size = FROM_BE (64, (x).pkg_size);			 \
	 (x).data_offset = FROM_BE (64, (x).data_offset);		   \
	 (x).data_size = FROM_BE (64, (x).data_size);
#define PKG_HEADER_TO_BE(x) PKG_HEADER_FROM_BE (x)

typedef struct 
{
	uint32_t drm_type_id; 
	uint32_t drm_type_size;
	uint32_t drm_type; 
	uint32_t content_type_id;
	uint32_t content_type_size;
	uint32_t content_type; 
	uint32_t pkg_type_id;
	uint32_t pkg_type_size;
	uint32_t pkg_type;
	uint32_t data_size_id;
	uint32_t data_size_size;
	uint32_t data_size[2]; 
	uint32_t vers_id;
	uint32_t vers_size;
	uint32_t vers;
} pkg_info;

typedef struct
{
	uint32_t name_offset;
	uint32_t name_size;
	uint64_t file_offset;
	uint64_t file_size;
	uint32_t type;
	uint32_t pad;
} pkg_file_entry;

#define PKG_FILE_ENTRY_FROM_BE(x)							 \
	(x).name_offset = FROM_BE (32, (x).name_offset);		  \
	(x).name_size = FROM_BE (32, (x).name_size);			  \
	(x).file_offset = FROM_BE (64, (x).file_offset);		  \
	(x).file_size = FROM_BE (64, (x).file_size);			  \
	(x).type = FROM_BE (32, (x).type);						  \
	(x).pad = FROM_BE (32, (x).pad); 
#define PKG_FILE_ENTRY_TO_BE(x) PKG_FILE_ENTRY_FROM_BE (x)


typedef struct
{
	pkg_file_entry fe;
	char *name;
	char *path;
} file_table_tr;

static const uint8_t PKG_AES_KEY[16] = 
{
	0x2e, 0x7b, 0x71, 0xd7,
	0xc9, 0xc9, 0xa1, 0x4e,
	0xa3, 0x22, 0x1f, 0x18,
	0x88, 0x28, 0xb8, 0xf8
};

static void keyToContext(uint8_t *key, uint8_t *largekey)
{
	int i;
	for(i=0; i<0x8;i++) largekey[i]=key[i];
	for(i=0; i<0x8;i++) largekey[i+0x8]=key[i];
	for(i=0; i<0x10;i++) largekey[i+0x10]=key[i+0x8];
	for(i=0; i<0x10;i++) largekey[i+0x18]=key[i+0x8];
	for(i=0; i<0x20;i++) largekey[i+0x20]=0;
}

static void manipulate(uint8_t *key) 
{
	uint64_t temp = (uint64_t) key[0x38] << 56 | 
					(uint64_t) key[0x39ULL] << 48 | 
					(uint64_t) key[0x3a] << 40 | 
					(uint64_t) key[0x3b] << 32 | 
					(uint64_t) key[0x3c] << 24 | 
					(uint64_t) key[0x3d] << 16 | 
					(uint64_t) key[0x3e] <<  8 | 
					(uint64_t) key[0x3f];
	temp++;
	key[0x38] = (temp >> 56) & 0xff;
	key[0x39] = (temp >> 48) & 0xff;
	key[0x3a] = (temp >> 40) & 0xff;
	key[0x3b] = (temp >> 32) & 0xff;
	key[0x3c] = (temp >> 24) & 0xff;
	key[0x3d] = (temp >> 16) & 0xff;
	key[0x3e] = (temp >>  8) & 0xff;
	key[0x3f] = (temp >>  0) & 0xff;
}

static void crypt(uint8_t *key, uint8_t *inbuff, uint64_t length, uint8_t *out)
{
	uint64_t offset = 0;
	uint64_t bytes_to_dump;
	uint64_t remaining=length;
	int i;
	
	while (remaining > 0) {
		bytes_to_dump = remaining;
		if (remaining > 0x10) bytes_to_dump = 0x10;
		uint8_t outhash[bytes_to_dump];
		sha1(key, sizeof(uint8_t)*0x40, outhash);
		for(i = 0; i < bytes_to_dump; i++) {
			out[offset] = outhash[i] ^ inbuff[offset];
			offset++;
		}
		manipulate(key);
		remaining -= bytes_to_dump;
	}
}

//*******
//PACK 
//*******

static u32 pkg_pack_traverse(const char *global_path, file_table_tr **ftr, u32 item_count,  const char *local_path)
{
	file_table_tr *cur = NULL;
	struct stat s;
	char full_path_item[255];
	char full_path[255];
	char local_path_item[255];
	char *temp;
	char name[512];

	DIR *d;
	struct dirent *dir;
	
	strcpy(full_path, global_path);
	strcat(full_path, "/");
	strcat(full_path, local_path);
	d = opendir(full_path);
	if(d==NULL) return 0;
	while ((dir = readdir(d))) {
		if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
		strcpy(full_path_item, global_path);
		strcat(full_path_item, "/");
		strcat(full_path_item, local_path);
		strcat(full_path_item, "/");
		strcat(full_path_item, dir->d_name);
	
		if(stat(full_path_item, &s) != 0) continue;
		
		strcpy(local_path_item, local_path);
		strcat(local_path_item, "/");
		strcat(local_path_item, dir->d_name);
		
		if(strstr(local_path, "/") !=NULL) {
			temp = strchr(local_path,'/');
			temp = &temp[1];
			strcpy(name, temp);
			strcat(name, "/");
			strcat(name, dir->d_name);
		} else strcpy(name, dir->d_name);
		
		(*ftr) = realloc((*ftr), ++item_count*sizeof(file_table_tr));
		cur = (*ftr) + (item_count - 1);
		cur->fe.name_size = htonl(strlen(name));
		cur->name = strdup(name);
		cur->path = strdup(full_path_item);
		cur->fe.type = 0;
		cur->fe.type |= PKG_FILE_ENTRY_OVERWRITE;
		
		if(dir->d_type & DT_DIR) {
			cur->fe.file_size = 0;
			cur->fe.type |= PKG_FILE_ENTRY_FOLDER;
			conv_htonl(cur->fe.type);
			
			item_count = pkg_pack_traverse(global_path, ftr, item_count, local_path_item);
		} else {
			cur->fe.file_size = htonll(s.st_size);
			
			if (!strcasecmp(dir->d_name, "EBOOT.BIN"))	{
				cur->fe.type |= PKG_FILE_ENTRY_NPDRM;
			} 
			else if (!strcasecmp(dir->d_name + strlen(dir->d_name) - 5, ".sdat")) {
				cur->fe.type |= PKG_FILE_ENTRY_SDAT;
			}
			else if (!strcasecmp(dir->d_name + strlen(dir->d_name) - 5, ".edat")) {
				cur->fe.type |= PKG_FILE_ENTRY_NPDRMEDAT;
			}
			else {
				cur->fe.type |= PKG_FILE_ENTRY_REGULAR;
			}
			conv_htonl(cur->fe.type);
			
		}
	}
	closedir(d);
	return item_count;
}

static void *pkg_pack_create_filetable(file_table_tr *tr, u32 item_count, char **n_table, uint32_t *n_table_len)
{
	pkg_file_entry *table;
	int i;
	uint64_t tmp;

	tmp = sizeof(pkg_file_entry)*item_count;
	table = malloc(tmp);
	
	print_load("Building filetable...");
	
	for (i = 0; i < item_count; i++)
	{
		memcpy((table+i), &((tr+i)->fe), sizeof(pkg_file_entry));
		(table+i)->name_offset = htonl(tmp);
		tmp += (ntohl((table+i)->name_size) + 0x0f) & ~0x0f;
		(table+i)->pad = 0;
	}
	
	(*n_table_len) = tmp - sizeof(pkg_file_entry)*item_count;
	(*n_table) = malloc(*n_table_len);
	memset(*n_table, 0, *n_table_len);
	
	for (i = 0; i < item_count; i++)
	{
		(table+i)->file_offset = htonll(tmp);
		tmp += (ntohll((table+i)->file_size) + 0x0f) & ~0x0f;
		
		memcpy((*n_table)+((ntohl((table+i)->name_offset) - 
						 sizeof(*table)*item_count)),
			   (tr+i)->name, ntohl((table+i)->name_size));
		
		free((tr+i)->name);
		
	}
	
	
	return table;
}

static int pkg_pack_data(file_table_tr *ftr, pkg_file_entry *table,  u32 item_count, sha1_context *ctx, FILE* out)
{
	int i;
	FILE* f;
	uint64_t tmp;
	uint8_t buf[BUF_SIZE];
	
	sha1_starts(ctx);
	
	print_head("Packing data...");
	
	u64 total_size=0;
	for (i=0; i<item_count; i++) {
		total_size+=ntohll((table+i)->file_size);
	}
	
	task_Init(total_size);
	for (i = 0; i < item_count; i++)
	{
		if(cancel) {
			for (; i < item_count; i++)	FREE((ftr+i)->path);
			return FAILED;
		}
		
		if (ntohl((ftr+i)->fe.type) & PKG_FILE_ENTRY_FOLDER) continue;
		
		f = fopen((ftr+i)->path, "rb");
		if (f == NULL) {
			for (; i < item_count; i++)	FREE((ftr+i)->path);	
			return FAILED;
		}
		
		print_load((ftr+i)->path);
		
		u64 read=0;
		
		task_Init(ntohll((table+i)->file_size));
		while ((tmp = fread(buf, 1, BUF_SIZE, f)) > 0) {
		
			read += tmp;
			task_Update(tmp);
			
			if(cancel) {
				for (; i < item_count; i++) FREE((ftr+i)->path);	
				fclose(f);
				return FAILED;
			}
			
			sha1_update(ctx, buf, tmp);
			fwrite(buf, 1, tmp, out);
		}
		task_End();
		
		tmp = (ntohll((table+i)->file_size) + 0x0f) & ~0x0f;
		memset(buf, 0, sizeof(buf));
		fwrite(buf, 1, tmp - ntohll((table+i)->file_size), out);
		
		fclose(f);
		
		FREE((ftr+i)->path);
	}
	task_End();
	
	return SUCCESS;
}

#define PKG_CRYPT_BUFFER_SIZE 0x10000

u8 pkg_crypt(u8 *key, FILE *dec, FILE *enc, u64 size)
{
	print_head("Encrypting and writing data...");
	
	u8 *buffer_dec = NULL;
	u8 *buffer_enc = NULL;
	u8 ret = FAILED;
	
	buffer_dec = (u8 *) malloc(PKG_CRYPT_BUFFER_SIZE);
	if( buffer_dec == NULL) {
		print_load("Error: failed to malloc buffer_dec pkg_crypt");
		goto error;
	}
	buffer_enc = (u8 *) malloc(PKG_CRYPT_BUFFER_SIZE);
	if( buffer_enc == NULL) {
		print_load("Error: failed to malloc buffer_enc pkg_crypt");
		goto error;
	}
	
	fseek(dec, 0, SEEK_SET);
	
	u64 done = 0;
	u64 data_len;
	task_Init(size);
	while(done < size)
	{
		task_Update2(done);
		
		if( done + PKG_CRYPT_BUFFER_SIZE < size) {
			data_len = PKG_CRYPT_BUFFER_SIZE;
		} else {
			data_len = size - done;
		}
		
		if(cancel) goto error;
		
		fread(buffer_enc, data_len, 1, dec);
		
		if(cancel) goto error;
		
		crypt(key, buffer_dec, data_len, buffer_enc);
		
		if(cancel) goto error;
		
		fwrite(buffer_dec, data_len, 1, enc);
		
		if(cancel) goto error;
		
		done += data_len;
	}
	task_End();
	
	ret=SUCCESS;
	
error:
	
	
	FREE(buffer_dec);
	FREE(buffer_enc);
	
	return ret;
}

u8 pkg_pack(char *fname, const char *content_id, const char *path, const char *dir)
{
	pkg_header header;
	pkg_info info;
	file_table_tr *ftr = NULL;
	pkg_file_entry *table = NULL;
	char *n_table = NULL;
	uint32_t n_table_len;
	u32 item_count;
	sha1_context ctx;
	unsigned char tmpdigest[32];
	uint64_t dec_size;
	FILE* dec, *out;
	char *dec_fname;
	int i;
	
	if(strlen(content_id) > sizeof(header.content_id)) return FAILED;
	
	out = fopen(fname, "wb+");
	if(out == NULL) return FAILED;
	
	item_count = pkg_pack_traverse(path, &ftr, 0, dir);
	if (item_count <= 0) return FAILED;
	
	table = pkg_pack_create_filetable(ftr, item_count, &n_table, &n_table_len);
	
	dec_fname = malloc(strlen(fname)+4);
	memset(dec_fname, 0, strlen(fname)+4);
	sprintf(dec_fname, "%s.dec", fname);
	
	dec = fopen(dec_fname, "wb+");
	if(dec == NULL) {
		free(ftr);
		free(n_table);
		return NOK;
	}
	
	fwrite(table, 1, item_count*sizeof(pkg_file_entry), dec);
	fwrite(n_table, 1, n_table_len, dec);
	
	if (pkg_pack_data(ftr, table, item_count, &ctx, dec)==FAILED) {
		free(ftr);
		free(table);
		free(n_table);
		Delete(dec_fname);
		return FAILED;
	}
	
	fseek(dec, 0, SEEK_END);	
	dec_size = ftell(dec);
	fseek(dec, 0, SEEK_SET);
	
	print_head("Making PKG...");
	
	header.magic = htonl(PKG_HEADER__MAGIC);
	header.pkg_rev_type = htonl((PKG_HEADER__PKG_REVISION_DEBUG << 16) | PKG_HEADER__PKG_TYPE_PS3);
	header.pkg_info_offset = htonl(PKG_HEADER__PKG_INFO_OFFSET + 0x40); //
	header.pkg_info_count = htonl(PKG_HEADER__PKG_INFO_COUNT);
	header.pkg_info_size = htonl(PKG_HEADER__PKG_INFO_SIZE + 0x40);
	header.item_count = htonl(item_count);
	header.data_offset = htonll((uint64_t)(PKG_HEADER__PKG_INFO_OFFSET + 0x40 + PKG_HEADER__PKG_INFO_SIZE + 0x40 ));
	header.data_size = htonll(dec_size);
	header.pkg_size = htonll(dec_size + PKG_HEADER__PKG_INFO_OFFSET + PKG_HEADER__PKG_INFO_SIZE + 0x40 + 0x40 + 0x60);  // +0x60 for sha_crap
	memset(header.content_id, 0, sizeof(header.content_id));
	memset(header.qa_digest, 0, sizeof(header.qa_digest));
	memset(header.KLicensee, 0, sizeof(header.KLicensee));
	
	uint64_t fileDescLength = item_count*sizeof(pkg_file_entry) + n_table_len ;
	uint8_t section[0x80]={0};
	u8 *fileDesc = (u8 *) malloc(fileDescLength);
	if(fileDesc==NULL) {
		// todo
		// goto error;
	}
	fread(fileDesc, fileDescLength, sizeof(uint8_t), dec);
	fseek(dec, 0, SEEK_SET);
	
	memcpy(section, &header, sizeof(section));
	sha1_update(&ctx, section, 0x80);
	sha1_update(&ctx, fileDesc, fileDescLength);
	sha1_finish(&ctx, tmpdigest);
	
	memcpy(&header.qa_digest, tmpdigest, sizeof(header.qa_digest));
	memcpy(header.content_id, content_id, strlen(content_id));
	FREE(fileDesc);
	
	info.drm_type_id = htonl(1);
	info.drm_type_size = htonl(sizeof(info.drm_type));
	info.drm_type = htonl(PKG_INFO__DRM_TYPE_FREE);
	info.content_type_id = htonl(2);
	info.content_type_size = htonl(sizeof(info.content_type));
	info.content_type = htonl(PKG_INFO__CONTENT_TYPE_GAME_EXEC);
	info.pkg_type_id = htonl(3);
	info.pkg_type_size = htonl(sizeof(info.pkg_type));
	info.pkg_type = htonl(0xE); //??
	info.data_size_id = htonl(4);
	info.data_size_size = htonl(sizeof(info.data_size));
	info.data_size[0] = htonll(dec_size<<32);
	info.data_size[1] = htonll(dec_size);
	info.vers_id = htonl(5);
	info.vers_size = htonl(sizeof(info.vers));
	info.vers = htonl(0x10610000);
	
	uint8_t context[0x40]; uint8_t licensee[0x10];
	memset(context, 0, sizeof(uint8_t)*0x40);
	keyToContext(header.qa_digest, context);
	for(i=0x38; i<0x40;i++) {context[i] = 0xFF;}
	crypt(context, header.KLicensee, 0x10, licensee);
	memcpy(header.KLicensee, licensee, sizeof(uint8_t)*0x10);
	fwrite(&header, 1, sizeof(header), out);
	memcpy(section, &header, sizeof(section));
	sha1(section, sizeof(uint8_t)*0x80, tmpdigest);
	uint8_t headerSHA[0x10];
	memcpy(headerSHA, tmpdigest+0x03, sizeof(uint8_t)*0x10);
	fwrite(headerSHA, 0x10, sizeof(uint8_t), out);
	uint8_t infoDataHeader[0x40]; 
	uint8_t infoSHA[0x10];
	memcpy(infoDataHeader, &info, sizeof(infoDataHeader));
	sha1(infoDataHeader, sizeof(uint8_t)*0x40, tmpdigest);
	memcpy(infoSHA, tmpdigest+0x03, sizeof(uint8_t)*0x10);
	uint8_t infoSHAPad[0x30];
	memset(infoSHAPad, 0, sizeof(infoSHAPad));
	uint8_t infoSHAPadEnc[0x30];
	uint8_t infoSHAPadEnc2[0x30];
	keyToContext(infoSHA, context);
	crypt(context, infoSHAPad, 0x30, infoSHAPadEnc);
	keyToContext(headerSHA, context);
	crypt(context, infoSHAPadEnc, 0x30, infoSHAPadEnc2);
	fwrite(infoSHAPadEnc2, 0x30, sizeof(uint8_t), out);
	fwrite(&info, 1, sizeof(info), out);
	fwrite(infoSHA, 0x10, sizeof(uint8_t), out);
	fwrite(infoSHAPadEnc, 0x30, sizeof(uint8_t), out);
	keyToContext(header.qa_digest, context);
	
	pkg_crypt(context, dec, out, dec_size); 
	
	/*/
	uint64_t empty[12];
	memset(empty, 0 ,sizeof(empty));
	fwrite(empty, 1, sizeof(empty), out);
	
	uint64_t size =  ftell(out);
	uint8_t *sha_crap = (uint8_t *) malloc(sizeof(uint8_t)*size);																							 
	temp=fopen(fname, "rb");
	fread(sha_crap, size , sizeof(uint8_t), temp);
	fclose(temp);
	memset(tmpdigest, 0, sizeof(tmpdigest));
	sha1(sha_crap, sizeof(uint8_t)*size, tmpdigest);
	fwrite(tmpdigest, 1, sizeof(tmpdigest), out);
	/*/

	FCLOSE(dec);
	FCLOSE(out);
	unlink(dec_fname);

	FREE(ftr);
	FREE(table);
	FREE(n_table);
	FREE(dec_fname);
	
	if(cancel) {
		Delete(fname);
		return FAILED;
	}
	
	return SUCCESS;
}

void make_pkg(const char *dir_path)
{
	FILE* f;
	
	char content_id[37];
	char dir_name[255];
	char src[255];
	char dst[255];
	char file[255];
	
	strcpy(file, dir_path);
	strcat(file, "/USRDIR/EBOOT.BIN");

	f = fopen(file, "rb");
	if(f==NULL) {
		char title_id[10];
		strcpy(file, dir_path);
		strcat(file, "/PARAM.SFO");
		if( path_info(file) == _NOT_EXIST ) {
			print_load("Error : PARAM.SFO not found, cannot get Content ID");
			return;
		}
		if(GetParamSFO("TITLE_ID", title_id, file) == FAILED ) {
			print_load("Error : Cannot get Content ID");
			return;
		}
		sprintf(content_id, "EP0001-%s_00-0000000000000000", title_id);
	} else {
		char check_npd[3];
		fseek(f, 0x420, SEEK_SET);
		fread(check_npd, 3, 1, f);
		if(strstr(check_npd, "NPD") == NULL) {
			print_load("Error : EBOOT is not NPDRM %s", check_npd);
			return;
		}
		fseek(f, 0x430, SEEK_SET);
		fread(&content_id, sizeof(char), 37, f);
		fclose(f);
	}
	
	strcpy(dir_name, &strrchr(dir_path, '/')[1]);
	
	strcpy(src, dir_path);
	src[strrchr(src, '/') - src] = 0;
	
	sprintf(dst, "%s/%s.pkg", src, content_id);
	
	pkg_pack(dst, content_id, src, dir_name);
}

//*******************************************************
//Extract PKG
//*******************************************************

static int pkg_debug_decrypt (PagedFile* f, PagedFileCryptOperation operation, u8 *ptr, u32 len, void *user_data)
{
  u64 *crypt_offset = user_data;
  u8 key[0x40];
  u8 bfr[0x14];
  u64 i;
  s64 seek;

  if (operation == PAGED_FILE_CRYPT_DECRYPT ||
	  operation == PAGED_FILE_CRYPT_ENCRYPT) {
	memset(key, 0, 0x40);
	memcpy(key, f->key, 8);
	memcpy(key + 0x08, f->key, 8);
	memcpy(key + 0x10, f->key + 8, 8);
	memcpy(key + 0x18, f->key + 8, 8);
	seek = (signed) ((f->page_pos + f->pos) - *crypt_offset) / 0x10;
	if (seek > 0)
	  wbe64(key + 0x38, be64(key + 0x38) + seek);

	for (i = 0; i < len; i++) {
	  if (i % 16 == 0) {
		sha1(key, 0x40, bfr);
		wbe64(key + 0x38, be64(key + 0x38) + 1);
	  }
	  ptr[i] ^= bfr[i & 0xf];
	}
  }

  return TRUE;
}

u8 pkg_open(const char *filename, PagedFile* in, pkg_header *header, pkg_file_entry **files)
{
	u32 i;

	if (paged_file_open (in, filename, TRUE) == FAILED) {
		print_load("Error : Unable to open package file");
		return FAILED;
	}

	paged_file_read (in, header, sizeof(pkg_header));
	PKG_HEADER_FROM_BE (*header);

	if (header->magic != 0x7f504b47) {
		print_load("Error : Magic number is not correct");
		 goto error;
	}

	paged_file_seek (in, header->data_offset);
	if (header->pkg_rev_type == 0x80000001) {
		paged_file_crypt (in, (u8 *) PKG_AES_KEY, header->KLicensee,PAGED_FILE_CRYPT_AES_128_CTR, NULL, NULL);
	} else {
		paged_file_crypt (in, header->qa_digest, header->KLicensee,
		PAGED_FILE_CRYPT_CUSTOM, pkg_debug_decrypt, &header->data_offset);
	}

	*files = malloc (header->item_count * sizeof(pkg_file_entry));
	paged_file_read (in, *files, header->item_count * sizeof(pkg_file_entry));

	for (i = 0; i < header->item_count; i++) {
		PKG_FILE_ENTRY_FROM_BE((*files)[i]);
	}

	return SUCCESS;

error:
	if (*files)
	free (*files);
	*files = NULL;

	paged_file_close (in);

	return FAILED;
}

u8 pkg_list(const char *filename)
{
	FILE* txt;
	PagedFile in = {0};
	pkg_header header;
	pkg_info info;
	pkg_file_entry *files = NULL;
	char str[255];
	
	strcpy(str, "/dev_hdd0/tmp");
	mkdir(str, 0777);
	
	txt = fopen("/dev_hdd0/tmp/pkg_list.txt", "wb");
	if(txt == NULL) {
		print_load("Error : cannot create pkg_list.txt");
		return FAILED;
	}
	
	if (pkg_open(filename, &in, &header, &files) == FAILED) {
		print_load("Error : pkg_open failed");
		fclose(txt);
		return FAILED;
	}
	
	sprintf(str, "PKG file : %s\n\n", &strrchr(filename, '/')[1]);
	fputs(str, txt);
	
	if(((header.pkg_rev_type >> 16) & (0xffff)) == PKG_HEADER__PKG_REVISION_RETAIL) {
		strcpy(str, "Revision : RETAIL (0x8000)\n");
	} else
	if(((header.pkg_rev_type >> 16) & (0xffff)) == PKG_HEADER__PKG_REVISION_DEBUG) {
		strcpy(str, "Revision : DEBUG (0x0000)\n");
	} else  {
		sprintf(str, "Revision : 0x%X\n", ((header.pkg_rev_type >> 16) & (0xffff)));
	}
	
	fputs(str, txt);
	
	if(((header.pkg_rev_type) & (0xffff)) == PKG_HEADER__PKG_TYPE_PS3) {
		strcpy(str, "Type : PS3 (0x0001)\n");
	} else
	if(((header.pkg_rev_type) & (0xffff)) == PKG_HEADER__PKG_TYPE_PSP) {
		strcpy(str, "Type : PSP (0x0002)\n");
	} else {
		sprintf(str, "Type : 0x%X\n", ((header.pkg_rev_type) & (0xffff)) );
	}
	fputs(str, txt);
	
	sprintf(str, "Item count : %d\n",	  header.item_count);
	fputs(str, txt);
	sprintf(str, "PKG size : %d\n",	(int) header.pkg_size);
	fputs(str, txt);
	sprintf(str, "Content ID : %s\n",	  header.content_id);
	fputs(str, txt);
	
	//fseek(in.fd, header.pkg_info_offset, SEEK_SET);
	//fread(&info, 1, sizeof(pkg_info), in.fd);
	// |-> broked by FAKE_ stdio functions...
	FILE *f;
	f = fopen((char *) filename, "rb");
	if( f!= NULL ) {
		fseek(f, header.pkg_info_offset, SEEK_SET);
		fread(&info, 1, sizeof(pkg_info), f);
		fclose(f);
	}
	
	switch (info.drm_type)
	{
		case PKG_INFO__DRM_TYPE_NETWORK:
			sprintf(str, "DRM : NETWORK (0x%X)\n", info.drm_type);
			break;
		case PKG_INFO__DRM_TYPE_LOCAL:
			sprintf(str, "DRM : LOCAL (0x%X)\n", info.drm_type);
			break;
		case PKG_INFO__DRM_TYPE_FREE:
			sprintf(str, "DRM : FREE (0x%X)\n", info.drm_type);
			break;
		case PKG_INFO__DRM_TYPE_FREE2:
			sprintf(str, "DRM : FREE2 (0x%X)\n", info.drm_type);
			break;
		case PKG_INFO__DRM_TYPE_PSP:
			sprintf(str, "DRM : PSP (0x%X)\n", info.drm_type);
			break; 
		default:
			sprintf(str, "DRM : UNKNOWN (0x%X)\n", info.drm_type);
			break;
	}
	fputs(str, txt);
	
	switch(info.content_type)
	{
		case PKG_INFO__CONTENT_TYPE_GAMEDATA:
			sprintf(str, "CONTENT : GAMEDATA * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_GAME_EXEC:
			sprintf(str, "CONTENT : GAME EXEC * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PS1EMU:
			sprintf(str, "CONTENT : PS1EMU * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSP:
			sprintf(str, "CONTENT : PSP * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_THEME:
			sprintf(str, "CONTENT : THEME * /dev_hdd0/theme/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_WIDGET:
			sprintf(str, "CONTENT : WIDGET * /dev_hdd0/widget/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_LICENCE:
			sprintf(str, "CONTENT : LICENCE * /dev_hdd0/home/<current user>/exdata * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_VSH_MODULE:
			sprintf(str, "CONTENT : VSH_MODULE * /dev_hdd0/modules/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSN_AVATAR:
			sprintf(str, "CONTENT : PSN_AVATAR * /dev_hdd0/home/<current user>/psn_avatar * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_NEOGEO:
			sprintf(str, "CONTENT : NEOGEO * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSPGO:
			sprintf(str, "CONTENT : PSPGO * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_VMC:
			sprintf(str, "CONTENT : VMC * /dev_hdd0/tmp/vmc/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PS2_CLASSIC:
			sprintf(str, "CONTENT : PS2_CLASSIC * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSP_REMASTERED:
			sprintf(str, "CONTENT : PSP_REMASTERED * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSVITA_PSPGD:
			sprintf(str, "CONTENT : PSVITA_PSPGD (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSVITA_PSPAC:
			sprintf(str, "CONTENT : PSVITA_PSPAC (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_PSVITA_PSPLA:
			sprintf(str, "CONTENT : PSVITA_PSPLA (0x%X)\n\n", info.drm_type);
			break;
		case PKG_INFO__CONTENT_TYPE_WT:
			sprintf(str, "CONTENT : WT * /dev_hdd0/game/ * (0x%X)\n\n", info.drm_type);
		default:
			break;
			sprintf(str, "CONTENT : UNKNOWN (0x%X)\n\n", info.drm_type);
	}
	
	fputs(str, txt);
	
	strcpy(str, "*** Item list ***\n");
	
	char *pkg_file_path = NULL;
	u32 i;
	for (i = 0; i < header.item_count; i++) {
		paged_file_seek (&in, files[i].name_offset + header.data_offset);
		pkg_file_path = malloc (files[i].name_size + 1);
		paged_file_read (&in, pkg_file_path, files[i].name_size);
		pkg_file_path[files[i].name_size] = 0;
		sprintf(str, "Item %d : %s", i, pkg_file_path);
		fputs(str, txt);
		if(files[i].file_size != 0) {
			sprintf(str, "   Size : %ld\n",  files[i].file_size);
		} else strcpy(str, "\n");
		fputs(str, txt);
		free (pkg_file_path);
	}
	fclose(txt);
	paged_file_close (&in);

	return SUCCESS;
}

void pkg_unpack (const char *filename, const char *destination)
{
	PagedFile in = {0};
	PagedFile out = {0};
	char out_dir[1024];
	char *pkg_file_path = NULL;
	char path[1024];
	pkg_header header;
	pkg_file_entry *files = NULL;
	u32 i;

	if( pkg_open(filename, &in, &header, &files) == FAILED) {
		print_load("Error : Unable to open pkg file");
		return;
	}
	
	print_head("Extracting %s", &strrchr(filename, '/')[1]);
	
	if (destination == NULL) {
		//char temp[255];
		//strcpy(temp, filename);
		//temp[strrchr(temp, '/') - temp] = 0;
		//sprintf(out_dir, "%s/%s", temp, header.content_id);
		strcpy(out_dir, filename);
		out_dir[strlen(out_dir)-4]=0;
	} else {
		strncpy (out_dir, destination, sizeof(out_dir));
	}
	MGZ_mkdir_recursive (out_dir);
	
	u64 total_size=0;
	for (i = 0; i < header.item_count; i++) {
		total_size += files[i].file_size;
	}
	
	task_Init(total_size);
	for (i = 0; i < header.item_count; i++) {
		int j;

		if(cancel) break;
		
		paged_file_seek (&in, files[i].name_offset + header.data_offset);
		pkg_file_path = malloc (files[i].name_size + 1);
		paged_file_read (&in, pkg_file_path, files[i].name_size);
		pkg_file_path[files[i].name_size] = 0;

		snprintf (path, sizeof(path), "%s/%s", out_dir, pkg_file_path);
		if ((files[i].type & 0xFF) == 4) {
			MGZ_mkdir_recursive (path);
		} else {
			j = strlen (path);
			while (j > 0 && path[j] != '/') j--;
			if (j > 0) {
				path[j] = 0;
				MGZ_mkdir_recursive (path);
				path[j] = '/';
			}
			paged_file_seek (&in, files[i].file_offset + header.data_offset);
			print_load("%s", pkg_file_path);
			if (paged_file_open (&out, path, FALSE) == FAILED){
				print_load("Error : Unable to open file : %s", path);
				return;
			}
			
			paged_file_splice (&out, &in, files[i].file_size);
			paged_file_close (&out);
		}
	}
	task_End();
	
	paged_file_close (&in);
	
	if(cancel) Delete(out_dir);
}

//*******************************************************
//Make launcher package
//*******************************************************

u8 write_AutoMount_setting(char *path, u8 launcher)
{
	char Mount_path[128];
	FILE* fp;
	u16 path_size = strlen(path);
	
	if( launcher ) {
		sprintf(Mount_path, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/AutoMount", ManaGunZ_id);
	} else {
		sprintf(Mount_path, "/dev_hdd0/game/%s/USRDIR/AutoMount", ManaGunZ_id);
	}
	
	fp = fopen(Mount_path, "wb");
	if(fp==NULL) return FAILED;
	
	fwrite(&direct_boot, sizeof(u8), 1, fp);
	fwrite(&clean_syscall, sizeof(u8), 1, fp);
	fwrite(&change_IDPS, sizeof(u8), 1, fp);
	fwrite(&IDPS, sizeof(u8), 0x10, fp);
	fwrite(&ext_game_data, sizeof(u8), 1, fp);
	fwrite(&payload, sizeof(u8), 1, fp);
	fwrite(&prim_USB, sizeof(u8), 1, fp);
	fwrite(&emu, sizeof(u8), 1, fp);
	fwrite(&libfs_from, sizeof(u8), 1, fp);
	fwrite(&mount_app_home, sizeof(u8), 1, fp);
	fwrite(&use_ex_plug, sizeof(u8), 1, fp);
	fwrite(&bt_audio, sizeof(u8), 1, fp);
	fwrite(&path_size, sizeof(u16), 1, fp);
	fwrite(path, path_size, 1, fp);
	fclose(fp);
	
	return SUCCESS;
}
	
u8 read_AutoMount_setting()
{
	char Mount_path[128];
	FILE* fp;
	u16 path_size;
	
	sprintf(Mount_path, "/dev_hdd0/game/%s/USRDIR/AutoMount", ManaGunZ_id);
	
	fp=fopen(Mount_path, "rb");
	
	if(fp==NULL) return FAILED;
	
	fread(&direct_boot, sizeof(u8), 1, fp);
	fread(&clean_syscall, sizeof(u8), 1, fp);
	fread(&change_IDPS, sizeof(u8), 1, fp);
	fread(&IDPS, sizeof(u8), 0x10, fp);
	fread(&ext_game_data, sizeof(u8), 1, fp);
	fread(&payload, sizeof(u8), 1, fp);
	fread(&prim_USB, sizeof(u8), 1, fp);
	fread(&emu, sizeof(u8), 1, fp);
	fread(&libfs_from, sizeof(u8), 1, fp);
	fread(&mount_app_home, sizeof(u8), 1, fp);
	fread(&use_ex_plug, sizeof(u8), 1, fp);	
	fread(&bt_audio, sizeof(u8), 1, fp);	
	
	fread(&path_size, sizeof(u16), 1, fp);
	memset(temp_buffer, 0, 8192);
	fread(temp_buffer, path_size, 1, fp);
	fclose(fp);
	
	memcpy(GamPath, temp_buffer, 512); // it's used in case it returns 'failed'
	
	u8 Path_exist = YES;
	if(path_info(temp_buffer) == _NOT_EXIST) {
		print_load("Warning : Game path not exist.");
		print_load("Searching in other devices...");
		
		Path_exist = NO;
		
		int n = 1, i; 
		while(temp_buffer[n] != '/' && temp_buffer[n] != 0) n++;
		
		char temp[8192]={0};
		
		sprintf(temp, "%s", &temp_buffer[n]);
		memset(temp_buffer, 0, 8192);
		
		for(i=0; i<=device_number; i++) {
			sprintf(temp_buffer, "/%s%s", list_device[i], temp);
			if(path_info(temp_buffer) != _NOT_EXIST) {
				print_load("Game found !");
				write_AutoMount_setting(temp_buffer, NO);
				Path_exist = YES;
				break;
			}
		}
		if(Path_exist == NO) return FAILED;
	}
	
	game_number = -1;
	
	add_GAMELIST(temp_buffer);
	
	if(game_number == -1) return FAILED;
	
	position = 0;
	
	iso = is_iso(list_game_path[position]);
	usb = is_usb(list_game_path[position]);
	
	if(iso) payload=SNAKE;
	if(!PEEKnPOKE) {
		if( mamba || cobra ) payload=SNAKE;
		else payload=NO_PAYLOAD;
	}
	
	if( HEN ) HEN_game_settings();
	
	return SUCCESS;
}

int make_launcher_pkg(char *title_id, char *path)
{

print_load("Init...");

	char title[512];	
	char content_id[37];
	char src[128];
	char dst[128];
	char lch[128];
	sprintf(lch, "/dev_hdd0/game/%s/USRDIR/launcher", ManaGunZ_id);
	Delete(lch);
	mkdir(lch, 0777);
	
	u8 _iso_ = is_iso(path);
	
//	loc
print_load("Copy loc...");
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/sys/loc", ManaGunZ_id);
	sprintf(src, "/dev_hdd0/game/%s/USRDIR/sys/loc", ManaGunZ_id);
	if( Copy(src, dst) == FAILED ) {
		print_load("Error : failed to copy loc directory");
		Delete(lch);
		return FAILED;
	}

// rawsceiso
	if( _iso_ ) {
print_load("Copy iso plugin...");
		sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/sys/sprx_iso", ManaGunZ_id);
		sprintf(src, "/dev_hdd0/game/%s/USRDIR/sys/sprx_iso", ManaGunZ_id);
		if( Copy(src, dst) == FAILED ) {
			print_load("Error : failed to copy sprx_iso directory");
			Delete(lch);
			return FAILED;
		}
	}
	
// data
print_load("Copy scetool data...");
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/sys/data", ManaGunZ_id);
	sprintf(src, "/dev_hdd0/game/%s/USRDIR/sys/data", ManaGunZ_id);
	if( Copy(src, dst) == FAILED ) {
		print_load("Error : failed to copy data directory");
		Delete(lch);
		return FAILED;
	}
	
	
//  self
print_load("Copy self...");
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/ManaGunZ.self", ManaGunZ_id);
	sprintf(src, "/dev_hdd0/game/%s/USRDIR/ManaGunZ.self", ManaGunZ_id);
	if( CopyFile(src, dst) == FAILED ) {
		print_load("Error : failed to copy ManaGunZ.self");
		Delete(lch);
		return FAILED;
	}
	
//	ICON0
print_load("Copy icon0...");
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/ICON0.PNG", ManaGunZ_id);
	if(_iso_) {
		if( ExtractFromISO(path, "/PS3_GAME/ICON0.PNG", dst) == FAILED) {
			print_load("Error : failed to get ICON0.PNG");
			Delete(lch);
			return FAILED;
		}
	} else {
		sprintf(src, "%s/PS3_GAME/ICON0.PNG", path);
		if( CopyFile(src, dst) == FAILED ) {
			print_load("Error : failed to copy ICON0.PNG");
			Delete(lch);
			return FAILED;
		}
	}
	
//	PARAM.SFO
print_load("Copy param...");
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/PARAM.SFO", ManaGunZ_id);
	sprintf(src, "/dev_hdd0/game/%s/PARAM.SFO", ManaGunZ_id);
	if( CopyFile(src, dst) == FAILED ) {
		print_load("Error : failed to copy PARAM.SFO");
		Delete(lch);
		return FAILED;
	}
	
// TITLE ID
print_load("Set title ID...");
	if( SetParamSFO("TITLE_ID", title_id, dst) == FAILED ) {
		print_load("Error : failed to change TITLE_ID");
		Delete(lch);
		return FAILED;
	}
	
// TITLE
print_load("Set title...");
	if( GetParamSFO("TITLE", title, path) == FAILED) {
		strcpy(title, &strrchr(path, '/')[1]);
		RemoveExtension(title);
	}
	if( SetParamSFO("TITLE", title, dst) == FAILED ) {
		print_load("Error : failed to change TITLE");
		Delete(lch);
		return FAILED;
	}
	
// AUTOMOUNT
print_load("Create AutoMount...");
	if( write_AutoMount_setting(path, YES) == FAILED ) {
		print_load("Error : failed to write AutoMount file");
		Delete(lch);
		return FAILED;
	}
	
// EBOOT.BIN
print_load("Extract EBOOT...");
	sprintf(src, "/dev_hdd0/game/%s/USRDIR/EBOOT.BIN", ManaGunZ_id);
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/EBOOT.elf", ManaGunZ_id);
	if( Extract_SELF(src, dst, NULL) == FAILED ) {
		print_load("Error : Failed extract EBOOT.BIN");
		Delete(lch);
		return FAILED;
	}
	
// NEW EBOOT
print_load("Make new EBOOT...");
	sprintf(src, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/EBOOT.elf", ManaGunZ_id);
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/launcher/USRDIR/EBOOT.BIN", ManaGunZ_id);
	sprintf(content_id, "EP0001-%s_00-0000000000000000", title_id);
	if(make_EBOOT_NPDRM(src, dst, content_id) == FAILED) {
		print_load("Error : Failed to make EBOOT.BIN");
		Delete(lch);
		return FAILED;
	}
	Delete(src);
	
// Name of PKG
print_load("Set pkg name...");
	char ascii_name[60]={0};
	int i;
	int k=0;
	int l=strlen(title);
	for(i=0; i<=l; i++) {		
		if(title[i]==32 //	space	
		|| (48<=title[i] && title[i]<=57) //number
		|| (65<=title[i] && title[i]<=90) // A..Z
		|| (97<=title[i] && title[i]<=122)) //a..z
		{
			ascii_name[k]=title[i];
			k++;
			if(k>40) {
				break;
			}
		}
	}
	strcat(ascii_name, " [");
	strcat(ascii_name, title_id);
	strcat(ascii_name, "]");
	
// Make package	
print_load("Make Package...");
	strcpy(dst, "/dev_hdd0/packages");
	mkdir(dst, 0777);
	sprintf(dst, "/dev_hdd0/packages/%s.pkg", ascii_name);
	Delete(dst);
	sprintf(src, "/dev_hdd0/game/%s/USRDIR", ManaGunZ_id);
	if( pkg_pack(dst, content_id, src, "launcher") == FAILED ) {
		print_load("Error : Failed to make PKG");
		Delete(lch);
		return FAILED;
	}
	
// Delete launcher directory
print_load("Delete launcher directory...");
	Delete(lch);
	
	return SUCCESS;
}

//*******************************************************
// Update ManaGunZ
//*******************************************************

// You must free the result if result is non-NULL.
char *str_replace(char *orig, char *rep, char *with) {
    char *result; // the return string
    char *ins;    // the next insert point
    char *tmp;    // varies
    int len_rep;  // length of rep (the string to remove)
    int len_with; // length of with (the string to replace rep with)
    int len_front; // distance between rep and end of last rep
    int count;    // number of replacements

    // sanity checks and initialization
    if (!orig || !rep)
        return NULL;
    len_rep = strlen(rep);
    if (len_rep == 0)
        return NULL; // empty rep causes infinite loop during count
    if (!with)
        with = "";
    len_with = strlen(with);

    // count the number of replacements needed
    ins = orig;
    for (count = 0; (tmp = strstr(ins, rep)); ++count) {
        ins = tmp + len_rep;
    }

    tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

    if (!result)
        return NULL;

    // first time through the loop, all the variable are set correctly
    // from here on,
    //    tmp points to the end of the result string
    //    ins points to the next occurrence of rep in orig
    //    orig points to the remainder of orig after "end of rep"
    while (count--) {
        ins = strstr(orig, rep);
        len_front = ins - orig;
        tmp = strncpy(tmp, orig, len_front) + len_front;
        tmp = strcpy(tmp, with) + len_with;
        orig += len_front + len_rep; // move to next "end of rep"
    }
    strcpy(tmp, orig);
    return result;
}

char *get_str_regex(char *mem, char *format)
{
	char str[255];
	memset(str, 0, 255);
	
	int formatlen = strlen(format);
	int memlen = strlen(mem);
    
	int i,j=0, l=0;
	for(i=0; i<memlen; i++) {
       
		if(format[j]=='*') {
			if(format[j+1] == mem[i]) {
				j++;
			} else {
				str[l] = mem[i];
				l++;
				continue;
			}
		}
		
		if(mem[i] == format[j]) {
			str[l] = mem[i];
			l++;
			j++;
			
			if(j==formatlen) return strcpy_malloc(str);
			
			continue;
		}
		
		j=0;
		l=0;
		memset(str, 0, sizeof(str));
	}
	return NULL;
	
}

float Get_MgzVersion()
{
	char mgz_title[32];
	float current_version=0;
	
	if(GetParamSFO("TITLE", mgz_title, "/dev_hdd0/game/MANAGUNZ0/PARAM.SFO") == FAILED) {
		print_load("Error : Get current version failed");
		return 0;
	}
	char *ptr = strrchr(mgz_title, 'v');
	if( ptr == NULL) return 0;
	
	sscanf(&ptr[1], "%f", &current_version);
	
	return current_version;
}

void update_MGZ()
{
	start_loading();
	
	char mgz_title[32];
	float current_version;
	float latest_version;
	char link[255];
	
	if(GetParamSFO("TITLE", mgz_title, "/dev_hdd0/game/MANAGUNZ0/PARAM.SFO") == FAILED) {
		print_load("Error : Get current version failed");
		end_loading();
		return;
	}
	
	sscanf(&strrchr(mgz_title, 'v')[1], "%f", &current_version);
	
	print_load("Current version : %.2f", current_version);
	
	Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
	mkdir("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp", 0777);

	if(download("https://github.com/Zarh/ManaGunZ/releases/latest", "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp/upd_mgz")==FAILED) {
		print_load("Error : Download latest failed");
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
		end_loading();
		return;
	}
	
	int file_size;
	char *mem = LoadFile("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp/upd_mgz", &file_size);
	if(mem==NULL) {
		print_load("Error : Loadfile latest failed");
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
		end_loading();
		return;
	}
	
	char *temp = get_str_regex(mem, "ManaGunZ/releases/download/*/ManaGunZ_v*pkg");
	if(temp==NULL) {
		print_load("Error : link not found");
		free(mem);
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
		end_loading();
		return;
	}
	
	sprintf(link, "https://github.com/Zarh/%s", temp);
	
	free(temp);
	
	sscanf(&strrchr(link, 'v')[1], "%f", &latest_version);

	print_load("Latest version : %.2f", latest_version);
	
	if(current_version >= latest_version) {
		show_msg(STR_UP2DATE);
		free(mem);
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
		end_loading();
		return;
	}
	
	end_loading();
	
	char diag_msg[64];
	sprintf(diag_msg, "%s v%.2f ?", STR_INSTALL_MGZ, latest_version);
	
	if( DrawDialogYesNo(diag_msg) == YES) {
		start_loading();
		print_head("Downloading...");
		if(download(link, "/dev_hdd0/game/MANAGUNZ0/USRDIR/temp/mgz.pkg")==FAILED) {
			print_load("Error : Download failed");
			free(mem);
			Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
			return;
		}
		
		pkg_unpack("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp/mgz.pkg", "/dev_hdd0/game/MANAGUNZ0");
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");		
		
		char *changelog = &strstr(mem, "<div class=\"markdown-body\">")[41];
		if(changelog) {
			changelog[strstr(changelog, "</div>")-changelog] = 0;
			changelog = str_replace(changelog, "<p>", "");
			changelog = str_replace(changelog, "</p>", "\n");
			changelog = str_replace(changelog, "<br>", "");
			
			char temp0[64];
			sprintf(temp0, "***** Changelog ManaGunZ v%.2f *****\n\n", latest_version);
		
			FILE* f;
			f=fopen("/dev_hdd0/game/MANAGUNZ0/USRDIR/sys/Changelog.txt", "w");
			if(f!=NULL) {
				fputs(temp0, f);
				fputs(changelog, f);
				fclose(f);
			}
			if(changelog) free(changelog);
		}
		
		free(mem);
		
		MGZ_exit();
		
		sysProcessExitSpawn2("/dev_hdd0/game/MANAGUNZ0/USRDIR/ManaGunZ.self", NULL, NULL, NULL, 0, 1001, SYS_PROCESS_SPAWN_STACK_SIZE_1M);
	}
	
	free(mem);
	
	Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/temp");
	
	return;
}

//*******************************************************
// Settings
//*******************************************************

void read_RootSetting()
{
	if( root_display != STYLE_CUSTOM ) return;
	if( lang_code_loaded == LANG_NONE ) return;
	
	FILE *fp;
	char setPath[128];
	u8 format_id[6]={0};
	
	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/root.bin", ManaGunZ_id);
	
	fp = fopen(setPath, "rb");
	if(fp==NULL) return;
	
	fread(&fm_LineSize, sizeof(u8), 1, fp);
	fread(&fm_RowNumber, sizeof(u8), 1, fp);
	fread(&fm_FontRowSize[0], sizeof(u8), 1, fp);
	fread(&fm_FontRowSize[1], sizeof(u8), 1, fp);
	fread(&fm_FontRowSize[2], sizeof(u8), 1, fp);
	fread(&fm_CustomIcons, sizeof(u8), 1, fp);
	fread(&fm_CapacityBarWidth, sizeof(float), 1, fp);
	fread(&format_id[0], sizeof(u8), 1, fp);
	fread(&format_id[1], sizeof(u8), 1, fp);
	fread(&format_id[2], sizeof(u8), 1, fp);
	fread(&format_id[3], sizeof(u8), 1, fp);
	fread(&format_id[4], sizeof(u8), 1, fp);
	fread(&format_id[5], sizeof(u8), 1, fp);
	fclose(fp);
	
	if(format_id[0] == FM_FORMAT_INIT) {
		fm_CustomIcons = NO;
		fm_LineSize=SMALL;
		fm_RowNumber=0;
		
		fm_FontRowSize[0] = LINE_H1;
		strcpy( fm_Format[ LEFTROW(0)  ], STR_FM_MOUNTPOINT);
		strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_EMPTY);
			
		fm_FontRowSize[1] = 0;
		strcpy( fm_Format[ LEFTROW(1)  ], STR_FM_EMPTY);
		strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
		fm_FontRowSize[2] = 0;
		strcpy( fm_Format[ LEFTROW(2)  ], STR_FM_EMPTY);
		strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
		
		fm_CapacityBarWidth=0;
		
		return;
	}
	
	int i;
	for(i=0; i < 6; i++) {
		char *format = FM_SetFormat(format_id[i]);
		if(format != NULL) {
			strcpy(fm_Format[i], format);
			FREE(format);
		}
	}
	
}

void write_RootSetting()
{
	if( root_display != STYLE_CUSTOM ) return;
	if( lang_code_loaded == LANG_NONE ) return;
	
	FILE *fp;
	char setPath[128];

	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/root.bin", ManaGunZ_id);
	
	u8 format_id[6] = {0};
	int i;
	for(i=0; i<6; i++) format_id[i] = FM_GetFormat(fm_Format[i]);
	
	fp = fopen(setPath, "wb");
	if(fp==NULL) return;
	
	fwrite(&fm_LineSize, sizeof(u8), 1, fp);
	fwrite(&fm_RowNumber, sizeof(u8), 1, fp);
	fwrite(&fm_FontRowSize[0], sizeof(u8), 1, fp);
	fwrite(&fm_FontRowSize[1], sizeof(u8), 1, fp);
	fwrite(&fm_FontRowSize[2], sizeof(u8), 1, fp);
	fwrite(&fm_CustomIcons, sizeof(u8), 1, fp);
	fwrite(&fm_CapacityBarWidth, sizeof(float), 1, fp);
	fwrite(&format_id[0], sizeof(u8), 1, fp);
	fwrite(&format_id[1], sizeof(u8), 1, fp);
	fwrite(&format_id[2], sizeof(u8), 1, fp);
	fwrite(&format_id[3], sizeof(u8), 1, fp);
	fwrite(&format_id[4], sizeof(u8), 1, fp);
	fwrite(&format_id[5], sizeof(u8), 1, fp);
	fclose(fp);
	
	SetFilePerms(setPath);
}

void read_setting()
{
	if( AutoM ) return;
	
	FILE* fp=NULL;
	char setPath[128];
	
	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/setting.bin", ManaGunZ_id);
	
	fp = fopen(setPath, "rb");
	if(fp!=NULL) {
		fread(&Themes[0], sizeof(char), 0x40, fp);
		fread(&Themes[1], sizeof(char), 0x40, fp);
		fread(&Themes[2], sizeof(char), 0x40, fp);
		fread(&Themes[3], sizeof(char), 0x40, fp);
		fread(&Show_ICON0, sizeof(u8), 1, fp);
		fread(&UI_position, sizeof(u8), 1, fp);
		fread(&GRID_TYPE, sizeof(u8), 1, fp);
		fread(&GRID_DIRECTION, sizeof(u8), 1, fp);
		fread(&GRID_ANIMATED, sizeof(u8), 1, fp);
		fread(&GRID_KEEP_PROP, sizeof(u8), 1, fp);
		fread(&GRID_NB_LINES, sizeof(u8), 1, fp);
		fread(&GRID_NB_COLUMNS, sizeof(u8), 1, fp);
		fread(&FLOW_inverse_button, sizeof(u8), 1, fp);
		fread(&videoscale_x, sizeof(int8_t), 1, fp);
		fread(&videoscale_y, sizeof(int8_t), 1, fp);
		fread(&COLOR_1, sizeof(u32), 1, fp);
		fread(&COLOR_2, sizeof(u32), 1, fp);
		fread(&COLOR_3, sizeof(u32), 1, fp);
		fread(&COLOR_4, sizeof(u32), 1, fp);
		fread(&XMB_priority, sizeof(u8), 1, fp);
		fread(&Show_COVER, sizeof(u8), 1, fp);
		fread(&Show_PIC1, sizeof(u8), 1, fp);
		fread(&Show_PS3, sizeof(u8), 1, fp);
		fread(&Show_PS2, sizeof(u8), 1, fp);
		fread(&Show_PS1, sizeof(u8), 1, fp);
		fread(&Show_PSP, sizeof(u8), 1, fp);
		fread(&Only_FAV, sizeof(u8), 1, fp);
		fread(&Use_SideMenu, sizeof(u8), 1, fp);
		fread(&Show_GameCase, sizeof(u8), 1, fp);
		fread(&lang_code, sizeof(u8), 1, fp);
		fread(&FLOW_3D, sizeof(u8), 1, fp);
		fread(&Show_Help, sizeof(u8), 1, fp);
		fread(&Show_Waves, sizeof(u8), 1, fp);
		fread(&WAVES_COLOR, sizeof(u32), 1, fp);
		fread(&Font, sizeof(char), 0x40, fp);
		fread(&filter_x, sizeof(float), 1, fp);
		fread(&filter_y, sizeof(float), 1, fp);
		fread(&FILTER_NOTIF, sizeof(u8), 1, fp);
		fread(&COLOR_NOTIF, sizeof(u32), 1, fp);
		fread(&FILTER_BOXHEAD, sizeof(u8), 1, fp);
		fread(&COLOR_BOXHEAD, sizeof(u32), 1, fp);
		fread(&FILTER_BOXBODY, sizeof(u8), 1, fp);
		fread(&COLOR_BOXBODY, sizeof(u32), 1, fp);
		fread(&FILTER_SIDEBAR, sizeof(u8), 1, fp);
		fread(&COLOR_SIDEBAR, sizeof(u32), 1, fp);
		fread(&FILTER_BGS, sizeof(u8), 1, fp);
		fread(&COLOR_BGS, sizeof(u32), 1, fp);
		fread(&FILTER_BG, sizeof(u8), 1, fp);
		fread(&COLOR_BG, sizeof(u32), 1, fp);
		fread(&root_display, sizeof(u8), 1, fp);
		fread(&LOG, sizeof(u8), 1, fp);
		fread(&DEBUG, sizeof(u8), 1, fp);
		fread(&IGNORE_ERR, sizeof(u8), 1, fp);
		fread(&with_3k3y_header, sizeof(u8), 1, fp);
		fread(&UPLOADER, sizeof(char), 0x40, fp);
		fread(&BOX3D_GAP, sizeof(u8), 1, fp);
		fread(&BOX3D_ALIGN, sizeof(u8), 1, fp);
		fread(&SHOW_LOG, sizeof(u8), 1, fp);
		fread(&OVERWRITE, sizeof(u8), 1, fp);
		fread(&DUMPER_MAX_TRY, sizeof(u8), 1, fp);
		
		fclose(fp);
	} 
	
	read_RootSetting();
}

void write_setting()
{
#ifdef FILAMANAGER
	UI_position=XMB;
#endif
	
	FILE* fp=NULL;
	char setPath[128];
	
	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/setting.bin", ManaGunZ_id);
	fp = fopen(setPath, "wb");
	if(fp!=NULL) {
		fwrite(&Themes[0], sizeof(char), 0x40, fp);
		fwrite(&Themes[1], sizeof(char), 0x40, fp);
		fwrite(&Themes[2], sizeof(char), 0x40, fp);
		fwrite(&Themes[3], sizeof(char), 0x40, fp);
		fwrite(&Show_ICON0, sizeof(u8), 1, fp);
		fwrite(&UI_position, sizeof(u8), 1, fp);
		fwrite(&GRID_TYPE, sizeof(u8), 1, fp);
		fwrite(&GRID_DIRECTION, sizeof(u8), 1, fp);
		fwrite(&GRID_ANIMATED, sizeof(u8), 1, fp);
		fwrite(&GRID_KEEP_PROP, sizeof(u8), 1, fp);
		fwrite(&GRID_NB_LINES, sizeof(u8), 1, fp);
		fwrite(&GRID_NB_COLUMNS, sizeof(u8), 1, fp);
		fwrite(&FLOW_inverse_button, sizeof(u8), 1, fp);
		fwrite(&videoscale_x, sizeof(int8_t), 1, fp);
		fwrite(&videoscale_y, sizeof(int8_t), 1, fp);
		fwrite(&COLOR_1, sizeof(u32), 1, fp);
		fwrite(&COLOR_2, sizeof(u32), 1, fp);
		fwrite(&COLOR_3, sizeof(u32), 1, fp);
		fwrite(&COLOR_4, sizeof(u32), 1, fp);
		fwrite(&XMB_priority, sizeof(u8), 1, fp);
		fwrite(&Show_COVER, sizeof(u8), 1, fp);
		fwrite(&Show_PIC1, sizeof(u8), 1, fp);
		fwrite(&Show_PS3, sizeof(u8), 1, fp);
		fwrite(&Show_PS2, sizeof(u8), 1, fp);
		fwrite(&Show_PS1, sizeof(u8), 1, fp);
		fwrite(&Show_PSP, sizeof(u8), 1, fp);
		fwrite(&Only_FAV, sizeof(u8), 1, fp);
		fwrite(&Use_SideMenu, sizeof(u8), 1, fp);
		fwrite(&Show_GameCase, sizeof(u8), 1, fp);
		fwrite(&lang_code, sizeof(u8), 1, fp);
		fwrite(&FLOW_3D, sizeof(u8), 1, fp);
		fwrite(&Show_Help, sizeof(u8), 1, fp);
		fwrite(&Show_Waves, sizeof(u8), 1, fp);
		fwrite(&WAVES_COLOR, sizeof(u32), 1, fp);
		fwrite(&Font, sizeof(char), 0x40, fp);
		fwrite(&filter_x, sizeof(float), 1, fp);
		fwrite(&filter_y, sizeof(float), 1, fp);
		fwrite(&FILTER_NOTIF, sizeof(u8), 1, fp);
		fwrite(&COLOR_NOTIF, sizeof(u32), 1, fp);
		fwrite(&FILTER_BOXHEAD, sizeof(u8), 1, fp);
		fwrite(&COLOR_BOXHEAD, sizeof(u32), 1, fp);
		fwrite(&FILTER_BOXBODY, sizeof(u8), 1, fp);
		fwrite(&COLOR_BOXBODY, sizeof(u32), 1, fp);
		fwrite(&FILTER_SIDEBAR, sizeof(u8), 1, fp);
		fwrite(&COLOR_SIDEBAR, sizeof(u32), 1, fp);
		fwrite(&FILTER_BGS, sizeof(u8), 1, fp);
		fwrite(&COLOR_BGS, sizeof(u32), 1, fp);
		fwrite(&FILTER_BG, sizeof(u8), 1, fp);
		fwrite(&COLOR_BG, sizeof(u32), 1, fp);
		fwrite(&root_display, sizeof(u8), 1, fp);
		fwrite(&LOG, sizeof(u8), 1, fp);
		fwrite(&DEBUG, sizeof(u8), 1, fp);
		fwrite(&IGNORE_ERR, sizeof(u8), 1, fp);
		fwrite(&with_3k3y_header, sizeof(u8), 1, fp);
		fwrite(&UPLOADER, sizeof(char), 0x40, fp);
		fwrite(&BOX3D_GAP, sizeof(u8), 1, fp);
		fwrite(&BOX3D_ALIGN, sizeof(u8), 1, fp);
		fwrite(&SHOW_LOG, sizeof(u8), 1, fp);
		fwrite(&OVERWRITE, sizeof(u8), 1, fp);
		fwrite(&DUMPER_MAX_TRY, sizeof(u8), 1, fp);
		
		fclose(fp);
		SetFilePerms(setPath);
	}
	
	write_RootSetting();
	
	char sfo[64];
	sprintf(sfo, "/dev_hdd0/game/%s/PARAM.SFO", ManaGunZ_id);
	SetParamSFO("ITEM_PRIORITY", (char *) &XMB_priority, sfo);
	
	if(lang_code != lang_code_loaded) update_lang();
	
	read_setting();
}

void read_game_setting(int pos)
{
	print_debug("read_game_setting");
	
	FILE* fp=NULL;
	
	if(0<=pos) {
		char oldPath[128];	
		char setPath[128];
		
		if(iso) sprintf(oldPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[ISO]%s.bin", ManaGunZ_id, list_game_title[pos]);
		else	sprintf(oldPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[JB]%s.bin", ManaGunZ_id, list_game_title[pos]);
		
		if(iso) sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[ISO]%s.bin", ManaGunZ_id, list_game_ID[pos]);
		else	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[JB]%s.bin", ManaGunZ_id, list_game_ID[pos]);
		
		if(path_info(setPath) == _FILE) Delete(oldPath); 
		else rename(oldPath, setPath);
		
		fp = fopen(setPath, "rb");
	}
	
	if(fp!=NULL) {
		fread(&direct_boot, sizeof(u8), 1, fp);
		fread(&clean_syscall, sizeof(u8), 1, fp);
		fread(&change_IDPS, sizeof(u8), 1, fp);
		fread(&IDPS, sizeof(long long unsigned int), 2, fp);
		fread(&ext_game_data, sizeof(u8), 1, fp);
		fread(&payload, sizeof(u8), 1, fp);
		fread(&prim_USB, sizeof(u8), 1, fp);
		fread(&emu, sizeof(u8), 1, fp);
		fread(&libfs_from, sizeof(u8), 1, fp);
		fread(&mount_app_home, sizeof(u8), 1, fp);
		fread(&use_ex_plug, sizeof(u8), 1, fp);
		fread(&bt_audio, sizeof(u8), 1, fp);
		fclose(fp);
	} else {
		direct_boot = NO;
		clean_syscall = NO;
		change_IDPS = NO;
		peek_IDPS();
		ext_game_data = NO;
		if(iso) payload=SNAKE;
		else payload=MM;
		prim_USB=NO;
		emu=NONE;
		libfs_from=MM;
		mount_app_home=NO;
		use_ex_plug=NO;
		bt_audio=NO;
	}
	
	if(iso) payload=SNAKE;
	if(PEEKnPOKE==NO) payload=SNAKE;
	
	if( HEN ) HEN_game_settings();
}

void write_game_setting(int pos)
{
	if(AutoM == YES) return;
	
	FILE* fp=NULL;
	
	if(0<=pos) {		
		char setPath[128];
		if(iso) sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[ISO]%s.bin", ManaGunZ_id, list_game_ID[pos]);
		else	sprintf(setPath, "/dev_hdd0/game/%s/USRDIR/setting/game_setting/[JB]%s.bin", ManaGunZ_id, list_game_ID[pos]);
		fp = fopen(setPath, "wb");
	}
	
	if(fp!=NULL){
		fwrite(&direct_boot, sizeof(u8), 1, fp);
		fwrite(&clean_syscall, sizeof(u8), 1, fp);
		fwrite(&change_IDPS, sizeof(u8), 1, fp);
		fwrite(&IDPS, sizeof(long long unsigned int), 2, fp);
		fwrite(&ext_game_data, sizeof(u8), 1, fp);
		fwrite(&payload, sizeof(u8), 1, fp);
		fwrite(&prim_USB, sizeof(u8), 1, fp);
		fwrite(&emu, sizeof(u8), 1, fp);
		fwrite(&libfs_from, sizeof(u8), 1, fp);
		fwrite(&mount_app_home, sizeof(u8), 1, fp);
		fwrite(&use_ex_plug, sizeof(u8), 1, fp);
		fwrite(&bt_audio, sizeof(u8), 1, fp);
		fclose(fp);
	}
	
	read_game_setting(pos);
}

void write_fav()
{
	FILE* fp=NULL;
	char favPath[128];
	int i;
	u16 path_size;
	
	sprintf(favPath, "/dev_hdd0/game/%s/USRDIR/setting/fav.bin", ManaGunZ_id);
	fp = fopen(favPath, "wb");
	if(fp!=NULL)	{
		fwrite(&FAV_game_number, sizeof(u8), 1, fp);
		for(i=0; i <= FAV_game_number; i++) {
			path_size = sizeof(char)*strlen(list_FAV_game_title[i]);
			fwrite(&path_size, sizeof(u16), 1, fp);
			fwrite(list_FAV_game_title[i], path_size, 1, fp);
			path_size = sizeof(char)*strlen(list_FAV_game_path[i]);
			fwrite(&path_size, sizeof(u16), 1, fp);
			fwrite(list_FAV_game_path[i], path_size, 1, fp);
		}
		fclose(fp);
	}
}

void read_fav()
{
	FILE* fp=NULL;
	char favPath[128];
	int i;
	u16 path_size;
	
	sprintf(favPath, "/dev_hdd0/game/%s/USRDIR/setting/fav.bin", ManaGunZ_id);
	fp = fopen(favPath, "rb");
	if(fp!=NULL)	{
		fread(&FAV_game_number, sizeof(u8), 1, fp);
		for(i=0; i <= FAV_game_number; i++) {
			path_size = sizeof(char)*strlen(list_FAV_game_title[i]);
			fread(&path_size, sizeof(u16), 1, fp);
			fread(list_FAV_game_title[i], path_size, 1, fp);
			path_size = sizeof(char)*strlen(list_FAV_game_path[i]);
			fread(&path_size, sizeof(u16), 1, fp);
			fread(list_FAV_game_path[i], path_size, 1, fp);
		}
		fclose(fp);
	}
}

u8 is_favorite(char *path)
{
	int j;
	for(j=0;j <= FAV_game_number; j++) {
		if(strcmp(list_FAV_game_path[j], path) == 0) return YES;
	}
	return NO;
}

u8 add_favorite()
{
	FAV_game_number++;
	strcpy(list_FAV_game_title[FAV_game_number], list_game_title[position]);
	strcpy(list_FAV_game_path[FAV_game_number], list_game_path[position]);
	write_fav();

	return is_favorite(list_game_path[position]);
}

u8 remove_favorite()
{
	int i, j;
	for(i=0; i <= FAV_game_number; i++) {
		if(strcmp(list_game_path[position], list_FAV_game_path[i]) == 0 ) {
			for(j=i; j<=FAV_game_number; j++) {
				strcpy(list_FAV_game_path[j], list_FAV_game_path[j+1]);
			}
			strcpy(list_FAV_game_path[FAV_game_number], "");
			FAV_game_number--;
			write_fav();
			
			break;
		}
	}
	
	if(is_favorite(list_game_path[position]) == YES) return FAILED;
	
	return SUCCESS;
}

//*******************************************************
//ResetBD
//*******************************************************

int umount_iso()
{
	u8 m;
	unsigned int real_disctype, effective_disctype, iso_disctype;
	cobra_get_disc_type(&real_disctype, &effective_disctype, &iso_disctype);

	//if (iso_disctype == DISC_TYPE_NONE)	return 0;
	
	if (effective_disctype != DISC_TYPE_NONE) {
		cobra_send_fake_disc_eject_event();
		usleep(4000);
	}
	
	cobra_umount_disc_image();
	
	// If there is a real disc in the system, issue an insert event
	if (real_disctype != DISC_TYPE_NONE)
	{
		cobra_send_fake_disc_insert_event();
		for(m=0; m<22; m++)
		{
			usleep(4000);
			if(path_info("/dev_bdvd") != _NOT_EXIST) break;
		}
		cobra_disc_auth();
	}
	return 0;
}

void clean_tables()
{
	int i;
	for(i=0; i<0x400; i+=8) {
		lv2poke(0x80000000007FAE00ULL + i, 0x0000000000000000ULL);
		lv2poke(0x80000000007FDB00ULL + i, 0x0000000000000000ULL);
	}
}

//*******************************************************
// Init ManaGunZ
//*******************************************************

int init_ManaGunZ()
{
	
	print_debug("start of init mgz");
	
	int i;

	cobra = is_cobra();
	mamba = is_mamba();
	HEN = is_HEN();
	
	if(PEEKnPOKE) {
		peek_IDPS();
		print_load("Reset BD");
		unpatch_bdmirror();
		clean_tables();
	}
	
	
	if(cobra) {
		print_debug("cobra functions");
		cobra_lib_init();
		umount_iso();
		usleep(4000);
		//cobra_map_game(NULL,NULL,NULL); bug
		//cobra_map_paths(NULL,NULL, 0); bug
		{sys_map_path((char*)"/dev_bdvd", NULL);}
		{sys_map_path((char*)"//dev_bdvd", NULL);}
		{sys_map_path((char*)"/app_home", NULL);}
		{sys_map_path((char*)"//app_home", NULL);}
		{sys_map_path("/dev_flash/sys/external/libfs.sprx", NULL);}
		{sys_map_path("/dev_flash/vsh/module/explore_plugin.sprx", NULL);}
		usleep(4000);
		cobra_unset_psp_umd();
	}
	else if(mamba) {
		print_debug("mamba functions");
		umount_iso();
		usleep(4000);
		{snake_map((char*)"/dev_bdvd", NULL);}
		{snake_map((char*)"//dev_bdvd", NULL);}
		{snake_map((char*)"/app_home", NULL);}
		{snake_map((char*)"//app_home", NULL);}
		{snake_map("/dev_flash/sys/external/libfs.sprx", NULL);}
		{snake_map("/dev_flash/vsh/module/explore_plugin.sprx", NULL);}
	}

	print_debug("sys_fs_unmount");
	sys_fs_unmount("/dev_bdvd");
	sys_fs_unmount("/dev_ps2disk");

	print_debug("sys_fs_mount");
	sys_fs_mount("CELL_FS_IOS:PATA0_BDVD_DRIVE", "CELL_FS_ISO9660", "/dev_bdvd", 1);
	// usleep(1000);
	// for(n=0; n<10;n++) {
		// if(path_info("/dev_bdvd") != _NOT_EXIST) break;
		// sys_fs_mount("CELL_FS_IOS:PATA0_BDVD_DRIVE", "CELL_FS_ISO9660", "/dev_bdvd", 1);
		// usleep(1000);
	// }
	
	/*
	if(cobra) {
		unsigned int real_disctype;
		cobra_get_disc_type(&real_disctype, NULL, NULL);
		if (real_disctype == DISC_TYPE_NONE) real_disk = NO; else
		real_disk = YES;
	} else {
		if(path_info("/dev_bdvd") == _NOT_EXIST) real_disk = NO; else
		real_disk = YES;
	}
	*/

	print_debug("getDevices");
	getDevices();

	print_debug("move_bdemubackup_to_origin");
	char temp[128];
	for(i=0; i<=device_number; i++) {
		sprintf(temp, "/%s", list_device[i]);
		move_bdemubackup_to_origin(temp);
	}
	
	print_debug("path_info changelog");
	if(path_info("/dev_hdd0/game/MANAGUNZ0/USRDIR/sys/Changelog.txt") == _FILE) {
		open_txt_viewer("/dev_hdd0/game/MANAGUNZ0/USRDIR/sys/Changelog.txt");
		Delete("/dev_hdd0/game/MANAGUNZ0/USRDIR/sys/Changelog.txt");
	}
	
	print_debug("init mgz : return ok");
	return OK;
}

//*******************************************************
// PAD
//*******************************************************

u8 AnyOldPad()
{
	if(old_pad) return YES;
	return NO;
}

u8 AnyNewPad()
{
	if(new_pad) return YES;
	return NO;
}

void SetHold(u32 button, u64 value);
u8 NewPad(u32 button)
{
	
	if(new_pad & button) {
		if(button != BUTTON_CIRCLE) {
			SetHold(BUTTON_CIRCLE, 0);
			hold_CIRCLE=0;
			spam_CIRCLE=-1;
		}
		return YES;
	}
	
	return NO;
}

u8 OldPad(u32 button)
{
	if(old_pad & button) return YES;
	return NO;
}

u64 GetHold(u32 button)
{
	if(button & BUTTON_R) return hold_value[0];
	if(button & BUTTON_L) return hold_value[1];
	if(button & BUTTON_LEFT) return hold_value[2];
	if(button & BUTTON_DOWN) return hold_value[3];
	if(button & BUTTON_RIGHT) return hold_value[4];
	if(button & BUTTON_UP) return hold_value[5];
	if(button & BUTTON_START) return hold_value[6];
	if(button & BUTTON_R3) return hold_value[7];
	if(button & BUTTON_L3) return hold_value[8];
	if(button & BUTTON_SELECT) return hold_value[9];
	if(button & BUTTON_SQUARE) return hold_value[10];
	if(button & BUTTON_CROSS) return hold_value[11];
	if(button & BUTTON_CIRCLE) return hold_value[12];
	if(button & BUTTON_TRIANGLE) return hold_value[13];
	if(button & BUTTON_R1) return hold_value[14];
	if(button & BUTTON_L1) return hold_value[15];
	if(button & BUTTON_R2) return hold_value[16];
	if(button & BUTTON_L2) return hold_value[17];
	
	return 0;	
}

void SetHold(u32 button, u64 value)
{
	if(button & BUTTON_R) hold_value[0]=value;
	if(button & BUTTON_L) hold_value[1]=value;
	if(button & BUTTON_LEFT) hold_value[2]=value;
	if(button & BUTTON_DOWN) hold_value[3]=value;
	if(button & BUTTON_RIGHT) hold_value[4]=value;
	if(button & BUTTON_UP) hold_value[5]=value;
	if(button & BUTTON_START) hold_value[6]=value;
	if(button & BUTTON_R3) hold_value[7]=value;
	if(button & BUTTON_L3) hold_value[8]=value;
	if(button & BUTTON_SELECT) hold_value[9]=value;
	if(button & BUTTON_SQUARE) hold_value[10]=value;
	if(button & BUTTON_CROSS) hold_value[11]=value;
	if(button & BUTTON_CIRCLE) hold_value[12]=value;
	if(button & BUTTON_TRIANGLE) hold_value[13]=value;
	if(button & BUTTON_R1) hold_value[14]=value;
	if(button & BUTTON_L1) hold_value[15]=value;
	if(button & BUTTON_R2) hold_value[16]=value;
	if(button & BUTTON_L2) hold_value[17]=value;
}

u64 GetSlow(u32 button)
{
	if(button & BUTTON_R) return slow_value[0];
	if(button & BUTTON_L) return slow_value[1];
	if(button & BUTTON_LEFT) return slow_value[2];
	if(button & BUTTON_DOWN) return slow_value[3];
	if(button & BUTTON_RIGHT) return slow_value[4];
	if(button & BUTTON_UP) return slow_value[5];
	if(button & BUTTON_START) return slow_value[6];
	if(button & BUTTON_R3) return slow_value[7];
	if(button & BUTTON_L3) return slow_value[8];
	if(button & BUTTON_SELECT) return slow_value[9];
	if(button & BUTTON_SQUARE) return slow_value[10];
	if(button & BUTTON_CROSS) return slow_value[11];
	if(button & BUTTON_CIRCLE) return slow_value[12];
	if(button & BUTTON_TRIANGLE) return slow_value[13];
	if(button & BUTTON_R1) return slow_value[14];
	if(button & BUTTON_L1) return slow_value[15];
	if(button & BUTTON_R2) return slow_value[16];
	if(button & BUTTON_L2) return slow_value[17];
	
	return 0;	
}

void SetSlow(u32 button, u64 value)
{
	if(button & BUTTON_R) slow_value[0]=value;
	if(button & BUTTON_L) slow_value[1]=value;
	if(button & BUTTON_LEFT) slow_value[2]=value;
	if(button & BUTTON_DOWN) slow_value[3]=value;
	if(button & BUTTON_RIGHT) slow_value[4]=value;
	if(button & BUTTON_UP) slow_value[5]=value;
	if(button & BUTTON_START) slow_value[6]=value;
	if(button & BUTTON_R3) slow_value[7]=value;
	if(button & BUTTON_L3) slow_value[8]=value;
	if(button & BUTTON_SELECT) slow_value[9]=value;
	if(button & BUTTON_SQUARE) slow_value[10]=value;
	if(button & BUTTON_CROSS) slow_value[11]=value;
	if(button & BUTTON_CIRCLE) slow_value[12]=value;
	if(button & BUTTON_TRIANGLE) slow_value[13]=value;
	if(button & BUTTON_R1) slow_value[14]=value;
	if(button & BUTTON_L1) slow_value[15]=value;
	if(button & BUTTON_R2) slow_value[16]=value;
	if(button & BUTTON_L2) slow_value[17]=value;
}

u8 OldPadTicks(u32 button, u32 Ticks) 
{
	if(OldPad(button)) {
		u64 hold = GetHold(button);
		if(Ticks < hold) return YES;
		hold++;
		SetHold(button, hold);
	} else SetHold(button, 0);
	
	return NO;
}

u64 OldPadDelay(u32 button, u64 nDelay) 
{
	if(OldPad(button)) {
		u64 start = GetHold(button);
		u64 end = nTime();
		if(start==0) {
			SetHold(button, end);
			return 0;
		}		
		u64 t = end - start;		
		if(nDelay < t) return t;
	} else SetHold(button, 0);
	
	return 0;
}

u8 HoldCircleTicks()
{
	if(NewPad(BUTTON_CIRCLE)) {
		hold_CIRCLE+=MAX_HOLD/4;
		if(MAX_HOLD < hold_CIRCLE) return YES;
		return NO;
	}
	
	if(OldPad(BUTTON_CIRCLE)) {
		if(MAX_HOLD < hold_CIRCLE) return YES;
		hold_CIRCLE++;
	} else {
		hold_CIRCLE-=2;
		if(hold_CIRCLE < 0) hold_CIRCLE=0;
	}
	
	return NO;
}

u64 WaitToUnload = 0;
s64 TimeCircle = 0;

u8 HoldCircleDelay()
{
	if(NewPad(BUTTON_CIRCLE)) {
		u64 start = GetHold(BUTTON_CIRCLE);
		WaitToUnload = nTime();
		if(start==0) SetHold(BUTTON_CIRCLE, WaitToUnload);
		spam_CIRCLE++;
		if(spam_CIRCLE==spam_CIRCLE_MAX) return YES;
		return NO;
	} else
	if(OldPad(BUTTON_CIRCLE)) {
		u64 start = GetHold(BUTTON_CIRCLE);
		
		if(start==0) return NO;
		
		u64 end = nTime();
		
		TimeCircle = end - start;
		
		if(TimeCircle<=0) {
			start=0;
			hold_CIRCLE = 0;
		} else {
			hold_CIRCLE = (u64) ((TimeCircle * MAX_HOLD / MAX_HOLD_S) * 2);
			if(MAX_HOLD < hold_CIRCLE) return YES;
		}
		
		if( 2*MAX_HOLD / 3 < hold_CIRCLE && spam_CIRCLE < 2) spam_CIRCLE=2; else
		if( MAX_HOLD / 3 < hold_CIRCLE && spam_CIRCLE < 1) spam_CIRCLE=1;
		
		WaitToUnload = end;
	} else {
		u64 start = GetHold(BUTTON_CIRCLE);
		if(start!=0) {
			u64 end = nTime();
			if(WaitToUnload) {
				s64 s = end - WaitToUnload;
				if(n_s(1) < s) {
					WaitToUnload = 0;
					spam_CIRCLE=-1;
				} else {
					SetHold(BUTTON_CIRCLE, start+s);
					return NO;
				}
			}
			
			start += n_ms(200);
			s64 t = end - start;
			
			while(TimeCircle < t) {
				start += n_ms(200);
				t = end - start;
			}
			TimeCircle = t;
			
			if(t <= 0) {
				start=0;
				hold_CIRCLE = 0;
			} else {
				hold_CIRCLE = (u64) ((t * MAX_HOLD / MAX_HOLD_S) * 2);
			}
			
			if(MAX_HOLD < hold_CIRCLE) {
				start=0;
				hold_CIRCLE = 0;
			}
			
			SetHold(BUTTON_CIRCLE, start);
		} else {
			hold_CIRCLE=0;
			spam_CIRCLE=-1;
		}
	}
	
	return NO;
}

u8 R2pad(u32 button)
{
	
	if(NewPad(button)) return YES;	
	
	u64 t = OldPadDelay(button, n_ms(50));
	if(0<t) {
		u64 slow = GetSlow(button);
		
		if( R2speed == 6 ) { // the user don't use R2
			if( n_s(4.0) < t ) {SetSlow(button, 0); return YES; } else
			if( n_s(3.5) < t && 0 < slow)  {SetSlow(button, 0); return YES; } else
			if( n_s(3.0) < t && 1 < slow ) {SetSlow(button, 0); return YES; } else
			if( n_s(2.5) < t && 2 < slow ) {SetSlow(button, 0); return YES; } else
			if( n_s(2.0) < t && 3 < slow ) {SetSlow(button, 0); return YES; } else
			if( n_s(1.5) < t && 4 < slow ) {SetSlow(button, 0); return YES; } else
			if( n_s(1.0) < t && 5 < slow ) {SetSlow(button, 0); return YES; }
		} else 
		if(R2speed < slow) {
			SetSlow(button, 0);
			return YES;
		}
		slow++;
		SetSlow(button, slow);
	} else SetSlow(button, 0);
		
	return NO;
}

u8 ComboNewPad(u32 button1, u32 button2)
{
	if( (NewPad(button1) && OldPad(button2))
	||  (NewPad(button2) && OldPad(button1)) ) return YES;
	
	return NO;
}

void get_R2speed()
{
	if(OldPad(BUTTON_R2)) {
		R2speed = 6 - paddata.PRE_R2/50;
	} else R2speed=6;
}

void R2_SyncLeftJoystick()
{
	u8 old_x = x_L;
	u8 old_y = y_L;
	
	x_L = (paddata.button[6] - 128);
	y_L = (paddata.button[7] - 128);
	
	if (y_L < -28) {
		if(old_y == 0) new_pad |= BUTTON_UP; else
		{
			old_pad |= BUTTON_UP;
			R2speed = 6 + y_L/20;
		}
	} else 
	if (28 < y_L) {
		if(old_y == 0) new_pad |= BUTTON_DOWN; else
		{
			old_pad |= BUTTON_DOWN;
			R2speed = 6 - y_L/20;
		}
	} else 
	if (x_L < -28) {
		if(old_x == 0) new_pad |= BUTTON_LEFT; else
		{
			old_pad |= BUTTON_LEFT;
			R2speed = 6 + x_L/20 ;
		}
	} else 
	if (28 < x_L) {
		if(old_x == 0) new_pad |= BUTTON_RIGHT; else
		{
			old_pad |= BUTTON_RIGHT;
			R2speed = 6 - x_L/20;
		}
	} else { 
		x_L=0; y_L=0;
		get_R2speed();
	}
}

float R2JoyStick_X(int joystick)
{
	float joy_x;
	
	if(joystick == BUTTON_R) {
		joy_x = (paddata.button[4] - 128.0f);
	} else
	if(joystick == BUTTON_L) {
		joy_x = (paddata.button[6] - 128.0f);
	} else return 0;
	
	if(28.0f < abs(joy_x) ) {
		return (float) (joy_x / (R2speed*5+1));
	}
	
	return 0;
}

float R2JoyStick_Y(int joystick)
{
	float joy_y;
	
	if(joystick == BUTTON_R) {
		joy_y = (paddata.button[5] - 128.0f);
	} else
	if(joystick == BUTTON_L) {
		joy_y = (paddata.button[7] - 128.0f);
	} else return 0;
	
	if(28.0f < abs(joy_y)) {
		return (float) (joy_y / (R2speed*5+1));
	}
	
	return 0;
}

//*******************************************************
// File Manager
//*******************************************************

void init_FileExplorer()
{
	if( DEBUG ) {
		start_loading();
		print_debug("init_FileExplorer");
	}
	
	int i;

	window_x = (float *) malloc(WINDOW_MAX * sizeof(float));
	window_y = (float *) malloc(WINDOW_MAX * sizeof(float));
	window_z = (float *) malloc(WINDOW_MAX * sizeof(float));
	window_h = (float *) malloc(WINDOW_MAX * sizeof(float));
	window_w = (float *) malloc(WINDOW_MAX * sizeof(float));
	
	window_path = (char **) malloc(WINDOW_MAX * sizeof(char *));
	for(i=0; i<WINDOW_MAX; i++) window_path[i]=NULL;
	window_lastpath = (char **) malloc(WINDOW_MAX * sizeof(char *));
	for(i=0; i<WINDOW_MAX; i++) window_lastpath[i]=NULL;
	window_content_Name = (char ***) malloc(WINDOW_MAX * sizeof(char **));
	for(i=0; i<WINDOW_MAX; i++) window_content_Name[i]=NULL;
	window_content_Size = (u64 **) malloc(WINDOW_MAX * sizeof(u64 *));
	for(i=0; i<WINDOW_MAX; i++) window_content_Size[i]=NULL;
	window_content_Type = (char ***) malloc(WINDOW_MAX * sizeof(char **));
	for(i=0; i<WINDOW_MAX; i++) window_content_Type[i]=NULL;
	window_content_Selected = (u8 **) malloc(WINDOW_MAX * sizeof(u8 *));
	for(i=0; i<WINDOW_MAX; i++) window_content_Selected[i]=NULL;
	
	window_sort = (u8 *) malloc(WINDOW_MAX * sizeof(u8));
	window_w_col_size = (float *) malloc(WINDOW_MAX * sizeof(float));
	
	window_content_N = (int *) malloc(WINDOW_MAX * sizeof(int));
	window_open = (u8 *) malloc(WINDOW_MAX * sizeof(u8));
	//for(i=0; i<WINDOW_MAX; i++) window_open[i]=NO; freeze...
	memset(window_open, 0, WINDOW_MAX * sizeof(u8));
	
	window_scroll_N = (u32 *) malloc(WINDOW_MAX * sizeof(u32));
	window_scroll_P = (u32 *) malloc(WINDOW_MAX * sizeof(u32));
	window_scroll_size = (float *) malloc(WINDOW_MAX * sizeof(float));
	window_scroll_y = (float *) malloc(WINDOW_MAX * sizeof(float));
	
	window_item_N = (s8 *) malloc(WINDOW_MAX * sizeof(s8));
	
	option_copy = (char **) malloc(WINDOW_MAX_ITEMS * sizeof(char *));
	for(i=0; i<WINDOW_MAX_ITEMS; i++) option_copy[i]=NULL;
	
	DevicesInfo = (DeviceInfo_t *) malloc(WINDOW_MAX_DEVICES * sizeof(DeviceInfo_t));
	memset(DevicesInfo, 0, WINDOW_MAX_DEVICES * sizeof(DeviceInfo_t));
	
	DevicesInfo_N = -1;
	
	print_debug("end of init_FileExplorer");
	end_loading();
}

void finalize_FileExplorer()
{
	if( DEBUG ) start_loading();
	
	u32 i,j;
	
	print_debug("finalize_FileExplorer");
	
	print_debug("window_x");
	FREE(window_x);
	print_debug("window_y");
	FREE(window_y);
	print_debug("window_z");
	FREE(window_z);
	print_debug("window_h");
	FREE(window_h);
	print_debug("window_w");
	FREE(window_w);
	
	print_debug("window_path");
	
	for(i=0; i<WINDOW_MAX; i++) FREE(window_path[i]);
	FREE(window_path);
	
	print_debug("window_lastpath");
	
	for(i=0; i<WINDOW_MAX; i++) FREE(window_lastpath[i]);
	FREE(window_lastpath);
	
	print_debug("window_content_Name");
	
	for(i=0; i<WINDOW_MAX; i++) {
		if(window_content_Name[i] == NULL) continue;
		for(j=0; j<WINDOW_MAX_ITEMS; j++) {
			FREE(window_content_Name[i][j]);
		}
		FREE(window_content_Name[i]);
	}
	FREE(window_content_Name);
	
	print_debug("window_content_Type");
	
	for(i=0; i<WINDOW_MAX; i++) {
		if(window_content_Type[i] == NULL) continue;
		for(j=0; j<WINDOW_MAX_ITEMS; j++) {
			FREE(window_content_Type[i][j]);
		}
		FREE(window_content_Type[i]);
	}
	FREE(window_content_Type);
	
	print_debug("window_content_Name");
	
	for(i=0; i<WINDOW_MAX; i++) FREE(window_content_Size[i]);
	FREE(window_content_Size);
	for(i=0; i<WINDOW_MAX; i++) FREE(window_content_Selected[i]);
	FREE(window_content_Selected);
	
	print_debug("window_sort");
	
	FREE(window_sort);
	FREE(window_w_col_size);

	print_debug("window_content");
	
	FREE(window_content_N);
	FREE(window_open);

	print_debug("window_scroll");
	
	FREE(window_scroll_N);
	FREE(window_scroll_P);
	FREE(window_scroll_size);
	FREE(window_scroll_y);

	print_debug("window_item");
	
	FREE(window_item_N);

	print_debug("option_copy");
	
	for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(option_copy[i]);
	FREE(option_copy);
	
	print_debug("DevicesInfo");
	
	FREE(DevicesInfo);
	
	window_activ=-1;
	
	print_debug("end of finalize_FileExplorer");
	end_loading();
}

// *** PRX list tools ***
u8 is_it_inside(char *file_path, char *str)
{
	int size;
	char *buff = LoadFile(file_path, &size);
	if(buff==NULL) return NO;
	
	if(strstr(buff, str) != NULL) {
		free(buff);
		return YES;
	}
	
	free(buff);

	return NO;

}

void add_to_list(char *file_path, char *str)
{
	FILE* fr;
	FILE* fw;
	char line[255] = {0};
	char temp[255];
	
	strcpy(temp, file_path);
	strcat(temp, "_temp");
	
	fr=fopen(file_path, "rb");
	if(fr==NULL) return;
	fw=fopen(temp, "wb");
	if(fw==NULL) return;
	
	uint8_t FirstLine = YES;
	
	while(fgets(line, 255, fr) != NULL) {
		if(line[0]=='\r' || line[0]=='\n') continue;
		
		if(strstr(line, "\r") != NULL) strtok(line, "\r");
		if(strstr(line, "\n") != NULL) strtok(line, "\n");
		
		if(FirstLine==NO) fputs("\n", fw);
		fputs(line, fw);
		
		memset(line, 0, 255);
		FirstLine=NO;
	}
	
	if(FirstLine==NO) fputs("\n", fw);
	fputs(str, fw);
	
	fclose(fr);
	fclose(fw);
	
	unlink(file_path);
	rename(temp, file_path);
}

void remove_from_list(char *file_path, char *str)
{
	FILE* fr;
	FILE* fw;
	char line[255] = {0};
	char temp[255];
	
	strcpy(temp, file_path);
	strcat(temp, "_temp");
	
	fr=fopen(file_path, "rb");
	if(fr==NULL) return;
	fw=fopen(temp, "wb");
	if(fw==NULL) return;
	
	uint8_t FirstLine = YES;
	
	while(fgets(line, 255, fr) != NULL) {
		if(line[0]=='\r' || line[0]=='\n') {memset(line, 0, 255); continue; }
		
		if(strstr(line, "\r") != NULL) strtok(line, "\r");
		if(strstr(line, "\n") != NULL) strtok(line, "\n");
		
		if(strcmp(line, str) == 0) {memset(line, 0, 255); continue;}
		
		if(FirstLine==NO) fputs("\n", fw);
		fputs(line, fw);
		FirstLine=NO;
		memset(line, 0, 255);
	}
	
	fclose(fr);
	fclose(fw);
	
	unlink(file_path);
	rename(temp, file_path);
}

// *** ICONS ***
void DrawIcon_Directory(float x, float y, float z)
{
	float k = LINE_H/LINE_H1;
	if(PICTURE_offset[FOLDER] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[FOLDER], PICTURE[FOLDER].width, PICTURE[FOLDER].height, PICTURE[FOLDER].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x+1*k, y+1*k, z, 0, 13*k, 13*k, WHITE, YES);
	} else {
		float k = LINE_H/LINE_H1;
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexPos(x+1*k , y+1*k , z);
		tiny3d_VertexColor(0xFFC90EFF);
		tiny3d_VertexPos(x+11*k , y+1*k , z);
		tiny3d_VertexPos(x+11*k , y+6*k , z);
		tiny3d_VertexPos(x+13*k , y+8*k , z);
		tiny3d_VertexPos(x+13*k , y+12*k , z);
		tiny3d_VertexPos(x+1*k  , y+12*k , z);
		tiny3d_End();
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexPos(x+1*k , y+1*k , z);
		tiny3d_VertexColor(0xFFE280FF);
		tiny3d_VertexPos(x+7*k , y+3*k , z);
		tiny3d_VertexPos(x+7*k , y+14*k , z);
		tiny3d_VertexPos(x+1*k , y+12*k , z);
		tiny3d_End();

		tiny3d_SetPolygon(TINY3D_LINES);
		tiny3d_VertexPos(x+1*k , y+1*k , z);
		tiny3d_VertexColor(BLACK);
		tiny3d_VertexPos(x+11*k , y+1*k , z);
		tiny3d_VertexPos(x+11*k , y+6*k , z);
		tiny3d_VertexPos(x+13*k , y+8*k , z);
		tiny3d_VertexPos(x+13*k , y+12*k , z);
		tiny3d_VertexPos(x+7 *k , y+12*k , z);
		tiny3d_End();

		tiny3d_SetPolygon(TINY3D_LINE_LOOP);
		tiny3d_VertexPos(x+1*k , y+1*k , z);
		tiny3d_VertexColor(BLACK);
		tiny3d_VertexPos(x+7*k , y+3*k , z);
		tiny3d_VertexPos(x+7*k , y+14*k , z);
		tiny3d_VertexPos(x+1*k , y+12*k , z);
		tiny3d_End();

		tiny3d_SetPolygon(TINY3D_LINES);
		tiny3d_VertexPos(x+12*k , y+9*k , z);
		tiny3d_VertexColor(BLACK);
		tiny3d_VertexPos(x+12*k , y+11*k , z);
		tiny3d_End();
	}

}

void DrawIcon_File(float x, float y, float z, u32 color)
{
	float k = LINE_H/LINE_H1;
	
	if(PICTURE_offset[FILES] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[FILES], PICTURE[FILES].width, PICTURE[FILES].height, PICTURE[FILES].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x+1*k, y+1*k, z, 0, 13*k, 13*k, color, YES);
	} else {
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexPos(x+2*k , y+1*k , z);
		tiny3d_VertexColor(color);
		tiny3d_VertexPos(x+10*k, y+1*k , z);
		tiny3d_VertexPos(x+13*k, y+4*k , z);
		tiny3d_VertexPos(x+13*k, y+14*k , z);
		tiny3d_VertexPos(x+2*k , y+14*k , z);
		tiny3d_End();
		tiny3d_SetPolygon(TINY3D_LINE_LOOP);
		tiny3d_VertexPos(x+2*k , y+1*k , z);
		tiny3d_VertexColor(BLACK);
		tiny3d_VertexPos(x+10*k, y+1*k , z);
		tiny3d_VertexPos(x+13*k, y+4*k , z);
		tiny3d_VertexPos(x+13*k, y+14*k , z);
		tiny3d_VertexPos(x+2 *k, y+14*k , z);
		tiny3d_End();
		tiny3d_SetPolygon(TINY3D_LINES);
		tiny3d_VertexPos(x+10*k , y+1*k , z);
		tiny3d_VertexColor(BLACK);
		tiny3d_VertexPos(x+10*k, y+4*k , z);
		tiny3d_VertexPos(x+13*k, y+4*k , z);
		tiny3d_End();
	}
	
}

void DrawIcon_TXT(float x, float y, float z, u32 color)
{
	float k = LINE_H/LINE_H1;
	
	DrawIcon_File(x, y, z, WHITE);
	
	tiny3d_SetPolygon(TINY3D_LINES);
	tiny3d_VertexPos(x+5*k , y+6*k , z);
	tiny3d_VertexColor(BLUE);
	tiny3d_VertexPos(x+12*k, y+6*k , z);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_LINES);
	tiny3d_VertexPos(x+5*k , y+8*k , z);
	tiny3d_VertexColor(BLUE);
	tiny3d_VertexPos(x+12*k, y+8*k , z);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_LINES);
	tiny3d_VertexPos(x+5*k , y+10*k , z);
	tiny3d_VertexColor(BLUE);
	tiny3d_VertexPos(x+12*k, y+10*k , z);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_LINES);
	tiny3d_VertexPos(x+5*k, y+12*k , z);
	tiny3d_VertexColor(BLUE);
	tiny3d_VertexPos(x+12*k, y+12*k , z);
	tiny3d_End();

}

void Draw_Lock(float x, float y, float z, float w, float h)
{
	if(PICTURE_offset[LOCK] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[LOCK], PICTURE[LOCK].width, PICTURE[LOCK].height, PICTURE[LOCK].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	} else {
		Draw_Box(x, y, z, 0, w, h, RED, YES);
	}
}

void DrawIcon(float x, float y, float z, u8 pic, u32 color, u8 lock)
{
	float k = LINE_H/LINE_H1;
	
	if(PICTURE_offset[pic] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[pic], PICTURE[pic].width, PICTURE[pic].height, PICTURE[pic].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x+k, y+k, z, 0, 13*k, 13*k, color, YES);
	} else {
		DrawIcon_File(x, y, z, color);
	}
	
	if(lock) Draw_Lock(x + LINE_H - LINE_H1/2, y + LINE_H - LINE_H1/2, z, LINE_H1/2, LINE_H1/2);
}

//**** DOCK ****

#define WINDOW_LOC_UNK			0
#define WINDOW_LOC_DEFAULT		1
#define WINDOW_LOC_RIGHT		2
#define WINDOW_LOC_LEFT			3
#define WINDOW_LOC_MAX			4

#define WINDOW_LOC_W_DEFAULT	(500.0f)
#define WINDOW_LOC_H_DEFAULT	(TOP_H + COL_H1 + LINE_H1 * 15 + BORDER)
#define WINDOW_LOC_X_DEFAULT	(X_MAX/2 - WINDOW_LOC_W_DEFAULT/2)
#define WINDOW_LOC_Y_DEFAULT	((Y_MAX-45)/2 - WINDOW_LOC_H_DEFAULT/2)

void SetWindowLocation(int WINDOW_LOC)
{
	switch(WINDOW_LOC)
	{
		case WINDOW_LOC_DEFAULT:
		{
			window_x[window_activ]=WINDOW_LOC_X_DEFAULT+30*window_activ;
			window_y[window_activ]=WINDOW_LOC_Y_DEFAULT+30*window_activ;
			window_h[window_activ]=WINDOW_LOC_H_DEFAULT;
			window_w[window_activ]=WINDOW_LOC_W_DEFAULT;
			break;
		}
		case WINDOW_LOC_RIGHT:
		{
			window_x[window_activ]=X_MAX/2;
			window_y[window_activ]=0;
			window_w[window_activ]=X_MAX/2;
			window_h[window_activ]=Y_MAX-45;
			break;
		}
		case WINDOW_LOC_LEFT:
		{
			window_x[window_activ]=0;
			window_y[window_activ]=0;
			window_w[window_activ]=X_MAX/2;
			window_h[window_activ]=Y_MAX-45;
			break;
		}
		case WINDOW_LOC_MAX:
		{
			window_x[window_activ]=0;
			window_y[window_activ]=0;
			window_w[window_activ]=X_MAX;
			window_h[window_activ]=Y_MAX-45;
			break;
		}
		default:
			break;
	}
}

u8 GetWindowLocation()
{
	if( window_x[window_activ]==WINDOW_LOC_X_DEFAULT+30*window_activ
	&&	window_y[window_activ]==WINDOW_LOC_Y_DEFAULT+30*window_activ
	&&	window_h[window_activ]==WINDOW_LOC_H_DEFAULT
	&&	window_w[window_activ]==WINDOW_LOC_W_DEFAULT) 
		return WINDOW_LOC_DEFAULT;
	else 
	if(	window_x[window_activ]==X_MAX/2
	&&	window_y[window_activ]==0
	&&	window_w[window_activ]==X_MAX/2
	&&	window_h[window_activ]==Y_MAX-45)
		return WINDOW_LOC_RIGHT;
	else
	if( window_x[window_activ]==0
	&&	window_y[window_activ]==0
	&&	window_w[window_activ]==X_MAX/2
	&&	window_h[window_activ]==Y_MAX-45)
		return WINDOW_LOC_LEFT;
	else
	if( window_x[window_activ]==0
	&&	window_y[window_activ]==0
	&&	window_w[window_activ]==X_MAX
	&&	window_h[window_activ]==Y_MAX-45)
		return WINDOW_LOC_MAX;
	
	return WINDOW_LOC_UNK;
}

void Draw_OnlyCloseBox(float x, float y, float z, float w, float h) 
{
	if(PICTURE_offset[CLOSE] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[CLOSE], PICTURE[CLOSE].width, PICTURE[CLOSE].height, PICTURE[CLOSE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	} else {
		Draw_Box(x, y, z, 3, w, h, 0xff1000ff, NO);
		Draw_Box(x+1, y+1, z, 3, w-2, h-2, 0x00000066, NO);
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexPos(x+4 , y+3 , z);
		tiny3d_VertexColor(WHITE);
		tiny3d_VertexPos(x+10, y+9 , z);
		tiny3d_VertexPos(x+16, y+3 , z);
		tiny3d_VertexPos(x+17, y+4 , z);
		tiny3d_VertexPos(x+11, y+10, z);
		tiny3d_VertexPos(x+17, y+16, z);
		tiny3d_VertexPos(x+16, y+17, z);
		tiny3d_VertexPos(x+10, y+11, z);
		tiny3d_VertexPos(x+4 , y+17, z);
		tiny3d_VertexPos(x+3 , y+16, z);
		tiny3d_VertexPos(x+9 , y+10, z);
		tiny3d_VertexPos(x+3 , y+4 , z);
		tiny3d_End();
		
	}
}

void Draw_CloseBox(float x, float y, float z, float w, float h, u8 mouse_over) 
{
	if( mouse_over ) {
		if(PICTURE_offset[CLOSE_HOVER] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[CLOSE_HOVER], PICTURE[CLOSE_HOVER].width, PICTURE[CLOSE_HOVER].height, PICTURE[CLOSE_HOVER].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(x, y, z, 0, w, h, WHITE, YES);
		} else {
			Draw_Box(x, y, z, 0, w, h, RED, NO);
			Draw_OnlyCloseBox(x, y, z, w, h);	
		}
	} else {
		Draw_OnlyCloseBox(x, y, z, w, h);
	}
}

void Draw_OnlyResetBox(float x, float y, float z, float w, float h) 
{
	if(PICTURE_offset[RESET] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[RESET], PICTURE[RESET].width, PICTURE[RESET].height, PICTURE[RESET].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	} else {
		float w1 = 3*w/4;
		float h1 = 3*h/4;
		
		Draw_Box(x+w/4, y, z, 0, w1, h1, WHITE, NO);
		Draw_BoxLine(x+w/4, y, z, w1, h1, BLACK);
		
		Draw_Box(x, y+w/4, z, 0, w1, h1, WHITE, NO);
		Draw_BoxLine(x, y+w/4, z, w1, h1, BLACK);
	}
}

void Draw_ResetBox(float x, float y, float z, float w, float h, u8 mouse_over)
{
	if( mouse_over ) {
		if(PICTURE_offset[RESET_HOVER] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[RESET_HOVER], PICTURE[RESET_HOVER].width, PICTURE[RESET_HOVER].height, PICTURE[RESET_HOVER].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(x, y, z, 0, w, h, WHITE, YES);
		} else {
			Draw_Box(x, y, z, 0, w, h, GREY, NO);
			Draw_OnlyResetBox(x, y, z, w, h);	
		}
	} else {
		Draw_OnlyResetBox(x, y, z, w, h);
	}
}

void Draw_OnlyDockMaxBox(float x, float y, float z, float w, float h) 
{
	if(PICTURE_offset[MAXIMIZE] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[MAXIMIZE], PICTURE[MAXIMIZE].width, PICTURE[MAXIMIZE].height, PICTURE[MAXIMIZE].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	} else {
		Draw_Box(x, y, z, 3, w, h, 0xff1000ff, NO);
		Draw_Box(x+1, y+1, z, 3, w-2, h-2, 0x00000066, NO);
		
		tiny3d_SetPolygon(TINY3D_POLYGON);
		tiny3d_VertexPos(x+3 , y+13 , z);
		tiny3d_VertexColor(WHITE);
		tiny3d_VertexPos(x+10, y+6  , z);
		tiny3d_VertexPos(x+17, y+13 , z);
		tiny3d_VertexPos(x+15, y+13 , z);
		tiny3d_VertexPos(x+10, y+8  , z);
		tiny3d_VertexPos(x+5 , y+13 , z);
	}
}

void Draw_DockMaxBox(float x, float y, float z, float w, float h, u8 mouse_over)
{
	if( GetWindowLocation() == WINDOW_LOC_MAX ) {
		Draw_ResetBox(x, y, z, w, h, mouse_over);
		return;
	}
	
	if( mouse_over ) {
		if(PICTURE_offset[MAXIMIZE_HOVER] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[MAXIMIZE_HOVER], PICTURE[MAXIMIZE_HOVER].width, PICTURE[MAXIMIZE_HOVER].height, PICTURE[MAXIMIZE_HOVER].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(x, y, z, 0, w, h, WHITE, YES);
		} else {
			Draw_Box(x, y, z, 0, w, h, GREY, NO);
			Draw_OnlyDockMaxBox(x, y, z, w, h);	
		}
	} else {
		Draw_OnlyDockMaxBox(x, y, z, w, h);
	}
}

void Draw_OnlyDockRightBox(float x, float y, float z, float w, float h) 
{
	if(PICTURE_offset[DOCK_R] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[DOCK_R], PICTURE[DOCK_R].width, PICTURE[DOCK_R].height, PICTURE[DOCK_R].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	} else {
		Draw_LineBoxInside(x, y, z, 2, w, h, WHITE);
		Draw_Box(x+w/2, y, z, 0, w/2, h, WHITE, NO);
	}
}

void Draw_DockRightBox(float x, float y, float z, float w, float h, u8 mouse_over)
{
	if( GetWindowLocation() == WINDOW_LOC_RIGHT ) {
		Draw_ResetBox(x, y, z, w, h, mouse_over);
		return;
	}
	
	if( mouse_over ) {
		if(PICTURE_offset[DOCK_R_HOVER] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[DOCK_R_HOVER], PICTURE[DOCK_R_HOVER].width, PICTURE[DOCK_R_HOVER].height, PICTURE[DOCK_R_HOVER].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(x, y, z, 0, w, h, WHITE, YES);
		} else {
			Draw_Box(x, y, z, 0, w, h, GREY, NO);
			Draw_OnlyDockRightBox(x, y, z, w, h);	
		}
	} else {
		Draw_OnlyDockRightBox(x, y, z, w, h);
	}
}

void Draw_OnlyDockLeftBox(float x, float y, float z, float w, float h) 
{
	if(PICTURE_offset[DOCK_L] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[DOCK_L], PICTURE[DOCK_L].width, PICTURE[DOCK_L].height, PICTURE[DOCK_L].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z, 0, w, h, WHITE, YES);
	} else {
		Draw_LineBoxInside(x, y, z, 2, w, h, WHITE);
		Draw_Box(x, y, z, 0, w/2, h, WHITE, NO);
	}
}

void Draw_DockLeftBox(float x, float y, float z, float w, float h, u8 mouse_over)
{
	if( GetWindowLocation() == WINDOW_LOC_LEFT ) {
		Draw_ResetBox(x, y, z, w, h, mouse_over);
		return;
	}
	
	if( mouse_over ) {
		if(PICTURE_offset[DOCK_L_HOVER] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[DOCK_L_HOVER], PICTURE[DOCK_L_HOVER].width, PICTURE[DOCK_L_HOVER].height, PICTURE[DOCK_L_HOVER].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(x, y, z, 0, w, h, WHITE, YES);
		} else {
			Draw_Box(x, y, z, 0, w, h, GREY, NO);
			Draw_OnlyDockLeftBox(x, y, z, w, h);	
		}
	} else {
		Draw_OnlyDockLeftBox(x, y, z, w, h);
	}
}


u8 is_dev_blind(char *path)
{
	int n=0;
	if( path[0]=='/') n++;
	
	if( !strncmp(path + n, "dev_blind", 9) ) return YES;
	if( !strncmp(path + n, "dev_rebug", 9) ) return YES;
	
	return NO;
}

u8 dev_blind_exist()
{
	if(path_info("/dev_blind") != _NOT_EXIST || path_info("/dev_rebug") != _NOT_EXIST) 
		return YES;
	
	return NO;
}

void Draw_RootIcon(char *mount_point, char *type, float x, float y, float z, u8 readonly)
{
	if( fm_CustomIcons == NO) {
	
		if( is_folder(type) ) {
			DrawIcon_Directory(x, y, z);
		} else {
			DrawIcon_File(x, y, z, WHITE);
		}
	} else {
		if( mount_point == NULL) { //root
			DrawIcon(x, y, z, FILES, WHITE, readonly);
		}
		if( strncmp(mount_point, "dev_hdd", 7)==0) {
			DrawIcon(x, y, z, HDD, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_usb", 7)==0) {
			DrawIcon(x, y, z, USB, WHITE, readonly);
		} else
		if( strncmp(mount_point, "ntfs", 4)==0) {
			DrawIcon(x, y, z, USB, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_bdvd", 8)==0) {
			DrawIcon(x, y, z, DISC_PS3, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_ps2disk", 11)==0) {
			DrawIcon(x, y, z, DISC_PS2, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_flash", 9)==0) {
			DrawIcon(x, y, z, FLASH, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_blind", 9)==0) {
			DrawIcon(x, y, z, FLASH, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_rebug", 9)==0) {
			DrawIcon(x, y, z, FLASH, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_rewrite", 9)==0) {
			DrawIcon(x, y, z, FLASH, WHITE, readonly);
		} else 
		if( strncmp(mount_point, "app_home", 8)==0) {
			if( !strcmp(type, _JB_PS3)) {
				DrawIcon(x, y, z, DISC_PS3, WHITE, readonly);
			} else {
				DrawIcon(x, y, z, APP_HOME, WHITE, readonly);
			}
		} else
		if( strncmp(mount_point, "host_root", 8)==0) {
			DrawIcon(x, y, z, HOST_ROOT, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_cf", 6)==0) {
			DrawIcon(x, y, z, CF, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_ms", 6)==0) {
			DrawIcon(x, y, z, MS, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_sd", 6)==0) {
			DrawIcon(x, y, z, SD, WHITE, readonly);
		} else
		if( strncmp(mount_point, "dev_simple_hdd", 14)==0) {
			DrawIcon(x, y, z, HDD, WHITE, readonly);
		} else {
			DrawIcon_File(x, y, z, WHITE);
		}
	}
}

// *** Window ***
void Draw_window()
{
	int n;
	
	for(n=0; n<WINDOW_MAX; n++) {
		if(window_open[n]==NO) continue;
		
		SetFontZ(window_z[n]);	
		
		//MAIN BOX
		if(window_activ==n) Draw_Box(window_x[n], window_y[n], window_z[n], 3, window_w[n], window_h[n], 0x4080D0FF, NO);
		else Draw_Box(window_x[n], window_y[n], window_z[n], 3, window_w[n], window_h[n], 0x205070FF, NO);
		
		//TOP
		char TOP_str[255];
		FontSize(TOP_H_FONT);
		FontColor(WHITE);
		
		// TOP LEFT ICON
		u8 read_only=NO;
		int e;
		LINE_H=LINE_H1;
		if(strcmp(window_path[n], "/") != 0) {
			for(e=0; e<=DevicesInfo_N; e++) {
				if( strncmp(DevicesInfo[e].MountPoint, window_path[n], strlen(DevicesInfo[e].MountPoint)) == 0) {								
					read_only = DevicesInfo[e].ReadOnly;
					break;
				}
			}
			Draw_RootIcon(&window_path[n][1], _SDIR, window_x[n]+BORDER, window_y[n]+BORDER, window_z[n], read_only);
		} 
/*		else {
			Draw_RootIcon(NULL, _SFILE, window_x[n]+BORDER, window_y[n]+BORDER, window_z[n], YES);
		}
*/

		// title	
		strcpy(TOP_str, window_path[n]);
		if(strcmp(TOP_str, "/") == 0) {
			if(fm_LineSize==BIG) LINE_H = LINE_H1*2.0;
			else LINE_H = LINE_H1;
			
			COL_H = 0;
			strcpy(TOP_str, STR_ROOTLABEL);
		} else {
			COL_H = COL_H1;
			LINE_H = LINE_H1;
			
			if( WidthFromStr(TOP_str) > window_w[n] - BORDER-CONTROLBOX_W-CONTROLBOX_W-5) {
				sprintf(TOP_str, "...%s", strrchr(window_path[n], '/'));
				while(WidthFromStr(TOP_str) > window_w[n] - BORDER-CONTROLBOX_W-CONTROLBOX_W-5) {
					TOP_str[strlen(TOP_str)-1] = 0;
					TOP_str[strlen(TOP_str)-1] = 0;
					TOP_str[strlen(TOP_str)-1] = 0;
					TOP_str[strlen(TOP_str)-1] = 0;
					TOP_str[strlen(TOP_str)] = '.';
					TOP_str[strlen(TOP_str)] = '.';
					TOP_str[strlen(TOP_str)] = '.';
				}
			}
			if( is_dev_blind(TOP_str) ) {
				TOP_str[5]='f';
				TOP_str[6]='l';
				TOP_str[7]='a';
				TOP_str[8]='s';
				TOP_str[9]='h';
			}
		}
		DrawString(window_x[n]+BORDER+LINE_H1+CONTROLBOX_GAP, window_y[n]+BORDER+1.5, TOP_str);
		
		if(n==window_activ) {
			//CLOSE
			float CONTROLBOX_X = window_x[n]+window_w[n]-BORDER-CONTROLBOX_W;
			float CONTROLBOX_Y = window_y[n]+BORDER;
			
			u8 mouse_over = NO;
			if( is_float_window() == NO) {
				if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
				&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
				{
					mouse_over = YES;
				}
			}
			Draw_CloseBox(CONTROLBOX_X, CONTROLBOX_Y, window_z[n], CONTROLBOX_W, CONTROLBOX_H, mouse_over);
			
			//DOCK_R
			CONTROLBOX_X -= CONTROLBOX_GAP + CONTROLBOX_W;
			mouse_over = NO;
			
			if( is_float_window() == NO) {
				if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
				&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
				{
					mouse_over = YES;
				}
			}
			Draw_DockRightBox(CONTROLBOX_X, CONTROLBOX_Y, window_z[n], CONTROLBOX_W, CONTROLBOX_H, mouse_over);
			
			//DOCK_FULL
			CONTROLBOX_X -= CONTROLBOX_GAP + CONTROLBOX_W;
			mouse_over = NO;
			
			if( is_float_window() == NO) {
				if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
				&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
				{
					mouse_over = YES;
				}
			}
			Draw_DockMaxBox(CONTROLBOX_X, CONTROLBOX_Y, window_z[n], CONTROLBOX_W, CONTROLBOX_H, mouse_over);
			
			//DOCK_LEFT
			CONTROLBOX_X -= CONTROLBOX_GAP + CONTROLBOX_W;
			mouse_over = NO;
			
			if( is_float_window() == NO) {
				if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
				&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
				{
					mouse_over = YES;
				}
			}
			Draw_DockLeftBox(CONTROLBOX_X, CONTROLBOX_Y, window_z[n], CONTROLBOX_W, CONTROLBOX_H, mouse_over);
			
			
		}
		
		//CONTENT BOX
		Draw_Box(window_x[n]+BORDER, window_y[n]+TOP_H, window_z[n], 0,  window_w[n]-BORDER*2, window_h[n]-TOP_H-BORDER, 0xF0F0F0FF, NO);
		
		//SCROLL BAR
		window_item_N[n] = ((window_h[n] - TOP_H-COL_H-BORDER) / LINE_H) - 1;
		window_scroll_N[n] = 0;
		if(window_content_N[n] > window_item_N[n] ) window_scroll_N[n] = window_content_N[n] - window_item_N[n];
		if(window_scroll_P[n] > window_scroll_N[n]) window_scroll_P[n] = window_scroll_N[n];
			
		window_scroll_size[n] = (window_h[n]-TOP_H-COL_H-BORDER) - (SCROLL_H_MIN*window_scroll_N[n]);
		if( window_scroll_size[n] < SCROLL_H_MIN ) window_scroll_size[n] = SCROLL_H_MIN;
		
		if(window_scroll_N[n]>0) {
			
			SCROLL_W = SCROLL_W1;
			
			window_scroll_y[n]	= (window_h[n]-TOP_H-COL_H-window_scroll_size[n]-BORDER) * window_scroll_P[n] / window_scroll_N[n];
			if(n==window_activ) window_scroll_y[n] += curs_move_scroll;
			if(window_scroll_y[n] < 0) window_scroll_y[n]=0;
			
			Draw_Box(window_x[n]+window_w[n]-BORDER-SCROLL_W, window_y[n]+TOP_H+COL_H, window_z[n],  0, SCROLL_W, window_h[n]-TOP_H-COL_H-BORDER, 0xD0D0D0FF, NO);
			Draw_Box(window_x[n]+window_w[n]-BORDER-SCROLL_W, window_y[n]+TOP_H+COL_H+window_scroll_y[n], window_z[n], 0, SCROLL_W, window_scroll_size[n], 0x9090C0FF, NO);			
		} else {
			SCROLL_W = 0;
		}
		
		FontColor(BLACK);
		if(strcmp(window_path[n], "/") != 0 ) {
		
			//COLUMN HEADER BOX
			Draw_Box(window_x[n]+BORDER, window_y[n]+TOP_H,  window_z[n], 0, window_w[n]-BORDER*2, COL_H, 0xD4DBEDFF, NO); 
			DrawString(window_x[n]+BORDER+5, window_y[n]+TOP_H+3, STR_NAME);
					
			if(window_w_col_size[n]< COL_W_MIN) window_w_col_size[n]=COL_W_MIN;
			if(window_w[n] - window_w_col_size[n] - BORDER*2 - SCROLL_W < COL_W_MIN) window_w_col_size[n] = window_w[n] - COL_W_MIN - BORDER*2 - SCROLL_W;
					
			tiny3d_SetPolygon(TINY3D_LINES);
			tiny3d_VertexPos(window_x[n]+window_w[n] - BORDER-SCROLL_W-window_w_col_size[n], window_y[n]+TOP_H+2 , window_z[n]);
			tiny3d_VertexColor(0x505050FF);
			tiny3d_VertexPos(window_x[n]+window_w[n] - BORDER-SCROLL_W-window_w_col_size[n], window_y[n]+TOP_H+COL_H-2 , window_z[n]);
			tiny3d_End();
			
			DrawString(window_x[n]+window_w[n]-BORDER-SCROLL_W-window_w_col_size[n] + 5, window_y[n]+TOP_H+3, STR_SIZE);
		}

		// CONTENT
		int i;
		for(i=0 ; i<=window_item_N[n]; i++) {
			if(window_content_N[n] < i+window_scroll_P[n]) break;
			
			if(n==window_activ) {
				if( is_float_window() == NO) {
					if(  window_x[n]+BORDER				    < curs_x && curs_x < window_x[n]+window_w[n]-BORDER-SCROLL_W
					&&	 window_y[n]+TOP_H+COL_H+LINE_H*i	< curs_y && curs_y < window_y[n]+TOP_H+COL_H+LINE_H*(i+1) )
					{
						Draw_Box(window_x[n]+BORDER, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], 0,
								 window_w[n]-BORDER-SCROLL_W-BORDER, LINE_H,  OVERLAY_COLOR, NO);
					}
				}
			}
			
			if(window_content_Selected[n][i+window_scroll_P[n]] == YES) {
				Draw_Box(window_x[n]+BORDER, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], 0, 
						 window_w[n]-BORDER-SCROLL_W-BORDER, LINE_H,  0x0090FFFF, NO);
			}
			
			if( strcmp(window_path[n], "/")==0) {
				int j;
				u8 found=NO;
				for(j=0; j<=DevicesInfo_N; j++) {
					if( strcmp(&DevicesInfo[j].MountPoint[1], window_content_Name[n][window_scroll_P[n]+i]) == 0) {								
						found=YES;
						break;
					}
				}
				
				
				char mount_point[32];
				strcpy(mount_point, window_content_Name[n][window_scroll_P[n]+i]);
				if( is_dev_blind(mount_point) ) {
					mount_point[4]='f';
					mount_point[5]='l';
					mount_point[6]='a';
					mount_point[7]='s';
					mount_point[8]='h';
				}
				
				// ------------------------------------------------------------
				// TODO give a LABEL to dev_hdd0, dev_hdd1, dev_flash... etc. 
				// Save them in mgz directory.
				// ------------------------------------------------------------
			
				if( fm_LineSize == SMALL ) {
					
					FontSize(LINE_H);
					
					float Rx = window_x[n]+BORDER+LINE_H+5;
					float Ry = window_y[n]+TOP_H+COL_H+LINE_H*i+1;
					float Rw = window_w[n]- BORDER*2-SCROLL_W-LINE_H-5-5-5;
					float Rx2 = Rx + Rw;
							
					char *RowLeft  =NULL;
					char *RowRight =NULL;
					
					if(found) {
						RowLeft = FM_GetContent(fm_Format[0], mount_point, DevicesInfo[j]);
						RowRight = FM_GetContent(fm_Format[1], mount_point, DevicesInfo[j]);
					} else {
						RowLeft = strcpy_malloc(mount_point);
					}
					
					float wrl = WidthFromStr(RowLeft);
					float wrr = WidthFromStr(RowRight);
					
					if( Rx2 - wrr < Rx + wrl ) FREE(RowRight);
					
					if(RowLeft!=NULL) {
						DrawTXTInBox(Rx, 
									 Ry, 
									 window_z[n], 
									 Rw, 
									 1, 
									 RowLeft,
									 0, BLACK);
						FREE(RowLeft);
					}
					if(RowRight!=NULL) {
						DrawTXTInBox(Rx2 - wrr, 
									 Ry, 
									 window_z[n], 
									 wrr+5,
									 1,
									 RowRight, 
									 0, BLACK);
						FREE(RowRight);
					}
					
				} else 
				if( fm_LineSize == BIG ) {
					float Rx = window_x[n]+BORDER+LINE_H+5;
					float Ry = window_y[n]+TOP_H+COL_H+LINE_H*i+1;
					float Rw = window_w[n]- BORDER*2-SCROLL_W-LINE_H-5-5-5;
					float Rx2 = Rx + Rw;
					
					u8 outside = NO;
					int k;		
					for(k=0; k<=fm_RowNumber*2; k+=2) {
						u8 f = FM_GetFormat(fm_Format[k]);
						if(FM_FORMAT_CAPACITY <= f) {
							if(fm_CapacityBarWidth != 0) Rx2 = Rx + fm_CapacityBarWidth;
							if(f==FM_FORMAT_CAPACITY_MEMOUTSIDE) outside=YES;
							break;
						}
					}
					
					for(k=0; k<=fm_RowNumber*2; k+=2) {
						FontSize(fm_FontRowSize[k/2]);
						u8 f = FM_GetFormat(fm_Format[k]);
						
						if(k!=0) Ry+=fm_FontRowSize[k/2]/4.0;
						
						if( f < FM_FORMAT_CAPACITY ) {
							
							char *RowLeft = NULL;
							char *RowRight= NULL;
							
							if( found ) {
								RowLeft = FM_GetContent(fm_Format[k], mount_point, DevicesInfo[j]);							
								RowRight = FM_GetContent(fm_Format[k+1], mount_point, DevicesInfo[j]);
							} else {
								if(FM_FORMAT_MOUNTPOINT<=f) {
									RowLeft = strcpy_malloc(mount_point);
								}
							}
							float wrl = WidthFromStr(RowLeft);
							float wrr = WidthFromStr(RowRight);
					
							if( outside == NO && Rx2 - wrr < Rx + wrl ) FREE(RowRight);
							if( outside == YES && Rx2 < Rx + wrl) FREE(RowRight);
							if( outside == YES && Rx + Rw < Rx2 + wrr) FREE(RowRight);
							
							if(RowLeft!=NULL) {
								DrawTXTInBox(Rx, 
											 Ry, 
											 window_z[n], 
											 Rw, 
											 1, 
											 RowLeft, 
											 0, BLACK);
								FREE(RowLeft);
							}
							if(RowRight!=NULL) {
								float wr = 3 ;
								if( outside == NO ) wr = -wrr;
								DrawTXTInBox(Rx2 + wr, 
											 Ry, 
											 window_z[n], 
											 wrr+5, 
											 1, 
											 RowRight, 
											 0, BLACK);
								FREE(RowRight);
							}							
						} 
						else 
						if( FM_FORMAT_CAPACITY <= f && found) {
							if( DevicesInfo[j].TotalSpace != 0 ) {
								float wc = fm_CapacityBarWidth;
								if( wc == 0 ) wc = Rw;
								float xc = 5.0;
								if(outside) xc = wc + 3;
								if(Rx + Rw < Rx + wc ) wc = Rw;
								
								DrawCapacityBar(Rx, 
												Ry, 
												window_z[n],
												wc, 
												fm_FontRowSize[k/2] - fm_FontRowSize[k/2]/6.0, 
												DevicesInfo[j].TotalSpace, 
												DevicesInfo[j].FreeSpace); 
								
								if ( FM_FORMAT_CAPACITY != f ) 
								{
									char MemRow[128];
									char *Total_str = get_unit(DevicesInfo[j].TotalSpace);
									char *Free_str = get_unit(DevicesInfo[j].FreeSpace);
									sprintf(MemRow, "%s %s %s", Free_str, STR_FREEOF, Total_str);
									FREE(Total_str);
									FREE(Free_str);
									
									float Rcy = Ry;
									if(outside) {
										if( Rx + Rw < Rx + xc + WidthFromStr(MemRow)) Rcy = -50;
									}
																		
									DrawTXTInBox(Rx+xc,
												 Rcy,
												 window_z[n], 
												 wc, 1, MemRow, 0, BLACK);
								}
							
							}
						}
						
						
						Ry+=fm_FontRowSize[k/2] - fm_FontRowSize[k/2]/4.0;
					}
				}
				
				// ICONS
				Draw_RootIcon(window_content_Name[n][window_scroll_P[n]+i], window_content_Type[n][window_scroll_P[n]+i], window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], DevicesInfo[j].ReadOnly);
				
				continue;
			}
				
			DrawTXTInBox(window_x[n]+BORDER+LINE_H+5, 
						 window_y[n]+TOP_H+COL_H+LINE_H*i + 2, 
						 window_z[n], 
						 window_w[n]- BORDER*2-SCROLL_W-window_w_col_size[n]-LINE_H-5-5-5, 
						 1, 
						 window_content_Name[n][window_scroll_P[n]+i], 
						 0, BLACK);
							 
			
			if( is_folder(window_content_Type[n][window_scroll_P[n]+i]) == NO && strcmp(window_path[n], "/") != 0) {
				char *size_str = get_unit(window_content_Size[n][window_scroll_P[n]+i]);
				float size_str_w = WidthFromStr(size_str);
				DrawString(window_x[n]+window_w[n]-BORDER-SCROLL_W-size_str_w - 5  , window_y[n]+TOP_H+COL_H+LINE_H*i, size_str);
				free(size_str);
			}
				
			char *ext = window_content_Type[n][window_scroll_P[n]+i];
			
			if( is_folder(ext) ) {
				DrawIcon_Directory(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n]);
			} else
			if(can_view(ext)) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], GREEN);
			} else
			if(can_read(ext)) {
				DrawIcon_TXT(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], WHITE);
			} else
			if( !strcasecmp(ext, ".self") || !strcasecmp(ext, ".sprx") || !strcmp(ext, _EBOOT_BIN)) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], RED);
			} else
			if( !strcasecmp(ext, ".elf") || !strcasecmp(ext, ".prx") || !strcmp(ext, _EBOOT_ELF)) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], ORANGE);
			} else
			if(!strcasecmp(ext, ".pkg")) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], BLUE);
			} else
			if(!strcasecmp(ext, ".rco")) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], PURPLE);
			} else
			if(!strcasecmp(ext, ".trp")) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], PINK);
			} else
			if(!strcasecmp(ext, ".sfo")) {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], GREY);
			} else
			if(!strcasecmp(ext, ".iso")) {
				Draw_DISK(window_x[n]+BORDER+1 , window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], LINE_H, COLOR_ISO);
			} else {
				DrawIcon_File(window_x[n]+BORDER+2, window_y[n]+TOP_H+COL_H+LINE_H*i, window_z[n], WHITE);
			}
		}
	}
}

void Draw_cursor()
{	
	if(loading) return;
	if(picture_viewer_activ) return;
	if(txt_viewer_activ) return;
	
	// main colors, separated here because eventually can be passed as arguments of the function
	u32 cci = 0xffffffff; // cursor color in
	u32 cco = 0x000000ff; // cursor color out
	u32 ccp = 0x70ff70ff; // cursor color push
	
	// shadow colors, separated here for alpha tests
	u32 sci = 0x00000080; // shadow color in
	u32 sco = 0x00000040; // shadow color out
	
	if(curs_push == YES) cci = ccp;
	
	if(window_resize_H == YES) {
		if(PICTURE_offset[CURSOR_H] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[CURSOR_H], PICTURE[CURSOR_H].width, PICTURE[CURSOR_H].height, PICTURE[CURSOR_H].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(curs_x-12.5, curs_y-5.5, 0, 0, 25, 11, cci, YES);
		}
		else {
			// shadows
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x-4 , curs_y+3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-3 , curs_y+3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x-4 , curs_y-3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-3 , curs_y-3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x+4 , curs_y+3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+5 , curs_y+3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+8 , curs_y   , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+9 , curs_y   , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+4 , curs_y-3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+5 , curs_y-3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			
			// heads
			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(curs_x-8 , curs_y   , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x-4 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x-4 , curs_y-3 , 0);
			tiny3d_VertexPos(curs_x+8 , curs_y   , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y-3 , 0);
			tiny3d_End();
			
			// shaft
			tiny3d_SetPolygon(TINY3D_TRIANGLE_STRIP);
			tiny3d_VertexPos(curs_x-4 , curs_y+1 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x+4 , curs_y+1 , 0);
			tiny3d_VertexPos(curs_x-4 , curs_y-1 , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y-1 , 0);
			tiny3d_End();
			
			// outline
			tiny3d_SetPolygon(TINY3D_LINE_LOOP);
			tiny3d_VertexPos(curs_x-8 , curs_y   , 0);
			tiny3d_VertexColor(cco);
			tiny3d_VertexPos(curs_x-4 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x-4 , curs_y+1 , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y+1 , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x+8 , curs_y   , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y-3 , 0);
			tiny3d_VertexPos(curs_x+4 , curs_y-1 , 0);
			tiny3d_VertexPos(curs_x-4 , curs_y-1 , 0);
			tiny3d_VertexPos(curs_x-4 , curs_y-3 , 0);
			tiny3d_End();
		}
	} else 
	if(window_resize_V == YES) {
		if(PICTURE_offset[CURSOR_V] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[CURSOR_V], PICTURE[CURSOR_V].width, PICTURE[CURSOR_V].height, PICTURE[CURSOR_V].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(curs_x-5.5, curs_y-12.5, 0, 0, 11, 25, cci, YES);
		}
		else {
			// shadows
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x   , curs_y-8 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+1 , curs_y-8 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+3 , curs_y-4 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+4 , curs_y-4 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x+1 , curs_y-4 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+2 , curs_y-4 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+1 , curs_y+4 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+2 , curs_y+4 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x+3 , curs_y+4 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+4 , curs_y+4 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x   , curs_y+8 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+1 , curs_y+8 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			
			// heads
			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(curs_x   , curs_y-8 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x-3 , curs_y-4 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y-4 , 0);
			tiny3d_VertexPos(curs_x   , curs_y+8 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y+4 , 0);
			tiny3d_VertexPos(curs_x-3 , curs_y+4 , 0);
			tiny3d_End();
			
			// shaft
			tiny3d_SetPolygon(TINY3D_TRIANGLE_STRIP);
			tiny3d_VertexPos(curs_x-1 , curs_y+4 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x+1 , curs_y+4 , 0);
			tiny3d_VertexPos(curs_x-1 , curs_y-4 , 0);
			tiny3d_VertexPos(curs_x+1 , curs_y-4 , 0);
			tiny3d_End();
			
			// outline
			tiny3d_SetPolygon(TINY3D_LINE_LOOP);
			tiny3d_VertexPos(curs_x   , curs_y-8 , 0);
			tiny3d_VertexColor(cco);
			tiny3d_VertexPos(curs_x+3 , curs_y-4 , 0);
			tiny3d_VertexPos(curs_x+1 , curs_y-4 , 0);
			tiny3d_VertexPos(curs_x+1 , curs_y+4 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y+4 , 0);
			tiny3d_VertexPos(curs_x   , curs_y+8 , 0);
			tiny3d_VertexPos(curs_x-3 , curs_y+4 , 0);
			tiny3d_VertexPos(curs_x-1 , curs_y+4 , 0);
			tiny3d_VertexPos(curs_x-1 , curs_y-4 , 0);
			tiny3d_VertexPos(curs_x-3 , curs_y-4 , 0);
			tiny3d_End();
		}
	} else
	if(window_resize_D1 == YES) {
		if(PICTURE_offset[CURSOR_D1] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[CURSOR_D1], PICTURE[CURSOR_D1].width, PICTURE[CURSOR_D1].height, PICTURE[CURSOR_D1].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(curs_x-9.5, curs_y-9.5, 0, 0, 19, 19, cci, YES);
		}
		else {
			// shadows
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x-6 , curs_y-6 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-5 , curs_y-6 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x   , curs_y-5 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+1 , curs_y-5 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x-2 , curs_y-3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-1 , curs_y-3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+3 , curs_y+2 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+4 , curs_y+2 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x+5 , curs_y   , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+6 , curs_y   , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+6 , curs_y+6 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+7 , curs_y+6 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x-5 , curs_y   , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-4 , curs_y   , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x-3 , curs_y-2 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-2 , curs_y-2 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			
			// heads
			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(curs_x-6 , curs_y-6 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x   , curs_y-5 , 0);
			tiny3d_VertexPos(curs_x-5 , curs_y   , 0);
			tiny3d_VertexPos(curs_x+6 , curs_y+6 , 0);
			tiny3d_VertexPos(curs_x   , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x+5 , curs_y   , 0);
			tiny3d_End();
			
			// shaft
			tiny3d_SetPolygon(TINY3D_TRIANGLE_STRIP);
			tiny3d_VertexPos(curs_x-3 , curs_y-2 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x+2 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x-2 , curs_y-3 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y+2 , 0);
			tiny3d_End();
			
			// outline
			tiny3d_SetPolygon(TINY3D_LINE_LOOP);
			tiny3d_VertexPos(curs_x-6 , curs_y-6 , 0);
			tiny3d_VertexColor(cco);
			tiny3d_VertexPos(curs_x   , curs_y-5 , 0);
			tiny3d_VertexPos(curs_x-2 , curs_y-3 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y+2 , 0);
			tiny3d_VertexPos(curs_x+5 , curs_y   , 0);
			tiny3d_VertexPos(curs_x+6 , curs_y+6 , 0);
			tiny3d_VertexPos(curs_x   , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x+2 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x-3 , curs_y-2 , 0);
			tiny3d_VertexPos(curs_x-5 , curs_y   , 0);
			tiny3d_End();
		}
	} else
	if(window_resize_D2 == YES) {
		if(PICTURE_offset[CURSOR_D2] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[CURSOR_D2], PICTURE[CURSOR_D2].width, PICTURE[CURSOR_D2].height, PICTURE[CURSOR_D2].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(curs_x-9.5, curs_y-9.5, 0, 0, 19, 19, cci, YES);
		}
		else {
			// shadows
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x-6 , curs_y+6 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-5 , curs_y+6 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x   , curs_y+5 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+1 , curs_y+5 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x-2 , curs_y+3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-1 , curs_y+3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+3 , curs_y-2 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+4 , curs_y-2 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x+5 , curs_y   , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+6 , curs_y   , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+6 , curs_y-6 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+7 , curs_y-6 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x-5 , curs_y   , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-4 , curs_y   , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x-3 , curs_y+2 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x-2 , curs_y+2 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			
			// heads
			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(curs_x-6 , curs_y+6 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x-5 , curs_y   , 0);
			tiny3d_VertexPos(curs_x   , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x+6 , curs_y-6 , 0);
			tiny3d_VertexPos(curs_x+5 , curs_y   , 0);
			tiny3d_VertexPos(curs_x   , curs_y-5 , 0);
			tiny3d_End();
			
			// shaft
			tiny3d_SetPolygon(TINY3D_TRIANGLE_STRIP);
			tiny3d_VertexPos(curs_x-3 , curs_y+2 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x-2 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x+2 , curs_y-3 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y-2 , 0);
			tiny3d_End();
			
			// outline
			tiny3d_SetPolygon(TINY3D_LINE_LOOP);
			tiny3d_VertexPos(curs_x-6 , curs_y+6 , 0);
			tiny3d_VertexColor(cco);
			tiny3d_VertexPos(curs_x   , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x-2 , curs_y+3 , 0);
			tiny3d_VertexPos(curs_x+3 , curs_y-2 , 0);
			tiny3d_VertexPos(curs_x+5 , curs_y   , 0);
			tiny3d_VertexPos(curs_x+6 , curs_y-6 , 0);
			tiny3d_VertexPos(curs_x   , curs_y-5 , 0);
			tiny3d_VertexPos(curs_x+2 , curs_y-3 , 0);
			tiny3d_VertexPos(curs_x-3 , curs_y+2 , 0);
			tiny3d_VertexPos(curs_x-5 , curs_y   , 0);
			tiny3d_End();
		}
	}
	else {
		if(PICTURE_offset[CURSOR] != 0) {
			tiny3d_SetTexture(0, PICTURE_offset[CURSOR], PICTURE[CURSOR].width, PICTURE[CURSOR].height, PICTURE[CURSOR].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(curs_x+1, curs_y+1, 0, 0, 11, 17, cci, YES);
		}
		else {
			// shadows
			tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
			tiny3d_VertexPos(curs_x,    curs_y,    0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+1,  curs_y,    0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+9 , curs_y+3 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+10, curs_y+3 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+6 , curs_y+5 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+7 , curs_y+5 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+12, curs_y+11, 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+13, curs_y+11, 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+11, curs_y+12, 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+12, curs_y+12, 0);
			tiny3d_VertexColor(sco);
			tiny3d_VertexPos(curs_x+5 , curs_y+6 , 0);
			tiny3d_VertexColor(sci);
			tiny3d_VertexPos(curs_x+6 , curs_y+6 , 0);
			tiny3d_VertexColor(sco);
			tiny3d_End();
			
			// head
			tiny3d_SetPolygon(TINY3D_TRIANGLE_FAN);
			tiny3d_VertexPos(curs_x, curs_y, 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x+3 , curs_y+9 , 0);
			tiny3d_VertexPos(curs_x+5 , curs_y+6 , 0);
			tiny3d_VertexPos(curs_x+6 , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x+9 , curs_y+3 , 0);
			tiny3d_End();
			
			// shaft
			tiny3d_SetPolygon(TINY3D_TRIANGLE_STRIP);
			tiny3d_VertexPos(curs_x+5,  curs_y+6 , 0);
			tiny3d_VertexColor(cci);
			tiny3d_VertexPos(curs_x+6 , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x+11, curs_y+12, 0);
			tiny3d_VertexPos(curs_x+12, curs_y+11, 0);
			tiny3d_End();
			
			// outline
			tiny3d_SetPolygon(TINY3D_LINE_LOOP);
			tiny3d_VertexPos(curs_x , curs_y , 0);
			tiny3d_VertexColor(cco);
			tiny3d_VertexPos(curs_x+3 , curs_y+9 , 0);
			tiny3d_VertexPos(curs_x+5 , curs_y+6 , 0);
			tiny3d_VertexPos(curs_x+11, curs_y+12, 0);
			tiny3d_VertexPos(curs_x+12, curs_y+11, 0);
			tiny3d_VertexPos(curs_x+6 , curs_y+5 , 0);
			tiny3d_VertexPos(curs_x+9 , curs_y+3 , 0);
			tiny3d_End();
		}
	}
}

void sort(int window_id)
{
	if(window_id==-1) return;
	
	if(strcmp(window_path[window_id], "/") == 0) window_sort[window_id] = ASC;
	
	int min;
	u8 t;
	u64 t1;
	int i, j;
	int Folder_N = -1;
	int File_N = -1;
	
	for (i = 0; i<=window_content_N[window_id]; i++) {
		if(strcmp(window_content_Name[window_id][i], "..") == 0) continue;
		if( is_folder(window_content_Type[window_id][i]) ) Folder_N++;
		else File_N++;
	}
	
	char **list_Dir = (char **) malloc( (Folder_N+2) * sizeof(char*) );
	u8 *list_Dir_sel = (u8 *) malloc( (Folder_N+2) * sizeof(u8) );
	char **list_Dir_type = (char **) malloc( (Folder_N+2) * sizeof(char*) );
	
	char **list_Fil = (char **) malloc( (File_N+2) * sizeof(char*) );
	u64 *list_Fil_siz = (u64 *) malloc( (File_N+2) * sizeof(u64) );
	u8 *list_Fil_sel = (u8 *) malloc( (File_N+2) * sizeof(u8) );
	char **list_Fil_type = (char **) malloc( (File_N+2) * sizeof(char*) );
	

	Folder_N = -1;
	File_N = -1;
	for (i = 0; i<=window_content_N[window_id]; i++) {
		if(strcmp(window_content_Name[window_id][i], "..") == 0) continue;
		if( is_folder(window_content_Type[window_id][i]) ) {
			Folder_N++;
			list_Dir[Folder_N] = strcpy_malloc(window_content_Name[window_id][i]);
			list_Dir_sel[Folder_N] = window_content_Selected[window_id][i];
			list_Dir_type[Folder_N] = strcpy_malloc(window_content_Type[window_id][i]);
		} else {
			File_N++;
			list_Fil[File_N] = strcpy_malloc(window_content_Name[window_id][i]);
			list_Fil_sel[File_N] = window_content_Selected[window_id][i];
			list_Fil_siz[File_N] = window_content_Size[window_id][i];
			list_Fil_type[File_N] = strcpy_malloc(window_content_Type[window_id][i]);
		}
	}
	
	char *ta=NULL;
	char *tb=NULL;
	
	for (i = 0; i<Folder_N; i++) { 
		min = i;
		for (j = i+1; j <= Folder_N; j++) { 
			FREE(ta);
			FREE(tb);
			ta = strcpy_malloc(list_Dir[j]);
			tb = strcpy_malloc(list_Dir[min]);
			if(ta[0]>=97 && ta[0]<=123) ta[0]-=32;
			if(tb[0]>=97 && tb[0]<=123) tb[0]-=32;
			if(window_sort[window_id] == ASC) {
				if(strcasecmp(ta, tb) < 0) min = j;
			} else if(strcasecmp(ta, tb) > 0) min = j;
		}
		if(min==i) continue;
		
		FREE(ta);
		ta = strcpy_malloc(list_Dir[min]);
		FREE(list_Dir[min]);
		list_Dir[min] = strcpy_malloc(list_Dir[i]);
		FREE(list_Dir[i]);
		list_Dir[i] = strcpy_malloc(ta);
		
		t = list_Dir_sel[min];
		list_Dir_sel[min] = list_Dir_sel[i];
		list_Dir_sel[i] = t;
		
		FREE(ta);
		ta = strcpy_malloc(list_Dir_type[min]);
		FREE(list_Dir_type[min]);
		list_Dir_type[min] = strcpy_malloc(list_Dir_type[i]);
		FREE(list_Dir_type[i]);
		list_Dir_type[i] = strcpy_malloc(ta);
	}
	
	for (i = 0; i<File_N; i++) { 
		min = i;
		for (j = i+1; j <= File_N; j++) {
			FREE(ta);
			FREE(tb);
			ta = strcpy_malloc(list_Fil[j]);
			tb = strcpy_malloc(list_Fil[min]);
			if(ta[0]>=97 && ta[0]<=123) ta[0]-=32;
			if(tb[0]>=97 && tb[0]<=123) tb[0]-=32;
			if(window_sort[window_id] == ASC) {
				if(strcasecmp(ta, tb) < 0) min = j;
			} else if(strcasecmp(ta, tb) > 0) min = j;
		}
		if(min==i) continue;
		
		FREE(ta);
		ta = strcpy_malloc(list_Fil[min]);
		FREE(list_Fil[min]);
		list_Fil[min] = strcpy_malloc(list_Fil[i]);
		FREE(list_Fil[i]);
		list_Fil[i] = strcpy_malloc(ta);
		
		t = list_Fil_sel[min];
		list_Fil_sel[min] = list_Fil_sel[i];
		list_Fil_sel[i] = t;
		
		t1 = list_Fil_siz[min];
		list_Fil_siz[min] = list_Fil_siz[i];
		list_Fil_siz[i] = t1;

		FREE(ta);
		ta = strcpy_malloc(list_Fil_type[min]);
		FREE(list_Fil_type[min]);
		list_Fil_type[min] = strcpy_malloc(list_Fil_type[i]);
		FREE(list_Fil_type[i]);
		list_Fil_type[i] = strcpy_malloc(ta);
	}
	FREE(ta);
	FREE(tb);
	
	u32 n;
	for(n=0; n<WINDOW_MAX_ITEMS; n++) FREE(window_content_Name[window_id][n]);
	
	u8 Parent=NO;
	if(strcmp(window_path[window_id], "/") != 0) {
		Parent=YES;
		window_content_Name[window_id][0] = strcpy_malloc("..");
		window_content_Selected[window_id][0] = NO;
		window_content_Type[window_id][0] = strcpy_malloc(_SDIR);
		window_content_Size[window_id][0] = 0;
	}

	if(window_sort[window_id] == ASC) {
		for(j=0; j<=Folder_N; j++) {
			window_content_Name[window_id][j+Parent] = strcpy_malloc(list_Dir[j]);
			window_content_Selected[window_id][j+Parent] = list_Dir_sel[j];
			window_content_Type[window_id][j+Parent] = strcpy_malloc(list_Dir_type[j]);
			window_content_Size[window_id][j+Parent] = 0;
		}
		for(j=0; j<=File_N; j++) {
			window_content_Name[window_id][j+Parent+Folder_N+1] = strcpy_malloc(list_Fil[j]);
			window_content_Selected[window_id][j+Parent+Folder_N+1] = list_Fil_sel[j];
			window_content_Type[window_id][j+Parent+Folder_N+1] = strcpy_malloc(list_Fil_type[j]);
			window_content_Size[window_id][j+Parent+Folder_N+1] = list_Fil_siz[j];
		}
	} else {
		for(j=0; j<=File_N; j++) {
			window_content_Name[window_id][j+Parent] = strcpy_malloc(list_Fil[j]);
			window_content_Selected[window_id][j+Parent] = list_Fil_sel[j];
			window_content_Type[window_id][j+Parent] = strcpy_malloc(list_Fil_type[j]);
			window_content_Size[window_id][j+Parent] = list_Fil_siz[j];
		}
		for(j=0; j<=Folder_N; j++) {
			window_content_Name[window_id][j+Parent+File_N+1] = strcpy_malloc(list_Dir[j]);
			window_content_Selected[window_id][j+Parent+File_N+1] = list_Dir_sel[j];
			window_content_Type[window_id][j+Parent+File_N+1] = strcpy_malloc(list_Dir_type[j]);
			window_content_Size[window_id][j+Parent+File_N+1] = 0;
		}
	}
	
	
	FREE(list_Dir);
	FREE(list_Dir_sel);
	FREE(list_Dir_type);
	FREE(list_Fil);
	FREE(list_Fil_siz);
	FREE(list_Fil_sel);
	FREE(list_Fil_type);
}

void CloseWindow(int window_id)
{
	if(window_id==-1) return;
	
	u32 i;
	
	FREE(window_path[window_id]);
	FREE(window_lastpath[window_id]);	
	for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(window_content_Name[window_id][i]);
	FREE(window_content_Name[window_id]);
	FREE(window_content_Size[window_id]);
	for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(window_content_Type[window_id][i]);
	FREE(window_content_Type[window_id]);
	FREE(window_content_Selected[window_id]);
	
	window_open[window_id] = NO;
	
	if(window_id == window_activ) {
		
		window_z[window_id]=0.0;
		window_activ=-1;
		
		for(i=0; i<WINDOW_MAX; i++) {
			if(window_open[i] == NO) continue;
			if(window_activ==-1) window_activ=i; else
			if(window_z[window_activ] > window_z[i]) window_activ=i; 
		}
		
		if(window_activ != -1) {
			window_z[window_activ] = 1.0f;
			for(i=0; i<WINDOW_MAX; i++) {
				if(window_open[i] == NO) continue;
				if(i==window_activ) continue;
				window_z[i]+=1.0f;
			}
		}
		
		
	}
	
	
}

u8 OpenWindow()
{
	print_debug("start of Open window");
	
	u32 n;
	for(n=0; n<WINDOW_MAX; n++){
		if( window_open[n] == NO ) {
			window_open[n] = YES;
			break;
		}
		if(n==WINDOW_MAX-1) {
			show_msg("MAX Windows");
			return FAILED;
		}
	}
	
	window_activ=n;
	
	SetWindowLocation(WINDOW_LOC_DEFAULT);
	
	window_lastpath[window_activ] = (char *) malloc(WINDOW_MAX_PATH_LENGTH * sizeof(char));
	window_path[window_activ] = (char *) malloc(WINDOW_MAX_PATH_LENGTH * sizeof(char));
	
	window_content_Type[window_activ] = (char **) malloc(WINDOW_MAX_ITEMS * sizeof(char *));
	window_content_Name[window_activ] = (char **) malloc(WINDOW_MAX_ITEMS * sizeof(char *));
	
	for(n=0; n<WINDOW_MAX_ITEMS; n++) {
		window_content_Name[window_activ][n]=NULL;
		window_content_Type[window_activ][n]=NULL;
	}

	window_content_Size[window_activ] = (u64 *) malloc(WINDOW_MAX_ITEMS * sizeof(u64));
	
	window_content_Selected[window_activ] = (u8 *) malloc(WINDOW_MAX_ITEMS * sizeof(u8));
	
	strcpy(window_path[window_activ], "/");
	strcpy(window_lastpath[window_activ], window_path[window_activ]);
	
	for(n=0; n<WINDOW_MAX; n++) {
		if(window_open[n] == YES && n != window_activ) {
			window_z[n]+=1.0f;
		}
	}
	
	window_z[window_activ]=1.0f;
	
	print_debug("End of Open window");
	
	return SUCCESS;
}

void UpdateLastPath()
{
	if( strncmp(window_lastpath[window_activ], window_path[window_activ], strlen(window_path[window_activ])) != 0) {
        strcpy(window_lastpath[window_activ], window_path[window_activ]);
    }
}

void RefreshDevices()
{
	memset(DevicesInfo, 0, sizeof(DevicesInfo));
	
	char temp[512];
	DevicesInfo_N=-1;
	DIR *d;
	struct dirent *dir;
	
	u8 hide_dev_flash=dev_blind_exist();
	
	d = opendir("/");
	if(d==NULL) return;
	while ((dir = readdir(d))) {
		if(strcmp(dir->d_name, ".")==0) continue;
		if(strcmp(dir->d_name, "..")==0) continue; 
		if(!strncmp(dir->d_name, "$", 1)) continue;
		
		if( !strcmp(dir->d_name, "dev_flash") && hide_dev_flash ) continue;
		
		DevicesInfo_N++;
		sprintf(temp, "/%s/", dir->d_name);
		GetDeviceInfo(temp, &DevicesInfo[DevicesInfo_N]);
	}
	closedir(d);
	
// can't see NTFS / exFAT with opendir("/")
	int r,i;
	for(i = 0; i < 8 ; i++) {
		r = -1;
		sprintf(temp, "ntfs%c", 48+i);
		r = NTFS_Test_Device(temp);
		if(r>=0) {
			sprintf(temp, "/ntfs%c:/", 48+i);
			DevicesInfo_N++;
			GetDeviceInfo(temp, &DevicesInfo[DevicesInfo_N]);
		}
	}

	for(i=0; i < MAXFDS; i++) {
		if( exFAT_is_mounted(i) == YES ) {
			sprintf(temp, "/exFAT%d:/", i);
			DevicesInfo_N++;
			GetDeviceInfo(temp, &DevicesInfo[DevicesInfo_N]);
		}
	}

}

void RefreshWindow(s8 window_id)
{	
	if(window_id < 0 || WINDOW_MAX < window_id) return;
	
	char temp[512];
	int n, i; 
	if(window_open[window_id] == NO) return;
	
	// clear
	window_content_N[window_id]=-1;
	for(n=0; n<WINDOW_MAX_ITEMS; n++) {
		FREE(window_content_Name[window_id][n]);
		FREE(window_content_Type[window_id][n]);
		window_content_Size[window_id][n] = 0;
		window_content_Selected[window_id][n] = NO;
	}
	
	u8 hide_dev_flash=dev_blind_exist();
	if( hide_dev_flash && !strncmp(window_path[window_id], "/dev_flash", 10) ) {
		if(path_info("/dev_blind") != _NOT_EXIST) {
			window_path[window_id][5]='b';
			window_path[window_id][6]='l';
			window_path[window_id][7]='i';
			window_path[window_id][8]='n';
			window_path[window_id][9]='d';
		} else 
		if(path_info("/dev_rebug") != _NOT_EXIST) {
			window_path[window_id][5]='r';
			window_path[window_id][6]='e';
			window_path[window_id][7]='b';
			window_path[window_id][8]='u';
			window_path[window_id][9]='g';
		}
	}
	
	// OpenDir
	DIR *d;
	struct dirent *dir;
	
	d = opendir(window_path[window_id]);
	if(d==NULL) return;
	
	while ((dir = readdir(d))) {
		if(strcmp(dir->d_name, ".")==0) continue;
		if(strcmp(dir->d_name, "..")==0) continue; // NTFS : added for all directories after
		if(!strncmp(dir->d_name, "$", 1)) continue; // NTFS : ignore system files

		if(window_content_N[window_id] == WINDOW_MAX_ITEMS-1) {
			show_msg("Too many files...");
			closedir(d);
			sort(window_id);
			return;
		}
		
		if( hide_dev_flash ) {
			if(strcmp(window_path[window_id], "/") == 0) {
				if( !strcmp(dir->d_name, "dev_flash")) continue;
			}
		}
		
		window_content_N[window_id]++;
		
		if(dir->d_type & DT_DIR) {
			window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SDIR);
			if(strcmp(window_path[window_id], "/") == 0) {
				if(strcmp(dir->d_name, "app_home") == 0 || strcmp(dir->d_name, "dev_bdvd") == 0) {
					sprintf(temp, "/%s", dir->d_name);
					window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(get_ext(temp));
				}
			}
		} else 
		if(dir->d_type & DT_REG) {
			if(strcmp(window_path[window_id], "/") != 0) {
				sprintf(temp, "%s/%s", window_path[window_id], dir->d_name);
				window_content_Size[window_id][window_content_N[window_id]] = get_size(temp);	
			}
			window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(get_ext(dir->d_name));
		} 
		else {
			if(strcmp(window_path[window_id], "/") == 0) {
				sprintf(temp, "/%s", dir->d_name);
				if( can_opendir(temp) ) {
					window_content_Type[window_id][window_content_N[window_id]] = get_ext(temp);
					if( is_folder(window_content_Type[window_id][window_content_N[window_id]]) == NO) {
						window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SDIR);
					}
				} else {
					window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SFILE);
				}
			} else {
				sprintf(temp, "%s/%s", window_path[window_id], dir->d_name);
				if( can_opendir(temp) ) {
					window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SDIR);
				} else {
					window_content_Size[window_id][window_content_N[window_id]] = get_size(temp);
					window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(get_ext(dir->d_name));
				}
			}
		}
		window_content_Name[window_id][window_content_N[window_id]] = strcpy_malloc(dir->d_name);
	}
	closedir(d);
	
	if(strcmp(window_path[window_id], "/") == 0) {
		// can't see NTFS with opendir("/")
		for(i = 0; i < 8 ; i++) {
			n = -1;
			sprintf(temp, "ntfs%c", 48+i);
			n = NTFS_Test_Device(temp);
			if(n>=0) {
				window_content_N[window_id]++;
				window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SDIR);
				sprintf(temp, "ntfs%c:", 48+i);
				window_content_Name[window_id][window_content_N[window_id]] = strcpy_malloc(temp);
			}
		}
		
		for(i = 0; i < MAXFDS; i++) {
			if( exFAT_is_mounted(i) ) {
				window_content_N[window_id]++;
				window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SDIR);
				sprintf(temp, "exFAT%d:", i);
				window_content_Name[window_id][window_content_N[window_id]] = strcpy_malloc(temp);	
			}
		}
		
	} else {
		window_content_N[window_id]++;
		window_content_Type[window_id][window_content_N[window_id]] = strcpy_malloc(_SDIR);
		window_content_Name[window_id][window_content_N[window_id]] = strcpy_malloc("..");
	}
	
	sort(window_id);
}

void Window(char *directory)
{
	char temp[512];
	
	if(directory==NULL) {
		if( OpenWindow() == FAILED) return;		
	} else 
	if(strcmp(directory, "..") == 0) {
		if(window_activ==-1) return;
		if(strcmp(window_path[window_activ], "/") == 0) return;
		strcpy(temp, window_path[window_activ]);
		temp[strrchr(temp, '/') - temp] = 0;
		memset(window_path[window_activ], 0, sizeof(window_path[window_activ]));
		strcpy(window_path[window_activ], temp);
		if(window_path[window_activ][0] == 0) window_path[window_activ][0] = '/';
	} else
	if(strcmp(directory, ".") == 0) {
		//refresh;
		if(window_activ==-1) return;
	} else {
		if(window_activ==-1) return;
		if(strcmp(window_path[window_activ], "/") != 0) {
			strcat(window_path[window_activ], "/");
		}
		strcat(window_path[window_activ], directory);
		UpdateLastPath();
	}
	
#ifdef RPCS3
	
	window_content_N[window_activ]=-1;
	int n;
	for(n=0; n<WINDOW_MAX_ITEMS; n++) {
		FREE(window_content_Name[window_activ][n]);
		FREE(window_content_Type[window_activ][n]);
		window_content_Size[window_activ][n] = 0;
		window_content_Selected[window_activ][n] = NO;
	}
	
	if(strcmp(window_path[window_activ], "/") == 0) {
		DevicesInfo_N=-1;
		memset(DevicesInfo, 0, sizeof(DevicesInfo));
		
		window_content_N[window_activ]++;
		window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
		window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc("dev_hdd0");
		DevicesInfo_N++;
		GetDeviceInfo("/dev_hdd0/", &DevicesInfo[window_content_N[window_activ]]);
		
		window_content_N[window_activ]++;
		window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
		window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc("dev_hdd1");
		DevicesInfo_N++;
		GetDeviceInfo("/dev_hdd1/", &DevicesInfo[window_content_N[window_activ]]);
		
		window_content_N[window_activ]++;
		window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
		window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc("dev_usb000");
		DevicesInfo_N++;
		GetDeviceInfo("/dev_usb000/", &DevicesInfo[window_content_N[window_activ]]);
		
		window_content_N[window_activ]++;
		window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
		window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc("dev_flash");
		DevicesInfo_N++;
		GetDeviceInfo("/dev_flash/", &DevicesInfo[window_content_N[window_activ]]);
		
// RPCS3 app_home = /dev_hdd0/game/MANAGUNZ0/USRDIR

		window_content_N[window_activ]++;
		window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
		window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc("app_home");
		DevicesInfo_N++;
		GetDeviceInfo("/app_home/", &DevicesInfo[window_content_N[window_activ]]);
		
		window_content_N[window_activ]++;
		window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
		window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc("app_home");
		DevicesInfo_N++;
		GetDeviceInfo("/dev_bdvd/", &DevicesInfo[window_content_N[window_activ]]);
		
		return;
	}
#endif
	
	NTFS_mount_all();
	
	exFAT_mount_all();
	
	if(path_info("/dev_hdd1")==_NOT_EXIST) {
		sys_fs_mount("CELL_FS_UTILITY:HDD1", "CELL_FS_FAT", "/dev_hdd1", 0);
		//sysFsAioInit("/dev_hdd1");
	}
	
	RefreshDevices();

	RefreshWindow(window_activ);
}

void GotoLastPath()
{
	UpdateLastPath();
	
	int curr_l = strlen(window_path[window_activ]);
    int last_l = strlen(window_lastpath[window_activ]);
    
	if(last_l<=curr_l) return;
	
	int dir_l = last_l-curr_l;
	
	char dir_n[dir_l];
	memset(dir_n, 0, dir_l);
    if(window_lastpath[window_activ][curr_l] != '/' && strcmp(window_path[window_activ], "/") != 0) return;
    
    int r=1;
    if(strcmp(window_path[window_activ], "/")==0) r=0;
	
    int j=0;
	int i;
    for(i=curr_l+r ; i<last_l ; i++) {
        if(window_lastpath[window_activ][i] == '/') break;
		dir_n[j]=window_lastpath[window_activ][i];
        j++;
    }
	dir_n[j]=0;
	j++;
	
	if(j==1) return;
	
	Window(dir_n);
}

//**** properties ****

void properties_input()
{
	if(prop_activ == NO) return;
	
	if(NewPad(BUTTON_CIRCLE))
	{
		prop_activ=NO;
		int i;
		for(i=0; i<=PROP_ITEM_NUMBER; i++) {
			FREE(PROP_ITEM[i]);
			FREE(PROP_ITEM_VALUE[i]);
		}
		FREE(PROP_ITEM);
		FREE(PROP_ITEM_VALUE);
		PROP_ITEM_NUMBER=-1;
	}
	
}

void Draw_properties()
{
	if(prop_activ == NO) return;
	
	SetFontZ(0);	
	FontSize(PROP_FONT);
	FontColor(BLACK);	
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO); // DARK 50%
	
	Draw_Box(PROP_X-2, PROP_Y-2, 0, 0, PROP_W+4, PROP_H+4, BLACK, NO); // BORDER
	Draw_Box(PROP_X, PROP_Y, 0, 0, PROP_W, PROP_H, 0xF0F0F0FF, NO);
	Draw_Box(PROP_X, PROP_Y, 0, 0, PROP_COL_W, PROP_H, 0xD4DBEDFF, NO);
	
	int i;
	for(i=0; i<=PROP_ITEM_NUMBER; i++) {
		DrawTXTInBox(PROP_X+5, PROP_Y+PROP_FONT*i, 0, PROP_COL_W, 1, PROP_ITEM[i], 0, BLACK);
		DrawTXTInBox(PROP_X+PROP_COL_W+5, PROP_Y+PROP_FONT*i, 0, PROP_W - PROP_COL_W, 1, PROP_ITEM_VALUE[i], 0, BLACK);
	}
}

void open_properties()
{
	start_gathering();	
	if(option_sel_N < 0) {
		get_size(window_path[window_activ]);
	} else {
		int i;
		for(i=0; i<=option_sel_N; i++) {
			get_size(option_sel[i]);
		}
	}	
	end_gathering();
	
	if(gathering_cancel) {
		reset_gathering();
		return;
	}
	
	start_loading();
	
	u8 have_fil=NO;
	u8 have_dir=NO;
	if( 0 < gathering_nb_file ) have_fil=YES;
	if( 0 < gathering_nb_directory ) have_dir=YES;
	
	PROP_ITEM = (char **) malloc(PROP_MAX_ITEMS*sizeof(char *));
	PROP_ITEM_VALUE = (char **) malloc(PROP_MAX_ITEMS*sizeof(char *));
	PROP_ITEM_NUMBER = -1;
	
	PROP_ITEM_NUMBER++;
	PROP_ITEM[PROP_ITEM_NUMBER] = strcpy_malloc(STR_PATH);
	if(option_sel_N == 0) {
		PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = strcpy_malloc(option_sel[0]);
	} else {
		PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = strcpy_malloc(window_path[window_activ]);
	}
	
	if( 0 < gathering_nb_directory ) {
		PROP_ITEM_NUMBER++;
		PROP_ITEM[PROP_ITEM_NUMBER] = strcpy_malloc(STR_DIRS);
		PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = sprintf_malloc("%d", gathering_nb_directory);
	}
	if(0 < gathering_nb_file) {
		PROP_ITEM_NUMBER++;
		PROP_ITEM[PROP_ITEM_NUMBER] = strcpy_malloc(STR_FILES);
		PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = sprintf_malloc("%d", gathering_nb_file);
	}
	
	PROP_ITEM_NUMBER++;
	PROP_ITEM[PROP_ITEM_NUMBER] = strcpy_malloc(STR_SIZE);
	char *prop_size_str = get_unit(gathering_total_size);
	if(gathering_total_size<1024) {
		PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = strcpy_malloc(prop_size_str);
	} else {
		PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = sprintf_malloc("%s (%llu %s)", prop_size_str, (long long unsigned int) gathering_total_size, STR_UNIT);
	}
	free(prop_size_str);

	if(option_sel_N == 0 && gathering_nb_file == 1) {
		u64 prop_md5[2];
		if( md5_file(option_sel[0], (u8 *) prop_md5) == SUCCESS) {
			PROP_ITEM_NUMBER++;
			PROP_ITEM[PROP_ITEM_NUMBER] = strcpy_malloc("MD5");
			PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = sprintf_malloc("%016llX%016llX", (long long unsigned int) prop_md5[0],
																				 (long long unsigned int) prop_md5[1]);
		}
		/*
		u32 prop_sha1[5];
		if( sha1_file(option_sel[0], (u8 *) prop_sha1) == SUCCESS) {
			PROP_ITEM_NUMBER++;
			PROP_ITEM[PROP_ITEM_NUMBER] = strcpy_malloc("SHA-1");
			PROP_ITEM_VALUE[PROP_ITEM_NUMBER] = sprintf_malloc("%08lX%08lX%08lX%08lX%08lX ", (long unsigned int) prop_sha1[0], (long unsigned int) prop_sha1[1], (long unsigned int) prop_sha1[2], (long unsigned int) prop_sha1[3], (long unsigned int) prop_sha1[4]);
		}
		*/
	}
	
	prop_activ = YES;

	end_loading();
}

//**** picture viewer ****

void picture_viewer_input()
{
	if(picture_viewer_activ == NO) return;
	
	if(NewPad(BUTTON_RIGHT))
	{	
		int flag=NO, i;
		for(i=0; i<=window_content_N[window_activ]; i++) {
			if(flag==YES) {
				if( can_view( window_content_Type[window_activ][i]) ) {
					sprintf(TMP_PIC_path, "%s/%s", window_path[window_activ], window_content_Name[window_activ][i]);
					Load_FM();
					break;
				}
			}
			if(strcmp(&strrchr(TMP_PIC_path, '/')[1], window_content_Name[window_activ][i])==0) flag=YES;
		}
	}
	
	if(NewPad(BUTTON_LEFT))
	{	
		int flag=NO, i;
		for(i=window_content_N[window_activ]; i>0; i--) {
			if(flag==YES) {
				if( can_view(window_content_Type[window_activ][i]) ) {
					sprintf(TMP_PIC_path, "%s/%s", window_path[window_activ], window_content_Name[window_activ][i]);
					Load_FM();
					break;
				 }
			}
			if(strcmp(&strrchr(TMP_PIC_path, '/')[1], window_content_Name[window_activ][i])==0) flag=YES;
		}
	}
	
	if(NewPad(BUTTON_CIRCLE))
	{
		picture_viewer_activ=NO;
		memset(TMP_PIC_path, 0, sizeof(TMP_PIC_path));
		TMP_PIC_offset = 0;
		
	}
}

void Draw_picture_viewer()
{
	if(picture_viewer_activ == NO) return;	
	
	if(APNG_offset[0]!=0) {Draw_APNG(); return;}
	
	SetFontZ(0);
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO); // DARK 50%
	
	float xi, yi, wi, hi;
	
	if(TMP_PIC_offset != 0 ) {
		tiny3d_SetTexture(0, TMP_PIC_offset, TMP_PIC.width, TMP_PIC.height, TMP_PIC.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		if( TMP_PIC.width > 748) {
			wi = 748 ;
			hi = TMP_PIC.height * 748 / TMP_PIC.width;
		
		} else 
		if (TMP_PIC.width > 412) {
			hi = 412;
			wi = TMP_PIC.width * 412 / TMP_PIC.height;
		} else {
			wi = TMP_PIC.width;
			hi = TMP_PIC.height;
		}
		xi = (848 - wi) / 2;
		yi = (512 - hi) / 2;
	
		Draw_Box(xi, yi, 0, 0, wi, hi, WHITE, YES);
		
		//DrawTXTInBox(30, 30, 0, 200, 450, picture_viewer_info, 0, WHITE);

		
	}
	
	Draw_Box(0, 460, 0, 0, 848, 20, BLACK, NO);
	FontColor(WHITE);
	DrawStringFromCenterX(424, 462 , &strrchr(TMP_PIC_path, '/')[1]);
	
}

void open_picture_viewer(char *pict_path)
{
	memset(TMP_PIC_path, 0, sizeof(TMP_PIC_path));
	
	strcpy(TMP_PIC_path, pict_path);

	Load_FM();
	
	picture_viewer_activ = YES;
	
}

//**** txt viewer ****

// LF remplaced by space
float DrawTXTinLineBox(float x, float y, float z, float w, char *string, u32 bg_color, u32 font_color)
{
	if(y<0) return x;
	
	SetFontZ(z);
	FontColor(font_color);
	
	float h1 = GetFontHeight();
	
	char local_str[1024]={0};
	u32 len = strlen(string);
	u32 i=0;
	u32 j=0;
	for(i=0; i<len; i++)
	{
		if( string[i] == '\r') continue;
		if( string[i] == '\n') {
			local_str[j]= ' ';
		} else {
			local_str[j]= string[i];
		}
		j++;
		if(j==1024) break;
	}
	
	if( bg_color != 0) Draw_Box(x, y, z, 0, w, h1, bg_color, NO);
	
	set_ttf_window(x, y, w, h1, 0);
	Z_ttf = z;
    x = (float) display_ttf_string(0, 0, local_str, font_color, 0, GetFontWidth(), GetFontHeight());
	
	set_ttf_window(0, 0, X_MAX, Y_MAX, 0);
	
	return x;
	
}

float DrawTXTInBox(float x, float y, float z, float w, float h, char *string, u32 bg_color, u32 font_color)
{
	if(y<0) return x;
	
	SetFontZ(z);
	FontColor(font_color);
	
	float h1 = h;
	if(h==1) h1 = GetFontHeight();
	
	if( bg_color != 0) Draw_Box(x, y, z, 0, w, h1, bg_color, NO);
	
	
	set_ttf_window(x, y, w, h1, WIN_AUTO_LF);
	Z_ttf = z;
    x = (float) display_ttf_string(0, 0, string, font_color, 0, GetFontWidth(), GetFontHeight());
	
	set_ttf_window(0, 0, X_MAX, Y_MAX, 0);
	
	return x;
}

float DrawTXTInBoxFromCenter(float x, float y, float z, float w, float h, char *string, u32 bg_color, u32 font_color)
{
	if(y<0) return x;
	
	SetFontZ(z);
	FontColor(font_color);
	float w_str = WidthFromStr(string);
	
	float h1 = h;
	if(h==1) h1 = GetFontHeight();
	
	if( bg_color != 0) Draw_Box(x, y, z, 0, w, h1, bg_color, NO);
	
	set_ttf_window(w/2 - w_str/2, y, w, h1, WIN_AUTO_LF);
	Z_ttf = z;
    x = (float) display_ttf_string(0, 0, string, font_color, 0, GetFontWidth(), GetFontHeight());
	set_ttf_window(0, 0, X_MAX, Y_MAX, 0);
	
	return x;
}

int GetNumberOfLine(float x, float y, float w, float h, char *string)
{
	float h1 = h;
	if(h==1) h1 = GetFontHeight();
	
	Z_ttf = 0.0;
	Y_ttf = y;
	set_ttf_window(x, y, w, h1, WIN_AUTO_LF);
    int lines = display_ttf_line(-1, 0, 0, string, 0, 0, GetFontWidth(), GetFontHeight());
	set_ttf_window(0, 0, X_MAX, Y_MAX, 0);
	
	return lines;
}

float DrawTXTInBoxScroll(int line, float x, float y, float z, float w, float h, char *string, u32 bg_color, u32 font_color)
{
	if(y<0) return x;
	
	SetFontZ(z);
	FontColor(font_color);
	
	float h1 = h;
	if(h==1) h1 = GetFontHeight();
	
	if( bg_color != 0) Draw_Box(x, y, z, 0, w, h1, bg_color, NO);
	
	set_ttf_window(x, y, w, h1, WIN_AUTO_LF);
    Z_ttf = z;
	x = (float) display_ttf_line(line, 0, 0, string, font_color, 0, GetFontWidth(), GetFontHeight());
	set_ttf_window(0, 0, X_MAX, Y_MAX, 0);
	
	return x;
}

void txt_viewer_input()
{
	if(txt_viewer_activ == NO) return;
	
	get_R2speed();
	
	if( R2pad(BUTTON_DOWN) )
	{
		if(txt_line < txt_scroll ) txt_line++;
	}
	if( R2pad(BUTTON_UP))
	{
		if(0<txt_line) txt_line--;
	}
	
	if(txt_viewer_path!=NULL) {
		if(NewPad(BUTTON_SQUARE)) {
			Delete(txt_viewer_path);
			FREE(txt_viewer_path);
		}
	}
	
	if(NewPad(BUTTON_CIRCLE))
	{
		txt_viewer_activ=NO;
		if(txt_viewer_path==NULL && scene==SCENE_FILEMANAGER) Window(".");
		memset(txt_viewer_content, 0, sizeof(txt_viewer_content));
		FREE(txt_viewer_content);
		FREE(txt_viewer_path);
	}
}

void Draw_txt_viewer_input()
{
	if(txt_viewer_activ == NO) return;	
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
	x=DrawButton(x, y, STR_SCROLL, BUTTON_UP | BUTTON_DOWN);
	if(txt_viewer_path!=NULL) x=DrawButton(x, y, STR_DELETE, BUTTON_SQUARE);
}

void Draw_txt_viewer()
{
	if(txt_viewer_activ == NO) return;	
	
	SetFontZ(0);
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO); // DARK 50%
	Draw_Box(TXT_X-20-5 , TXT_Y-20-5 , 0, 0, TXT_W+40+10 , TXT_H+40+10 , BLACK, NO); // Black Border
	Draw_Box(TXT_X-20   , TXT_Y-20   , 0, 0, TXT_W+40	, TXT_H+40	, WHITE, NO); // White Border
	
	DrawTXTInBoxScroll(txt_line, TXT_X, TXT_Y, 0, TXT_W, TXT_H, txt_viewer_content, WHITE, BLACK);
}

void open_txt_viewer(char *txt_path)
{
	txt_line=0;
	txt_scroll=0; 
	
	FREE(txt_viewer_path);
	txt_viewer_path = strcpy_malloc(txt_path);
	
	int size;
	txt_viewer_content = LoadFile(txt_viewer_path, &size);
	if(txt_viewer_content != NULL) {
		txt_viewer_content = realloc(txt_viewer_content, size + 1);
		txt_viewer_content[size + 1] = 0;
		txt_scroll = GetNumberOfLine(TXT_X, TXT_Y, TXT_W, TXT_H, txt_viewer_content) + 1;
	}
	
	SetFontSize(15, 15);
	
	txt_viewer_activ = YES;
}

//**** SFO viewer ****

typedef struct
{
	uint32_t magic; 				/* Always PSF */
	uint32_t version; 				/* Usually 1.1 */
	uint32_t key_table_start; 		/* Start offset of key_table */
	uint32_t data_table_start; 		/* Start offset of data_table */
	uint32_t nb_entries; 			/* Number of entries in all tables */
} sfo_header;

typedef struct 
{
	uint16_t key_offset; 	/* param_key offset (relative to start offset of key_table) */
	uint16_t data_type;		/* param_data data type */
	uint32_t data_len;		/* param_data used bytes */
	uint32_t data_max_len;	/* param_data total bytes */
	uint32_t data_offset;	/* param_data offset (relative to start offset of data_table) */
} sfo_table_entry;

void es_header(sfo_header *h)
{	
	//h->magic = ES(h->magic);
	h->version = ES(h->version);
	h->key_table_start = ES(h->key_table_start);
	h->data_table_start = ES(h->data_table_start);
	h->nb_entries = ES(h->nb_entries);
}

void es_table_entry(sfo_table_entry *e)
{	
	e->key_offset = ES(e->key_offset);
	e->data_type = ES(e->data_type);
	e->data_len = ES(e->data_len);
	e->data_max_len = ES(e->data_max_len);
	e->data_offset = ES(e->data_offset);
}

void SFO_viewer_input()
{
	if(SFO_viewer_activ == NO) return;
	
	if(NewPad(BUTTON_CIRCLE))
	{
		SFO_viewer_activ=NO;
	}
}

void open_SFO_viewer(char *path)
{
	FILE* sfo;
	sfo_header header;
	
	sfo = fopen(path, "rb");
	if(sfo == NULL)  {
		print_load("Error : failed to open file");
		return;
	}
	
// read header
	fread(&header, sizeof(sfo_header), 1, sfo);
	es_header(&header);

	if(header.magic != SFO_MAGIC) {
		print_load("Error : wrong magic value");
		return;
	}
	
	sfo_table_entry table_entry[header.nb_entries];
	
// read table entries
	int i;
	for(i=0; i < header.nb_entries; i++) {
		fread(&table_entry[i], sizeof(sfo_table_entry), 1, sfo);
		es_table_entry(&table_entry[i]);
	}

	memset(SFO_KEY, 0, sizeof(SFO_KEY));
	memset(SFO_DATA, 0, sizeof(SFO_DATA));
	SFO_NB = 0;
	
// get KEYS
	for(i=0; i < header.nb_entries; i++) {
		//if(table_entry[i].data_type == SFO_DATA_TYPE_UTF8S) continue ; // ignore
		fseek(sfo, header.key_table_start + table_entry[i].key_offset, SEEK_SET );
		fgets(SFO_KEY[i], 64, sfo);
		SFO_NB++;
	}
	
	char *entry_data_utf8;
	uint32_t entry_data_int32;
	
// get DATAS
	for(i=0; i < header.nb_entries; i++) {
		
		fseek(sfo, header.data_table_start + table_entry[i].data_offset, SEEK_SET );
		
		if(table_entry[i].data_type == SFO_DATA_TYPE_UTF8S
		|| table_entry[i].data_type == SFO_DATA_TYPE_UTF8) {
			entry_data_utf8 = (char *) malloc(table_entry[i].data_max_len);
			fread(entry_data_utf8, table_entry[i].data_max_len, 1, sfo);
			strcpy(SFO_DATA[i], entry_data_utf8);
			free(entry_data_utf8);
		} else
		if(table_entry[i].data_type == SFO_DATA_TYPE_INT32) {
			fread(&entry_data_int32, table_entry[i].data_max_len, 1, sfo);
			entry_data_int32 = ES(entry_data_int32);
			sprintf(SFO_DATA[i], "%d", entry_data_int32);
		}
	}

	fclose(sfo);
	
	SFO_viewer_activ = TRUE;
}

u8 GetParamSFO(const char *name, char *value, char *path)
{	
	FILE* sfo=NULL;
	u32 sfo_start=0;
	u32 sfo_size=0;
	
	if(path == NULL) {
		print_load("GetParamSFO path==NULL");
		return FAILED;
	}
	
	sfo = openSFO(path, &sfo_start, &sfo_size, "rb");
	if(sfo==NULL) {
		print_load("Failed to open %s", path);
		return FAILED;
	}
	
	fseek(sfo, sfo_start, SEEK_SET);
	
	sfo_header header;
	
	// read header
	fread(&header, sizeof(sfo_header), 1, sfo);
	es_header(&header);

	if(header.magic != SFO_MAGIC) {
		print_load("Error : wrong magic value");
		return FAILED;
	}
	
	sfo_table_entry table_entry[header.nb_entries];
	
// read table entries
	int i;
	for(i=0; i < header.nb_entries; i++) {
		fread(&table_entry[i], sizeof(sfo_table_entry), 1, sfo);
		es_table_entry(&table_entry[i]);
	}

	char KEY[64]={0};
	s32 ENTRY_ID=-1;
	u32 len = strlen(name);
	
// get KEY
	for(i=0; i < header.nb_entries; i++) {
		//if(table_entry[i].data_type == SFO_DATA_TYPE_UTF8S) continue ; // ignore
		fseek(sfo, header.key_table_start + table_entry[i].key_offset + sfo_start, SEEK_SET );
		memset(KEY, 0, 64);
		fgets(KEY, 64, sfo);
		if(!strncmp(KEY, name, len))  {
			ENTRY_ID = i;
			break;
		}
	}
	
	if(ENTRY_ID == -1) {
		print_debug("Failed to find %s in param.sfo", name);
		return FAILED;
	}
	
	char *entry_data_utf8;
	uint32_t entry_data_int32;
	
// get DATAS
	fseek(sfo, header.data_table_start + table_entry[ENTRY_ID].data_offset + sfo_start, SEEK_SET );
	
	if(table_entry[ENTRY_ID].data_type == SFO_DATA_TYPE_UTF8 || table_entry[ENTRY_ID].data_type == SFO_DATA_TYPE_UTF8S) {
		entry_data_utf8 = (char *) malloc(table_entry[ENTRY_ID].data_max_len);
		if(entry_data_utf8==NULL) {
			fclose(sfo);
			print_debug("Error : failed to malloc entry_data_utf8");
			return FAILED;
		}
		fread(entry_data_utf8, 1, table_entry[i].data_max_len, sfo);
		strcpy(value, entry_data_utf8);
		free(entry_data_utf8);
	} else
	if(table_entry[ENTRY_ID].data_type == SFO_DATA_TYPE_INT32) {
		fread(&entry_data_int32, 1, table_entry[i].data_max_len, sfo);
		entry_data_int32 = ES(entry_data_int32);
		sprintf(value, "%d", entry_data_int32);
	}
	fclose(sfo);
	
	return SUCCESS;
}

void Draw_SFO_viewer()
{
	if(SFO_viewer_activ == NO) return;
	int i;
	
	SetFontZ(0);	
	FontSize(SFO_FONT);
	FontColor(BLACK);
	
	int SFO_COL1_W=0;
	int SFO_H=SFO_FONT*SFO_NB;
	int SFO_Y=512/2-SFO_H/2;
	float x=0;
	for(i=0; i<SFO_NB; i++) {
		if(x < WidthFromStr(SFO_KEY[i])) x = WidthFromStr(SFO_KEY[i]);
	}
	SFO_COL1_W = x + 10;
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO);
	Draw_Box(SFO_X-2, SFO_Y-2, 0, 0, SFO_W+4, SFO_H+4, BLACK, NO);
	Draw_Box(SFO_X, SFO_Y, 0, 0, SFO_W, SFO_H, 0xF0F0F0FF, NO);
	Draw_Box(SFO_X, SFO_Y, 0, 0, SFO_COL1_W, SFO_H, 0xD4DBEDFF, NO);
	
	for(i=0; i<SFO_NB; i++) {
		DrawString(SFO_X+5, SFO_Y+SFO_FONT*i, SFO_KEY[i]);
		DrawTXTInBox(SFO_X+SFO_COL1_W+5, SFO_Y+SFO_FONT*i, 0, SFO_COL2_W-10-5, 1, SFO_DATA[i], 0, BLACK);
	}
}

void update_RootDisplay()
{
	memset(fm_Format, 0, sizeof(fm_Format));
	
	switch(root_display)
	{
		case STYLE1:
		{
			fm_CustomIcons = NO;
			fm_LineSize=SMALL;
			fm_RowNumber=0;
			
			fm_FontRowSize[0] = LINE_H1;
			strcpy( fm_Format[ LEFTROW(0)  ], STR_FM_MOUNTPOINT);
			strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_EMPTY);
			
			fm_FontRowSize[1] = 0;
			strcpy( fm_Format[ LEFTROW(1)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
			fm_FontRowSize[2] = 0;
			strcpy( fm_Format[ LEFTROW(2)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
			
			fm_CapacityBarWidth=0;
			
			break;
		}
		case STYLE2:
		{
		
			fm_CustomIcons = YES;
			fm_LineSize=SMALL;
			fm_RowNumber=0;
			
			fm_FontRowSize[0] = LINE_H1;
			sprintf(fm_Format[ LEFTROW(0) ], "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT);
			strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_FILESYSTEM);
			
			fm_FontRowSize[1] = 0;
			strcpy( fm_Format[ LEFTROW(1)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
			fm_FontRowSize[2] = 0;
			strcpy( fm_Format[ LEFTROW(2)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
			
			fm_CapacityBarWidth=0;
			
			
			break;
		}
		case STYLE3:
		{
			fm_CustomIcons = YES;
			fm_LineSize=BIG;
			fm_RowNumber=1;
			
			fm_FontRowSize[0] = LINE_H1;
			sprintf(fm_Format[ LEFTROW(0)  ], "%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT);
			strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_FILESYSTEM);
			
			fm_FontRowSize[1] = 12.0;
			sprintf(fm_Format[ LEFTROW(1)  ], "%s + %s", STR_FM_CAPACITY, STR_FM_MEMINSIDE);
			strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
			fm_FontRowSize[2] = 0;
			strcpy( fm_Format[ LEFTROW(2)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
			
			fm_CapacityBarWidth=0;
						
			break;
		}
		case STYLE4:
		{
			fm_CustomIcons = YES;
			fm_LineSize=BIG;
			fm_RowNumber=1;
			
			fm_FontRowSize[0] = LINE_H1;
			sprintf(fm_Format[ LEFTROW(0)  ], "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT);
			strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_FILESYSTEM);
			
			fm_FontRowSize[1] = LINE_H1;
			sprintf(fm_Format[ LEFTROW(1)  ], "%s + %s", STR_FM_CAPACITY, STR_FM_MEMOUTSIDE);
			strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
			fm_FontRowSize[2] = 0;
			strcpy( fm_Format[ LEFTROW(2)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
			
			fm_CapacityBarWidth=250;
			
			
			break;
		}
		case STYLE5:
		{
			fm_CustomIcons = YES;
			fm_LineSize=BIG;
			fm_RowNumber=2;
			
			fm_FontRowSize[0] = 16.0;
			sprintf(fm_Format[ LEFTROW(0)  ], "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT);
			strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_FILESYSTEM);
			
			fm_FontRowSize[1] = 16.0;
			strcpy( fm_Format[ LEFTROW(1)  ], STR_FM_MEMORY);
			strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
			fm_FontRowSize[2] = 0.0;
			strcpy( fm_Format[ LEFTROW(2)  ], STR_FM_EMPTY);
			strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
			
			fm_CapacityBarWidth=0;
			
			
			break;
		}
		case STYLE6:
		{
			fm_CustomIcons = YES;
			fm_LineSize=BIG;
			fm_RowNumber=2;
			
			fm_FontRowSize[0] = 14;
			sprintf(fm_Format[ LEFTROW(0)  ], "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT);
			strcpy( fm_Format[ RIGHTROW(0) ], STR_FM_EMPTY);
			
			fm_FontRowSize[1] = 7;
			strcpy( fm_Format[ LEFTROW(1)  ], STR_FM_FILESYSTEM);
			strcpy( fm_Format[ RIGHTROW(1) ], STR_FM_EMPTY);
			
			fm_FontRowSize[2] = 11;
			sprintf(fm_Format[ LEFTROW(2)  ], "%s + %s", STR_FM_CAPACITY, STR_FM_MEMINSIDE);
			strcpy( fm_Format[ RIGHTROW(2) ], STR_FM_EMPTY);
			
			fm_CapacityBarWidth=250;
			
			
			break;
		}
		case STYLE_CUSTOM:
		default:
		{	
			read_RootSetting();
			
			break;
		}
	}
	
	write_setting();
}

void show_msg_RootDisplay()
{
	
	switch(root_display)
	{
		case STYLE_CUSTOM:
		{
			show_msg(STR_STYLE_CUSTOM);
			break;
		}
		case STYLE1:
		{
			show_msg(STR_STYLE1);
			break;
		}
		case STYLE2:
		{
			show_msg(STR_STYLE2);
			break;
		}
		case STYLE3:
		{
			show_msg(STR_STYLE3);
			break;
		}
		case STYLE4:
		{
			show_msg(STR_STYLE4);			
			break;
		}
		case STYLE5:
		{
			show_msg(STR_STYLE5);		
			break;
		}
		case STYLE6:
		{
			show_msg(STR_STYLE6);
			break;
		}
		default:
		{	
			break;
		}
	}
}



//**** Option ****

void Option(char *item)
{
	char temp[512];
	int i;
	int ret=-1;
	
	if(strcmp(item, STR_NEWFOLDER) == 0) {
		sprintf(temp, "%s/New_Folder", window_path[window_activ]);
		if(path_info(temp) != _NOT_EXIST) {
			for(i=0; i<100; i++) {
				sprintf(temp, "%s/New_Folder_%d", window_path[window_activ], i);
				if(path_info(temp) == _NOT_EXIST) break;
			}
		}
		ret = mkdir(temp, 0777);
		if(ret != 0 ) {
			show_msg(STR_FAILED);
		} else {
			window_content_N[window_activ]++;
			window_content_Size[window_activ][window_content_N[window_activ]] = 0;
			window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SDIR);
			window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc(&strrchr(temp, '/')[1]);
			sort(window_activ);
		}
	} else
	if(strcmp(item, STR_NEWFILE) == 0) {
		sprintf(temp, "%s/New_File.txt", window_path[window_activ]);
		if(path_info(temp) != _NOT_EXIST) {
			for(i=0; i<100; i++) {
				sprintf(temp, "%s/New_File_%d.txt", window_path[window_activ], i);
				if(path_info(temp) == _NOT_EXIST) break;
			}
		}
		FILE* f;
		f = fopen(temp, "wb");
		if(f==NULL) show_msg(STR_FAILED);
		else {
			fclose(f);
			window_content_N[window_activ]++;
			window_content_Size[window_activ][window_content_N[window_activ]] = 0;
			window_content_Type[window_activ][window_content_N[window_activ]] = strcpy_malloc(_SFILE);
			window_content_Name[window_activ][window_content_N[window_activ]] = strcpy_malloc(&strrchr(temp, '/')[1]);
			sort(window_activ);
		}
	} else
	if(strcmp(item, STR_MOUNT_DVD) == 0) {
		start_loading();
		MountISO(option_sel[0], EMU_DVD);
		end_loading();
	} else
	if(strcmp(item, STR_MOUNT_BD) == 0) {
		start_loading();
		MountISO(option_sel[0], EMU_BD);
		end_loading();
	} else
	if(strcmp(item, "Test") == 0) {
		start_loading();
		
		end_loading();
	} else
	if(strcmp(item, "Test2") == 0) {
		start_loading();
		
		end_loading();
	} else
	if(strcmp(item, "Test3") == 0) {
		start_loading();
	
		end_loading();
	} else
	if(strcmp(item, "InsertEject") == 0) {
		start_loading();
		int maxTry = 10;
		for(i=0; i<maxTry; i++) {
			if( path_info("/dev_bdvd") != _NOT_EXIST) break;
			print_head("Try %d/%d", i+1, maxTry); 
			bdvd_eject(NO);
			sleep(3);
			bdvd_insert(NO);
			sleep(40);
		}
		end_loading();
	} else
	if(strcmp(item, STR_SYMLINK_SRC) == 0) {
		FREE(FM_OLD_PATH);
		FM_OLD_PATH = strcpy_malloc(option_sel[0]);
		for(i=0; i<WINDOW_MAX_ITEMS; i++) window_content_Selected[window_activ][i]=NO;
	} else
	if(strcmp(item, STR_SYMLINK_TARGET) == 0) {
		{sys_map_path((char*)FM_OLD_PATH, option_sel[0]);}
		FREE(FM_OLD_PATH);
		for(i=0; i<WINDOW_MAX_ITEMS; i++) window_content_Selected[window_activ][i]=NO;
	} else
	if(strcmp(item, STR_LOAD_MAMBA) == 0) {
		mamba = install_mamba();
		if(mamba) show_msg(STR_DONE);
	} else
	if(strcmp(item, STR_PASTE) == 0) {
		if(option_copy_N==0 && is_66600(option_copy[0])) {
			start_gathering();
			strcpy(copy_src, option_copy[0]);
			sprintf(copy_dst, "%s%s", window_path[window_activ], strrchr(copy_src, '/'));
			Get_Game_Size(option_copy[0]);
			end_gathering();
			
			if( gathering_cancel == NO ) {
				if( GetFreeSpace(copy_dst) < gathering_total_size ) {
					show_msg("Not enough space!");
					reset_gathering();
					return;
				}
			}
			
			start_copy_loading();
			CopyJoin(copy_src, copy_dst);
			end_copy_loading();
		} 
		else {
			start_gathering();
			for(i=0; i<=option_copy_N; i++){
				get_size(option_copy[i]);
			}
			end_gathering();
			
			if( gathering_cancel == NO ) {
				if( GetFreeSpace(window_path[window_activ]) < gathering_total_size ) {
					show_msg("Not enough space!");
					reset_gathering();
					return;
				}
			}
			
			start_copy_loading();
			for(i=0; i<=option_copy_N; i++) {
				strcpy(copy_src, option_copy[i]);
				sprintf(copy_dst, "%s%s", window_path[window_activ], strrchr(copy_src, '/'));
				if(option_cut == YES) 
					Move(copy_src, copy_dst); 
				else {
					Copy(copy_src, copy_dst);
				}
				if(cancel || copy_cancel) break;
			}
			end_copy_loading();
		}
		
		for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(option_copy[i]);	
		option_copy_N=-1;
		Window(".");
	} else
	if(strcmp(item, STR_JOIN) == 0) {
			
		for(i=0; i<=option_sel_N; i++) {
			strcpy(copy_src, option_sel[i]);
			sprintf(copy_dst, "%s%s", window_path[window_activ], strrchr(copy_src, '/'));
			
			start_gathering();
			Get_Game_Size(option_sel[i]);
			end_gathering();
			
			start_copy_loading();
			CopyJoin(copy_src, copy_dst);
			end_copy_loading();
		}
		Window(".");
	} else
	if(strcmp(item, STR_COPY) == 0) {
		for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(option_copy[i]);
		for(i=0; i<=option_sel_N; i++) {
			option_copy[i] = strcpy_malloc(option_sel[i]);
		}
		option_copy_N = option_sel_N;
		option_cut = NO;
	} else
	if(strcmp(item, STR_CUT) == 0) {
		for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(option_copy[i]);
		for(i=0; i<=option_sel_N; i++) {
			option_copy[i] = strcpy_malloc(option_sel[i]);
		}
		option_copy_N = option_sel_N;
		option_cut = YES;
	} else
	if(strcmp(item, STR_DELETE) == 0) {
		char diag_msg[4096];
		if( option_sel_N == 0 ) {
			sprintf(diag_msg, "%s\n%s: %s", STR_ASK_TO_DELETE, STR_PATH, option_sel[0]);
		} else 
		if( 0 < option_sel ) {
			u32 fil_n=0;
			u32 dir_n=0;
			for(i=0; i<=option_sel_N; i++) {
				u8 info = path_info(option_sel[i]);
				if( info == _FILE) fil_n++; else
				if( info == _DIRECTORY) dir_n++;
			}
			sprintf(diag_msg, "%s\n%s: %s\n%s: %d\n%s: %d\n", STR_ASK_TO_DELETE, STR_PATH, window_path[window_activ], STR_FILES, fil_n, STR_DIRS, dir_n);
		}
		if( DrawDialogYesNo(diag_msg) == YES) {
			start_loading();
			for(i=0; i<=option_sel_N; i++) {
				Delete(option_sel[i]);
			}
			end_loading();
			Window(".");
		}
	} else
	if(strcmp(item, STR_UNSELECT_ALL) == 0) {
		for(i=0; i<WINDOW_MAX_ITEMS; i++) window_content_Selected[window_activ][i]=NO;
	} else
	if(strcmp(item, STR_SELECT_ALL) == 0) {
		for(i=0; i<=window_content_N[window_activ]; i++) {
			if(strcmp(window_content_Name[window_activ][i], "..") == 0) {
				window_content_Selected[window_activ][i] = NO;
			} else window_content_Selected[window_activ][i] = YES;
		}
		option_activ=NO;
	} else
	if(strcmp(item, STR_RENAME) == 0) {
		char New_Name[255];
		strcpy(New_Name, &strrchr(option_sel[0], '/')[1]);
		if(Get_OSK_String(STR_RENAME, New_Name, 255) == SUCCESS) {
			if(New_Name[0] != 0) {
				char New_Path[512];
				sprintf(New_Path, "%s/%s", window_path[window_activ], New_Name);
				rename(option_sel[0], New_Path);
			}
		}
		Window(".");
	} else
	if(strcmp(item, STR_OPEN_WINDOW)==0) {
		Window(NULL);
	} else
	if(strcmp(item, STR_REFRESH)==0) {
		Window(".");
	} else
	if(strcmp(item, STR_MOUNT_DEVBLIND)==0) {
		sys_fs_mount("CELL_FS_IOS:BUILTIN_FLSH1", "CELL_FS_FAT", "/dev_blind", 0);
		Window(".");
	} else
	if(strcmp(item, STR_UNMOUNT_DEVBLIND)==0) {
		sys_fs_unmount("/dev_blind");
		sys_fs_unmount("/dev_rebug");
		Window(".");
	} else
	if(strcmp(item, STR_PROPS) == 0) {
		open_properties();
	} else
	if(strcmp(item, STR_VIEW) == 0) {
		open_picture_viewer(option_sel[0]);
	} else
	if(strcmp(item, STR_VIEW_TXT) == 0) {
		open_txt_viewer(option_sel[0]);
	} else
	if(strcmp(item, STR_VIEW_SFO) == 0) {
		start_loading();
		open_SFO_viewer(option_sel[0]);
		end_loading();
	} else
	if(strcmp(item, STR_EXTRACT_ELF) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			char elf[255];
			strcpy(elf, option_sel[i]);	
			RemoveExtension(elf);
			strcat(elf, ".elf");
			
			if( path_info(elf) != _NOT_EXIST) Delete(elf);
			
			if(Extract_SELF(option_sel[i], elf, NULL)==FAILED) {
				print_load("Error : Failed to extract");
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_RESIGN_SELF) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			re_sign_SELF(option_sel[i]);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_LAUNCH_SELF) == 0) {
		sysProcessExitSpawn2(option_sel[0], NULL, NULL, NULL, 0, 1001, SYS_PROCESS_SPAWN_STACK_SIZE_1M);
	} else
	if(strcmp(item, STR_EXTRACT_EBOOT) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			char elf[255];
			strcpy(elf, option_sel[i]);	
			RemoveExtension(elf);
			strcat(elf, ".ELF");
			
			if( path_info(elf) != _NOT_EXIST) Delete(elf);
			
			if(Extract_SELF(option_sel[i], elf, NULL)==FAILED) {
				print_load("Error : Failed to extract");
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_RESIGN_EBOOT) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			re_sign_EBOOT(option_sel[i]);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_LAUNCH_EBOOT) == 0) {
		sysProcessExitSpawn2(option_sel[0], NULL, NULL, NULL, 0, 1001, SYS_PROCESS_SPAWN_STACK_SIZE_1M);
	} else
	if(strcmp(item, STR_SIGN_EBOOT) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			char BIN[255];
			strcpy(BIN, option_sel[i]);	
			RemoveExtension(BIN);
			strcat(BIN, ".BIN");
			
			char BIN_ORI[255];
			strcpy(BIN_ORI, BIN);
			strcat(BIN_ORI, "_ORI");
			
			if( path_info(BIN) != _NOT_EXIST) {
				rename(BIN, BIN_ORI);
			}
			
			if( Sign_EBOOT(option_sel[i], BIN) == FAILED) {
				print_load("Error : failed to sign EBOOT");
				rename(BIN_ORI, BIN);
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_SIGN_ELF) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			char SELF[255];
			strcpy(SELF, option_sel[i]);	
			RemoveExtension(SELF);
			strcat(SELF, ".self");
			
			char SELF_ORI[255];
			strcpy(SELF_ORI, SELF);
			strcat(SELF_ORI, "_ORI");
			
			if( path_info(SELF) != _NOT_EXIST) {
				rename(SELF, SELF_ORI);
			}
			
			if( Sign_ELF(option_sel[i], SELF) == FAILED) {
				print_load("Error : failed to sign ELF");
				rename(SELF_ORI, SELF);
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_EXTRACT_PRX) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			char prx[255];
			strcpy(prx, option_sel[i]);	
			RemoveExtension(prx);
			strcat(prx, ".prx");
			if( path_info(prx) != _NOT_EXIST) Delete(prx);
			if(Extract_SELF(option_sel[i], prx, NULL)==FAILED) {
				print_load("Error : Failed to extract");
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_DECRYPT_NPDATA) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) npd_decrypt(option_sel[i]);
		end_loading();
		Window(".");
	} else	
	if(strcmp(item, STR_RESIGN_SPRX) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			re_sign_SPRX(option_sel[i]);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_SIGN_PRX) == 0) {
		start_loading();
		
		for(i=0; i<=option_sel_N; i++) {
			char SPRX[255];
			strcpy(SPRX, option_sel[i]);	
			RemoveExtension(SPRX);
			strcat(SPRX, ".sprx");
			
			char SPRX_ORI[255];
			strcpy(SPRX_ORI, SPRX);
			strcat(SPRX_ORI, "_ORI");
			
			if( path_info(SPRX) != _NOT_EXIST) {	
				rename(SPRX, SPRX_ORI);
			}
			
			if( Sign_ELF(option_sel[i], SPRX) == FAILED) {
				print_load("Error : failed to sign SPRX");
				rename(SPRX_ORI, SPRX);
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_CHECK_IRD) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			if ( IRD_check(option_sel[i]) == SUCCESS) {
				sprintf(temp, "%s.result_md5.txt", option_sel[i]);
				if(option_sel_N==0) open_txt_viewer(temp);
			}
		}
		end_loading();
	} else
	if(strcmp(item, STR_MAKE_SHTCUT_PKG) == 0) {
	
		start_loading();
		read_game_setting(-1);
		for(i=0; i<=option_sel_N; i++) {
			char mk_pkg_ID[10];
			srand(time(NULL));
			int r = rand()%9999;
			sprintf(mk_pkg_ID, "NPEB4%04d", r);
			make_launcher_pkg(mk_pkg_ID, option_sel[i]);
		}
		end_loading();
	} else
	if(strcmp(item, STR_EXTRACT_PKG) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			pkg_unpack(option_sel[i], NULL);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_PKG_INFO) == 0) {
		start_loading();
		i=pkg_list(option_sel[0]);
		end_loading();
		if(i==SUCCESS) open_txt_viewer("/dev_hdd0/tmp/pkg_list.txt");
	} else
	if(strcmp(item, STR_MAKE_PKG) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			make_pkg(option_sel[i]);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_REMOVE_PRXLOADER) == 0) {
		remove_from_list("/dev_hdd0/game/PRXLOADER/USRDIR/plugins.txt", option_sel[0]);
	} else
	if(strcmp(item, STR_ADD_PRXLOADER) == 0) {
		add_to_list("/dev_hdd0/game/PRXLOADER/USRDIR/plugins.txt", option_sel[0]);
	}  else
	if(strcmp(item, STR_REMOVE_PRXLOADER2) == 0) {
		remove_from_list("/dev_hdd0/prx_plugins.txt", option_sel[0]);
	} else
	if(strcmp(item, STR_ADD_PRXLOADER2) == 0) {
		add_to_list("/dev_hdd0/prx_plugins.txt", option_sel[0]);
	} else
	if(strcmp(item, STR_REMOVE_MAMBA) == 0) {
		remove_from_list("/dev_hdd0/mamba_plugins.txt", option_sel[0]);
	} else
	if(strcmp(item, STR_ADD_MAMBA) == 0) {
		add_to_list("/dev_hdd0/mamba_plugins.txt", option_sel[0]);
	}  else
	if(strcmp(item, STR_REMOVE_COBRA) == 0) {
		remove_from_list("/dev_hdd0/boot_plugins.txt", option_sel[0]);
	} else
	if(strcmp(item, STR_ADD_COBRA) == 0) {
		add_to_list("/dev_hdd0/boot_plugins.txt", option_sel[0]);
	} else
	if(strcmp(item, STR_DUMP_LV2) == 0) {
		start_loading();
		dump_lv2("/dev_hdd0");
		end_loading();
	} else
	if(strcmp(item, STR_DUMP_LV1) == 0) {
		start_loading();
		dump_lv1("/dev_hdd0");
		end_loading();
	} else
	if(strcmp(item, STR_DUMP_FLASH) == 0) {
		start_loading();
		dump_flash("/dev_hdd0");
		end_loading();
	} else
	if(strcmp(item, STR_EXTRACT_TRP) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			trophy_extract(option_sel[i]);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_GETMD5) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			HashFolder(MD5_HASH, option_sel[i]);
			if(cancel == NO) {
				char temp[255];
				sprintf(temp, "%s/content.md5", option_sel[i]);
				open_txt_viewer(temp);
			}
		}
		end_loading();
	} else
	if(strcmp(item, STR_GETSHA1) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			HashFolder(SHA1_HASH, option_sel[i]);
			if(cancel == NO) {
				char temp[255];
				sprintf(temp, "%s/content.sha1", option_sel[i]);
				open_txt_viewer(temp);
			}
		}
		end_loading();
	} else 
	if(strcmp(item, STR_CHECK_CRC32) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			if(CheckCRC32(option_sel[i]) == SUCCESS) {
				char temp[255];
				strcpy(temp, option_sel[i]);
				temp[strlen(temp)-4]=0;
				strcat(temp, "_CHECK.crc");
				open_txt_viewer(temp);
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_CHECK_MD5) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			if(CheckMD5(option_sel[i]) == SUCCESS) {
				char temp[255];
				strcpy(temp, option_sel[i]);
				temp[strlen(temp)-4]=0;
				strcat(temp, "_CHECK.md5");
				if(option_sel_N==0) open_txt_viewer(temp);
			}
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_EXTRACT_RCO) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting %s", option_sel[i]);
			rco_dump(option_sel[i]);
		}		
		end_loading();
		Window(".");
	} else 
	if(strcmp(item, STR_EXTRACT_ISO) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting %s", option_sel[i]);
		
			char dst[255];
			strcpy(dst, option_sel[0]);
			if(strstr(dst, ".iso.0") || strstr(dst, ".ISO.0")) dst[strlen(dst)-6]=0; 
			else dst[strlen(dst)-4]=0;
			
			u8 ret = extractps3iso(option_sel[0], dst, is_FAT32(option_sel[0]));
			
			if(ret==FAILED) show_msg(STR_FAILED); 
			else show_msg(STR_DONE);
		}
		end_loading();
		Window(".");
	} 
	else
	if(strcmp(item, STR_CONVERT_ISO) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Converting to ISO : %s", option_sel[i]);
			
			char dst[255];
			if( strcmp(option_sel[i], "/dev_bdvd") == 0) {
				strcpy(dst, "/dev_hdd0/dev_bdvd.iso");
			} else {
				sprintf(dst, "%s.ISO", option_sel[i]);
			}
			
			u8 ret = makeps3iso(option_sel[i], dst, is_FAT32(option_sel[i]));
			
			if(ret==FAILED) show_msg(STR_FAILED); 
			else show_msg(STR_DONE);
		}
		end_loading();
		Window(".");
	}
	else
	if(strcmp(item, STR_COMPRESS_ISO) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Compressing ISO : %s", option_sel[i]);
			char dst[255];
			strcpy(dst, option_sel[i]);
			dst[strlen(dst)-3]='C';
			dst[strlen(dst)-2]='S';
			dst[strlen(dst)-1]='O';
			if(comp_ciso(option_sel[i], dst, 1)==FAILED) Delete(dst);
		}
		end_loading();
		Window(".");
	} else
	if(strcmp(item, STR_DECOMPRESS_CSO) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Decompressing CSO : %s", option_sel[i]);
			char dst[255];
			strcpy(dst, option_sel[i]);
			dst[strlen(dst)-3]='I';
			dst[strlen(dst)-2]='S';
			dst[strlen(dst)-1]='O';
			if(decomp_ciso(option_sel[i], dst)==FAILED) Delete(dst);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_EXTRACT_THM) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting THM : %s", option_sel[i]);
			ExtractTHM(option_sel[i]);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_EXTRACT_P3T) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting P3T...");
			cxml_extract(option_sel[i]);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_EXTRACT_RAF) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting RAF...");
			cxml_extract(option_sel[i]);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_EXTRACT_QRC) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting QRC...");
			ExtractQRC(option_sel[i]);
		}
		end_loading();
		Window(".");
	}
	else
	if(strcmp(item, STR_CONVERT_GTF_DDS) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Converting to DDS...");
			char dst[255];
			strcpy(dst, option_sel[i]);
			dst[strlen(dst)-3]='d';
			dst[strlen(dst)-2]='d';
			dst[strlen(dst)-1]='s';
			gtf2dds(option_sel[i], dst, 0, 0);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_CONVERT_VAG_WAV) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			char dst[255];
			strcpy(dst, option_sel[i]);
			dst[strlen(dst)-3]='w';
			dst[strlen(dst)-2]='a';
			dst[strlen(dst)-1]='v';
			print_head("Converting to wav...");
			VAG2WAV(option_sel[i], dst);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_CONVERT_JSX_JS) == 0) {
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Converting to JS...");
			char dst[255];
			strcpy(dst, option_sel[0]);
			dst[strlen(dst)-1]=0;
			JSX2JS(option_sel[i], dst);
		}
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_CONVERT_DDS_PNG) == 0) { 
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Converting to PNG...");
			char dst[255];
			strcpy(dst, option_sel[i]);
			dst[strlen(dst)-3]='p';
			dst[strlen(dst)-2]='n';
			dst[strlen(dst)-1]='g';
			ConvertImage(option_sel[i], dst);
		}
		end_loading();
		Window(".");
	}
	else
	if(strcmp(item, STR_CONVERT_TO_PNG) == 0) { 
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Converting to PNG...");
			char dst[255];
			strcpy(dst, option_sel[i]);
			RemoveExtension(dst);
			strcat(dst, ".png");
			convert_to_png(option_sel[i], dst);
		}
		end_loading();
		Window(".");
	}
	else	
	if(strcmp(item, STR_MAKE_APNG) == 0) { 
		start_loading();
		char dst[255];
		strcpy(dst, option_sel[0]);
		dst[strrchr(dst, '/') - dst] = 0;
		strcat(dst, "/Animated.png\0");
		Build_APNG(option_sel, option_sel_N, dst, 0);
		end_loading();
		Window(".");
	}
	else 
	if(strcmp(item, STR_READ_XREG) == 0) { 
		start_loading();
		if( xreg2txt(option_sel[0], "/dev_hdd0/tmp/xreg.txt") == SUCCESS ) 
			open_txt_viewer("/dev_hdd0/tmp/xreg.txt");
		end_loading();
	}
	else
	if(strcmp(item, STR_SET_PERMS) == 0) {
		start_loading();
		print_head("Setting permissions...");
		for(i=0; i<=option_sel_N; i++) {
			SetPerms(option_sel[i]);
		}
		end_loading();
	}
	else
	if(strcmp(item, STR_EXTRACT_HERE) == 0) { 
		start_loading();
		for(i=0; i<=option_sel_N; i++) {
			print_head("Extracting archive...");
			ExtractArchive(option_sel[i]);
		}
		end_loading();
		Window(".");
	}
	else
	if(strcmp(item, STR_MOUNTGAME) == 0) {
		start_loading();
		read_game_setting(-1);
		ret = MountGame(option_sel[0]);
		end_loading();
		if(ret) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	}
	else
	if(strcmp(item, STR_DOCK_FULL) == 0) {
		SetWindowLocation(WINDOW_LOC_MAX);
	} 
	else
	if(strcmp(item, STR_DOCK_LEFT) == 0) {
		SetWindowLocation(WINDOW_LOC_LEFT);
	} 
	else
	if(strcmp(item, STR_DOCK_RIGHT) == 0) {
		SetWindowLocation(WINDOW_LOC_RIGHT);
	} 
	else
	if(strcmp(item, STR_RESTORE) == 0) {
		SetWindowLocation(WINDOW_LOC_DEFAULT);
	} 
	else
	if(strcmp(item, STR_CLOSE) == 0) {
		CloseWindow(window_activ);
	}
	
}

void add_option_item(char *str)
{
	option_item_N++;
	option_item[option_item_N] = strcpy_malloc(str);
}

void Open_option()
{
	option_item_N = -1;
	option_sel_N = -1;
	
	int i;
	option_item = (char **) malloc(OPTION_MAX * sizeof(char *));
	option_sel = (char **) malloc(WINDOW_MAX_ITEMS * sizeof(char *));
	
	for(i=0; i<WINDOW_MAX_ITEMS; i++) option_sel[i]=NULL;
	for(i=0; i<OPTION_MAX; i++) option_item[i]=NULL;
	
	if(window_activ == -1) {
		add_option_item(STR_OPEN_WINDOW);
		return;
	} 
	else {
		int same_ext = -1;
		char *ext=NULL;
		
		for(i=0; i<=window_content_N[window_activ]; i++) {
			if(window_content_Selected[window_activ][i] == YES) {
				option_sel_N++;
				if(strcmp(window_path[window_activ], "/") == 0) {
					option_sel[option_sel_N] = sprintf_malloc("/%s", window_content_Name[window_activ][i]);
				} else {
					option_sel[option_sel_N] = sprintf_malloc("%s/%s", window_path[window_activ], window_content_Name[window_activ][i]);
				}
				
				if(same_ext == -1) { //1st
					same_ext = YES;
					ext = get_ext(option_sel[option_sel_N]);
				} else 
				if(same_ext == YES) {
					if(strcasecmp(ext, get_ext(option_sel[option_sel_N]))) same_ext = NO;
				}
			}
		}
		
		if( window_x[window_activ] + BORDER < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] - BORDER - 40
		&&  window_y[window_activ] + BORDER < curs_y && curs_y < window_y[window_activ] + TOP_H ) {
			u8 loc = GetWindowLocation();
			if(loc!=WINDOW_LOC_MAX) add_option_item(STR_DOCK_FULL);
			if(loc!=WINDOW_LOC_LEFT) add_option_item(STR_DOCK_LEFT);
			if(loc!=WINDOW_LOC_RIGHT) add_option_item(STR_DOCK_RIGHT);
			if(loc!=WINDOW_LOC_DEFAULT) add_option_item(STR_RESTORE);
			add_option_item(STR_CLOSE);
		} else
		if(strcmp( window_path[window_activ], "/") == 0) {
			add_option_item(STR_OPEN_WINDOW);
			
			u8 flash_readonly = YES;
			for(i=0; i<=window_content_N[window_activ]; i++) {
				if( is_dev_blind(window_content_Name[window_activ][i]) ) {
					flash_readonly = NO;
					break;
				}
			}
			if( flash_readonly ) {
				add_option_item(STR_MOUNT_DEVBLIND);
			} 
			else {
				add_option_item(STR_UNMOUNT_DEVBLIND);
			}
			
			if(PEEKnPOKE) {
				add_option_item(STR_DUMP_LV1);
				add_option_item(STR_DUMP_LV2);
			}
			add_option_item(STR_DUMP_FLASH);
			
			
			//add_option_item("Test");
			//add_option_item("Test2");
			//add_option_item("Test3");
			
			add_option_item("InsertEject");
			
			
			if( !cobra && !mamba && PEEKnPOKE) {
				add_option_item(STR_LOAD_MAMBA);
			}
			
			if(option_sel_N==0 ) {
				if( cobra || mamba ) {
					if( FM_OLD_PATH == NULL ) {
						add_option_item(STR_SYMLINK_SRC);
					} else {
						add_option_item(STR_SYMLINK_TARGET);
					}
				}
			}
		}
		else {
			add_option_item(STR_REFRESH);
			add_option_item(STR_NEWFOLDER);
			add_option_item(STR_NEWFILE);
			
			if(0 <= option_copy_N) {
				add_option_item(STR_PASTE);
			}
			if(0 <= option_sel_N) {
				add_option_item(STR_COPY);
				add_option_item(STR_CUT);
				add_option_item(STR_DELETE);
				add_option_item(STR_UNSELECT_ALL);
			}																									
			add_option_item(STR_SELECT_ALL);
			
			if(option_sel_N==0) {
				add_option_item(STR_RENAME);
				
				if( cobra || mamba ) {
					if( FM_OLD_PATH == NULL ) {
						add_option_item(STR_SYMLINK_SRC);
					} else {
						add_option_item(STR_SYMLINK_TARGET);
					}
				}
			}
			
			if( 0 <= option_sel_N) {
				if(same_ext == YES) {		
					
					if( is_folder(ext) ) {
						add_option_item(STR_MAKE_PKG);
						add_option_item(STR_GETMD5);
						add_option_item(STR_GETSHA1);
					}
					
					if(can_view(ext)) {
						if(option_sel_N==0) add_option_item(STR_VIEW);
						
						if(strcasecmp(ext, ".png")) {
							add_option_item(STR_CONVERT_TO_PNG);
						}
						if(!strcasecmp(ext, ".png") && option_sel_N < 0) {
							add_option_item(STR_MAKE_APNG);
						}
					}
					if( can_read(ext) == YES) {
						if(option_sel_N==0) add_option_item(STR_VIEW_TXT);
					}
					
					if(!strcasecmp(ext, ".edat") || !strcasecmp(ext, ".sdat")) {
						add_option_item(STR_DECRYPT_NPDATA);
					} else
					if(!strcasecmp(ext, ".sfo")) {
						if(option_sel_N==0) add_option_item(STR_VIEW_SFO);
					} else
					if(!strcmp(ext, _XREG)) {
						if(option_sel_N==0) add_option_item(STR_READ_XREG);
					} else
					if(!strcasecmp(ext, ".self")) {
						add_option_item(STR_EXTRACT_ELF);
						add_option_item(STR_RESIGN_SELF);
						if(option_sel_N==0) add_option_item(STR_LAUNCH_SELF);
					} else 
					if(!strcmp(ext, _EBOOT_BIN)) {
						add_option_item(STR_EXTRACT_EBOOT);
						add_option_item(STR_RESIGN_EBOOT);
						if(option_sel_N==0) add_option_item(STR_LAUNCH_EBOOT);
					} else 
					if(!strcmp(ext, _EBOOT_ELF)) {
						add_option_item(STR_SIGN_EBOOT);
					} else 
					if(!strcasecmp(ext, ".elf")) {
						add_option_item(STR_SIGN_ELF);
					}  else		
					if(!strcasecmp(ext, ".sprx")) {
						add_option_item(STR_EXTRACT_PRX);
						add_option_item(STR_RESIGN_SPRX);
						
						if(option_sel_N==0) {
							if(path_info("/dev_hdd0/game/PRXLOADER/USRDIR/plugins.txt") != _NOT_EXIST) {
								if(is_it_inside("/dev_hdd0/game/PRXLOADER/USRDIR/plugins.txt", option_sel[0]) == YES) {
									add_option_item(STR_REMOVE_PRXLOADER);
								} else {
									add_option_item(STR_ADD_PRXLOADER);
								}					
							}					
							if(path_info("/dev_hdd0/prx_plugins.txt") != _NOT_EXIST) {
								if(is_it_inside("/dev_hdd0/prx_plugins.txt", option_sel[0]) == YES) {
									add_option_item(STR_REMOVE_PRXLOADER2);
								} else {
									add_option_item(STR_ADD_PRXLOADER2);
								}					
							}
							
							if(path_info("/dev_hdd0/mamba_plugins.txt") != _NOT_EXIST) {
								if(is_it_inside("/dev_hdd0/mamba_plugins.txt", option_sel[0]) == YES) {
									add_option_item(STR_REMOVE_MAMBA);
								} else {
									add_option_item(STR_ADD_MAMBA);
								}
							}
							
							if(path_info("/dev_hdd0/boot_plugins.txt") != _NOT_EXIST) {
								if(is_it_inside("/dev_hdd0/boot_plugins.txt", option_sel[0]) == YES) {
									add_option_item(STR_REMOVE_COBRA);
								} else {
									add_option_item(STR_ADD_COBRA);
								}
							}
						
						}
					} else
					if(!strcasecmp(ext, ".prx")) {
						add_option_item(STR_SIGN_PRX);
					} else
					if(!strcasecmp(ext, ".rco")) {
						add_option_item(STR_EXTRACT_RCO);
					} else 
					if(!strcasecmp(ext, ".pkg")) {
						add_option_item(STR_EXTRACT_PKG);
						if(option_sel_N==0) add_option_item(STR_PKG_INFO);
					} else
					if(!strcasecmp(ext, ".trp")) {
						add_option_item(STR_EXTRACT_TRP);
					} else
					if(!strcmp(ext, _JB_PS3)) {
						add_option_item(STR_CONVERT_ISO);
						//add_option_item(STR_MAKE_SHTCUT_PKG);
						add_option_item(STR_CHECK_IRD);
					} else
					if(!strcmp(ext, _ISO_PS3)) {
						add_option_item(STR_EXTRACT_ISO);
						//add_option_item(STR_MAKE_SHTCUT_PKG);
						add_option_item(STR_CHECK_IRD);
					} else
					if(!strcmp(ext, _ISO_PSP)) {
						add_option_item(STR_COMPRESS_ISO);
						add_option_item(STR_CHECK_CRC32);
					} else
					if(!strcasecmp(ext, ".cso")) {
						add_option_item(STR_DECOMPRESS_CSO);
					} else
					if(!strcasecmp(ext, ".thm")) {
						add_option_item(STR_EXTRACT_THM);
					} else
					if(!strcasecmp(ext, ".p3t")) {
						add_option_item(STR_EXTRACT_P3T);
					} else
					if(!strcasecmp(ext, ".raf")) {
						add_option_item(STR_EXTRACT_RAF);
					} else
					if(!strcasecmp(ext, ".qrc")) {
						add_option_item(STR_EXTRACT_QRC);
					} else
					if(!strcasecmp(ext, ".jsx")) {
						add_option_item(STR_CONVERT_JSX_JS);
					} else
					if(!strcasecmp(ext, ".vag")) {
						add_option_item(STR_CONVERT_VAG_WAV);
					} else
					if(is_archive(ext)) {
						add_option_item(STR_EXTRACT_HERE);
					}
				}
				
				if(option_sel_N==0) {
					if( is_66600(option_sel[0])) {
						add_option_item(STR_JOIN);
					}
					
					if( can_be_mounted(get_platform_from_ext(ext))) {
						add_option_item(STR_MOUNTGAME);
					} else
					if( !strcmp(ext, _ISO_BD_VIDEO) ) {
						add_option_item(STR_MOUNT_BD);
					} else
					if( !strcmp(ext, _ISO_DVD_VIDEO) ) {
						add_option_item(STR_MOUNT_DVD);
					} else
					if( !strcasecmp(ext, _ISO)) {
						add_option_item(STR_MOUNT_DVD);
						add_option_item(STR_MOUNT_BD);
					}
				}
				
				add_option_item(STR_SET_PERMS);
			}
			add_option_item(STR_PROPS);
		}
	}
	
	float k=0;
	for(i=0; i<=option_item_N; i++) {
		if(k<WidthFromStr(option_item[i])) k=WidthFromStr(option_item[i]);
	}
	option_activ = YES;
	option_x = curs_x - 7;
	option_y = curs_y - 7;
	option_h = (option_item_N+1)*15;
	option_w = k+30;
	if(option_y+option_h > 485) option_y = 485 - option_h; 
}

void Draw_option()
{
	if(option_activ == NO) return;
	
	FontColor(BLACK);
	Draw_Box(option_x-1, option_y-1, 0, 0, option_w+2, option_h+2, BLACK, NO); // BORDER
	Draw_Box(option_x, option_y, 0, 0, option_w, option_h, 0xF0F0F0FF, NO);
	FontSize(15);
	SetFontZ(0);
	
	int i;
	for(i=0; i<=option_item_N;i++) {
		if(option_x 	 < curs_x && curs_x < option_x+option_w
		&& option_y+15*i < curs_y && curs_y < option_y+15*(i+1)) {
			FontColor(GREEN);
			Draw_Box(option_x, option_y+15*i, 0, 0, option_w, 15, OVERLAY_COLOR, NO);
		} else FontColor(BLACK);
		
		DrawFormatString(option_x+5, option_y+15*i+2, option_item[i]);
	}
}

void close_option()
{
	int i;
	for(i=0; i<OPTION_MAX; i++) FREE(option_item[i]);
	FREE(option_item);
	
	for(i=0; i<WINDOW_MAX_ITEMS; i++) FREE(option_sel[i]);
	FREE(option_sel);
		
	option_activ = NO;
}

u8 option_input()
{
	if(option_activ == NO) return OFF;
	
	if(NewPad(BUTTON_CROSS)) {	
		//Cursor on option
		if(	option_x < curs_x && curs_x < option_x + option_w
		&& 	option_y < curs_y && curs_y < option_y + option_h )
		{
			int i;
			for(i=0; i<=option_item_N; i++) {
				if(option_x 	 < curs_x && curs_x < option_x+option_w
				&& option_y+15*i < curs_y && curs_y < option_y+15*(i+1)) {
					Option(option_item[i]);
				}
			}
		}
		close_option();
	}
	
	if(NewPad(BUTTON_TRIANGLE) || NewPad(BUTTON_CIRCLE) ) {
		close_option();
	}
	
	if(NewPad(BUTTON_UP)) {
		if(	option_x < curs_x && curs_x < option_x + option_w
		&& 	option_y + 15 < curs_y && curs_y < option_y + option_h )
		{
			curs_y -= 15;
		}
	}
	
	if(NewPad(BUTTON_DOWN)) {
		if(	option_x < curs_x && curs_x < option_x + option_w
		&& 	option_y < curs_y && curs_y < option_y + option_h - 15 )
		{
			curs_y += 15;
		}
	}
	
	return ON;
}

void cursor_input() 
{
	if(picture_viewer_activ) return;
	
	curs_move_x = R2JoyStick_X(BUTTON_L);
	curs_move_y = R2JoyStick_Y(BUTTON_L);
	curs_x += curs_move_x;
	curs_y += curs_move_y;
	if(curs_x > 848) curs_x=848;
	if(curs_x < 0  ) curs_x=0  ;
	if(curs_y > 512) curs_y=512;
	if(curs_y < 0  ) curs_y=0  ;

}

u8 is_float_window()
{
	if(option_activ) return YES;
	if(prop_activ) return YES;
	if(picture_viewer_activ) return YES;
	if(txt_viewer_activ) return YES;
	if(SFO_viewer_activ) return YES;
	
	return NO;
}

u8 window_input()
{
	int i;
	int k;
	
	if(is_float_window()) return CONTINUE;
	
	get_R2speed();

	if(OldPad(BUTTON_CROSS)) curs_push = YES;
	else curs_push = NO;

// Exit FileManager
#ifdef FILEMANAGER
	if(window_activ < 0) {	
		if(HoldCircleDelay()) {
			finalize_FileExplorer();
			return BREAK;
		}
	}
	else {
		if(NewPad(BUTTON_CIRCLE)) {
			CloseWindow(window_activ);
			return CONTINUE;
		}
	}
#else
	if(NewPad(BUTTON_CIRCLE)) {
		if(window_activ < 0) {
			finalize_FileExplorer();
			return BREAK;
		} else {
			CloseWindow(window_activ);
			return CONTINUE;
		}
	}
#endif

	if(NewPad(BUTTON_R3)) {
		root_display++;
		if(MAX_STYLE<root_display) root_display=0;
		update_RootDisplay();
		show_msg_RootDisplay();
	}
	
	// OPTIONS
	if(NewPad(BUTTON_TRIANGLE)) {
		Open_option();
		return CONTINUE;
	}
	
	// New window
	if(NewPad(BUTTON_START)) {
		Window(NULL);
	}
	
#ifdef FILEMANAGER
	if(NewPad(BUTTON_SELECT)) {
		open_SETTINGS();
		return CONTINUE;
	}
#endif
	
	if(window_activ < 0) {
		window_move = NO;
		window_resize_H = NO;
		window_resize_V = NO;
		window_resize_D1 = NO;
		window_resize_D2 = NO;
		return CONTINUE;
	}
	
	if(strcmp(window_path[window_activ], "/") == 0) {
		if(fm_LineSize==BIG) LINE_H = LINE_H1*2.0;
		else LINE_H = LINE_H1;
		COL_H=0;
	} else {
		COL_H = COL_H1;
		LINE_H = LINE_H1;
	}
	
	if(window_scroll_N[window_activ]>0) {
		SCROLL_W = SCROLL_W1;		
	} else {
		SCROLL_W = 0;
	}
	
	// R3 move window
	window_x[window_activ] += R2JoyStick_X(BUTTON_R);
	window_y[window_activ] += R2JoyStick_Y(BUTTON_R);
	if(window_x[window_activ] + window_w[window_activ] > 848 ) window_x[window_activ]=848-window_w[window_activ];
	if(window_x[window_activ] < 0 ) window_x[window_activ]=0;
	if(window_y[window_activ] + window_h[window_activ] > 512 ) window_y[window_activ]=512-window_h[window_activ];
	if(window_y[window_activ] < 0 ) window_y[window_activ]=0;

	
	//Cursor on activ window
	if(	window_x[window_activ] < curs_x && curs_x < (window_x[window_activ] + window_w[window_activ])
	&& 	window_y[window_activ] < curs_y && curs_y < (window_y[window_activ] + window_h[window_activ])   )
	{
		// 'MOUSE CLICK'
		if(NewPad(BUTTON_CROSS)) {
			// browse
			for(i=0 ; i<=window_item_N[window_activ]; i++) {
				if(window_content_N[window_activ] < i+window_scroll_P[window_activ]) break;
				if(  window_x[window_activ]+BORDER					< curs_x && curs_x < window_x[window_activ]	+ window_w[window_activ]-SCROLL_W-BORDER
				&&	 window_y[window_activ]+TOP_H+COL_H+LINE_H*i	< curs_y && curs_y < window_y[window_activ]+TOP_H+COL_H+LINE_H*(i+1)				)
				{
					if( is_folder(window_content_Type[window_activ][i+window_scroll_P[window_activ]]) ){
						Window(window_content_Name[window_activ][i+window_scroll_P[window_activ]]);
					} else 
					if( can_view(window_content_Type[window_activ][i+window_scroll_P[window_activ]]) == YES){
						char picpath[255];
						sprintf(picpath, "%s/%s", window_path[window_activ], window_content_Name[window_activ][i+window_scroll_P[window_activ]]);
						open_picture_viewer(picpath);
					} else 
					if( can_read(window_content_Type[window_activ][i+window_scroll_P[window_activ]] ) == YES ) {
						char txtpath[255];
						sprintf(txtpath, "%s/%s", window_path[window_activ], window_content_Name[window_activ][i+window_scroll_P[window_activ]]);
						open_txt_viewer(txtpath);
					} else 
					if(!strcasecmp(window_content_Type[window_activ][i+window_scroll_P[window_activ]], ".sfo")) {
						char sfopath[255];
						sprintf(sfopath, "%s/%s", window_path[window_activ], window_content_Name[window_activ][i+window_scroll_P[window_activ]]);
						open_SFO_viewer(sfopath);
					} else 
					if(is_iso(window_content_Type[window_activ][i+window_scroll_P[window_activ]])) {
						char IsoPath[255];
						sprintf(IsoPath, "%s/%s", window_path[window_activ], window_content_Name[window_activ][i+window_scroll_P[window_activ]]);
						read_game_setting(-1);
						if( MountGame(IsoPath) == SUCCESS) {
							finalize_FileExplorer();
							MGZ_exit();
							exit(0);
						}
					}
				}
			}
			
			// CLOSE
			float CONTROLBOX_X = window_x[window_activ]+window_w[window_activ]-BORDER-CONTROLBOX_W;
			float CONTROLBOX_Y = window_y[window_activ]+BORDER;
			
			u8 mouse_over = NO;
			if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
			&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
			{
				CloseWindow(window_activ);
				return CONTINUE;
			}
			
			//DOCK_R
			CONTROLBOX_X -= CONTROLBOX_GAP + CONTROLBOX_W;
			mouse_over = NO;
			if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
			&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
			{
				if(GetWindowLocation() != WINDOW_LOC_RIGHT) {
					SetWindowLocation(WINDOW_LOC_RIGHT);
				} else {
					SetWindowLocation(WINDOW_LOC_DEFAULT);
				}
				return CONTINUE;
			}
			
			//DOCK_MAX
			CONTROLBOX_X -= CONTROLBOX_GAP + CONTROLBOX_W;
			mouse_over = NO;
			if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
			&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
			{
				if(GetWindowLocation() != WINDOW_LOC_MAX) {
					SetWindowLocation(WINDOW_LOC_MAX);
				} else {
					SetWindowLocation(WINDOW_LOC_DEFAULT);
				}
				return CONTINUE;
			}
			
			//DOCK_LEFT
			CONTROLBOX_X -= CONTROLBOX_GAP + CONTROLBOX_W;
			mouse_over = NO;
			if( CONTROLBOX_X	< curs_x && curs_x < CONTROLBOX_X + CONTROLBOX_W
			&&  CONTROLBOX_Y	< curs_y && curs_y < CONTROLBOX_Y + CONTROLBOX_H )
			{
				if(GetWindowLocation() != WINDOW_LOC_LEFT) {
					SetWindowLocation(WINDOW_LOC_LEFT);
				} else {
					SetWindowLocation(WINDOW_LOC_DEFAULT);
				}
				return CONTINUE;
			}
			
			// sort Name
			if(0 < COL_H) {
				if( window_x[window_activ]+BORDER   < curs_x && curs_x < window_x[window_activ] + window_w[window_activ]-BORDER-SCROLL_W - window_w_col_size[window_activ]- 10
				&&	window_y[window_activ]+TOP_H	< curs_y && curs_y < window_y[window_activ] + TOP_H + COL_H )
				{
					if(window_sort[window_activ] == ASC) window_sort[window_activ] = DSC;
					else window_sort[window_activ] = ASC;
					sort(window_activ);
				}
			}
		}
	}
	// cursor on passiv window
	else {
		if(NewPad(BUTTON_CROSS) || NewPad(BUTTON_SQUARE) || NewPad(BUTTON_TRIANGLE)) {
			k=-1;
			for(i=0; i<WINDOW_MAX; i++) {
				if(i==window_activ) continue;
				if(window_open[i]==NO) continue;
				if(	window_x[i] < curs_x && curs_x < (window_x[i] + window_w[i])
				&& 	window_y[i] < curs_y && curs_y < (window_y[i] + window_h[i])   )
				{
					if(k==-1) k=i; else
					if(window_z[i] < window_z[k]) k=i;
				}
			}
			if(k!=-1) {
				window_activ = k;
				window_z[window_activ] = 1.0f;
				for(i=0; i<WINDOW_MAX; i++) {
					if(window_open[i] == NO) continue;
					if(i==window_activ) continue;
					window_z[i]+=1.0f;
				}
			}
		}
	}
	
	//SELECT ITEM
	if(NewPad(BUTTON_SQUARE)) {
		if(	window_x[window_activ] < curs_x && curs_x < (window_x[window_activ] + window_w[window_activ])
		&& 	window_y[window_activ] < curs_y && curs_y < (window_y[window_activ] + window_h[window_activ])   )
		{
			for(i=0 ; i <=window_item_N[window_activ]; i++) {
				if(window_content_N[window_activ] < i + window_scroll_P[window_activ]) break;
				if(  window_x[window_activ]+BORDER		 					< curs_x && curs_x < window_x[window_activ] + window_w[window_activ]-SCROLL_W-BORDER
				&&	 window_y[window_activ]+TOP_H+COL_H+LINE_H*i		< curs_y && curs_y < window_y[window_activ]+TOP_H+COL_H+LINE_H*(i+1)				)
				{
					if(window_content_Selected[window_activ][i+window_scroll_P[window_activ]] == NO) {
						if(strcmp(window_content_Name[window_activ][i+window_scroll_P[window_activ]], "..") != 0) {
							window_content_Selected[window_activ][i+window_scroll_P[window_activ]]=YES;
						}
					} else window_content_Selected[window_activ][i+window_scroll_P[window_activ]]=NO;
				}
			}
		}
	}
	
	//MOVE WINDOW
	if((window_x[window_activ] + BORDER < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] - BORDER - 40
	&&  window_y[window_activ] + BORDER < curs_y && curs_y < window_y[window_activ] + TOP_H)
	||
	((	window_move == YES && curs_push) &&
	(	window_x[window_activ] - BORDER*3 < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] + BORDER*3 
	&&  window_y[window_activ] - BORDER*3 < curs_y && curs_y < window_y[window_activ] + TOP_H + BORDER*3) ) )
	{
		window_move = YES;
		if(curs_push) {
			window_x[window_activ] += curs_move_x;
			window_y[window_activ] += curs_move_y;
			if(window_x[window_activ] + window_w[window_activ] > 848 ) window_x[window_activ]=848-window_w[window_activ];
			if(window_x[window_activ] < 0 ) window_x[window_activ]=0;
			if(window_y[window_activ] + window_h[window_activ] > 512 ) window_y[window_activ]=512-window_h[window_activ];
			if(window_y[window_activ] < 0 ) window_y[window_activ]=0;
		}
	} else window_move = NO;
	
	// LEFT
	if((window_x[window_activ] < curs_x && curs_x < window_x[window_activ] + BORDER  
	&&  window_y[window_activ] + BORDER < curs_y && curs_y < window_y[window_activ] + window_h[window_activ] - BORDER )
	||
	((window_resize_H && curs_push) && 
	(	window_x[window_activ] - BORDER*3 < curs_x && curs_x < window_x[window_activ] + BORDER*3  
	&&  window_y[window_activ] + BORDER*3 < curs_y && curs_y < window_y[window_activ] + window_h[window_activ] - BORDER*3 ) ) )
	{
		window_resize_H = YES;
		if(curs_push && (window_w[window_activ] > WINDOW_MIN || curs_move_x < 0)) {
			window_w[window_activ] -= curs_move_x ;
			window_x[window_activ] += curs_move_x;
		}
	} else
	// RIGHT
	if((window_x[window_activ] + window_w[window_activ] - BORDER < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] 
	&&  window_y[window_activ] + BORDER < curs_y && curs_y < window_y[window_activ] + window_h[window_activ] - BORDER )
	||
	((window_resize_H && curs_push) && 
	(   window_x[window_activ] + window_w[window_activ] - BORDER*3 < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] + BORDER*3
	&&  window_y[window_activ] + BORDER*3 < curs_y && curs_y < window_y[window_activ] + window_h[window_activ] - BORDER*3 ) ) )
	{
		window_resize_H = YES;
		if(curs_push && (window_w[window_activ] > WINDOW_MIN || curs_move_x > 0)) window_w[window_activ] += curs_move_x ;
	} else 
	//resize column
	if((window_x[window_activ]+window_w[window_activ]-BORDER-SCROLL_W-window_w_col_size[window_activ] - 5 < curs_x && curs_x < window_x[window_activ]+window_w[window_activ]-BORDER-SCROLL_W-window_w_col_size[window_activ] + 5
	&&  window_y[window_activ]+TOP_H < curs_y && curs_y < window_y[window_activ]+TOP_H+COL_H )
	||( window_resize_H 
	&&  curs_push
	&& 	window_x[window_activ]+window_w[window_activ]-BORDER-SCROLL_W-window_w_col_size[window_activ] - 30 < curs_x && curs_x < window_x[window_activ]+window_w[window_activ]-BORDER-SCROLL_W-window_w_col_size[window_activ] + 30
	&&  window_y[window_activ]+TOP_H < curs_y && curs_y < window_y[window_activ]+TOP_H+COL_H) )
	{
		window_resize_H = YES;
		if(curs_push==YES) window_w_col_size[window_activ] -= curs_move_x;
	} else window_resize_H = NO;
	
	//TOP
	if((window_y[window_activ]  < curs_y && curs_y < window_y[window_activ] + BORDER
	&&	window_x[window_activ] + BORDER < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] - BORDER )
	||
	((window_resize_V && curs_push) && 
	(	window_y[window_activ] - BORDER*3 < curs_y && curs_y < window_y[window_activ] + BORDER*3
	&&	window_x[window_activ] + BORDER*3 < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] - BORDER*3 ) ) )
	{
		window_resize_V = YES;
		if(curs_push && (window_h[window_activ] > WINDOW_MIN || curs_move_y < 0)) {
			window_h[window_activ] -= curs_move_y;
			window_y[window_activ] += curs_move_y;
		}
		
	} else 
	//BOT
	if((window_y[window_activ] + window_h[window_activ] - BORDER < curs_y && curs_y < window_y[window_activ] + window_h[window_activ]
	&&	window_x[window_activ] + BORDER							< curs_x && curs_x < window_x[window_activ] + window_w[window_activ] - BORDER )
	||
	((window_resize_V && curs_push) && 
	(	window_y[window_activ] + window_h[window_activ] - BORDER*3   < curs_y && curs_y < window_y[window_activ] + window_h[window_activ] + BORDER*3
	&&	window_x[window_activ] + BORDER*3							 < curs_x && curs_x < window_x[window_activ] + window_w[window_activ] - BORDER*3 ) ) )
	{
		window_resize_V = YES;
		if(curs_push && (window_h[window_activ] > WINDOW_MIN || curs_move_y > 0)) {
			window_h[window_activ] += curs_move_y;
		}
	} else window_resize_V = NO;
	
	//TOP-LEFT
	if((window_x[window_activ] < curs_x && curs_x < window_x[window_activ] + BORDER 
	&&  window_y[window_activ] < curs_y && curs_y < window_y[window_activ] + BORDER )
	||
	((window_resize_D1 && curs_push) && 
	(	window_x[window_activ]-BORDER*3 < curs_x && curs_x < window_x[window_activ]+BORDER*3 
	&&  window_y[window_activ]-BORDER*3 < curs_y && curs_y < window_y[window_activ]+BORDER*3) ) )
	{
		window_resize_D1 = YES;
		if(curs_push && (window_h[window_activ] > WINDOW_MIN || curs_move_y < 0)) {
			window_h[window_activ] -= curs_move_y;
			window_y[window_activ] += curs_move_y;
		}
		if(curs_push && (window_w[window_activ] > WINDOW_MIN || curs_move_x < 0)) {
			window_w[window_activ] -= curs_move_x ;
			window_x[window_activ] += curs_move_x;
		}
	} else
	//BOT-RIGHT
	if((window_x[window_activ]+window_w[window_activ]-BORDER < curs_x && curs_x < window_x[window_activ]+window_w[window_activ] 
	&&  window_y[window_activ]+window_h[window_activ]-BORDER < curs_y && curs_y < window_y[window_activ]+window_h[window_activ]  )
	||
	((window_resize_D1 && curs_push) && 
	(	window_x[window_activ]+window_w[window_activ]-BORDER*3 < curs_x && curs_x < window_x[window_activ]+window_w[window_activ] +BORDER*3 
	&&  window_y[window_activ]+window_h[window_activ]-BORDER*3 < curs_y && curs_y < window_y[window_activ]+window_h[window_activ] +BORDER*3 ) ) )
	{
		window_resize_D1 = YES;
		if(curs_push && (window_h[window_activ] > WINDOW_MIN || curs_move_y > 0)) window_h[window_activ] += curs_move_y;
		if(curs_push && (window_w[window_activ] > WINDOW_MIN || curs_move_x > 0)) window_w[window_activ] += curs_move_x ;
	} else window_resize_D1 = NO;
	
	//TOP-RIGHT
	if((window_x[window_activ]+window_w[window_activ]-BORDER < curs_x && curs_x < window_x[window_activ]+window_w[window_activ] 
	&&  window_y[window_activ]								 < curs_y && curs_y < window_y[window_activ]+BORDER )
	||
	(	window_resize_D2 
	&& 	curs_push 
	&&  window_x[window_activ]+window_w[window_activ]-BORDER*3	< curs_x && curs_x < window_x[window_activ]+window_w[window_activ] + BORDER*3 
	&&  window_y[window_activ]-BORDER*3							< curs_y && curs_y < window_y[window_activ]+BORDER*3 ) )
	{
		window_resize_D2 = YES;
		if(curs_push && (window_h[window_activ] > WINDOW_MIN || curs_move_y < 0)) {
			window_h[window_activ] -= curs_move_y;
			window_y[window_activ] += curs_move_y;
		}
		if(curs_push && (window_w[window_activ] > WINDOW_MIN || curs_move_x > 0)) window_w[window_activ] += curs_move_x ;
	} else
	//BOT-LEFT
	if((window_x[window_activ]							< curs_x && curs_x < window_x[window_activ]+BORDER 
	&&  window_y[window_activ]+window_h[window_activ]-BORDER < curs_y && curs_y < window_y[window_activ]+window_h[window_activ] )
	||
	(window_resize_D2
	&& curs_push
	&& window_x[window_activ]-BORDER*3 							< curs_x && curs_x < window_x[window_activ]+BORDER*3 
	&& window_y[window_activ]+window_h[window_activ]-BORDER*3   < curs_y && curs_y < window_y[window_activ]+window_h[window_activ]+BORDER*3 ) )	
	{
		window_resize_D2 = YES;
		if(curs_push && (window_h[window_activ] > WINDOW_MIN || curs_move_y > 0)) window_h[window_activ] += curs_move_y;
		if(curs_push && (window_w[window_activ] > WINDOW_MIN || curs_move_x < 0)) {
			window_w[window_activ] -= curs_move_x ;
			window_x[window_activ] += curs_move_x;
		}
	} else window_resize_D2 = NO;
	
	//scroll
	if(window_scroll_N[window_activ]>0 && curs_push) {
		if( window_x[window_activ]+window_w[window_activ]-BORDER-SCROLL_W < curs_x && curs_x < window_x[window_activ]+window_w[window_activ]-BORDER) {
			// Hold it to move
			if( window_y[window_activ]+TOP_H+COL_H+window_scroll_y[window_activ] < curs_y && curs_y < window_y[window_activ]+TOP_H+COL_H+window_scroll_y[window_activ]+window_scroll_size[window_activ] )
			{
				if(( curs_move_y < 0 && window_scroll_P[window_activ] > 0) 
				|| ( curs_move_y > 0 && window_scroll_P[window_activ] < window_scroll_N[window_activ])) 
				{
					
					curs_move_scroll += curs_move_y;
					
					if(curs_move_scroll > 0 && (window_h[window_activ]-TOP_H-COL_H-window_scroll_size[window_activ]-BORDER) * (window_scroll_P[window_activ]+1) / window_scroll_N[window_activ] < window_scroll_y[window_activ] ) {
						window_scroll_P[window_activ]++;
						curs_move_scroll=0;
					}
					if(curs_move_scroll < 0 && window_scroll_y[window_activ] < (window_h[window_activ]-TOP_H-COL_H-window_scroll_size[window_activ]-BORDER) * (window_scroll_P[window_activ]-1) / window_scroll_N[window_activ] ) {
						window_scroll_P[window_activ]--;
						curs_move_scroll=0;
					}
				}
				else curs_move_scroll=0;
			} else
			// Down
			if(window_y[window_activ]+TOP_H+COL_H+window_scroll_y[window_activ]+window_scroll_size[window_activ] < curs_y && curs_y < window_y[window_activ]+window_h[window_activ]-BORDER) {
				if(window_scroll_P[window_activ] + window_item_N[window_activ] < window_scroll_N[window_activ])	window_scroll_P[window_activ]+=window_item_N[window_activ];
				else window_scroll_P[window_activ] = window_scroll_N[window_activ];
			} else
			// Up
			if(window_y[window_activ]+TOP_H+COL_H < curs_y && curs_y < window_y[window_activ]+TOP_H+COL_H+window_scroll_y[window_activ]) {
				if(window_scroll_P[window_activ] > window_item_N[window_activ] ) window_scroll_P[window_activ]-=window_item_N[window_activ];
				else window_scroll_P[window_activ]=0;
			}
		}
	}
	
	// DOCK screen
	if(OldPad(BUTTON_R1)) {
		if(NewPad(BUTTON_LEFT)) {
			SetWindowLocation(WINDOW_LOC_LEFT);
			return CONTINUE;
		} else
		if(NewPad(BUTTON_UP)) {
			SetWindowLocation(WINDOW_LOC_MAX);
			return CONTINUE;
		} else
		if(NewPad(BUTTON_RIGHT)) {
			SetWindowLocation(WINDOW_LOC_RIGHT);
			return CONTINUE;
		} else
		if(NewPad(BUTTON_DOWN)) {
			SetWindowLocation(WINDOW_LOC_DEFAULT);
			return CONTINUE;
		}
	 }
	
	//Refresh Window 
	if(NewPad(BUTTON_L3)) {
		Window(".");
	}
	
	//Parent directory
	if(OldPad(BUTTON_L1)) {
		if(NewPad(BUTTON_LEFT)) {
			Window("..");
			return CONTINUE;
		} else
		if(NewPad(BUTTON_RIGHT)) {
			GotoLastPath();
			return CONTINUE;
		}
	}
	
	
	//Grid_move up page
	if( R2pad(BUTTON_LEFT) ) {
		if(window_scroll_P[window_activ]>0) {
			if(window_scroll_P[window_activ] > window_item_N[window_activ] ) window_scroll_P[window_activ]-=window_item_N[window_activ];
			else window_scroll_P[window_activ]=0;
		}
	}
	
	//Grid_move down page
	if( R2pad(BUTTON_RIGHT) ){
		if(window_scroll_N[window_activ]>0) {
			if(window_scroll_P[window_activ] < window_scroll_N[window_activ]) {
				if(window_scroll_P[window_activ] + window_item_N[window_activ] < window_scroll_N[window_activ])	window_scroll_P[window_activ]+=window_item_N[window_activ];
				else window_scroll_P[window_activ] = window_scroll_N[window_activ];
			}
		}
	}
	
	//Grid_move up scroll
	if( R2pad(BUTTON_UP) ) {
		if(window_scroll_P[window_activ]>0) window_scroll_P[window_activ]--;
	}
	
	//Grid_move down scroll
	if( R2pad(BUTTON_DOWN) ) {
		if(window_scroll_N[window_activ] > 0)
		if(window_scroll_P[window_activ] < window_scroll_N[window_activ]) window_scroll_P[window_activ]++;
	}

	return CONTINUE;
}

void Draw_input()
{
    float x=INPUT_X;
    float y=INPUT_Y;
    FontColor(COLOR_1);
    SetFontZ(0);
 
    if(is_float_window() == NO) {
		x=DrawButton(x, y, STR_OPEN, BUTTON_START);
#ifdef FILEMANAGER
        x=DrawButton(x, y, STR_SETTINGS, BUTTON_SELECT);
#endif
        if(0 <= window_activ) {
            x=DrawButton(x, y, STR_SELECT, BUTTON_SQUARE);
            x=DrawButton(x, y, STR_OPTION, BUTTON_TRIANGLE);
            x=DrawButton(x, y, STR_CLICK, BUTTON_CROSS);
            x=DrawButton(x, y, STR_CURSOR, BUTTON_L);
            x=DrawButton(x, y, STR_REFRESH, BUTTON_L3);
            x=DrawButton(x, y, STR_WINDOW, BUTTON_R);
            x=DrawButton(x, y, STR_SCROLL, BUTTON_UP | BUTTON_DOWN | BUTTON_LEFT | BUTTON_RIGHT);
            x=DrawButton(x, y, STR_CLOSE, BUTTON_CIRCLE);
        } else
        if(window_activ < 0) {
#ifdef FILEMANAGER
			x=DrawSpam(x, y);
			x=DrawButton(x, y, STR_EXIT, BUTTON_CIRCLE);
#else
			x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
#endif
        }
    } else
    if(option_activ == YES) {
        x=DrawButton(x, y, STR_CLICK, BUTTON_CROSS);
        x=DrawButton(x, y, STR_CURSOR, BUTTON_L);
        x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
    } else
    if(prop_activ == YES || SFO_viewer_activ == YES) {
        x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
    } else
    if(txt_viewer_activ == YES){
        Draw_txt_viewer_input();
    } else
    if(picture_viewer_activ == YES) {
        x=DrawButton(x, y, STR_PREVIOUS, BUTTON_LEFT);
        x=DrawButton(x, y, STR_NEXT, BUTTON_RIGHT);
        x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
    }
}

// close if device of this window is unplugged
void AutoClose(int window_id)
{
	if(window_open[window_id] == NO) return;

	if(strcmp(window_path[window_id], "/") == 0) return;

	int n=1;
	char temp[512];
	while(window_path[window_id][n] != '/' && window_path[window_id][n] != 0) n++;
	strncpy(temp, window_path[window_id], n);
	temp[n]=0;

	u8 found = NO;
	for(n=0; n <=DevicesInfo_N; n++) {
		if(strcmp(temp, DevicesInfo[n].MountPoint) == 0) {
			found = YES;
			break;
		}
	}
	
	if(found==NO) CloseWindow(window_id);
}

void AutoRefresh_Windows()
{

#ifdef RPCS3
	return;
#endif

	if(PlugAndPlay == NO) {start_PlugAndPlay(); return;}
	if(do_Refresh == NO) return;
	
	NTFS_mount_all();
	
	exFAT_mount_all();
	
	RefreshDevices();

	int k;
	for(k=0; k<WINDOW_MAX; k++) {
		AutoClose(k);
		if(window_open[k] == NO) continue;
		if(strcmp(window_path[k], "/") == 0) RefreshWindow(k);
	}
	
	do_Refresh  = NO;
}

void Draw_FileExplorer()
{
	start_loading();
	end_load_CURPIC();
	update_RootDisplay();
	init_FileExplorer();
	
	Window(NULL);
	end_loading();
	
	u8 LoopBreak=1;
	while(LoopBreak)
	{		
		cls();
		
		Draw_BGS();
		Draw_MemMonitor();
		
		if(MENU) {
			scene = SCENE_SETTINGS;
			Draw_MENU();
			Draw_MENU_input();
			Draw_picture_viewer();
			Draw_txt_viewer();
			Draw_SFO_viewer();
			Draw_Notification();
		} else {
			scene = SCENE_FILEMANAGER;
			Draw_window();
			Draw_option();
			Draw_properties();
			Draw_picture_viewer();
			Draw_txt_viewer();
			Draw_SFO_viewer();
			Draw_Notification();
			Draw_input();
			Draw_cursor();
		}
		
		AutoRefresh_Windows();
		
		tiny3d_Flip();
		ps3pad_read();
		
		ScreenShot();
		
		if(MENU) {
			input_MENU();
		} else {
			if(	option_input() == OFF)
			if( window_input() == BREAK) {
				LoopBreak=0;
				break;
			}
			cursor_input();
			properties_input();
		}
		
		picture_viewer_input();
		txt_viewer_input();
		SFO_viewer_input();
	}
}

void preview_window(u8 show_window)
{

	if(show_window==NO) {
#ifndef FILEMANAGER
		if(window_path!=NULL) finalize_FileExplorer();
#else
		if( window_x[window_activ]==275 && window_y[window_activ]==250 && window_z[window_activ]==0 ) {
			SetWindowLocation(WINDOW_LOC_DEFAULT);
		}
#endif
		return;
	}
	if(window_path==NULL) {
		update_RootDisplay();
		init_FileExplorer();
		Window(NULL);
	}
	
	int n;
	int wo=0;
	for(n=0; n<WINDOW_MAX; n++) {
		if(window_open[n]==NO) continue;
		wo++;
	}
	
	if( wo == 0 ) {
		Window(NULL);
	} else
	if( 1 < wo ) {
		while(0<=window_activ) CloseWindow(window_activ);
		Window(NULL);
	}
	window_x[window_activ]=275.0f;
	window_y[window_activ]=250.0f;
	window_z[window_activ]=0.0f;

	Draw_window();
}

void show_preview()
{
	u32 title=ITEMS_POSITION;
	if(TITLES[title]==NULL) {
		int i;
		for(i=1; i<=ITEMS_NUMBER; i++) {
			int i_pos = ITEMS_POSITION-i;
			if( i_pos < 0 ) return;
			if(TITLES[i_pos] != NULL) {
				title = i_pos;
				break;
			}
		}
	}
	if(TITLES[title]!=NULL) preview_window(strcmp(TITLES[title], STR_FILEMANAGER) == 0 && MENU_LVL != LVL_TITLE);
}

//*******************************************************
// MENU
//*******************************************************
	
void free_MENU()
{
	int i, j;
	for(i=0; i<MENU_MAX_ITEMS; i++) FREE(ITEMS[i]);
	FREE(ITEMS);

	for(i=0; i<MENU_MAX_ITEMS; i++) {
		for(j=0; j<MENU_MAX_ITEMS_VALUE; j++) {
			FREE(ITEMS_VALUE[i][j]);
		}
		FREE(ITEMS_VALUE[i]);
	}
	FREE(ITEMS_VALUE);
	
	FREE(ITEMS_VALUE_NUMBER);
	FREE(ITEMS_VALUE_POSITION);
	FREE(ITEMS_VALUE_SHOW);
	FREE(ITEMS_TYPE);
	
	for(i=0; i<MENU_MAX_ITEMS; i++) FREE(TITLES[i]);
	FREE(TITLES);
}

void new_MENU()
{
	int i, j;
	
	if(ITEMS!=NULL) free_MENU();
	
	ITEMS = (char **) malloc(MENU_MAX_ITEMS*sizeof(char *));
	for(i=0; i<MENU_MAX_ITEMS; i++) ITEMS[i]=NULL;
	
	ITEMS_VALUE = (char ***) malloc(MENU_MAX_ITEMS*sizeof(char **));
	for(i=0; i<MENU_MAX_ITEMS; i++) {
		ITEMS_VALUE[i] = (char **) malloc(MENU_MAX_ITEMS_VALUE*sizeof(char *));
		for(j=0; j<MENU_MAX_ITEMS_VALUE; j++) ITEMS_VALUE[i][j]=NULL;
	}
	
	ITEMS_VALUE_NUMBER = (s8 *) malloc(MENU_MAX_ITEMS*sizeof(s8));
	ITEMS_VALUE_POSITION = (u8 *) malloc(MENU_MAX_ITEMS*sizeof(u8));
	ITEMS_VALUE_SHOW = (u8 *) malloc(MENU_MAX_ITEMS*sizeof(u8));
	ITEMS_TYPE = (u8 *) malloc(MENU_MAX_ITEMS*sizeof(u8));
	
	for(i=0; i<MENU_MAX_ITEMS; i++) {
		ITEMS_VALUE_NUMBER[i]=-1;
		ITEMS_VALUE_POSITION[i]=0;
		ITEMS_VALUE_SHOW[i]=NO;
		ITEMS_TYPE[i]=ITEM_TEXTBOX;
	}
	
	TITLES = (char **) malloc(MENU_MAX_ITEMS*sizeof(char *));
	for(i=0; i<MENU_MAX_ITEMS; i++) TITLES[i]=NULL;
	
	ITEMS_POSITION = 0;	
	MENU=YES;
	
	if(USE_TITLE_MENU) MENU_LVL=LVL_TITLE;
	else MENU_LVL=LVL_ITEMS;
	
}

void init_MENU()
{
	int i, j;
	for(i=0; i<MENU_MAX_ITEMS; i++) {
		FREE(ITEMS[i]);
		for(j=0; j<MENU_MAX_ITEMS_VALUE; j++) {
			FREE(ITEMS_VALUE[i][j]);
		}
		ITEMS_VALUE_NUMBER[i]=-1;
		ITEMS_VALUE_SHOW[i]=NO;
		ITEMS_TYPE[i]=ITEM_TEXTBOX;
		FREE(TITLES[i]);
	}
	
	ITEMS_NUMBER = -1;
	
	MENU_COLUMN_ITEMS_NUMBER=-1;
	MENU_COLUMN_ITEMS_W = 200;
	MENU_TABLE_START=-1;
	MENU_TABLE_END=-1;
}

void add_item_MENU(char *str, u8 type)
{
	if(MENU_MAX_ITEMS <= ITEMS_NUMBER) {
		show_msg("MAX items !");
		return;
	}
	
	ITEMS_NUMBER++;
	FREE(ITEMS[ITEMS_NUMBER]);
	ITEMS[ITEMS_NUMBER] = strcpy_malloc(str);
	ITEMS_TYPE[ITEMS_NUMBER]=type;
	
	if(type==ITEM_CHECKBOX || type==ITEM_COMMAND || type==ITEM_TOGGLE) {
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=NO;
		ITEMS_VALUE_NUMBER[ITEMS_NUMBER] = 1;
	} else 
	if(type==ITEM_LOCKED) {
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=0;
	}
}

void add_item_value_MENU(char *str)
{
	if(MENU_MAX_ITEMS_VALUE <= ITEMS_VALUE_NUMBER[ITEMS_NUMBER]) {
		show_msg("MAX items value !");
		return;
	}
	ITEMS_VALUE_NUMBER[ITEMS_NUMBER]++;
	FREE(ITEMS_VALUE[ITEMS_NUMBER][ITEMS_VALUE_NUMBER[ITEMS_NUMBER]]);
	ITEMS_VALUE[ITEMS_NUMBER][ITEMS_VALUE_NUMBER[ITEMS_NUMBER]] = strcpy_malloc(str);
}

void add_title_MENU(char *str)
{
	FREE(TITLES[ITEMS_NUMBER+1]);
	TITLES[ITEMS_NUMBER+1] = strcpy_malloc(str);
}

u8 item_is(char *str)
{
	if(MENU_LVL == LVL_TITLE && 0<=TITLE_MENU_FIRST_ITEM) {
		if(strcmp(TITLES[TITLE_MENU_FIRST_ITEM], str) == 0) return YES;
	} else {
		if(ITEMS[ITEMS_POSITION]==NULL) return NO;
		if(strcmp(ITEMS[ITEMS_POSITION], str) == 0) return YES;
	}
	
	return NO;
}

u8 item_value_is(char *str)
{
	if(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]==NULL) return NO;
	if(strcmp(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], str) == 0 ) return YES;

	return NO;
}

u8 item_title_is(char *str)
{
	if(MENU_LVL == LVL_TITLE) return NO;
	
	if( 0<=TITLE_MENU_FIRST_ITEM ){
		if(strcmp(TITLES[TITLE_MENU_FIRST_ITEM], str) == 0 ) return YES;
	}
	
	return NO;
	
}

void Draw_HELP()
{
	float x=50;
	float y=23;
	FontColor(COLOR_1);
	FontSize(13);
	
	if(item_is(STR_OVERWRITE)) {
		DrawString(x, y, STR_OVERWRITE_DESC);
	} else
	if(item_is(STR_BOX3D_GAP)) {
		DrawString(x, y, STR_BOX3D_GAP_DESC);
	} else
	if(item_is(STR_HDD_UNLOCK_SPACE)) {
		DrawString(x, y, STR_HDD_UNLOCK_SPACE_DESC);
	} else
	if(item_is(STR_DUMPER_MAX_TRY)) {
		DrawString(x, y, STR_DUMPER_MAX_TRY_DESC);
	} else
	if(item_is(STR_BOX3D_ALIGN)) {
		DrawString(x, y, STR_BOX3D_ALIGN_DESC);
	} else
	if(item_is(STR_DUMP_DEC)) {
		DrawString(x, y, STR_DUMP_DEC_DESC);
	} else
	if(item_is(STR_DUMP_ENC)) {
		DrawString(x, y, STR_DUMP_ENC_DESC);
	} else
	if(item_is(STR_DUMP_ERK)) {
		DrawString(x, y, STR_DUMP_ERK_DESC);
	} else
	if(item_is(STR_SHOWLOGS)) {
		DrawString(x, y, STR_SHOWLOGS_DESC);
	} else
	if(item_is(STR_DUMP_3DUMP)) {
		DrawString(x, y, STR_DUMP_3DUMP_DESC);
	} else
	if(item_is(STR_REDUMP_LOG)) {
		DrawString(x, y, STR_REDUMP_LOG_DESC);
	} else
	if(item_is(STR_IGNORE_ERR)) {
		DrawString(x, y, STR_IGNORE_ERR_DESC);
	} else
	if(item_is(STR_3K3Y_HEADER)) {
		DrawString(x, y, STR_3K3Y_HEADER_DESC);
	} else
	if(item_is(STR_DYNAREC)) {
		DrawString(x, y, STR_DYNAREC_DESC);
	} else
	if(item_is(STR_BUILD_ISO)) {
		DrawString(x, y, STR_BUILD_ISO_DESC);
	} else
	if(item_is(STR_UPLOADER)) {
		DrawString(x, y, STR_UPLOADER_DESC);
	} else
	if(item_is(STR_BT_AUDIO)) {
		DrawString(x, y, STR_BT_AUDIO_DESC);
	} else
	if(item_is(STR_3D)) {
		DrawString(x, y, STR_3D_DESC);
	} else
	if(item_is(STR_INVERSE)) {
		DrawString(x, y, STR_INVERSE_DESC);
	} else
	if(item_is(STR_NB_LINE)) {
		DrawString(x, y, STR_NB_LINE_DESC);
	} else
	if(item_is(STR_NB_COL)) {
		DrawString(x, y, STR_NB_COL_DESC);
	} else
	if(item_is(STR_KEEP_PROP)) {
		DrawString(x, y, STR_KEEP_PROP_DESC);
	} else
	if(item_is(STR_ANIMATED)) {
		DrawString(x, y, STR_ANIMATED_DESC);
	} else
	if(item_is(STR_DIRECTION)) {
		DrawString(x, y, STR_DIRECTION_DESC);
	} else
	if(item_is(STR_GRID_TYPE)) {
		DrawString(x, y, STR_GRID_TYPE_DESC);
	} else
	if(item_is(STR_SHOW_ICON0)) {
		DrawString(x, y, STR_SHOW_ICON0_DESC);
	} else
	if(item_is(STR_SHOW_GAMECASE)) {
		DrawString(x, y, STR_SHOW_GAMECASE_DESC);
	} else
	if(item_is(STR_SHOW_COVER)) {
		DrawString(x, y, STR_SHOW_COVER_DESC);
	} else
	if(item_is(STR_SHOW_PIC1)) {
		DrawString(x, y, STR_SHOW_PIC1_DESC);
	} else
	if(item_is(STR_SIDE_MENU)) {
		DrawString(x, y, STR_SIDE_MENU_DESC);
	} else
	if(item_is(STR_UI)) {
		DrawString(x, y, STR_UI_DESC);
	} else
	if(item_is(STR_COLOR_1) || item_is(STR_COLOR_2) || item_is(STR_COLOR_3) || item_is(STR_COLOR_4)
	|| item_is(STR_COLOR_NOTIF) || item_is(STR_COLOR_BOXHEAD) || item_is(STR_COLOR_BOXBODY) || item_is(STR_COLOR_SIDEBAR)
	|| item_is(STR_COLOR_BGS) || item_is(STR_COLOR_BG) )
	{
		DrawString(x, y, STR_COLOR_DESC);
	} else
	if(item_is(STR_SHOW_WAVES)) {
		DrawString(x, y, STR_SHOW_WAVES_DESC);
	} else
	if(item_is(STR_WAVES_COLOR)) {
		DrawString(x, y, STR_WAVES_COLOR_DESC);
	} else
	if(item_is(STR_XMB_PRIO)) {
		DrawString(x, y, STR_XMB_PRIO_DESC);
	} else
	if(item_is(STR_HELP)) {
		DrawString(x, y, STR_HELP_DESC);
	} else
	if(item_is(STR_GAME_PATHS)) {
		DrawString(x, y, STR_GAME_PATHS_DESC);
	} else
	if(item_is(STR_UPD_MGZ)) {
		DrawString(x, y, STR_UPD_MGZ_DESC);
	} else
	if(item_is(STR_PLUGIN_MANAGER)) {
		DrawString(x, y, STR_PLUGIN_MANAGER_DESC);
	} else
	if(item_is(STR_DL_COVER)) {
		DrawString(x, y, STR_DL_COVER_DESC);
	} else
	if(item_is(STR_ADJUST)) {
		DrawString(x, y, STR_ADJUST_DESC);
	} else
	if(item_is(STR_DL_UPDATE)) {
		DrawString(x, y, STR_DL_UPDATE_DESC);
	} else
	if(item_is(STR_CHECK_IRD) || item_is(STR_CHECK_CRC32) || item_is(STR_CHECK_MD5)) {
		DrawString(x, y, STR_CHECK_DESC);
	} else
	if(item_is(STR_FIX_PERMS)) {
		DrawString(x, y, STR_FIX_PERMS_DESC);
	} else
	if(item_is(STR_CONVERT_ISO)) {
		DrawString(x, y, STR_CONVERT_ISO_DESC);
	} else
	if(item_is(STR_EXTRACT_ISO)) {
		DrawString(x, y, STR_EXTRACT_ISO_DESC);
	} else
	if(item_is(STR_RESTORE)) {
		DrawString(x, y, STR_RESTORE_DESC);
	} else
	if(item_is(STR_RESIGN)) {
		DrawString(x, y, STR_RESIGN_DESC);
	} else
	if(item_is(STR_PATCH_EBOOT)) {
		DrawString(x, y, STR_PATCH_EBOOT_DESC);
	} else
	if(item_is(STR_MAKE_SHTCUT_PKG)) {
		DrawString(x, y, STR_MAKE_SHTCUT_PKG_DESC);
	} else
	if(item_is(STR_PATCH_EXP)) {
		DrawString(x, y, STR_PATCH_EXP_DESC);
	} else
	if(item_is(STR_MOUNT_APPHOME)) {
		DrawString(x, y, STR_MOUNT_APPHOME_DESC);
	} else
	if(item_is(STR_PATCH_LIBFS)) {
		DrawString(x, y, STR_PATCH_LIBFS_DESC);
	} else
	if(item_is(STR_BDEMU)) {
		DrawString(x, y, STR_BDEMU_DESC);
	} else
	if(item_is(STR_PRIM_USB)) {
		DrawString(x, y, STR_PRIM_USB_DESC);
	} else
	if(item_is(STR_PAYLOAD)) {
		DrawString(x, y, STR_PAYLOAD_DESC);
	} else
	if(item_is(STR_EXT_GAME_DATA)) {
		DrawString(x, y, STR_EXT_GAME_DATA_DESC);
	} else
	if(item_is(STR_CHANGE_IDPS)) {
		DrawString(x, y, STR_CHANGE_IDPS_DESC);
	} else
	if(item_is(STR_CLEAN_SYSCALL)) {
		DrawString(x, y, STR_CLEAN_SYSCALL_DESC);
	} else
	if(item_is(STR_DIRECT_BOOT)) {
		DrawString(x, y, STR_DIRECT_BOOT_DESC);
	} else
	if(item_is(STR_CONFIG)) {
		DrawString(x, y, STR_CONFIG_DESC);
	} else
	if(item_is(STR_PROPS)) {
		DrawString(x, y, STR_PROPS_DESC);
	} else
	if(item_is(STR_ENABLE_NETEMU) || item_is(STR_DISABLE_NETEMU)) {
		DrawString(x, y, STR_NETEMU_DESC);
	} else
	if(item_is(STR_ENABLE_YFIX) || item_is(STR_DISABLE_YFIX)) {
		DrawString(x, y, STR_YFIX_DESC);
	} else
	if(item_is(STR_ENABLE_FMVSKIP) || item_is(STR_DISABLE_FMVSKIP)) {
		DrawString(x, y, STR_FMVSKIP_DESC);
	} else
	if(item_is(STR_ENABLE_480P) || item_is(STR_DISABLE_480P)) {
		DrawString(x, y, STR_480P_DESC);
	} else
	if(item_is(STR_ENABLE_WS) || item_is(STR_DISABLE_WS)) {
		DrawString(x, y, STR_WS_DESC);
	} else
	if(item_is(STR_APPLY_PNACH)) {
		DrawString(x, y, STR_APPLY_PNACH_DESC);
	} else
	if(item_is(STR_REST_PNACH)) {
		DrawString(x, y, STR_REST_PNACH_DESC);
	} else
	if(item_is(STR_CREATE_ICON0)) {
		DrawString(x, y, STR_CREATE_ICON0_DESC);
	} else
	if(item_is(STR_COPY)) {
		DrawString(x, y, STR_COPY_DESC);
	} else
	if(item_is(STR_JOIN)) {
		DrawString(x, y, STR_JOIN_DESC);
	} else
	if(item_is(STR_DELETE)) {
		DrawString(x, y, STR_DELETE_DESC);
	} else
	if(item_is(STR_RENAME)) {
		DrawString(x, y, STR_RENAME_DESC);
	} else
	if(item_is(STR_ADD_FAV) || item_is(STR_REM_FAV)) {
		DrawString(x, y, STR_FAV_DESC);
	} else
	if(item_is(STR_THM)) {
		DrawString(x, y, STR_THM_DESC);
	} else
	if(item_is(STR_LANG)) {
		DrawString(x, y, STR_LANG_DESC);
	} else
	if(item_is(STR_ADD_LIMG) || item_is(STR_REMOVE_LIMG)) {
		DrawString(x, y, STR_LIMG_DESC);
	} else
	if(item_is(STR_FONT)) {
		DrawString(x, y, STR_FONT_DESC);
	} else
	if(item_is(STR_COLORSET)) {
		DrawString(x, y, STR_COLORSET_DESC);
	} else
/*
	if(item_is("Tri-Ace Hack")) {
		DrawString(x, y, "Fixes Tri-Ace games boot crash. VU Add/Sub hack.");
	} else
*/
	if(item_is("0x0E")) {
		DrawString(x, y, "FPU? ADD/SUB accurate opcode");
	} else
	if(item_is("0x0F")) {
		DrawString(x, y, "FPU MUL/DIV/SUB/ADD accurate range");
	} else
	if(item_is("0x10")) {
		DrawString(x, y, "COP2 MUL/DIV/SUB/ADD accurate range - MULDIV_Accurate_range");
	} else
	if(item_is("0x11")) {
		DrawString(x, y, "VU ADD/SUB accurate opcode");
	} else
	if(item_is("0x13")) {
		DrawString(x, y, "Memory card timing related");
	} else
	if(item_is("0x26")) {
		DrawString(x, y, "FPU ADD/SUB accurate range - FPU_Accurate_range");
	} else
	if(item_is("0x27")) {
		DrawString(x, y, "COP2-VU0 MUL/DIV/SUB/ADD accurate range - VU0 macromode accurate range");
	} else
	if(item_is("0x2A")) {
		DrawString(x, y, "Improves COP2 operations accuracy for selected memory range - VU0 macromode accurate range");
	} else
	if(item_is("0x2B")) {
		DrawString(x, y, "Setting mecha HACK to show GODZCD as GODZCDDA. So, it fake cd to be cdda");
	} else
	if(item_is("0x2F")) {
		DrawString(x, y, "Set new SPU2 param");
	} else
	if(item_is("0x35")) {
		DrawString(x, y, "Enable Force Flip Field  - Fix for '[Hang] For soft-lock'");
	} else
	if(item_is("0x41")) {
		DrawString(x, y, "(?) Speedhack (?)");
	} else
	if(item_is("0x44")) {
		DrawString(x, y, "Disable smoothing");
	} else
	if(item_is("0x46")) {
		DrawString(x, y, "Enable L2H Improvement - Fix screen shakes - Dedicated to 2D games");
	} else
	if(item_is("0x47")) {
		DrawString(x, y, "Enable XOR CSR - Fix fullscreen line corruption");
	} else
	if(item_is("0x50")) {
		DrawString(x, y, "Enable button pressure sensitivity.");
	}

	FontSize(15);
}

void Draw_MENU()
{
	if(MENU == NO) return;
	if(txt_viewer_activ) return;
	
	int x1, x2, x3, y=40, y1, i, j;
	u32 color;
	
	y1=y;
	
	FontSize(15);
	SetFontZ(10);
	
	float FINAL_ITEMS_X = 50.0;
	if(MENU_SIDE == NO) {
		MENU_ITEMS_X = FINAL_ITEMS_X;
		MENU_ITEMS_VALUE_X = 250;
		Draw_BGS();
	} else {
		FINAL_ITEMS_X = 593.0;
		TranslateTo(&MENU_ITEMS_X, FINAL_ITEMS_X);
		MENU_ITEMS_VALUE_X = 2*(X_MAX-MENU_ITEMS_X)/3 + MENU_ITEMS_X;
		Draw_SIDEBAR(MENU_ITEMS_X-10);
		SetFontZ(9);
	}
	
	if( USE_TITLE_MENU ) {
		x3 = MENU_ITEMS_X;
		x1 = MENU_ITEMS_VALUE_X;
		x2 = MENU_ITEMS_VALUE_X + 200;
	} else {
		x3 = 0;
		x1 = MENU_ITEMS_X;
		x2 = MENU_ITEMS_VALUE_X;
	}
	
	if( USE_TITLE_MENU ) {
		TITLE_MENU_FIRST_ITEM =ITEMS_POSITION;
		TITLE_MENU_LAST_ITEM  =ITEMS_POSITION;
			
		for(i=1; i<=ITEMS_NUMBER; i++) {
			int i_pos = ITEMS_POSITION+i;
			if( ITEMS_NUMBER < i_pos) break;
			if(TITLES[i_pos] != NULL) break;
			TITLE_MENU_LAST_ITEM = i_pos;
		}
		for(i=0; i<=ITEMS_NUMBER; i++) {
			int i_pos = ITEMS_POSITION-i;
			if(i_pos<0) break;
			TITLE_MENU_FIRST_ITEM = i_pos;
			if(TITLES[i_pos] != NULL) break;
		}	
	}
	
	if(ITEMS_POSITION < MENU_SCROLL_START) MENU_SCROLL = 0;
	if(MENU_SCROLL_START <= ITEMS_POSITION && ITEMS_POSITION <= MENU_SCROLL_START + MENU_SCROLL ) MENU_SCROLL = ITEMS_POSITION - MENU_SCROLL_START;
	
	if(Show_Help) Draw_HELP();
	
	for(i=0; i<=ITEMS_NUMBER; i++) {
		
		if(ITEMS_POSITION == i) {
			if( USE_TITLE_MENU ) {
				current_x=x1;
				current_y=y+new_line(1);
			} else {
				current_x=x2;
				current_y=y;
			}
		}
		
		if(TITLES[i] != NULL) {
			
			if( USE_TITLE_MENU ) {
				if( TITLE_MENU_FIRST_ITEM==i) FontColor(COLOR_2);
				else FontColor(COLOR_1);
				DrawString(x3, y1, TITLES[i]);
				y1+=new_line(1);
			} 
			else {
				y+=10;
				Draw_title(x1, y, TITLES[i]);
				
				if(strcmp( TITLES[i], STR_THM_SETTINGS)==0) {
					FontColor(COLOR_4);
					FontSize(18);
					DrawFormatString(x2, y, Themes[UI_position]);
					FontSize(15);
					FontColor(COLOR_1);
				}
				
				y+=new_line(1)+15;
				y1=y;
				
				if(MENU_SCROLL > 0) {
					for(j=ITEMS_NUMBER; j>=0; j--){
						if(TITLES[j] != NULL) {
							MENU_SCROLL_START=j;
							break;
						}
					}
					if(MENU_SCROLL_START==i) {
						DrawUp(x1-7, y1+5);
						i+=MENU_SCROLL;
					}
				}
			}
		}
		
		if( USE_TITLE_MENU ) {
			if( !(TITLE_MENU_FIRST_ITEM<=i && i<=TITLE_MENU_LAST_ITEM) ) continue;
			if( i == TITLE_MENU_FIRST_ITEM ) y = 40;
		}
		
		if(ITEMS_TYPE[i] == ITEM_TOGGLE) {
			u8 active=YES;
			
			if(ITEMS_POSITION == i && MENU_LVL != LVL_TITLE) {
				color = COLOR_2;
				FontColor(COLOR_2); 
			} else {
				color = COLOR_1;
				FontColor(COLOR_1);
				//active=NO;
			}
			
			if( strcmp(ITEMS[i], STR_PATCH_EXP) == 0 ) {
				DrawChildArrow(x1+5, y, 9, 10, 7, color);
				DrawFormatString(x1+20, y, ITEMS[i]);
			} else {
				DrawFormatString(x1, y, ITEMS[i]);
			}
			
			Draw_toggle(x2, y, 9, 12, ITEMS_VALUE_POSITION[i], active);
			
			y+=new_line(1);
			
		} else
		if(ITEMS_TYPE[i] == ITEM_LOCKED) {
		
			color = SetALPHA(GetALPHA(COLOR_1)/2, COLOR_1);
			
			FontColor(color);
			
			if( strcmp(ITEMS[i], STR_CURRENT) == 0 ) {
				DrawChildArrow(x1+5, y, 9, 10, 7, color);
				DrawFormatString(x1+20, y, ITEMS[i]);
			} else {
				DrawFormatString(x1, y, ITEMS[i]);
			}
			
			if( ITEMS_VALUE_NUMBER[i] == 0 ) DrawFormatString(x2, y, ITEMS_VALUE[i][0]);
			
			y+=new_line(1);
		} else
		if(ITEMS_TYPE[i] == ITEM_TEXTBOX) {
			
			if(ITEMS_POSITION == i && MENU_LVL != LVL_TITLE) {
				color = COLOR_2;
				FontColor(COLOR_2);
			} else {
				color = COLOR_1;
				FontColor(COLOR_1);
			}
			
			if( strcmp(ITEMS[i], STR_PATCH_LIBFS) == 0 ) {
				DrawChildArrow(x1+5, y, 9, 10, 7, color);
				DrawFormatString(x1+20, y, ITEMS[i]);
			} else 
			if( strcmp(&ITEMS[i][4], STR_FM_LEFT_CONTENT) == 0 || strcmp(&ITEMS[i][4], STR_FM_RIGHT_CONTENT) == 0)
			{
				DrawChildArrow(x1+5, y, 9, 10, 7, color);
				DrawFormatString(x1+20, y, &ITEMS[i][4]);
			} else {
				DrawFormatString(x1, y, ITEMS[i]);
			}
			
			FontColor(COLOR_1);
			
			if( ITEMS_VALUE_NUMBER[i] != -1 ) {
				float x2_t = x2;
				
				if(MENU_LVL==LVL_VALUE && ITEMS_POSITION==i) {
					FontColor(COLOR_2);
					
					float w=WidthFromStr(ITEMS_VALUE[i][ITEMS_VALUE_POSITION[i]]);				
					
					if(X_MAX - 5 < x2+w && MENU_ITEMS_X == FINAL_ITEMS_X) {
						y+=new_line(1);
						DrawChildArrow(x1+10, y, 9, 10, 7, COLOR_2);
						x2_t=x1+25;
					}
					
					if( ITEMS_VALUE_NUMBER[i] > 0 ) {
						float h=GetFontHeight();
						DrawDown(x2_t+w/2, y+h*0.85);
						DrawUp(x2_t+w/2,  y);
					}					
					
					DrawFormatString(x2_t, y, ITEMS_VALUE[i][ITEMS_VALUE_POSITION[i]]);
					
				} else {
					FontColor(COLOR_1);
					
					if(ITEMS_VALUE_SHOW[i]==YES) {
						float w=WidthFromStr(ITEMS_VALUE[i][ITEMS_VALUE_POSITION[i]]);				
					
						if(X_MAX - 5 < x2+w && MENU_ITEMS_X == FINAL_ITEMS_X) {
							y+=new_line(1);
							DrawChildArrow(x1+10, y, 9, 10, 7, COLOR_1);
							x2_t=x1+25;
						}
						DrawFormatString(x2_t, y, ITEMS_VALUE[i][ITEMS_VALUE_POSITION[i]]);
					}
				}
				
			}
			
			y+=new_line(1);
		} else
		if(ITEMS_TYPE[i] == ITEM_CHECKBOX) {
			if(i>0) {
				if(ITEMS_TYPE[i-1] != ITEM_CHECKBOX) { y+=10; y1=y; }
			}
			
			Draw_itembox(x1, y, 0, ITEMS[i], ITEMS_VALUE_POSITION[i], ITEMS_POSITION==i && MENU_LVL != LVL_TITLE, ITEMS_VALUE_SHOW[i], COLOR_3);
			
			y+=new_line(1);
		} else
		if(ITEMS_TYPE[i] == ITEM_COMMAND) {
			if(i>0) {
				if(ITEMS_TYPE[i-1] != ITEM_COMMAND) { y+=10; y1=y; }
			}
			
			Draw_itembox(x1, y, 0, ITEMS[i], ITEMS_VALUE_POSITION[i], ITEMS_POSITION==i, ITEMS_VALUE_SHOW[i], RED);
			
			y+=new_line(1);
			
			if(ITEMS_POSITION==i) {	
				for(j=2; j<=ITEMS_VALUE_NUMBER[i]; j++) {
					if(ITEMS_VALUE[i][j] == NULL) break;
					
					if( strncmp( ITEMS_VALUE[i][j], "*", 1) == 0) FontColor(COLOR_4);
					else FontColor(COLOR_1);
					
					DrawFormatString(x1+20, y, ITEMS_VALUE[i][j]);
					y+=new_line(1);
					if(y>450) {
						DrawFormatString(x1+20, y-5, ". . .");
						break;
					}
				}
				FontColor(COLOR_1);
			}
			
		} else
		if(ITEMS_TYPE[i] == ITEM_COLORBOX) {			
			if(ITEMS_POSITION == i && MENU_LVL != LVL_TITLE) FontColor(COLOR_2); 
			else FontColor(COLOR_1);
			
			DrawFormatString(x1, y, ITEMS[i]);

			memcpy(&color, ITEMS_VALUE[i][0], 4);
			
			DrawFormatString(x2 + 20, y, "0x%08X", color);
			
			color=color - GetALPHA(color) + 0xFF;
			Draw_Box(x2, y+1, 10, 0, 16, 10, color, NO);		
						
			y+=new_line(1);
		}
			
		if(MENU_COLUMN_ITEMS_NUMBER != -1 && MENU_TABLE_START != -1) {
			if(MENU_TABLE_START<i && i<=MENU_TABLE_END ) {
				if( (i-MENU_TABLE_START)%MENU_COLUMN_ITEMS_NUMBER == 0 ) {
					x1+=MENU_COLUMN_ITEMS_W;
					x2+=MENU_COLUMN_ITEMS_W;
					y=y1;
				}
				if(i==MENU_TABLE_END) {
					y=y1+new_line(1)*MENU_COLUMN_ITEMS_NUMBER;
					x1=MENU_ITEMS_X;
					x2=MENU_ITEMS_VALUE_X;
				}
			}
			if(MENU_TABLE_START == i) y1=y;
		}
		
		if(y>450 && !USE_TITLE_MENU) {
			if(ITEMS_POSITION > i) MENU_SCROLL += ITEMS_POSITION - i;
			if(i<ITEMS_NUMBER) DrawDown(x1-7, 450);
			break;
		}
	}
	
	show_preview();
}

//*******************************************************
// PS2 MENU
//*******************************************************

float X_ICON0_creator=0;
float Y_ICON0_creator=0;
float W_ICON0_creator=0;
float H_ICON0_creator=0;
char ICON0_creator_CoverPath[512];
u8 ICON0_creator=NO;

void input_ICON0_creator()
{
	if(ICON0_creator == NO) return;

	if(OldPad(BUTTON_UP)) {
		if(Y_ICON0_creator>0) Y_ICON0_creator--;
	}
	
	if(OldPad(BUTTON_DOWN)) {
		if(Y_ICON0_creator + H_ICON0_creator < COVER.height) Y_ICON0_creator++;
	}
	
	if(OldPad(BUTTON_LEFT)) {
		if(X_ICON0_creator>0) X_ICON0_creator--;
	}
	
	if(OldPad(BUTTON_RIGHT)) {
		if(X_ICON0_creator + W_ICON0_creator < COVER.width) X_ICON0_creator++;
	}
	
	if(OldPad(BUTTON_L1)) {
		if(W_ICON0_creator < COVER.width) {
			W_ICON0_creator++;
			H_ICON0_creator = 176 * W_ICON0_creator / 320;
			if(X_ICON0_creator + W_ICON0_creator > COVER.width) X_ICON0_creator=COVER.width-W_ICON0_creator;
			if(Y_ICON0_creator + H_ICON0_creator > COVER.height) Y_ICON0_creator=COVER.height-H_ICON0_creator;
		}
	}
	
	if(OldPad(BUTTON_L2)) {
		if(W_ICON0_creator > COVER.width / 4) {
			W_ICON0_creator--;
			H_ICON0_creator = 176 * W_ICON0_creator / 320;
		}
	}
	
	if(NewPad(BUTTON_SQUARE)) {
		start_loading();
		char out[512];
		strcpy(out, list_game_path[position]);
		RemoveExtension(out);
		strcat(out, ".ICON0.jpg");
		Crop_Image(ICON0_creator_CoverPath, out, X_ICON0_creator, Y_ICON0_creator, W_ICON0_creator, H_ICON0_creator);
		ICON0_creator=NO;
		memset(ICON0_creator_CoverPath, 0, sizeof(ICON0_creator_CoverPath));
		end_loading();
		if( !(list_game_havepic[position] & GAMEPIC_ICON0) ) list_game_havepic[position] |= GAMEPIC_ICON0;
	}
	
	if(NewPad(BUTTON_CIRCLE))
	{
		ICON0_creator=NO;
		memset(ICON0_creator_CoverPath, 0, sizeof(ICON0_creator_CoverPath));
	}
}

void Draw_ICON0_creator()
{
	if(ICON0_creator == NO) return;	
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO); // DARK 50%
	
	float xi, yi, wi, hi;
	float xj, yj, wj, hj;
	
	if(COVER_offset != 0 ) {
		tiny3d_SetTexture(0, COVER_offset, COVER.width, COVER.height, COVER.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		if( COVER.width > 748) {
			wi = 748;
			hi = COVER.height * 748 / COVER.width;
		} else 
		if (COVER.width > 412) {
			hi = 412;
			wi = COVER.width * 412 / COVER.height;
		} else {
			wi = COVER.width;
			hi = COVER.height;
		}
		xi = (848 - wi) / 2;
		yi = (512 - hi) / 2;
	
		Draw_Box(xi, yi, 0, 0, wi, hi, WHITE, YES);
		
		wj = W_ICON0_creator * wi / COVER.width;
		hj = H_ICON0_creator * hi / COVER.height;
		
		xj = X_ICON0_creator * wi / COVER.width;
		yj = Y_ICON0_creator * hi / COVER.height ;
		
		Draw_LineBoxOutside(xi+xj, yi+yj, 0, 5, wj, hj, RED);
	}
}

void Draw_ICON0_creator_input()
{
	if(ICON0_creator == NO) return;	
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_CREATE, BUTTON_SQUARE);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
	x=DrawButton(x, y, STR_ZOOM_OUT, BUTTON_L1 );
	x=DrawButton(x, y, STR_ZOOM_IN, BUTTON_L2 );
	x=DrawButton(x, y, STR_MOVE_FRAME, BUTTON_UP | BUTTON_DOWN | BUTTON_LEFT | BUTTON_RIGHT );
}


void open_ICON0_creator()
{
	int n=0;
	char *temp=NULL;
	while(1)
	{
		temp = GetPath_GAMEPIC_COVER2D(position, n);
		if( temp == NULL) return;
		
		if(path_info(temp) == _FILE) break;
		
		FREE(temp);
		n++;
	}
	
	memset(ICON0_creator_CoverPath, 0, sizeof(ICON0_creator_CoverPath));
	strcpy(ICON0_creator_CoverPath, temp);
	
	FREE(temp);
	
	X_ICON0_creator=0;
	Y_ICON0_creator=0;
	W_ICON0_creator= COVER.width;
	H_ICON0_creator= 176 * W_ICON0_creator / 320;
	
	ICON0_creator = YES;
}

void open_PS2_GAME_MENU();

#define BCNETEMU_ON			1
#define BCNETEMU_OFF		0
#define BCNETEMU_STATUS		2
#define BCNETEMU_ISNOTBC	-1		
#define SYSCALL8_OPCODE_ENABLE_PS2NETEMU	0x1EE9	/* Cobra 7.50 */
#define PS2NETEMU_GET_STATUS				2

// param=1		enable patch
// param=0		disable patch
// param=2		return current status​
// return  1	enabled patch
// return  0	disabled patch
// return -1	its not a bc or semi bc ps3

#define NETCONFIG		1
#define GXCONFIG		2
#define SOFTCONFIG		4
#define CUSTCONFIG		8
#define CURRCONFIG		16
#define MGZ_CUSTCONFIG	32
	
int ps2netemu_cobra(int param)
{
	lv2syscall2(8, (uint64_t) SYSCALL8_OPCODE_USE_PS2NETEMU, (uint64_t)(int)param);
	return_to_user_prog(int);
}

void config_command(u8 state, char *str)
{
	int i;
	for(i=0; i<=ITEMS_NUMBER; i++){
		if(strcmp(ITEMS[i], str) == 0){
			ITEMS_VALUE_POSITION[i] = state;
		}
	}
}

u8 *LoadMEMfromISO(char *iso_file, u32 sector, u32 offset, u32 size)
{
	FILE *f;	
	u32 SectSize=0;
	u32 JP=0;
	
	//print_load("Open %s", iso_file);
	f = fopen(iso_file, "rb");
	if(f==NULL) {
		print_load("Error : LoadMEMfromISO, failed to fopen");
		return NULL;
	}
	if( get_SectorSize(f, &SectSize, &JP) == FAILED) {
		fclose(f);
		print_load("Error : LoadMEMfromISO, failed to get_SectorSize");
		return NULL;
	}
	u8 *mem = (u8*) malloc(size+1);
	if(mem==NULL) {
		print_load("Error : LoadMEMfromISO, failed to malloc");
		fclose(f);
		return NULL;
	}	
	
	u64 iso_offset = (u64)SectSize*(u64)sector+(u64)offset+(u64)JP;
	
	u8 split666 = is_66600(iso_file);
	if(is_splitted_iso(iso_file)==YES || split666) {
			
		char iso_path[128];
		char temp[128];
		u64 fsize=0;
		int i;
		int l = strlen(iso_file);
		
		strcpy(iso_path, iso_file);
		iso_path[l-1]=0;
		if(split666) iso_path[l-2]=0;
		strcpy(temp, iso_path);
		
		for(i=0; i<32; i++) {
			if(split666) sprintf(iso_path, "%s%02d", temp, i);
			else sprintf(iso_path, "%s%d", temp, i);
			
			fsize = get_size(iso_path);
			
			if(iso_offset<fsize) {
				if(i!=0) {
					fclose(f);
					f = fopen(iso_path, "rb");	
					if(f==NULL) return NULL;
				}
				break;
			}
			iso_offset -= fsize;
		}
	}
	
	fseek(f, iso_offset, SEEK_SET);
	
	//print_load("ISO offset : %016llX", iso_offset);
	if( fread(mem, size, 1, f) != size) {
		print_load("Error : LoadMEMfromISO, failed to fread");
		free(mem);
		fclose(f);
		return NULL;
	}
	fclose(f);
	
	return mem;
}

u8 PS2ELF_compare(u32 EE_offset, u8 *data, u32 data_size)
{
	u32 VirtualProg=0;
	u32 ProgOffset=0;
	u16 ProgHeaderNumber=0;
	u32 ProgType=0;
	u32 filesz=0;
	
	memcpy(&ProgHeaderNumber, &PS2ELF_mem[0x2C], 2);
	ProgHeaderNumber = reverse16(ProgHeaderNumber);
	
	int i;
	for(i=0; i < ProgHeaderNumber; i++) {
		memcpy(&ProgType, &PS2ELF_mem[0x34+i*0x20], 4);
		ProgType = reverse32(ProgType);
	
		memcpy(&filesz, &PS2ELF_mem[0x34+0x10+i*0x20], 4);
		filesz = reverse32(filesz);

		if(ProgType==1 && filesz!=0) {
			memcpy(&ProgOffset, &PS2ELF_mem[0x34 + 4 + i*0x20], 4);
			ProgOffset = reverse32(ProgOffset);
			
			memcpy(&VirtualProg, &PS2ELF_mem[0x34 + 4 + 4 + i*0x20], 4);
			VirtualProg = reverse32(VirtualProg);
			
			break;
		}
	}
	
	if(ProgType!=1 || filesz==0) {
		print_load("Error : ProgOffset and VirtualProg not found");
		return NO;
	}
	
	u32 elf_offset;
	elf_offset = EE_offset - (VirtualProg - ProgOffset);
	
	print_load("elf_offset %X", elf_offset);
	print_load("data %02X%02X%02X%02X", data[0], data[1], data[2], data[3]);
	print_load("data %02X%02X%02X%02X", PS2ELF_mem[elf_offset], PS2ELF_mem[elf_offset+1], PS2ELF_mem[elf_offset+2], PS2ELF_mem[elf_offset+3]);
	
	if(!memcmp((char *) &PS2ELF_mem[elf_offset], (char *) data, data_size))
		return YES;
	
	return NO;
}

u8 Create_PS2_CONFIG()
{
	char CONFIG_path[255];
	int i,j;
	unsigned int val32=0;
	unsigned int val32_2=0;
	unsigned int cmdID;
	char CFG_path[255];
	// u64 cur_MD5[2];
	// u64 cfg_md5[2];
	
	sprintf(CONFIG_path, "%s.CONFIG", list_game_path[position]);
	Delete(CONFIG_path);
	
	FILE* f;
	f = fopen(CONFIG_path, "wb");
	if(f==NULL) return FAILED;
	
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;
		if( ITEMS_VALUE_POSITION[i] == NO) continue;
		
		if(strcmp(ITEMS[i], "0x3D") == 0) {
			sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &val32);
			val32=reverse32(val32);
			break;
		}
	}
	
	u32 x3D = 0x3D000000;
	fwrite(&x3D, sizeof(u32), 1, f);
	if(val32==0) val32=0x57440000;
	fwrite(&val32, sizeof(u32), 1, f);
	
	for(i=0; i<=ITEMS_NUMBER; i++) {
				
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;
		if( ITEMS_VALUE_POSITION[i] == NO) continue;
		if(strcmp(ITEMS[i], "0x00") == 0) continue;
		if(strcmp(ITEMS[i], "0x3D") == 0) continue;
			
		sscanf(&ITEMS[i][2], "%X", &cmdID);
		cmdID = reverse32(cmdID);
		fwrite(&cmdID, sizeof(u32), 1, f);
		cmdID=reverse32(cmdID);
		
		switch(cmdID) {
			case 0x01 :
			case 0x02 :
			case 0x0F :
			case 0x10 :
			case 0x26 :
			case 0x27 :
			case 0x29 :
			case 0x48 :
			case 0x4B :
			case 0x4C :
			{
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &val32);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				
				sscanf(&strrchr(ITEMS_VALUE[i][3], ':')[2], "%X", &val32);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				
				break;
			}
			case 0x04 :
			case 0x07 :
			case 0x0D :
			case 0x0E :
			case 0x11 :
			case 0x15 :
			case 0x1F :
			case 0x21 :
			case 0x28 :
			case 0x2C :
			case 0x2E :
			case 0x2F :
			case 0x3D :
			case 0x3F :
			case 0x42 :
			case 0x43 :
			case 0x4D :
			case 0x17 : //u8
			case 0x1C : //u8
			case 0x1D : //u8
			case 0x1E : //u8
			{
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &val32);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				
				break;
			}
			case 0x08 :
			{
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X %X", &val32, &val32_2);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				fwrite(&val32_2, sizeof(u32), 1, f);
				
				sscanf(&strrchr(ITEMS_VALUE[i][3], ':')[2], "%X %X", &val32, &val32_2);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				fwrite(&val32_2, sizeof(u32), 1, f);
				
				sscanf(&strrchr(ITEMS_VALUE[i][4], ':')[2], "%X %X", &val32, &val32_2);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				fwrite(&val32_2, sizeof(u32), 1, f);
				
				sscanf(&strrchr(ITEMS_VALUE[i][5], ':')[2], "%X %X", &val32, &val32_2);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				fwrite(&val32_2, sizeof(u32), 1, f);
				
				break;
			}
			case 0x09 :
			{
				u32 nb;
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &nb);
				nb=reverse32(nb);
				fwrite(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				
				for(j=0; j<nb; j++)
				{
					sscanf(&strrchr(ITEMS_VALUE[i][3+j*3], ':')[2], "%X", &val32);
					val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
					
					sscanf(&strrchr(ITEMS_VALUE[i][4+j*3], ':')[2], "%X %X", &val32_2, &val32);
					//val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
					//val32_2=reverse32(val32_2);
					fwrite(&val32_2, sizeof(u32), 1, f);
					
					sscanf(&strrchr(ITEMS_VALUE[i][5+j*3], ':')[2], "%X %X", &val32_2, &val32);
					//val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
					//val32_2=reverse32(val32_2);
					fwrite(&val32_2, sizeof(u32), 1, f);
				}
				break;
			}
			case 0x0A :
			{
				u32 nb;						
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &nb);
				nb=reverse32(nb);
				fwrite(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				for(j=0; j<nb; j++)
				{
					sscanf(&strrchr(ITEMS_VALUE[i][3+j*3], ':')[2], "%X", &val32);
					val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
					
					sscanf(&strrchr(ITEMS_VALUE[i][4+j*3], ':')[2], "%X", &val32);
					//val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
				
					sscanf(&strrchr(ITEMS_VALUE[i][5+j*3], ':')[2], "%X", &val32);
					//val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
				}
				break;
			}
			case 0x0B :
			{			
				u32 nb;						
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &nb);
				nb=reverse32(nb);
				fwrite(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				
				int t=3;
				for(j=0; j<nb; j++)
				{
					sscanf(&strrchr(ITEMS_VALUE[i][t], ':')[2], "%X", &val32);
					val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
					t++;
					
					sscanf(&strrchr(ITEMS_VALUE[i][t], ':')[2], "%X", &val32);
					val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
					t++;				
					
					u32 size;
					sscanf(&strrchr(ITEMS_VALUE[i][t], ':')[2], "%X", &size);
					size=reverse32(size);
					fwrite(&size, sizeof(u32), 1, f);
					t++;
					
					size=reverse32(size);
					int k;
					for(k=0; k<size/4; k++) {
						if(k%8==0 && k!=0) t++;
						sscanf(&strrchr(ITEMS_VALUE[i][t], ':')[2+9*(k%10)], "%X", &val32);
						val32=reverse32(val32);
						fwrite(&val32, sizeof(u32), 1, f);
					}
					t++;
					for(k=0; k<size/4; k++) {
						if(k%8==0 && k!=0) t++;
						sscanf(&strrchr(ITEMS_VALUE[i][t], ':')[2+9*(k%10)], "%X", &val32);
						val32=reverse32(val32);
						fwrite(&val32, sizeof(u32), 1, f);
					}
					t++;
				}
				break;
			}
			case 0xC :
			{
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &val32);
				sscanf(&strrchr(ITEMS_VALUE[i][3], ':')[2], "%X", &val32_2);
				u32 val = val32*0x10000 + val32_2;
				val=reverse32(val);
				fwrite(&val, sizeof(u32), 1, f);				
				
				break;
			}
			case 0x12 :
			{
				u32 nb;						
				sscanf(&strrchr(ITEMS_VALUE[i][2], ':')[2], "%X", &nb);
				nb=reverse32(nb);
				fwrite(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
								
				for(j=0; j<nb; j++)
				{
					sscanf(&strrchr(ITEMS_VALUE[i][3+j], ':')[2], "%X", &val32);
					val32=reverse32(val32);
					fwrite(&val32, sizeof(u32), 1, f);
				}
				
				break;
			}
			case 0x13 :
			case 0x20 :
			case 0x24 :
			{			
				char str_val[9];
				
				strncpy(str_val, &strrchr(ITEMS_VALUE[i][2], ':')[2], 8);
				sscanf(str_val, "%X", &val32);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				
				strncpy(str_val, &strrchr(ITEMS_VALUE[i][2], ':')[2+8], 8);
				sscanf(str_val, "%X", &val32);
				val32=reverse32(val32);
				fwrite(&val32, sizeof(u32), 1, f);
				
				break;
			}
			default :
				break;
		}		
	}
	
	val32 = 0;
	fwrite(&val32, sizeof(u32), 1, f);
	
	char ID[12];
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if(strcmp(ITEMS[i], "0x00") == 0) {
			if(ITEMS_VALUE[i][2] == NULL) break;
			strcpy(ID, &strrchr(ITEMS_VALUE[i][2], ':')[2]);
			fputs(ID, f);
			fclose(f);
			goto CopyCustom;
		}
	}
	
	strcpy(ID, PS2_ID);
	ID[4]='-';
	ID[8]=ID[9];
	ID[9]=ID[10];
	ID[10]=0;
	fputs(ID, f);
	
	fclose(f);
	
CopyCustom:
	
	/*

	md5_file(CONFIG_path, (u8 *) cur_MD5);
	
	sprintf(CFG_path, "/dev_hdd0/game/%s/USRDIR/sys/CONFIG/NET/%s.CONFIG", ManaGunZ_id, PS2_ID);
	if(path_info(CFG_path) == _FILE) { 
		md5_file(CFG_path, (u8 *) cfg_md5);
		if(cur_MD5[0]==cfg_md5[0] && cur_MD5[1]==cfg_md5[1]) return SUCCESS;
	}
	
	sprintf(CFG_path, "/dev_hdd0/game/%s/USRDIR/sys/CONFIG/GX/%s.CONFIG", ManaGunZ_id, PS2_ID);
	if(path_info(CFG_path) == _FILE) { 
		md5_file(CFG_path, (u8 *) cfg_md5);
		if(cur_MD5[0]==cfg_md5[0] && cur_MD5[1]==cfg_md5[1]) return SUCCESS;
	}
	
	sprintf(CFG_path, "/dev_hdd0/game/%s/USRDIR/sys/CONFIG/SOFT/%s.CONFIG", ManaGunZ_id, PS2_ID);
	if(path_info(CFG_path) == _FILE) { 
		md5_file(CFG_path, (u8 *) cfg_md5);
		if(cur_MD5[0]==cfg_md5[0] && cur_MD5[1]==cfg_md5[1]) return SUCCESS;
	}

	*/
	
	sprintf(CFG_path, "/dev_hdd0/game/%s/USRDIR/sys/custom_cfg/%s.CONFIG", ManaGunZ_id, PS2_ID);
	CopyFile(CONFIG_path, CFG_path);
	
	return SUCCESS;
}

u16 MGZCONFIG()
{
	u8 ret=0;
	char CONFIG_path[128];
	
	sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/NET/%s.CONFIG", PS2_ID);
	if(path_info(CONFIG_path) == _FILE) ret += NETCONFIG;
	
	sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/GX/%s.CONFIG", PS2_ID);
	if(path_info(CONFIG_path) == _FILE) ret += GXCONFIG;
	
	sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/SOFT/%s.CONFIG", PS2_ID);
	if(path_info(CONFIG_path) == _FILE) ret += SOFTCONFIG;
	
	sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/CUSTOM/%s.CONFIG", PS2_ID);
	if(path_info(CONFIG_path) == _FILE) ret += CUSTCONFIG;
	
	sprintf(CONFIG_path, "%s.CONFIG", list_game_path[position]);
	if(path_info(CONFIG_path) == _FILE) ret += CURRCONFIG;
	
	sprintf(CONFIG_path, "/dev_hdd0/game/%s/USRDIR/sys/custom_cfg/%s.CONFIG", ManaGunZ_id, PS2_ID);
	if(path_info(CONFIG_path) == _FILE) {
		if(ret & CUSTCONFIG) {
			u8 MGZ_CONFIG_MD5[0x10];
			u8 DB_CONFIG_MD5[0x10];
			
			md5_file(CONFIG_path, (u8 *) DB_CONFIG_MD5);
			
			sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/CUSTOM/%s.CONFIG", PS2_ID);
			
			md5_file(CONFIG_path, (u8 *) MGZ_CONFIG_MD5);
			
			if( memcmp(DB_CONFIG_MD5, MGZ_CONFIG_MD5, 0x10) != 0) ret += MGZ_CUSTCONFIG;
		}
	}
	
	return ret;
}

void CONFIG_check(char *IsoPath)
{
	char CurrentCONFIG[128];
	
	sprintf(CurrentCONFIG, "%s.CONFIG", IsoPath);
	
	if(path_info(CurrentCONFIG) == _FILE) return;
		
	if( Get_ID(IsoPath, ISO_PS2, PS2_ID) == FAILED) return;
	
	u16 MGZCFGS = MGZCONFIG();
	
	if(MGZCFGS != NONE) {
	
		end_loading();
			
		u8 config_position=0;
		s8 config_number=-1;
		char CONFIG_STR[10][10];

		if(MGZCFGS & MGZ_CUSTCONFIG)  {
			config_number++;
			strcpy(CONFIG_STR[config_number], STR_MGZ_CUSTOM);
		}
		if(MGZCFGS & NETCONFIG) {
			config_number++;
			strcpy(CONFIG_STR[config_number], STR_NET);
		}
		if(MGZCFGS & GXCONFIG) {
			config_number++;
			strcpy(CONFIG_STR[config_number], STR_GX);
		}
		if(MGZCFGS & SOFTCONFIG) {
			config_number++;
			sprintf(CONFIG_STR[config_number], STR_SOFT);
		}
		if(MGZCFGS & CUSTCONFIG)  {
			config_number++;
			sprintf(CONFIG_STR[config_number], STR_CUSTOM);
		}
		
		u8 LoopBreak=1;
		while(LoopBreak)
		{
			cls();
			Draw_BGS();
						
			FontColor(COLOR_1);
			FontSize(20);
			
			float x=250, y=200; 
			DrawFormatString(x, y, "%s", STR_USE_CONFIG);
			y+=20;
			x = DrawFormatString(x, y, "%s : ", STR_LOAD);
			FontColor(COLOR_2);
			DrawString(x, y, CONFIG_STR[config_position]);
			
			FontColor(COLOR_1);
			
			x=INPUT_X;
			y=INPUT_Y;
			FontColor(COLOR_1);
			SetFontZ(0);
			
			x = DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
			x = DrawButton(x, y, STR_CANCEL, BUTTON_CIRCLE);
			
			if(config_number>0) DrawButton(x, y, STR_CHANGE, BUTTON_SQUARE);
			
			Draw_MemMonitor();
			tiny3d_Flip();
			ScreenShot();
			ps3pad_read();
			
			
			if(config_number>0 && NewPad(BUTTON_SQUARE)) {
				if(config_position==config_number) config_position=0;
				else config_position++;
			}
			if(NewPad(BUTTON_CROSS)) {
				char CONFIG_path[128];
				
				if( strcmp(	CONFIG_STR[config_position], STR_MGZ_CUSTOM) == 0) {
					sprintf(CONFIG_path, "/dev_hdd0/game/%s/USRDIR/sys/custom_cfg/%s.CONFIG", ManaGunZ_id, PS2_ID);
				} else
				if( strcmp(	CONFIG_STR[config_position], STR_CUSTOM) == 0) {
					sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/CUSTOM/%s.CONFIG", PS2_ID);
				} else
				if( strcmp(	CONFIG_STR[config_position], STR_NET) == 0) {
					sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/NET/%s.CONFIG", PS2_ID);
				} else
				if( strcmp(	CONFIG_STR[config_position], STR_GX) == 0) {
					sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/GX/%s.CONFIG", PS2_ID);
				} else
				if( strcmp(	CONFIG_STR[config_position], STR_SOFT) == 0) {
					sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/SOFT/%s.CONFIG", PS2_ID);
				}
				
				CopyFile(CONFIG_path, CurrentCONFIG);
				LoopBreak = 0;
				break;
			}
			if(NewPad(BUTTON_CIRCLE)) {
				LoopBreak=0;
				break;
			}
		}
		start_loading();
	}

}

u32 GetVirtualProg()
{
	u32 VirtualAddr=0;
	u32 ProgOffset=0;
	u16 ProgHeaderNumber=0;
	u32 ProgType=0;
	u32 filesz=0;
		
	memcpy(&ProgHeaderNumber, &PS2ELF_mem[0x2C], 2);
	ProgHeaderNumber = reverse16(ProgHeaderNumber);
	
	int i;
	for(i=0; i < ProgHeaderNumber; i++) {
		memcpy(&ProgType, &PS2ELF_mem[0x34+i*0x20], 4);
		ProgType = reverse32(ProgType);

		memcpy(&filesz, &PS2ELF_mem[0x34+0x10+i*0x20], 4);
		filesz = reverse32(filesz);

		if(ProgType==1 && filesz!=0) {
			memcpy(&ProgOffset, &PS2ELF_mem[0x34 + 4 + i*0x20], 4);
			ProgOffset = reverse32(ProgOffset);
			
			memcpy(&VirtualAddr, &PS2ELF_mem[0x34 + 4 + 4 + i*0x20], 4);
			VirtualAddr = reverse32(VirtualAddr);
			
			break;
		}
	}
	
	if(ProgType!=1 || filesz==0) {
		print_load("Error : ProgOffset and VirtualAddr not found");
		return 0;
	}
	
	return (VirtualAddr - ProgOffset);

}

u8 CONFIG_exist_PS2PATCH(u32 ELF_offset, u32 EE_offset)
{
	int i;
	u32 ELFoffset;
	u32 EEoffset;
	
	EEoffset=EE_offset;
	ELFoffset=ELF_offset;
	
	u32 VirtualProg = GetVirtualProg();
	if(VirtualProg==0) return NO;
	
	if(EEoffset==0) EEoffset = ELFoffset + VirtualProg;
	if(ELFoffset==0) ELFoffset = EEoffset - VirtualProg;
	
	if(ELFoffset > PS2ELF_mem_size) return NO;
	
	int ITEM_A=-1;
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;
		if(strcmp(ITEMS[i], "0x0A") == 0) {ITEM_A=i; break;}
	}
	
	if(ITEM_A==-1) return NO;
	
	u32 nb;
	u32 val32;
	sscanf(&strrchr(ITEMS_VALUE[ITEM_A][2], ':')[2], "%X", &nb);
	
	for(i=0; i<nb; i++)
	{
		sscanf(&strrchr(ITEMS_VALUE[ITEM_A][3+i*3], ':')[2], "%X", &val32);
		if(val32==EEoffset) return YES;
	}
	
	return NO;
}

u8 CONFIG_exist_TRIACEHACK()
{
	u32 val32;
	int i;
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;
		if(strcmp(ITEMS[i], "0x01") == 0) {
			sscanf(&strrchr(ITEMS_VALUE[i][3], ':')[2], "%X", &val32);
			if(val32==0x0A) return YES;
		}
	}
	return NO;
}

u8 CONFIG_add_TRIACEHACK()
{
	add_item_MENU("0x01", ITEM_COMMAND);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
	
	add_item_value_MENU("Offset : 00000000");
	add_item_value_MENU("Hack ID : 0000000A");
	
	return SUCCESS;
}

u8 CONFIG_remove_TRIACEHACK()
{
	u32 val32;
	int i;
	int ITEM_TRIACE=-1;
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;
		if(strcmp(ITEMS[i], "0x01") == 0) {
			sscanf(&strrchr(ITEMS_VALUE[i][3], ':')[2], "%X", &val32);
			if(val32==0x0A) {ITEM_TRIACE=i; break;}
		}
	}
	if(ITEM_TRIACE==-1) return FAILED;
	
	int j;
	for(i=ITEM_TRIACE; i<=ITEMS_NUMBER; i++) {
		FREE(ITEMS[i]);
		ITEMS[i] = strcpy_malloc(ITEMS[i+1]);
		for(j=0; j<MENU_MAX_ITEMS_VALUE; j++) {
			FREE(ITEMS_VALUE[i][j]);
			ITEMS_VALUE[i][j] = strcpy_malloc(ITEMS_VALUE[i+1][j]);
		}
		ITEMS_VALUE_NUMBER[i] = ITEMS_VALUE_NUMBER[i+1];
		ITEMS_VALUE_POSITION[i] = ITEMS_VALUE_POSITION[i+1];
		ITEMS_VALUE_SHOW[i] = ITEMS_VALUE_SHOW[i+1];
		ITEMS_TYPE[i] = ITEMS_TYPE[i+1];
	}
	ITEMS_NUMBER--;
	
	return SUCCESS;
}

void CONFIG_remove_PS2PATCH(u32 ELF_offset, u32 EE_offset, u32 patch_size)
{
	int i,j;
	u32 ELFoffset;
	u32 EEoffset;
	
	EEoffset=EE_offset;
	ELFoffset=ELF_offset;
	
	u32 VirtualProg = GetVirtualProg();
	if(VirtualProg==0) return;
	
	if(EEoffset==0) EEoffset = ELFoffset + VirtualProg;
	if(ELFoffset==0) ELFoffset = EEoffset - VirtualProg;
	
	// don't know how to get the original data if it's not in the elf
	if(ELFoffset+patch_size > PS2ELF_mem_size) return; 
	
	int ITEM_A=-1;
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;
		if(strcmp(ITEMS[i], "0x0A") == 0) {ITEM_A=i; break;}
	}
	
	if(ITEM_A==-1) return;
	
	u32 nb;
	u32 val32;
	int k=0;
	sscanf(&strrchr(ITEMS_VALUE[ITEM_A][2], ':')[2], "%X", &nb);
	for(i=0; i<nb; i++)
	{
		sscanf(&strrchr(ITEMS_VALUE[ITEM_A][3+i*3], ':')[2], "%X", &val32);
		if(val32==EEoffset+k*4) {
			for(j=i; j<nb; j++) {
				FREE(ITEMS_VALUE[ITEM_A][3+j*3]);
				FREE(ITEMS_VALUE[ITEM_A][4+j*3]);
				FREE(ITEMS_VALUE[ITEM_A][5+j*3]);
				
				if(5+(j+1)*3 < MENU_MAX_ITEMS_VALUE) {
					ITEMS_VALUE[ITEM_A][3+j*3] = strcpy_malloc(ITEMS_VALUE[ITEM_A][3+(j+1)*3]);
					ITEMS_VALUE[ITEM_A][4+j*3] = strcpy_malloc(ITEMS_VALUE[ITEM_A][4+(j+1)*3]);
					ITEMS_VALUE[ITEM_A][5+j*3] = strcpy_malloc(ITEMS_VALUE[ITEM_A][5+(j+1)*3]);
				}
			}
			nb--;
			i--;
			k++;
			if(k==patch_size/4) break;
			continue;
		}
	}
	
	FREE(ITEMS_VALUE[ITEM_A][2]);
	ITEMS_VALUE[ITEM_A][2] = sprintf_malloc("Number : %08X", nb);
	if(nb==0) {
		int j;
		for(i=ITEM_A; i<=ITEMS_NUMBER; i++) {
			FREE(ITEMS[i]);
			ITEMS[i] = strcpy_malloc(ITEMS[i+1]);
			for(j=0; j<MENU_MAX_ITEMS_VALUE; j++) {
				FREE(ITEMS_VALUE[i][j]);
				ITEMS_VALUE[i][j] = strcpy_malloc(ITEMS_VALUE[i+1][j]);
			}
			ITEMS_VALUE_NUMBER[i] = ITEMS_VALUE_NUMBER[i+1];
			ITEMS_VALUE_POSITION[i] = ITEMS_VALUE_POSITION[i+1];
			ITEMS_VALUE_SHOW[i] = ITEMS_VALUE_SHOW[i+1];
			ITEMS_TYPE[i] = ITEMS_TYPE[i+1];
		}
		ITEMS_NUMBER--;
	}
}

void add_item_value(int item, char *str)
{
	if(MENU_MAX_ITEMS_VALUE <= ITEMS_VALUE_NUMBER[item]-1) {
		show_msg("Max ITEMS value !");
		return;
	}
	
	ITEMS_VALUE_NUMBER[item]++;
	FREE(ITEMS_VALUE[item][ITEMS_VALUE_NUMBER[item]]);
	ITEMS_VALUE[item][ITEMS_VALUE_NUMBER[item]] = strcpy_malloc(str);
}

void CONFIG_add_PS2PATCH(u32 ELF_offset, u32 EE_offset, u8 *patch, u32 patch_size)
{
	int i,j;
	u32 ELFoffset;
	u32 EEoffset;
	
	EEoffset=EE_offset;
	ELFoffset=ELF_offset;

	u32 VirtualProg = GetVirtualProg();
	if(VirtualProg==0) return;
	
	if(EEoffset==0) EEoffset = ELFoffset + VirtualProg;
	if(ELFoffset==0) ELFoffset = EEoffset - VirtualProg;
	
	// don't know how to get the original data if it's not in the elf
	if(ELFoffset+patch_size > PS2ELF_mem_size) return;
	
	char str[128];
	int ITEM_A=-1;
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if( ITEMS_TYPE[i] != ITEM_COMMAND) continue;

		if(strcmp(ITEMS[i], "0x0A") == 0) {ITEM_A=i; break;}
	}
	
	if(ITEM_A==-1) {
		add_item_MENU("0x0A", ITEM_COMMAND);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
		
		ITEM_A=ITEMS_NUMBER;
		
		sprintf(str, "Number : %08X", 0);
		add_item_value_MENU(str);
	}

	u32 nb;
	u32 val32;
	u32 new_patch_number=0;
	sscanf(&strrchr(ITEMS_VALUE[ITEM_A][2], ':')[2], "%X", &nb);
	
	for(i=0; i<patch_size/4; i++)
	{
		u8 patch_exist=NO;
		for(j=0; j<nb; j++) {
			sscanf(&strrchr(ITEMS_VALUE[ITEM_A][3+j*3], ':')[2], "%X", &val32);
			if(val32==EEoffset+i*4) {patch_exist=YES; break;}
		}
		if(patch_exist) continue;
		
		if(MENU_MAX_ITEMS_VALUE <= ITEMS_VALUE_NUMBER[ITEM_A] + 3) {
			show_msg("Too much Patches !");
			break;
		}
		
		new_patch_number++;
		sprintf(str, "Offset : %08X", EEoffset+i*4);
		print_load(str);
		add_item_value(ITEM_A, str);
		
		memcpy(&val32, &PS2ELF_mem[ELFoffset+i*4], 4);
		sprintf(str, "Original data : %08X", val32);
		print_load(str);
		add_item_value(ITEM_A, str);
		
		memcpy(&val32, &patch[i*4], 4);
		sprintf(str, "Patched data : %08X", val32);
		print_load(str);
		add_item_value(ITEM_A, str);
	}
	
	FREE(ITEMS_VALUE[ITEM_A][2]);
	ITEMS_VALUE[ITEM_A][2] = sprintf_malloc("Number : %08X", nb+new_patch_number);
}

u8 CONFIG_exist_PNACH(char *PnachPath)
{
	FILE* fp;
	char line[128];
	u8 ret=NO;
	
	u32 EEoffset;
	u32 Patched_Data;
	
	fp = fopen(PnachPath, "rb");
	if(fp==NULL) {
		print_load("Error : failed to open pnach file");
		return NO;
	}
	
	while(fgets(line, 128, fp) != NULL) {
		if( strstr(line, "patch") == NULL && strstr(line, "comment")==NULL && strstr(line, "gametitle")==NULL ) continue;
		
		if(strncmp(line, "patch=", 6) == 0) 
		{			
			if(strstr(line, ",") == NULL) continue;
			
			char *token;
			unsigned long int value=0;
			token = strtok (line, ", "); //toggle patch
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //cpu
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //addr
			if(token == NULL) continue;
			sscanf(token, "%8lX", &value);
			EEoffset = value;
			value = 0;
			token = strtok (NULL, ", "); //type
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //data
			sscanf(token, "%8lX", &value);
			Patched_Data = reverse32(value);
			
			EEoffset = EEoffset - (EEoffset >> 28)*0x10000000;
			
			ret += CONFIG_exist_PS2PATCH(0, EEoffset);
		}
	}

	fclose(fp);
	if(ret) ret=YES;
	return ret;
}

void CONFIG_remove_PNACH(char *PnachPath)
{
	FILE* fp;
	char line[128];
	
	u32 EEoffset;
	u32 Patched_Data;
	
	fp = fopen(PnachPath, "rb");
	if(fp==NULL) {
		print_load("Error : failed to open pnach file");
		return;
	}
	
	while(fgets(line, 128, fp) != NULL) {
		if( strstr(line, "patch") == NULL && strstr(line, "comment")==NULL && strstr(line, "gametitle")==NULL ) continue;
		
		if(strncmp(line, "patch=", 6) == 0) 
		{			
			if(strstr(line, ",") == NULL) continue;
			
			char *token;
			unsigned long int value=0;
			token = strtok (line, ", "); //toggle patch
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //cpu
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //addr
			if(token == NULL) continue;
			sscanf(token, "%8lX", &value);
			EEoffset = value;
			value = 0;
			token = strtok (NULL, ", "); //type
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //data
			sscanf(token, "%8lX", &value);
			Patched_Data = reverse32(value);

			EEoffset = EEoffset - (EEoffset >> 28)*0x10000000;
			
			CONFIG_remove_PS2PATCH(0, EEoffset, 4);
			
		} else
		if(strncmp(line, "gametitle=", 10) || strncmp(line, "comment=", 8)==0) {
			print_load(&strrchr(line, '=')[1]);
		}
	}

	fclose(fp);
}

void CONFIG_add_PNACH(char *PnachPath)
{
	FILE* fp;
	char line[128];
	
	u32 EEoffset;
	u32 Patched_Data;
	fp = fopen(PnachPath, "rb");
	if(fp==NULL) {
		print_load("Error : failed to open pnach file");
		return;
	}
	
	while(fgets(line, 128, fp) != NULL) {
		if( strstr(line, "patch") == NULL && strstr(line, "comment")==NULL && strstr(line, "gametitle")==NULL ) continue;
		
		if(strncmp(line, "patch=", 6) == 0) 
		{			
			if(strstr(line, ",") == NULL) continue;
			
			char *token;
			unsigned long int value=0;
			token = strtok (line, ", "); //toggle patch
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //cpu
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //addr
			if(token == NULL) continue;
			sscanf(token, "%8lX", &value);
			EEoffset = value;
			value = 0;
			token = strtok (NULL, ", "); //type
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //data
			sscanf(token, "%8lX", &value);
			Patched_Data = reverse32(value);
			
			EEoffset = EEoffset - (EEoffset >> 28)*0x10000000;
			
			CONFIG_add_PS2PATCH(0, EEoffset, (u8 *) &Patched_Data, 4);
			
		} else
		if(strncmp(line, "gametitle=", 10) || strncmp(line, "comment=", 8)==0) {
			print_load(&strrchr(line, '=')[1]);
		}
	}

	fclose(fp);
}

void init_PS2_CONFIG_EDITOR()
{
	init_MENU();
	
	add_title_MENU(STR_CONFIG);
	
	u16 MGZCFGS = MGZCONFIG();	
	if(MGZCFGS != NONE) {
		add_item_MENU(STR_LOAD, ITEM_TEXTBOX);
		
		if(MGZCFGS & CURRCONFIG) {
			add_item_value_MENU(STR_CURRENT);
		}
		if(MGZCFGS & NETCONFIG) {
			add_item_value_MENU(STR_NET);
		}
		if(MGZCFGS & SOFTCONFIG) {
			add_item_value_MENU(STR_SOFT);
		}
		if(MGZCFGS & GXCONFIG) {
			add_item_value_MENU(STR_GX);
		}
		if(MGZCFGS & CUSTCONFIG) {
			add_item_value_MENU(STR_CUSTOM);
		}
		if(MGZCFGS & MGZ_CUSTCONFIG) {
			add_item_value_MENU(STR_MGZ_CUSTOM);
		}
	}
		
	add_item_MENU(STR_NEW_CMD, ITEM_TEXTBOX);
	
	char str[5];
	int i;
	for(i=0; i<=0x50; i++) {
		if(i == 0x30 || i == 0x31 || i == 0x32 || i == 0x33					////////////
		|| i == 0x34 || i == 0x36 || i == 0x37 || i == 0x38					// ??
		|| i == 0x39 || i == 0x3A || i == 0x3B || i == 0x4E || i == 0x4F	////////////
		|| i == 0x03 || i == 0x06 || i == 0x14 || i == 0x19					////////////
		|| i == 0x1A || i == 0x1B || i == 0x22 || i == 0x23					//
		|| i == 0x2A || i == 0x2B || i == 0x35 || i == 0x3E					// simple
		|| i == 0x40 || i == 0x41 || i == 0x44 || i == 0x45					//
		|| i == 0x46 || i == 0x47 || i == 0x49 || i == 0x4A || i == 0x50	////////////
		|| i == 0x2D || i == 0x25 || i == 0x18 || i == 0x16 || i == 0x05	// Next ID
		)	continue;
			
		sprintf(str, "0x%02X", i);
		add_item_value_MENU(str);	
	}
	
	if( Pnach_exist() ) {
		add_item_MENU(STR_PNACH, ITEM_CHECKBOX);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=CONFIG_exist_PNACH(pnach);
	}
	
	if( WS_exist() ) {
		add_item_MENU(STR_WIDESCREEN, ITEM_CHECKBOX);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=CONFIG_exist_PNACH(WS);
	} 
	
	if(PS2PATCH_480P_offset) {
		add_item_MENU(STR_480P, ITEM_CHECKBOX);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=CONFIG_exist_PS2PATCH(PS2PATCH_480P_offset, 0);
	}
	
	if(PS2PATCH_YFIX_offset) {
		add_item_MENU(STR_YFIX, ITEM_CHECKBOX);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=CONFIG_exist_PS2PATCH(PS2PATCH_YFIX_offset+0x24, 0);
	}
	
	if(PS2PATCH_FMVSKIP_offset) {
		add_item_MENU(STR_FMV, ITEM_CHECKBOX);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=CONFIG_exist_PS2PATCH(PS2PATCH_FMVSKIP_offset+8, 0);
	}
/*	
	add_item_MENU("Tri-Ace Hack", ITEM_CHECKBOX);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER]=CONFIG_exist_TRIACEHACK();
*/	
	add_title_MENU(STR_SIMPLE);
	
	MENU_TABLE_START = ITEMS_NUMBER;
	add_item_MENU("0x03", ITEM_COMMAND);
	add_item_MENU("0x06", ITEM_COMMAND);
	add_item_MENU("0x14", ITEM_COMMAND);
	add_item_MENU("0x19", ITEM_COMMAND);
	add_item_MENU("0x1A", ITEM_COMMAND);
	add_item_MENU("0x1B", ITEM_COMMAND);
	add_item_MENU("0x22", ITEM_COMMAND);
	add_item_MENU("0x23", ITEM_COMMAND);
	add_item_MENU("0x2A", ITEM_COMMAND);
	add_item_MENU("0x2B", ITEM_COMMAND);
	add_item_MENU("0x35", ITEM_COMMAND);
	add_item_MENU("0x3E", ITEM_COMMAND);
	add_item_MENU("0x40", ITEM_COMMAND);
	add_item_MENU("0x41", ITEM_COMMAND);
	add_item_MENU("0x44", ITEM_COMMAND);
	add_item_MENU("0x45", ITEM_COMMAND);
	add_item_MENU("0x46", ITEM_COMMAND);
	add_item_MENU("0x47", ITEM_COMMAND);
	add_item_MENU("0x49", ITEM_COMMAND);
	add_item_MENU("0x4A", ITEM_COMMAND);
	add_item_MENU("0x50", ITEM_COMMAND);
	MENU_TABLE_END = ITEMS_NUMBER;
	MENU_COLUMN_ITEMS_NUMBER = 3;
	MENU_COLUMN_ITEMS_W = 100;
	
	add_title_MENU(STR_ADVANCED);
	
}

void load_PS2_CONFIG(char *CONFIG_path)
{
	init_PS2_CONFIG_EDITOR();

	int i;
	u32 cmdID;
	u32 val32;
	u32 val32_2;
	char str[128];
	
	FILE *f;
	
	f = fopen(CONFIG_path, "rb");
	if(f==NULL) return;

	print_load("Open %s", CONFIG_path);
	
	u8 LoopBreak=1;
	while(LoopBreak)
	{
		if( fread(&cmdID, sizeof(u32), 1, f) != 4) {
			LoopBreak=0;
			goto end;
		}

		cmdID=reverse32(cmdID);
		sprintf(str, "0x%02X", cmdID);
		
		print_load("Command %s", str);
		
		switch(cmdID)
		{
			case 0x03 :
			case 0x06 :
			case 0x14 :
			case 0x19 :
			case 0x1A :
			case 0x1B :
			case 0x22 :
			case 0x23 :
			case 0x2A :
			case 0x2B :
			case 0x35 :
			case 0x3E :
			case 0x40 :
			case 0x41 :
			case 0x44 :
			case 0x45 :
			case 0x46 :
			case 0x47 :
			case 0x49 :
			case 0x4A :
			case 0x50 :
			{
				config_command(YES, str);
				break;
			}
			case 0x2D :
			case 0x25 :
			case 0x18 :
			case 0x16 :
			case 0x05 :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				print_load("Next ID");
				add_item_value_MENU("Next ID");
				break;
			}
			case 0x00 :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				char gameID[10];
				
				if( fread(&gameID, sizeof(char), 10, f) != 10) 	{
					LoopBreak=0;
					goto end;
				}		
				
				sprintf(str, "Game ID : %s", gameID);
				print_load(str);
				add_item_value_MENU(str);
				
				LoopBreak=0;
				goto end;
				
				break;
			}
			case 0x01 :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Offset : %08X", val32);
				print_load(str);
				add_item_value_MENU(str);
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Hack ID : %08X", val32);
				print_load(str);
				add_item_value_MENU(str);
				
				break;
			}
			case 0x02 :
			case 0x0F :
			case 0x10 :
			case 0x26 :
			case 0x27 :
			case 0x29 :
			case 0x48 :
			case 0x4B :
			case 0x4C :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Param 1 : %08X", val32);
				print_load(str);
				add_item_value_MENU(str);
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Param 2 : %08X", val32);
				print_load(str);
				add_item_value_MENU(str);
				
				break;
			}
			case 0x04 :
			case 0x07 :
			case 0x0D :
			case 0x0E :
			case 0x11 :
			case 0x15 :
			case 0x1F :
			case 0x21 :
			case 0x28 :
			case 0x2C :
			case 0x2E :
			case 0x2F :
			case 0x3D :
			case 0x3F :
			case 0x42 :
			case 0x43 :
			case 0x4D :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Param : %08X", val32);
				print_load(str);
				add_item_value_MENU(str);
				
				break;
			}
			case 0x08 :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				fread(&val32_2, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				sprintf(str, "PatchedDataMask : %08X %08X", val32, val32_2);
				print_load(str);
				add_item_value_MENU(str);
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				fread(&val32_2, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				sprintf(str, "PatchedData : %08X %08X", val32, val32_2);
				print_load(str);
				add_item_value_MENU(str);
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				fread(&val32_2, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				sprintf(str, "OriginalDataMask : %08X %08X", val32, val32_2);
				print_load(str);
				add_item_value_MENU(str);
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				fread(&val32_2, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				sprintf(str, "OriginalData : %08X %08X", val32, val32_2);
				print_load(str);
				add_item_value_MENU(str);
				
				break;
			}
			case 0x09 :
			{
				u32 nb;
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				fread(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				sprintf(str, "Number : %08X", nb);
				print_load(str);
				add_item_value_MENU(str);
				
				for(i=0; i<nb; i++)
				{
					u32 offset;
					fread(&offset, sizeof(u32), 1, f);
					offset=reverse32(offset);
					sprintf(str, "Offset : %08X", offset);
					print_load(str);
					add_item_value_MENU(str);
					
					fread(&val32, sizeof(u32), 1, f);
					//val32=reverse32(val32);
					fread(&val32_2, sizeof(u32), 1, f);
					//val32_2=reverse32(val32_2);
					
					if( PS2ELF_compare(offset, (u8 *) &val32_2, 4) == NO ||
						PS2ELF_compare(offset+4, (u8 *) &val32, 4) == NO )
					{
						ITEMS_VALUE_SHOW[ITEMS_NUMBER]=YES;
						sprintf(str, "*Original data : %08X %08X", val32_2, val32);
					} else {
						sprintf(str, "Original data : %08X %08X", val32_2, val32);
					}
					print_load(str);
					add_item_value_MENU(str);
					
					fread(&val32, sizeof(u32), 1, f);
					//val32=reverse32(val32);
					fread(&val32_2, sizeof(u32), 1, f);
					//val32_2=reverse32(val32_2);
					sprintf(str, "Patched data : %08X %08X", val32_2, val32);
					print_load(str);
					add_item_value_MENU(str);
					
				}
				break;
			}
			case 0x0A :
			{
				u32 nb;
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				sprintf(str, "Number : %08X", nb);
				print_load(str);
				add_item_value_MENU(str);
				
				for(i=0; i<nb; i++)
				{
					u32 offset;
					fread(&offset, sizeof(u32), 1, f);
					offset=reverse32(offset);
					sprintf(str, "Offset : %08X", offset);
					print_load(str);
					add_item_value_MENU(str);
					
					fread(&val32, sizeof(u32), 1, f);
					//val32=reverse32(val32);
					if( PS2ELF_compare(offset, (u8 *) &val32, 4) == NO ) {
						ITEMS_VALUE_SHOW[ITEMS_NUMBER]=YES;
						sprintf(str, "*Original data : %08X", val32);
					} else {
						sprintf(str, "Original data : %08X", val32);
					}
					print_load(str);
					add_item_value_MENU(str);
					
					fread(&val32, sizeof(u32), 1, f);
					//val32=reverse32(val32);
					sprintf(str, "Patched data : %08X", val32);
					print_load(str);
					add_item_value_MENU(str);
				}
				break;
			}
			case 0x0B :
			{
				u32 nb;
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				sprintf(str, "Number : %08X", nb);
				print_load(str);
				add_item_value_MENU(str);
								
				for(i=0; i<nb; i++)
				{
					u32 sector;
					fread(&sector, sizeof(u32), 1, f);
					sector=reverse32(sector);
					sprintf(str, "Sector : %08X", sector);
					print_load(str);
					add_item_value_MENU(str);
					
					u32 offset;
					fread(&offset, sizeof(u32), 1, f);
					offset=reverse32(offset);
					sprintf(str, "Offset : %08X", offset);
					print_load(str);
					add_item_value_MENU(str);
					
					u32 size;
					fread(&size, sizeof(u32), 1, f);
					size=reverse32(size);
					sprintf(str, "Size : %08X", size);
					print_load(str);
					add_item_value_MENU(str);
										
					char temp[128];
					int k;
					
					strcpy(str, "Patched data :");
					for(k=0; k<size/4; k++) {
						if(k%8==0 && k!=0) {
							add_item_value_MENU(str);
							strcpy(str, "               :");
						}
						strcpy(temp, str);
						if( fread(&val32, sizeof(u32), 1, f) == 0) break;
						val32=reverse32(val32);
						sprintf(str, "%s %08X", temp, val32);
					}
					print_load(str);
					add_item_value_MENU(str);
					
					u8 *ISO_data = LoadMEMfromISO(list_game_path[position], sector, offset, size);
					strcpy(str, "Original data :");
					for(k=0; k<size/4; k++) {
						if(k%8==0 && k!=0) {
							print_load(str);
							add_item_value_MENU(str);
							strcpy(str, "              :");
						}
						strcpy(temp, str);
						if( fread(&val32, sizeof(u32), 1, f) == 0) break;
						val32=reverse32(val32);
						sprintf(str, "%s %08X", temp, val32);
						
						if(ISO_data && str[0] != '*') {
							
							if(memcmp((char *) &ISO_data[k*4], (char *) &val32, 4) != 0) {
								ITEMS_VALUE_SHOW[ITEMS_NUMBER]=YES;
								sprintf(str, "*%s %08X", temp, val32);
								
								//print_load("%X : ISO    : %02X%02X%02X%02X", k*4, ISO_data[k*4], ISO_data[k*4+1], ISO_data[k*4+2], ISO_data[k*4+3]);
								//print_load("%X : CONFIG : %08X",k*4, val32);
							}
						}
					}
					print_load(str);
					add_item_value_MENU(str);
					if(ISO_data) free(ISO_data);
				}
				break;
			}
			case 0xC :
			{
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Param 1 : %02X\n", val32 >> 16);
				print_load(str);
				add_item_value_MENU(str);
				sprintf(str, "Param 2 : %02X\n", val32 & 0xFFFF);
				print_load(str);
				add_item_value_MENU(str);				
				
				break;
			}
			case 0x12 :
			{
				u32 nb;
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&nb, sizeof(u32), 1, f);
				nb=reverse32(nb);
				sprintf(str, "Number : %08X", nb);
				print_load(str);
				add_item_value_MENU(str);
								
				for(i=0; i<nb; i++)
				{
					fread(&val32, sizeof(u32), 1, f);
					val32=reverse32(val32);
					sprintf(str, "Param : %08X", val32);
					print_load(str);
					add_item_value_MENU(str);
				}
				
				break;
			}
			case 0x13 :
			case 0x20 :
			case 0x24 :
			{			
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				fread(&val32_2, sizeof(u32), 1, f);
				val32_2=reverse32(val32_2);
				sprintf(str, "Param : %08X%08X", val32, val32_2);
				print_load(str);
				add_item_value_MENU(str);
				
				break;
			}
			case 0x17 :
			case 0x1C :
			case 0x1D :
			case 0x1E :
			{			
				add_item_MENU(str, ITEM_COMMAND);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER]=YES;
				
				fread(&val32, sizeof(u32), 1, f);
				val32=reverse32(val32);
				sprintf(str, "Param : %02X", val32>>24);
				print_load(str);
				add_item_value_MENU(str);
				
				break;
			}
			default :
				break;
		}
	}

end:
	if(f) fclose(f);
	
	for(i=0; i <= ITEMS_NUMBER; i++) {
		if(strcmp(ITEMS[i], STR_PNACH) == 0) 
			ITEMS_VALUE_POSITION[i]=CONFIG_exist_PNACH(pnach);
		else
		if(strcmp(ITEMS[i], STR_WIDESCREEN) == 0) 
			ITEMS_VALUE_POSITION[i]=CONFIG_exist_PNACH(WS);
		else
		if(strcmp(ITEMS[i], STR_480P) == 0) 
			ITEMS_VALUE_POSITION[i]=CONFIG_exist_PS2PATCH(PS2PATCH_480P_offset, 0);
		else
		if(strcmp(ITEMS[i], STR_YFIX) == 0) 
			ITEMS_VALUE_POSITION[i]=CONFIG_exist_PS2PATCH(PS2PATCH_YFIX_offset+0x24, 0);
		else
		if(strcmp(ITEMS[i], STR_FMV) == 0) 
			ITEMS_VALUE_POSITION[i]=CONFIG_exist_PS2PATCH(PS2PATCH_FMVSKIP_offset+8, 0);
		
		//else
		//if(strcmp(ITEMS[i], "Tri-Ace Hack") == 0)
		//	ITEMS_VALUE_POSITION[i]=CONFIG_exist_TRIACEHACK();
		
	}
	
}

void PS2_CONFIG_MENU_CROSS()
{
	if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_COMMAND) {
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == YES) 
			ITEMS_VALUE_POSITION[ITEMS_POSITION]=NO;
		else
			ITEMS_VALUE_POSITION[ITEMS_POSITION]=YES;
	} else
	if(item_is(STR_PNACH)) {
		if( DEBUG ) start_loading();
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) 
			CONFIG_add_PNACH(pnach);
		else
			CONFIG_remove_PNACH(pnach);
			
		ITEMS_VALUE_POSITION[ITEMS_POSITION]=CONFIG_exist_PNACH(pnach);
		end_loading();
	} else
	if(item_is(STR_WIDESCREEN)) {
		if( DEBUG ) start_loading();
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) 
			CONFIG_add_PNACH(WS);
		else
			CONFIG_remove_PNACH(WS);
		ITEMS_VALUE_POSITION[ITEMS_POSITION]=CONFIG_exist_PNACH(WS);
		end_loading();
	} else
	if(item_is(STR_YFIX)) {
		if( DEBUG ) start_loading();
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) 
			CONFIG_add_PS2PATCH(PS2PATCH_YFIX_offset+0x24, 0, &PS2PATCH_YFIX_FLAG_ENABLE[0x24], 4);
		else
			CONFIG_remove_PS2PATCH(PS2PATCH_YFIX_offset+0x24, 0, 4);
		ITEMS_VALUE_POSITION[ITEMS_POSITION]=CONFIG_exist_PS2PATCH(PS2PATCH_YFIX_offset+0x24, 0);
		end_loading();
	} else
	if(item_is(STR_480P)) {
		if( DEBUG ) start_loading();
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) {
			CONFIG_add_PS2PATCH(PS2PATCH_480P_offset, 0, PS2PATCH_480P_FLAG_ENABLE, 4);
			CONFIG_add_PS2PATCH(PS2PATCH_480P_offset+8, 0, &PS2PATCH_480P_FLAG_ENABLE[8], 4);
			CONFIG_add_PS2PATCH(PS2PATCH_480P_offset+0x10, 0, &PS2PATCH_480P_FLAG_ENABLE[0x10], 4);
		}
		else {
			CONFIG_remove_PS2PATCH(PS2PATCH_480P_offset, 0, 4);
			CONFIG_remove_PS2PATCH(PS2PATCH_480P_offset+8, 0, 4);
			CONFIG_remove_PS2PATCH(PS2PATCH_480P_offset+0x10, 0, 4);
		}
		ITEMS_VALUE_POSITION[ITEMS_POSITION]=CONFIG_exist_PS2PATCH(PS2PATCH_480P_offset, 0);
		end_loading();
	} else
	if(item_is(STR_FMV)) {
		if( DEBUG ) start_loading();
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) 
			CONFIG_add_PS2PATCH(PS2PATCH_FMVSKIP_offset+8, 0, &PS2PATCH_FMVSKIP_FLAG_ENABLE[8], 4);
		else
			CONFIG_remove_PS2PATCH(PS2PATCH_FMVSKIP_offset+8, 0, 4);
		ITEMS_VALUE_POSITION[ITEMS_POSITION]=CONFIG_exist_PS2PATCH(PS2PATCH_FMVSKIP_offset+8, 0);
		end_loading();
	} else
/*
	if(item_is("Tri-Ace Hack")) {
		start_loading();
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) 
			CONFIG_add_TRIACEHACK();
		else
			CONFIG_remove_TRIACEHACK();
		ITEMS_VALUE_POSITION[ITEMS_POSITION]=CONFIG_exist_TRIACEHACK();
		end_loading();
	} else
*/
	if(item_is(STR_LOAD)) {
		char CONFIG_path[128];
		if(item_value_is(STR_CURRENT)) {
			sprintf(CONFIG_path, "%s.CONFIG", list_game_path[position]);
		} else
		if(item_value_is(STR_MGZ_CUSTOM)) {
			sprintf(CONFIG_path, "/dev_hdd0/game/%s/USRDIR/sys/custom_cfg/%s.CONFIG", ManaGunZ_id, PS2_ID);
		} else
		if(item_value_is(STR_NET)) {
			sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/NET/%s.CONFIG", PS2_ID);
		} else
		if(item_value_is(STR_SOFT)) {
			sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/SOFT/%s.CONFIG", PS2_ID);
		} else
		if(item_value_is(STR_GX)) {
			sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/GX/%s.CONFIG", PS2_ID);
		} else
		if(item_value_is(STR_CUSTOM)) {
			sprintf(CONFIG_path, "/dev_hdd0/game/PS2CONFIG/USRDIR/CONFIG/CUSTOM/%s.CONFIG", PS2_ID);
		}
		if( DEBUG ) start_loading();
		load_PS2_CONFIG(CONFIG_path);
		end_loading();
	} else
	if(item_is(STR_NEW_CMD)) {
		show_msg("TODO");
	}
	
}

void close_PS2_CONFIG_EDITOR()
{	
	free_MENU();
	open_PS2_GAME_MENU();
}

void input_PS2_CONFIG_EDITOR()
{
	get_R2speed();
		
	if(MENU_TABLE_START < ITEMS_POSITION && ITEMS_POSITION <=MENU_TABLE_END) {
		if(R2pad(BUTTON_RIGHT)) {
			if(ITEMS_POSITION + MENU_COLUMN_ITEMS_NUMBER <= MENU_TABLE_END) ITEMS_POSITION += MENU_COLUMN_ITEMS_NUMBER;
		} else
		if(R2pad(BUTTON_LEFT)) {
			if(ITEMS_POSITION - MENU_COLUMN_ITEMS_NUMBER > MENU_TABLE_START) ITEMS_POSITION -= MENU_COLUMN_ITEMS_NUMBER;
		}
		if(MENU_TABLE_END < ITEMS_NUMBER) {
			if(R2pad(BUTTON_DOWN)) {
				if( (ITEMS_POSITION-MENU_TABLE_START)%MENU_COLUMN_ITEMS_NUMBER == 0 ) ITEMS_POSITION=MENU_TABLE_END;
			}
		}
		if(0<MENU_TABLE_START) {
			if(R2pad(BUTTON_UP)) {
				if( (ITEMS_POSITION-MENU_TABLE_START)%MENU_COLUMN_ITEMS_NUMBER == 1 ) ITEMS_POSITION=MENU_TABLE_START+1;
			}
		}
	}
	
	if(R2pad(BUTTON_UP)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
			else ITEMS_POSITION--;
			if(ITEMS_POSITION==MENU_TABLE_END) ITEMS_POSITION=MENU_TABLE_START+MENU_COLUMN_ITEMS_NUMBER; 
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
		}
	} else
	if(R2pad(BUTTON_DOWN)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
			else ITEMS_POSITION++;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
		}
	} else
	if(NewPad(BUTTON_CROSS)) {
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION]==0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1 
		&& ITEMS_TYPE[ITEMS_POSITION] != ITEM_COMMAND && ITEMS_TYPE[ITEMS_POSITION] != ITEM_CHECKBOX) 
		{
			MENU_LVL = LVL_VALUE;
		} else {
			PS2_CONFIG_MENU_CROSS();
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(MENU_LVL == LVL_ITEMS)
			close_PS2_CONFIG_EDITOR();
		else
			MENU_LVL = LVL_ITEMS;
	} else
	if(NewPad(BUTTON_START)) {
		if(MENU_LVL == LVL_ITEMS) {
			start_loading();
			if( Create_PS2_CONFIG() ) show_msg(STR_DONE);
			else show_msg(STR_FAILED);
			
			end_loading();
		}
	}
	
}

void Draw_PS2_CONFIG_EDITOR_input()
{
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_COMMAND || ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX) {
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == YES) {
			x=DrawButton(x, y, STR_UNCHECK, BUTTON_CROSS);
		} else {
			x=DrawButton(x, y, STR_CHECK, BUTTON_CROSS);
		}
	} else
	if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_TEXTBOX) {
		x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
	}
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
	if(MENU_LVL == LVL_ITEMS) {
		x=DrawButton(x, y, STR_SAVE_CONFIG, BUTTON_START );
	}
}

void close_PS2_GAME_MENU();
void open_PS2_CONFIG_EDITOR()
{
	start_loading();
	
	close_PS2_GAME_MENU();
	USE_TITLE_MENU=NO;
	new_MENU();
	
	char CONFIG_path[128];
	sprintf(CONFIG_path, "%s.CONFIG", list_game_path[position]);
	load_PS2_CONFIG(CONFIG_path);
	
	MENU_SIDE=NO;
	Draw_MENU_input = &Draw_PS2_CONFIG_EDITOR_input;
	input_MENU = &input_PS2_CONFIG_EDITOR;
	
	end_loading();

}

u32 Get_PS2CRC()
{
	if(PS2ELF_mem == NULL) return 0;
	
	print_load("Getting current CRC...");
	
	u32 CRC=0;
	u32 i;
	prog_bar1_value=0;
	const u32* srcdata = (u32*) PS2ELF_mem;
	u32 max = PS2ELF_mem_size/4;
	for(i=max; i; --i, ++srcdata) {
		CRC ^= *srcdata;
		prog_bar1_value =  (max - i) * 100 / max;
	}

	prog_bar1_value=-1;
	
	return reverse32(CRC);
}

typedef struct
{
	u32 offset;
	u32 data;
} PnachRestore_s;

PnachRestore_s *LoadPnachRestore(char *file, int *size)
{
	int lsize;
	
	PnachRestore_s *data = (PnachRestore_s *) LoadFile(file, &lsize);
	
	*size = lsize/8;
	
	return data;
}

u8 GetRestoreData(PnachRestore_s *in, int size, u32 offset, u32 *data)
{
	int j;
	
	for(j=0; j<size; j++) {
		if(offset==in[j].offset) {
			*data = in[j].data;
			return SUCCESS;
		}
	}
	*data = 0;
	
	return FAILED;
}

u32 Get_Original_PS2CRC()
{	
	
	if(PS2ELF_mem == NULL) return 0;
	
	print_load("Getting original CRC...");
	
	char Rest[128];
	char wsRest[128];
	
	sprintf(Rest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnachrest", ManaGunZ_id, PS2CRC);	
	sprintf(wsRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.wsrest", ManaGunZ_id, PS2CRC);	
	
	int i;
	u32 CRC=0;
	
	int RestSize;
	int wsRestSize;
	PnachRestore_s *RestData = LoadPnachRestore(Rest, &RestSize);
	PnachRestore_s *wsRestData = LoadPnachRestore(wsRest, &wsRestSize);
	
	
	if(PS2PATCH_480P_offset && PS2PATCH_480P == YES) {
		memcpy((char *) PS2ELF_mem + PS2PATCH_480P_offset,  (char *) PS2PATCH_480P_FLAG_DISABLE, sizeof(PS2PATCH_480P_FLAG_DISABLE));	
	}
	
	if(PS2PATCH_YFIX_offset && PS2PATCH_YFIX == YES) {
		memcpy((char *) PS2ELF_mem + PS2PATCH_YFIX_offset,  (char *) PS2PATCH_YFIX_FLAG_DISABLE, sizeof(PS2PATCH_YFIX_FLAG_DISABLE));	
	}
	
	if(PS2PATCH_FMVSKIP_offset && PS2PATCH_FMVSKIP == YES) {
		memcpy((char *) PS2ELF_mem + PS2PATCH_FMVSKIP_offset,  (char *) PS2PATCH_FMVSKIP_FLAG_DISABLE, sizeof(PS2PATCH_FMVSKIP_FLAG_DISABLE));	
	}
		
	for(i=0; i<PS2ELF_mem_size; i+=4) {
		u32 data=0;
		if(GetRestoreData(RestData, RestSize, i, &data)==SUCCESS) {
			CRC ^= data;
		} else 
		if(GetRestoreData(wsRestData, wsRestSize, i, &data)==SUCCESS) {
			CRC ^= data;
		} else {
			CRC ^= *(u32 *) &PS2ELF_mem[i];
		}	
	}
	
	if(PS2PATCH_480P_offset && PS2PATCH_480P == YES) {
		memcpy((char *) PS2ELF_mem + PS2PATCH_480P_offset,  (char *) PS2PATCH_480P_FLAG_ENABLE, sizeof(PS2PATCH_480P_FLAG_ENABLE));	
	}
	if(PS2PATCH_YFIX_offset && PS2PATCH_YFIX == YES) {
		memcpy((char *) PS2ELF_mem + PS2PATCH_YFIX_offset,  (char *) PS2PATCH_YFIX_FLAG_ENABLE, sizeof(PS2PATCH_YFIX_FLAG_ENABLE));	
	}
	if(PS2PATCH_FMVSKIP_offset && PS2PATCH_FMVSKIP == YES) {
		memcpy((char *) PS2ELF_mem + PS2PATCH_FMVSKIP_offset,  (char *) PS2PATCH_FMVSKIP_FLAG_ENABLE, sizeof(PS2PATCH_FMVSKIP_FLAG_ENABLE));	
	}
	
	return reverse32(CRC);
	
}

void find_PS2PATCH()
{
	print_load("Searching PS2 patches...");
	
	PS2PATCH_480P = NO;
	PS2PATCH_YFIX = NO;
	PS2PATCH_FMVSKIP = NO;

	PS2PATCH_480P_offset = 0;
	PS2PATCH_YFIX_offset = 0;
	PS2PATCH_FMVSKIP_offset = 0;
	
	int n;
	prog_bar1_value=0;
	prog_bar2_value=0;
	for(n=0; n < PS2ELF_mem_size ; n+=4) {
	
		prog_bar1_value=(n*100)/PS2ELF_mem_size;
		
		if(!PS2PATCH_480P_offset) {
			if(!memcmp((char *) &PS2ELF_mem[n], (char *) PS2PATCH_480P_FLAG_DISABLE, sizeof(PS2PATCH_480P_FLAG_DISABLE)))
			{
				print_load("480P patch found !");
				PS2PATCH_480P_offset = n;
				PS2PATCH_480P = NO;
				prog_bar2_value += 100/3;
			} else
			if(!memcmp((char *) &PS2ELF_mem[n], (char *) PS2PATCH_480P_FLAG_ENABLE, sizeof(PS2PATCH_480P_FLAG_ENABLE)))
			{
				print_load("480P patch found !");
				PS2PATCH_480P_offset = n;
				PS2PATCH_480P = YES;
				prog_bar2_value += 100/3;
			}			
		}
		
		if(!PS2PATCH_YFIX_offset) {
			if(!memcmp((char *) &PS2ELF_mem[n], (char *) PS2PATCH_YFIX_FLAG_DISABLE, sizeof(PS2PATCH_YFIX_FLAG_DISABLE)))
			{
				print_load("YFIX patch found !");
				PS2PATCH_YFIX_offset = n;
				PS2PATCH_YFIX = NO;
				prog_bar2_value += 100/3;
			} else
			if(!memcmp((char *) &PS2ELF_mem[n], (char *) PS2PATCH_YFIX_FLAG_ENABLE, sizeof(PS2PATCH_YFIX_FLAG_ENABLE)))
			{
				print_load("YFIX patch found !");
				PS2PATCH_YFIX_offset = n;
				PS2PATCH_YFIX = YES;
				prog_bar2_value += 100/3;
			}
		}
		
		if(!PS2PATCH_FMVSKIP_offset) {
			if(!memcmp((char *) &PS2ELF_mem[n], (char *) PS2PATCH_FMVSKIP_FLAG_DISABLE, sizeof(PS2PATCH_FMVSKIP_FLAG_DISABLE)))
			{
				print_load("FMV SKIP patch found !");
				PS2PATCH_FMVSKIP_offset = n;
				PS2PATCH_FMVSKIP = NO;
				prog_bar2_value += 100/3;
			} else
			if(!memcmp((char *) &PS2ELF_mem[n], (char *) PS2PATCH_FMVSKIP_FLAG_ENABLE, sizeof(PS2PATCH_FMVSKIP_FLAG_ENABLE)))
			{
				print_load("FMV SKIP patch found !");
				PS2PATCH_FMVSKIP_offset = n;
				PS2PATCH_FMVSKIP = YES;
				prog_bar2_value += 100/3;
			}
		}
		
		if(PS2PATCH_480P_offset)
		if(PS2PATCH_YFIX_offset)
		if(PS2PATCH_FMVSKIP_offset)
		break;
	}
	
	prog_bar1_value=-1;
	prog_bar2_value=-1;
}

void init_PS2CRC()
{
	if(PS2ELF_mem!=NULL) FREE(PS2ELF_mem);
	
	print_head("Loading...");
		
	PS2ELF_mem = LoadFileFromISO(YES, list_game_path[position], PS2_ID, &PS2ELF_mem_size);
	if(PS2ELF_mem==NULL) print_load("Error : failed to load elf %s", PS2_ID);
	
	find_PS2PATCH();
	
	PS2CRC=0;
	PS2ORICRC=0;
	
	PS2CRC = Get_PS2CRC();
	PS2ORICRC = Get_Original_PS2CRC();
}

void update_PS2CRC()
{
	if(PS2ELF_mem==NULL) {
		init_PS2CRC();
		return;
	}
	
	u32 new_PS2CRC = Get_PS2CRC();
	
	if( new_PS2CRC == PS2CRC) return;
	
	char old[255];
	char new[255];
	
	sprintf(old, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnatchrest", ManaGunZ_id, PS2CRC);
	sprintf(new, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnatchrest", ManaGunZ_id, new_PS2CRC);
	
	if( path_info(old) == _FILE) {
		if( rename(old, new) != 0) {
			print_load("Error : failed to rename %08X.pnatchrest to %08X.pnatchrest", PS2CRC, new_PS2CRC);
		}
	}
	
	sprintf(old, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.wsrest", ManaGunZ_id, PS2CRC);
	sprintf(new, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.wsrest", ManaGunZ_id, new_PS2CRC);
	
	if( path_info(old) == _FILE) {
		if( rename(old, new) != 0) {
			print_load("Error : failed to rename %08X.wsrest to %08X.wsrest", PS2CRC, new_PS2CRC);
		}
	}
	
	PS2CRC = new_PS2CRC;
}

u8 Apply_PS2PATCH(u32 patch_offset, u8 *patch_value, int patch_size)
{
	FILE* fi;
	
	fi = fopen(list_game_path[position], "rb+");
	if(fi==NULL) {print_load(list_game_path[position]); print_load("Error : failed to open iso file"); return FAILED; }

	u64 file_offset=0;
	u32 size=0;
	u8 ret;

	ret = get_FileOffset(fi, PS2_ID, &file_offset, &size); 

	if(file_offset==0 || size==0 || ret == FAILED) {
		print_load("Error : file_pos. File : %s file_offset= %X size= %X", PS2_ID, file_offset, size);
		fclose(fi);
		return FAILED;
	}
	
	fseek(fi, file_offset + patch_offset, SEEK_SET);
	
	fwrite(patch_value, 1, patch_size, fi);
	
	fclose(fi);
	
	memcpy((char *) PS2ELF_mem + patch_offset, patch_value, patch_size);
	
	update_PS2CRC();
	
	return SUCCESS;
}

u8 is_pnached()
{
	char PnachRest[128];
	
	sprintf(PnachRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnachrest", ManaGunZ_id, PS2CRC);
	
	if(path_info(PnachRest) == _NOT_EXIST) return NO; else
	return YES;
}

u8 Pnach_exist()
{
	sprintf(pnach, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnach", ManaGunZ_id, PS2ORICRC);
	if(path_info(pnach) == _FILE) return YES;
	
	int i;
	for(i=0; i<=device_number; i++) {
		sprintf(pnach, "/%s/PNACH/%08X.pnach", list_device[i], PS2ORICRC);
		if(path_info(pnach) == _FILE) return YES;
	}
	
	return NO;
}

u8 restore_pnach(char *PnachRest)
{
	FILE* fi;
	FILE* fr;
	u32 offset;
	u32 data;

	fi = fopen(list_game_path[position], "rb+");
	if(fi==NULL) { print_load("Error : Cannot open ISO"); return FAILED;}
	
	fr = fopen(PnachRest, "rb");
	if(fr==NULL) { fclose(fi); print_load("Error : Cannot open PnachRestore file"); return FAILED;}
	
	u64 file_offset=0;
	u32 size=0;
	u8 ret;

	ret = get_FileOffset(fi, PS2_ID, &file_offset, &size); 

	if(file_offset==0 || size==0 || ret == FAILED) {
		print_load("Error : file_pos. File : %s file_offset= %X size= %X", PS2_ID, file_offset, size);
		fclose(fi);
		fclose(fr);
		return FAILED;
	}
	
	while( fread(&offset, 1, 4, fr) == 4) {
		if( fread(&data, 1, 4, fr) == 4 ) {
			fseek(fi, file_offset + offset, SEEK_SET);
			fwrite(&data, 4, 1, fi);
			*(u32 *) &PS2ELF_mem[offset] = data; 
		}
    }
	
	fclose(fi);
	fclose(fr);
	
	Delete(PnachRest);
	
	update_PS2CRC();
	
	return SUCCESS;
}

/*
struct ELF_HEADER {
	u8	e_ident[16];	//0x7f,"ELF"  (ELF file identifier)
	u16	e_type;			//ELF type: 0=NONE, 1=REL, 2=EXEC, 3=SHARED, 4=CORE
	u16	e_machine;	  //Processor: 8=MIPS R3000
	u32	e_version;	  //Version: 1=current
	u32	e_entry;		//Entry point address
	u32	e_phoff;		//Start of program headers (offset from file start)
	u32	e_shoff;		//Start of section headers (offset from file start)
	u32	e_flags;		//Processor specific flags = 0x20924001 noreorder, mips
	u16	e_ehsize;	   //ELF header size (0x34 = 52 bytes)
	u16	e_phentsize;	//Program headers entry size
	u16	e_phnum;		//Number of program headers
	u16	e_shentsize;	//Section headers entry size
	u16	e_shnum;		//Number of section headers
	u16	e_shstrndx;	 //Section header stringtable index
};

struct ELF_PHR {
	u32 p_type;		 //see notes1
	u32 p_offset;	   //Offset from file start to program segment.
	u32 p_vaddr;		//Virtual address of the segment
	u32 p_paddr;		//Physical address of the segment
	u32 p_filesz;	   //Number of bytes in the file image of the segment
	u32 p_memsz;		//Number of bytes in the memory image of the segment
	u32 p_flags;		//Flags for segment
	u32 p_align;		//Alignment. The address of 0x08 and 0x0C must fit this alignment. 0=no alignment
};
*/

u8 apply_pnach(char *pnach_file, char *PnachRest)
{
	FILE* fp;
	FILE* fi;
	FILE* fr;
	char line[128];
	
	u32 offset;
	u32 new_data;
	u32 old_data;
	
	fp = fopen(pnach_file, "rb");
	if(fp==NULL) { print_load("Error : failed to open pnach file");return FAILED; }
	
	fi = fopen(list_game_path[position], "rb+");
	if(fi==NULL) { fclose(fp); print_load(list_game_path[position]); print_load("Error : failed to open iso file"); return FAILED; }
	
	fr = fopen(PnachRest, "wb");
	if(fr==NULL) { fclose(fp); fclose(fi); print_load("Error : failed to open pnachrest file"); return FAILED; }
	
	u64 file_offset=0;
	u32 size=0;
	u8 ret;

	ret = get_FileOffset(fi, PS2_ID, &file_offset, &size); 

	if(file_offset==0 || size==0 || ret == FAILED) {
		print_load("Error : file_pos. File : %s file_offset= %X size= %X", PS2_ID, file_offset, size);
		fclose(fi);
		fclose(fp); 
		fclose(fr);
		Delete(PnachRest);
		return FAILED;
	}
	
	u32 VirtualAddr;
	u32 ProgOffset;
	u16 ProgHeaderNumber;
	u32 ProgType;
	u32 filesz;
	
	fseek(fi, file_offset + 0x2C, SEEK_SET);
	fread(&ProgHeaderNumber, 2, 1, fi);
	
	ProgHeaderNumber = reverse16(ProgHeaderNumber);
	
	int i;
	for(i=0; i < ProgHeaderNumber; i++) {
		
		filesz = 0;
		ProgOffset = 0;
		VirtualAddr = 0;
		ProgType = 0;
		
		fseek(fi, file_offset + 0x34+i*0x20, SEEK_SET);
		
		fread(&ProgType, 4, 1, fi);
		ProgType = reverse32(ProgType);
		
		fread(&ProgOffset, 4, 1, fi);
		ProgOffset = reverse32(ProgOffset);
		
		fread(&VirtualAddr, 4, 1, fi);
		VirtualAddr = reverse32(VirtualAddr);
		
		fseek(fi, file_offset + 0x34+0x10+i*0x20, SEEK_SET);
		fread(&filesz, 4, 1, fi);
		
		if(ProgType==1 && filesz!=0) {
			break;
		}
	}
		
	if(ProgType != 1 || filesz==0) {
		print_load("Error : ProgOffset and VirtualAddr not found");
		fclose(fi);
		fclose(fp); 
		fclose(fr);
		Delete(PnachRest);
		return FAILED;
	}
	
	while(fgets(line, 128, fp) != NULL) {
		if( strstr(line, "patch") == NULL && strstr(line, "comment")==NULL && strstr(line, "gametitle")==NULL ) continue;
		
		if(strncmp(line, "patch=", 6) == 0) 
		{
			if(strstr(line, ",") == NULL) continue;
			
			char *token;
			unsigned long int value=0;
			token = strtok (line, ", "); //toggle patch
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //cpu
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //addr
			if(token == NULL) continue;
			sscanf(token, "%8lX", &value);
			offset = value;
			value = 0;
			token = strtok (NULL, ", "); //type
			if(token == NULL) continue;
			token = strtok (NULL, ", "); //data
			sscanf(token, "%8lX", &value);
			new_data = reverse32(value);
			
			offset = offset - (offset >> 28)*0x10000000;
			offset = offset - (VirtualAddr - ProgOffset);
			
			if(offset > size) { 
				
				print_load("Error : offset %X > Elf_size %X | VirtualAddr %X | ProgOffset %X", offset, size, VirtualAddr, ProgOffset);
				
				fclose(fr);
				fclose(fi);
				fclose(fp);
				restore_pnach(PnachRest);
				return FAILED;
			}
			
			fseek(fi, file_offset + offset, SEEK_SET);
			fread(&old_data, 4, 1, fi);
			
			fseek(fi, file_offset + offset, SEEK_SET);
			
			fwrite(&new_data, 4, 1, fi);
			
			*(u32 *) &PS2ELF_mem[offset] = new_data;
			
			fwrite(&offset, 4, 1, fr);
			fwrite(&old_data, 4, 1, fr);
			
		} else
		if(strncmp(line, "gametitle=", 10) || strncmp(line, "comment=", 8)==0) {
			print_load(&strrchr(line, '=')[1]);
		}
	}
	
	fclose(fr);
	fclose(fi);
	fclose(fp);
	
	update_PS2CRC();
	
	return SUCCESS;
}

u8 WS_exist()
{
	sprintf(WS, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.ws", ManaGunZ_id, PS2ORICRC);
	
	if(path_info(WS) == _NOT_EXIST) return NO;
	
	return YES;
}

void get_WS()
{
	sprintf(WS, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.ws", ManaGunZ_id, PS2ORICRC);
	
	if(path_info(WS) != _NOT_EXIST) return;
	
	char ZIP_WS[32];
	char ZIP[128];
	
	sprintf(ZIP_WS, "%08X.pnach", PS2ORICRC);
	sprintf(ZIP, "/dev_hdd0/game/%s/USRDIR/sys/ws.zip", ManaGunZ_id);
	
	ExtractZipFile(ZIP, ZIP_WS, WS);
}

u8 is_WS()
{
	char WSRest[128];
	
	sprintf(WSRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.wsrest", ManaGunZ_id, PS2CRC);
	
	if(path_info(WSRest) == _NOT_EXIST) return NO; else
	return YES;
}

u8 LIMG_exist(char *iso_file)
{
	u8 split666 = is_66600(iso_file);
	if(is_splitted_iso(iso_file)==YES || split666) {
		//TODO
		return NO;
	}
	
	FILE *f;
	f = fopen(iso_file, "rb");
	if(f==NULL) {
		print_load("Error : LIMG_exist, failed to fopen");
		return NO;
	}
	fseek(f, 0, SEEK_END);
	u64 LIMG_OFFSET = ftell(f) - LIMG_SIZE;
	fseek(f, LIMG_OFFSET, SEEK_SET);
	
	char LIMG_FLAG[5];
	fread(&LIMG_FLAG, 4, 1, f);
	LIMG_FLAG[4]=0;
	
	fclose(f);
	
	if(strcmp(LIMG_FLAG, "LIMG")==0) return YES;
	
	else return NO;
}

// return has_LIMG
u8 Remove_LIMG(char *iso_file)
{
	if(LIMG_exist(iso_file) == NO) return NO; 
	
	u8 split666 = is_66600(iso_file);
	if(is_splitted_iso(iso_file)==YES || split666) {
		//TODO
		print_load("Error : splitted ISO not supported yet");
		return NO;
	}
	
	u64 size = get_size(iso_file) - LIMG_SIZE;
	
	if(truncate(iso_file, size) == 0) return NO;
	
	return LIMG_exist(iso_file);
}

// return has_LIMG
u8 Add_LIMG(char *iso_file)
{
	if(LIMG_exist(iso_file) == YES) return SUCCESS; 
	
	u8 split666 = is_66600(iso_file);
	if(is_splitted_iso(iso_file)==YES || split666) {
		//TODO
		print_load("Error : splitted ISO not supported yet");
		return FAILED;
	}
	
	FILE *f;	
	u32 SectSize=0;
	u32 JP=0;
	
	f = fopen(iso_file, "rb");
	if(f==NULL) {
		print_load("Error : LIMG_exist, failed to fopen");
		return FAILED;
	}
	if( get_SectorSize(f, &SectSize, &JP) == FAILED) {
		fclose(f);
		print_load("Error : Add_LIMG, failed to get_SectorSize");
		return FAILED;
	}
	FCLOSE(f);
	
	u64 Size = get_size(iso_file);
	
	// it must be a better way to detect properly cd / dvd ...
	u32 DiskType=2; // CD
	if(Size > 700*1024*1024) DiskType=1; // DVD 
	
	u32 SectorNumber = Size/SectSize + 1;
	
	f = fopen(iso_file, "ab");
	if(f==NULL) {
		print_load("Error : LIMG_exist, failed to fopen");
		return FAILED;
	}
	fputs("LIMG", f);
	fwrite(&DiskType, sizeof(u32), 1, f);
	fwrite(&SectorNumber, sizeof(u32), 1, f);
	fwrite(&SectSize, sizeof(u32), 1, f);
	fclose(f);
	
	truncate(iso_file, Size+LIMG_SIZE);
	
	return LIMG_exist(iso_file);
}

void init_PS2_GAME_MENU()
{
	int i,j;
		
	init_MENU();

	add_title_MENU(STR_GAME_OPTION);
	
	if( is_favorite(list_game_path[position]) == NO )
		add_item_MENU(STR_ADD_FAV, ITEM_TEXTBOX);
	else 
		add_item_MENU(STR_REM_FAV, ITEM_TEXTBOX);
	
	
	add_item_MENU(STR_RENAME, ITEM_TEXTBOX);
	
	add_item_MENU(STR_DELETE, ITEM_TEXTBOX);
	
	if(device_number != 0) {
		add_item_MENU(STR_COPY, ITEM_TEXTBOX);
		for(j=0; j<=scan_dir_number; j++) {
			for(i=0; i<=device_number; i++) {
				if(strstr(list_game_path[position], list_device[i])) continue;
				char tmp[128];
				sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
				add_item_value_MENU(tmp);
			}
		}
	}
	
	if(is_66600(list_game_path[position])==YES && is_FAT32(list_game_path[position])==NO) {
		add_item_MENU(STR_JOIN, ITEM_TEXTBOX);
	}

	if(has_LIMG==YES) {
		add_item_MENU(STR_REMOVE_LIMG, ITEM_TEXTBOX);
	} else {
		add_item_MENU(STR_ADD_LIMG, ITEM_TEXTBOX);
	}
	
	if(list_game_havepic[position] & GAMEPIC_COVER2D) {
		add_item_MENU(STR_CREATE_ICON0, ITEM_TEXTBOX);
	}
	
	if( is_pnached() ) {
		add_item_MENU(STR_REST_PNACH, ITEM_TEXTBOX);
	}
	else 
	if( Pnach_exist() ) {
		add_item_MENU(STR_APPLY_PNACH, ITEM_TEXTBOX);
	}
	
	if( is_WS() ) {
		add_item_MENU(STR_DISABLE_WS, ITEM_TEXTBOX);
	} else 
	if( WS_exist() ) {
		add_item_MENU(STR_ENABLE_WS, ITEM_TEXTBOX);
	}
	
	if(PS2PATCH_480P_offset) {
		if(PS2PATCH_480P == YES) {
			add_item_MENU(STR_DISABLE_480P, ITEM_TEXTBOX);
		} else {
			add_item_MENU(STR_ENABLE_480P, ITEM_TEXTBOX);
		}
	}
	
	if(PS2PATCH_YFIX_offset) {
		if(PS2PATCH_YFIX == YES) {
			add_item_MENU(STR_DISABLE_YFIX, ITEM_TEXTBOX);
		} else {
			add_item_MENU(STR_ENABLE_YFIX, ITEM_TEXTBOX);
		}
	}
	
	if(PS2PATCH_FMVSKIP_offset) {
		if(PS2PATCH_FMVSKIP == YES) {
			add_item_MENU(STR_DISABLE_FMVSKIP, ITEM_TEXTBOX);
		} else {
			add_item_MENU(STR_ENABLE_FMVSKIP, ITEM_TEXTBOX);
		}
	}
	
	i = ps2netemu_cobra(BCNETEMU_STATUS);
	if(i != BCNETEMU_ISNOTBC) {
		if(i == BCNETEMU_OFF) {
			add_item_MENU(STR_ENABLE_NETEMU, ITEM_TEXTBOX);
		} else
		if(i == BCNETEMU_ON) {
			add_item_MENU(STR_DISABLE_NETEMU, ITEM_TEXTBOX);
		}	
	}
	
	add_item_MENU(STR_CONFIG, ITEM_TEXTBOX);
	
	add_item_MENU(STR_CHECK_MD5, ITEM_TEXTBOX);
	
	add_item_MENU(STR_PROPS, ITEM_TEXTBOX);

}

void close_PS2_GAME_MENU()
{
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	MENU=NO;
	free_MENU();
}

u8 PS2_GAME_MENU_CROSS()
{
	
	if(item_is(STR_ADD_LIMG)) {
		start_loading();
		has_LIMG = Add_LIMG(list_game_path[position]);
		end_loading();
	} else 
	if(item_is(STR_REMOVE_LIMG)) {
		start_loading();
		has_LIMG = Remove_LIMG(list_game_path[position]);
		end_loading();
	} else
	if(item_is(STR_RENAME)) {
		char NewName[255];
		strcpy(NewName, list_game_title[position]);
		char *extension = GetExtension(list_game_path[position]);
		if(Get_OSK_String(STR_RENAME, NewName, 255) == SUCCESS) {
			if(NewName[0] != 0) {
				char DirPath[255];
				char NewPath[255];
				strcpy(DirPath, list_game_path[position]);
				DirPath[strrchr(DirPath, '/') - DirPath] = 0;
				sprintf(NewPath, "%s/%s%s", DirPath, NewName, extension);
				if( rename(list_game_path[position], NewPath) == 0) {
					FREE(list_game_path[position]);				
					list_game_path[position] = strcpy_malloc(NewPath);
					FREE(list_game_path[position])
					list_game_title[position] = strcpy_malloc(NewName);
				}
			}
		}
	} else 
	if(item_is(STR_CREATE_ICON0)) {
		open_ICON0_creator();
	} else 
	if(item_is(STR_ADD_FAV)) {
		if(add_favorite()==SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_REM_FAV)) {
		if(remove_favorite()==SUCCESS) {
			show_msg(STR_DONE);
			if(UI_position != XMB && Only_FAV) {
				int i;
				int old_position = position;
				for(i=0; i<=game_number; i++) {
					if(position-i<0 && game_number<position+i) break;
					if(Show_it(position+i) == YES) {position+=i; break;}
					if(Show_it(position-i) == YES) {position-=i; break;}
				}
				if(old_position == position && 0 <= position) position = -1;
				return BREAK;
			} else 
			if(UI_position == XMB && XMB_H_position==XMB_COLUMN_FAVORITES) {
				return BREAK;
			}	
		} else {
			show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_REST_PNACH)) {
		start_loading();
		char PnachRest[128];
		sprintf(PnachRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnachrest", ManaGunZ_id, PS2CRC);
		u8 ret = restore_pnach(PnachRest);
		end_loading();
		if( ret == SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_APPLY_PNACH)) {
		start_loading();
		char PnachRest[128];
		sprintf(PnachRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.pnachrest", ManaGunZ_id, PS2CRC);
		u8 ret = apply_pnach(pnach, PnachRest);
		end_loading();
		
		if( ret == SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_ENABLE_WS)) {
		start_loading();
		char WSRest[128];
		sprintf(WSRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.wsrest", ManaGunZ_id, PS2CRC);
		u8 ret = apply_pnach(WS, WSRest);
		end_loading();
		if( ret == SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_DISABLE_WS)) {
		start_loading();
		char WSRest[128];
		sprintf(WSRest, "/dev_hdd0/game/%s/USRDIR/setting/PS2/%08X.wsrest", ManaGunZ_id, PS2CRC);
		u8 ret = restore_pnach(WSRest);
		end_loading();
		if( ret == SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_ENABLE_NETEMU)) {
		if( ps2netemu_cobra(BCNETEMU_ON) == BCNETEMU_ON) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_DISABLE_NETEMU)) {
		if( ps2netemu_cobra(BCNETEMU_OFF) == BCNETEMU_OFF) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_CONFIG)) {
		open_PS2_CONFIG_EDITOR();
		return CONTINUE;
	} else 
	if(item_is(STR_CHECK_MD5)) {
		start_loading();
		u8 ret = CheckMD5(list_game_path[position]);
		end_loading();
		if(ret == SUCCESS) {
			char temp[255];
			strcpy(temp, list_game_path[position]);
			temp[strlen(temp)-4]=0;
			strcat(temp, "_CHECK.md5");
			open_txt_viewer(temp);
		}
	} else 
	if(item_is(STR_COPY)) {
		Copy_Game(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
	} else 
	if(item_is(STR_JOIN)) {
		char dest[255];
		strcpy(dest, list_game_path[position]);
		dest[strrchr(dest, '/') - dest] = 0;
		Copy_Game(list_game_path[position], dest);
	} else 
	if(item_is(STR_DELETE)) {
		char diag_msg[4096];
		sprintf(diag_msg, "%s\n%s: %s\n%s: %s\n", STR_ASK_TO_DELETE, STR_GAME_TITLE, list_game_title[position], STR_PATH, list_game_path[position]);
		if( DrawDialogYesNo(diag_msg) == YES) {
			start_loading();
			u8 ret = Delete_Game(NULL, position);
			end_loading();
			if(ret==SUCCESS) {
				show_msg(STR_DONE);
				return BREAK;
			} else show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_PROPS)) {
		start_gathering();
		Get_Game_Size(list_game_path[position]);
		end_gathering();
		
		if(gathering_cancel==NO) Draw_GameProperties();
		else gathering_cancel=NO;
	} else
	if(item_is(STR_ENABLE_480P)) {
		start_loading();
		u8 ret = Apply_PS2PATCH(PS2PATCH_480P_offset, PS2PATCH_480P_FLAG_ENABLE, sizeof(PS2PATCH_480P_FLAG_ENABLE));
		end_loading();
		if( ret == SUCCESS) {
			PS2PATCH_480P = YES;
			show_msg(STR_DONE);
		}
		else show_msg(STR_FAILED);
	} else
	if(item_is(STR_DISABLE_480P)) {
		start_loading();
		u8 ret = Apply_PS2PATCH(PS2PATCH_480P_offset, PS2PATCH_480P_FLAG_DISABLE, sizeof(PS2PATCH_480P_FLAG_DISABLE));
		end_loading();
		if( ret == SUCCESS) {
			PS2PATCH_480P = NO;
			show_msg(STR_DONE);
		} 
		else show_msg(STR_FAILED);
	} else
	if(item_is(STR_ENABLE_YFIX)) {
		start_loading();
		u8 ret = Apply_PS2PATCH(PS2PATCH_YFIX_offset, PS2PATCH_YFIX_FLAG_ENABLE, sizeof(PS2PATCH_YFIX_FLAG_ENABLE));
		end_loading();
		if( ret == SUCCESS) {
			PS2PATCH_YFIX = YES;
			show_msg(STR_DONE);
		} 
		else show_msg(STR_FAILED);
	} else
	if(item_is(STR_DISABLE_YFIX)) {
		start_loading();
		u8 ret = Apply_PS2PATCH(PS2PATCH_YFIX_offset, PS2PATCH_YFIX_FLAG_DISABLE, sizeof(PS2PATCH_YFIX_FLAG_DISABLE));
		end_loading();
		if( ret == SUCCESS) {
			PS2PATCH_YFIX = NO;
			show_msg(STR_DONE);
		} 
		else show_msg(STR_FAILED);
	} else
	if(item_is(STR_ENABLE_FMVSKIP)) {
		start_loading();
		u8 ret = Apply_PS2PATCH(PS2PATCH_FMVSKIP_offset, PS2PATCH_FMVSKIP_FLAG_ENABLE,  sizeof(PS2PATCH_FMVSKIP_FLAG_ENABLE));
		end_loading();
		if( ret == SUCCESS) {
			PS2PATCH_FMVSKIP = YES;
			show_msg(STR_DONE);
		} 
		else show_msg(STR_FAILED);
	} else
	if(item_is(STR_DISABLE_FMVSKIP)) {
		start_loading();
		u8 ret = Apply_PS2PATCH(PS2PATCH_FMVSKIP_offset, PS2PATCH_FMVSKIP_FLAG_DISABLE, sizeof(PS2PATCH_FMVSKIP_FLAG_DISABLE));
		end_loading();
		if( ret == SUCCESS) {
			PS2PATCH_FMVSKIP = NO;
			show_msg(STR_DONE);
		} 
		else show_msg(STR_FAILED);
	}
	
	init_PS2_GAME_MENU();
	
	return CONTINUE;
}

void Draw_PS2_GAME_MENU_input()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void input_PS2_GAME_MENU()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;
	
	get_R2speed();
	
	if(R2pad(BUTTON_UP)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
			else ITEMS_POSITION--;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
		}
	}
	
	if(R2pad(BUTTON_DOWN)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
			else ITEMS_POSITION++;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
		}
	}
	
	if(NewPad(BUTTON_CROSS)) {
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION]==0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			MENU_LVL = LVL_VALUE;
		} else {
			if( PS2_GAME_MENU_CROSS() == BREAK ) close_PS2_GAME_MENU();
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(MENU_LVL == LVL_ITEMS) {
			close_PS2_GAME_MENU();
			if(PS2ELF_mem != NULL) {
				free(PS2ELF_mem);
				PS2ELF_mem_size=0;
				PS2ELF_mem=NULL;
			}
		}
		else {
			init_PS2_GAME_MENU();
			MENU_LVL = LVL_ITEMS;
		}
	}
}

void open_PS2_GAME_MENU()
{
	start_loading();
	USE_TITLE_MENU=NO;
	new_MENU();
	
	Get_ID(list_game_path[position], list_game_platform[position], PS2_ID);
	
	init_PS2CRC();
	get_WS();
	
	has_LIMG = LIMG_exist(list_game_path[position]);
	
	init_PS2_GAME_MENU();
	MENU_SIDE=Use_SideMenu;
	if(MENU_SIDE) MENU_ITEMS_X=X_MAX;
	Draw_MENU_input = &Draw_PS2_GAME_MENU_input;
	input_MENU = &input_PS2_GAME_MENU;
	
	end_loading();
}

//*******************************************************
// PSP MENU
//*******************************************************

void init_PSP_GAME_MENU()
{
	int i,j;
	
	init_MENU();
	
	add_title_MENU(STR_GAME_OPTION);
	
	if( is_favorite(list_game_path[position]) == NO )
		add_item_MENU(STR_ADD_FAV, ITEM_TEXTBOX);
	else 
		add_item_MENU(STR_REM_FAV, ITEM_TEXTBOX);
	
	
	add_item_MENU(STR_RENAME, ITEM_TEXTBOX);
	
	add_item_MENU(STR_DELETE, ITEM_TEXTBOX);
	
	if(device_number != 0) {
		add_item_MENU(STR_COPY, ITEM_TEXTBOX);
		for(j=0; j<=scan_dir_number; j++) {
			for(i=0; i<=device_number; i++) {
				if(strstr(list_game_path[position], list_device[i])) continue;
				char tmp[128];
				sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
				add_item_value_MENU(tmp);
			}
		}
	}
	
	if(is_66600(list_game_path[position])==YES && is_FAT32(list_game_path[position])==NO) {
		add_item_MENU(STR_JOIN, ITEM_TEXTBOX);
	}
	
	add_item_MENU(STR_CHECK_CRC32, ITEM_TEXTBOX);
	
	add_item_MENU(STR_PROPS, ITEM_TEXTBOX);
	
}

void close_PSP_GAME_MENU()
{
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	MENU=NO;
	free_MENU();
}

u8 PSP_GAME_MENU_CROSS()
{
	if(item_is(STR_RENAME)) {
		char NewName[255];
		strcpy(NewName, list_game_title[position]);
		char *extension = GetExtension(list_game_path[position]);
		if(Get_OSK_String(STR_RENAME, NewName, 255) == SUCCESS) {
			if(NewName[0] != 0) {
				char DirPath[255];
				char NewPath[255];
				strcpy(DirPath, list_game_path[position]);
				DirPath[strrchr(DirPath, '/') - DirPath] = 0;
				sprintf(NewPath, "%s/%s%s", DirPath, NewName, extension);
				if( rename(list_game_path[position], NewPath) == 0) {
					FREE(list_game_path[position]);				
					list_game_path[position] = strcpy_malloc(NewPath);
					FREE(list_game_path[position])
					list_game_title[position] = strcpy_malloc(NewName);
				}
			}
		}
	} else 
	if(item_is(STR_ADD_FAV)) {
		if(add_favorite()==SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_REM_FAV)) {
		if(remove_favorite()==SUCCESS) {
			show_msg(STR_DONE);
			if(UI_position != XMB && Only_FAV) {
				int i;
				int old_position = position;
				for(i=0; i<=game_number; i++) {
					if(position-i<0 && game_number<position+i) break;
					if(Show_it(position+i) == YES) {position+=i; break;}
					if(Show_it(position-i) == YES) {position-=i; break;}
				}
				if(old_position == position && 0 <= position) position = -1;
				return BREAK;
			} else 
			if(UI_position == XMB && XMB_H_position==XMB_COLUMN_FAVORITES) {
				return BREAK;
			}	
		} else {
			show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_CHECK_CRC32)) {
		start_loading();
		u8 ret = CheckCRC32(list_game_path[position]);
		end_loading();
		if(ret == SUCCESS) {
			char temp[255];
			strcpy(temp, list_game_path[position]);
			temp[strlen(temp)-4]=0;
			strcat(temp, "_CHECK.crc");
			open_txt_viewer(temp);
		}
	} else 
	if(item_is(STR_COPY)) {
		Copy_Game(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
	} else 
	if(item_is(STR_JOIN)) {
		char dest[255];
		strcpy(dest, list_game_path[position]);
		dest[strrchr(dest, '/') - dest] = 0;
		Copy_Game(list_game_path[position], dest);
	} else 
	if(item_is(STR_DELETE)) {
		char diag_msg[4096];
		sprintf(diag_msg, "%s\n%s: %s\n%s: %s\n", STR_ASK_TO_DELETE, STR_GAME_TITLE, list_game_title[position], STR_PATH, list_game_path[position]);
		if( DrawDialogYesNo(diag_msg) == YES) {
			start_loading();
			u8 ret = Delete_Game(NULL, position);
			end_loading();
			if(ret==SUCCESS) {
				show_msg(STR_DONE);
				return BREAK;
			} else show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_PROPS)) {
		start_gathering();
		Get_Game_Size(list_game_path[position]);
		end_gathering();
		
		if(gathering_cancel==NO) Draw_GameProperties();
		else gathering_cancel=NO;
	}
	
	init_PSP_GAME_MENU();
	
	return CONTINUE;
}

void Draw_PSP_GAME_MENU_input()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void input_PSP_GAME_MENU()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;
	
	get_R2speed();

	if(R2pad(BUTTON_UP)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
			else ITEMS_POSITION--;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
		}
	}
	
	if(R2pad(BUTTON_DOWN)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
			else ITEMS_POSITION++;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
		}
	}
	
	if(NewPad(BUTTON_CROSS)) {
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION]==0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			MENU_LVL = LVL_VALUE;
		} else {
			if( PSP_GAME_MENU_CROSS() == BREAK ) close_PSP_GAME_MENU();
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(MENU_LVL == LVL_ITEMS) close_PSP_GAME_MENU();
		else {
			init_PSP_GAME_MENU();
			MENU_LVL = LVL_ITEMS;
		}
	}
}

void open_PSP_GAME_MENU()
{
	start_loading();
	USE_TITLE_MENU=NO;
	new_MENU();
	init_PSP_GAME_MENU();
	MENU_SIDE=Use_SideMenu;
	if(MENU_SIDE) MENU_ITEMS_X=X_MAX;
	Draw_MENU_input = &Draw_PSP_GAME_MENU_input;
	input_MENU = &input_PSP_GAME_MENU;
	end_loading();
}

//*******************************************************
// PS1 MENU
//*******************************************************

void init_PS1_GAME_MENU()
{
	int i,j;
	
	init_MENU();
	
	add_title_MENU(STR_GAME_OPTION);
	
	if( is_favorite(list_game_path[position]) == NO )
		add_item_MENU(STR_ADD_FAV, ITEM_TEXTBOX);
	else 
		add_item_MENU(STR_REM_FAV, ITEM_TEXTBOX);
	
	
	add_item_MENU(STR_RENAME, ITEM_TEXTBOX);
	
	add_item_MENU(STR_DELETE, ITEM_TEXTBOX);
	
	if(device_number != 0) {
		add_item_MENU(STR_COPY, ITEM_TEXTBOX);
		for(j=0; j<=scan_dir_number; j++) {
			for(i=0; i<=device_number; i++) {
				if(strstr(list_game_path[position], list_device[i])) continue;
				char tmp[128];
				sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
				add_item_value_MENU(tmp);
			}
		}
	}
	
	if(is_66600(list_game_path[position])==YES && is_FAT32(list_game_path[position])==NO) {
		add_item_MENU(STR_JOIN, ITEM_TEXTBOX);
	}
	
	if(list_game_havepic[position] & GAMEPIC_COVER2D) {
		add_item_MENU(STR_CREATE_ICON0, ITEM_TEXTBOX);
	}
	
	add_item_MENU(STR_CHECK_MD5, ITEM_TEXTBOX);
	
	add_item_MENU(STR_PROPS, ITEM_TEXTBOX);
	
}

void close_PS1_GAME_MENU()
{
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	MENU=NO;
	free_MENU();
}

u8 PS1_GAME_MENU_CROSS()
{
	if(item_is(STR_RENAME)) {
		char NewName[255];
		strcpy(NewName, list_game_title[position]);
		char *extension = GetExtension(list_game_path[position]);
		if(Get_OSK_String(STR_RENAME, NewName, 255) == SUCCESS) {
			if(NewName[0] != 0) {
				char DirPath[255];
				char NewPath[255];
				strcpy(DirPath, list_game_path[position]);
				DirPath[strrchr(DirPath, '/') - DirPath] = 0;
				sprintf(NewPath, "%s/%s%s", DirPath, NewName, extension);
				if( rename(list_game_path[position], NewPath) == 0) {
					FREE(list_game_path[position]);				
					list_game_path[position] = strcpy_malloc(NewPath);
					FREE(list_game_path[position])
					list_game_title[position] = strcpy_malloc(NewName);
				}
			}
		}
	} else 
	if(item_is(STR_CREATE_ICON0)) {
		open_ICON0_creator();
	} else 
	if(item_is(STR_ADD_FAV)) {
		if(add_favorite()==SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_REM_FAV)) {
		if(remove_favorite()==SUCCESS) {
			show_msg(STR_DONE);
			if(UI_position != XMB && Only_FAV) {
				int i;
				int old_position = position;
				for(i=0; i<=game_number; i++) {
					if(position-i<0 && game_number<position+i) break;
					if(Show_it(position+i) == YES) {position+=i; break;}
					if(Show_it(position-i) == YES) {position-=i; break;}
				}
				if(old_position == position && 0 <= position) position = -1;
				return BREAK;
			} else 
			if(UI_position == XMB && XMB_H_position==XMB_COLUMN_FAVORITES) {
				return BREAK;
			}	
		} else {
			show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_CHECK_MD5)) {
		start_loading();
		u8 ret = CheckMD5(list_game_path[position]);
		end_loading();
		if(ret == SUCCESS) {
			char temp[255];
			strcpy(temp, list_game_path[position]);
			temp[strlen(temp)-4]=0;
			strcat(temp, "_CHECK.md5");
			open_txt_viewer(temp);
		}
	} else 
	if(item_is(STR_COPY)) {
		Copy_Game(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
	} else 
	if(item_is(STR_JOIN)) {
		char dest[255];
		strcpy(dest, list_game_path[position]);
		dest[strrchr(dest, '/') - dest] = 0;
		Copy_Game(list_game_path[position], dest);
	} else 
	if(item_is(STR_DELETE)) {
		char diag_msg[4096];
		sprintf(diag_msg, "%s\n%s: %s\n%s: %s\n", STR_ASK_TO_DELETE, STR_GAME_TITLE, list_game_title[position], STR_PATH, list_game_path[position]);
		if( DrawDialogYesNo(diag_msg) == YES) {
			start_loading();
			u8 ret = Delete_Game(NULL, position);
			end_loading();
			if(ret==SUCCESS) {
				show_msg(STR_DONE);
				return BREAK;
			} else show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_PROPS)) {
		start_gathering();
		Get_Game_Size(list_game_path[position]);
		end_gathering();
			
		if(gathering_cancel==NO) Draw_GameProperties();
		else gathering_cancel=NO;
	}
	
	init_PS1_GAME_MENU();
	
	return CONTINUE;
}

void Draw_PS1_GAME_MENU_input()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void input_PS1_GAME_MENU()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;

	get_R2speed();

	if(R2pad(BUTTON_UP)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
			else ITEMS_POSITION--;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
		}
	}
	
	if(R2pad(BUTTON_DOWN)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
			else ITEMS_POSITION++;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
		}
	}
	
	if(NewPad(BUTTON_CROSS)) {
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION]==0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			MENU_LVL = LVL_VALUE;
		} else {
			if( PS1_GAME_MENU_CROSS() == BREAK ) close_PS1_GAME_MENU();
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(MENU_LVL == LVL_ITEMS) close_PS1_GAME_MENU();
		else {
			init_PS1_GAME_MENU();
			MENU_LVL = LVL_ITEMS;
		}
	}
}

void open_PS1_GAME_MENU()
{
	start_loading();
	USE_TITLE_MENU=NO;
	new_MENU();
	init_PS1_GAME_MENU();
	MENU_SIDE=Use_SideMenu;
	if(MENU_SIDE) MENU_ITEMS_X=X_MAX;
	Draw_MENU_input = &Draw_PS1_GAME_MENU_input;
	input_MENU = &input_PS1_GAME_MENU;
	end_loading();
}

//*******************************************************
// PS3 MENU
//*******************************************************

void open_PS3_GAME_MENU();
void close_PS3_GAME_MENU();
void open_BDVD_MENU();
void close_BDVD_MENU();


typedef struct
{
	float pkgVers;
	u64 size;
	char url[255];
	float sysVers;
	char str[64];
	u8 to_dl;
	char pkg_path[255];
	u8 pkg_exist;
} update_data;

update_data *ps3_game_updates;
int ps3_game_updates_number=-1;
char ps3_game_current_version[4]={0};

void get_current_version(char *gameID)
{
	char sfo_path[255];
	sprintf(sfo_path, "/dev_hdd0/game/%s/USRDIR/param.sfo", gameID);
	
	memset(ps3_game_current_version, 0, 4);
	if( GetParamSFO("APP_VER", ps3_game_current_version, sfo_path)== FAILED) {
		strcpy(ps3_game_current_version, "01.00");
	}
}

update_data *download_upd_xml(char *gameID, int *nPKG)
{	
	char url[128];
	char dst[128];
	u32 n;
	u32 k=0;
	update_data *data=NULL;
	int size;
	
	*nPKG = -1;
	
	sprintf(url, "https://a0.ww.np.dl.playstation.net/tpl/np/%s/%s-ver.xml", gameID, gameID);
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/sys/temp", ManaGunZ_id);
	mkdir(dst, 0777);
	sprintf(dst, "/dev_hdd0/game/%s/USRDIR/sys/temp/%s.xml", ManaGunZ_id, list_game_ID[position]);
	
	print_load("Downloading xml...");
	if(download(url, dst) == FAILED) {
		print_load("Error: Failed to download xml");
		return NULL;
	}
	
	print_load("Loading xml...");
	char *xml = LoadFile(dst, &size);
	if(!xml) {
		print_load("Error: Failed to load xml");
		return NULL;
	}
	
	print_load("Parsing xml...");
	for(n=0 ; n<size; n++) {
		if(strncmp(&xml[n], "package version", 15)==0) {
			*nPKG = *nPKG + 1;
			data = (update_data *) realloc(data, (*nPKG+1) * sizeof(update_data));
			sscanf(&xml[n+17], "%f", &data[*nPKG].pkgVers);
		}
		if(strncmp(&xml[n], "size", 4)==0) {
			sscanf(&xml[n+6], "%lld", (long long int *) &data[*nPKG].size);
		}
		if(strncmp(&xml[n], "url", 3)==0) {
			k=n+5;
		}
		if(strncmp(&xml[n], ".pkg", 4)==0) {
			memcpy(data[*nPKG].url, &xml[k], n+4-k);
		}
		if(strncmp(&xml[n], "ps3_system_ver", 14)==0) {
			sscanf(&xml[n+16], "%f", &data[*nPKG].sysVers);
			char *unit = get_unit(data[*nPKG].size);
			sprintf(data[*nPKG].str, "%02.2f (%s)", data[*nPKG].pkgVers, unit);
			data[*nPKG].to_dl=NO;
			sprintf(data[*nPKG].pkg_path, "/dev_hdd0/packages%s", strrchr(data[*nPKG].url, '/'));
			if(path_info(data[*nPKG].pkg_path) == _FILE) data[*nPKG].pkg_exist = YES;
			else data[*nPKG].pkg_exist = NO;			
		}
	}
	FREE(xml);
	
	if(*nPKG==-1) return NULL;
	
	return data;
}

void close_PS3_UPDATE_MENU()
{
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	free_MENU();
	
	FREE(ps3_game_updates);
	ps3_game_updates_number=-1;
	
	if(list_game_platform[position]==BDVD) open_BDVD_MENU(); 
	else open_PS3_GAME_MENU();
}

void init_PS3_UPDATE_MENU()
{
	init_MENU();

	add_title_MENU(STR_GAME_UPDATE_TITLE);
	
	add_item_MENU(STR_GAME_TITLE, ITEM_LOCKED);
	add_item_value_MENU(list_game_title[position]);
	
	add_item_MENU(STR_GAMEID, ITEM_LOCKED);
	add_item_value_MENU(list_game_ID[position]);
	
	add_item_MENU(STR_CURRENT_VERS, ITEM_LOCKED);
	add_item_value_MENU(ps3_game_current_version);
	
	add_item_MENU(STR_UPDATE_FOUND, ITEM_LOCKED);
	char temp[8];
	sprintf(temp, "%d", ps3_game_updates_number+1);
	add_item_value_MENU(temp);
	
	MENU_TABLE_START=ITEMS_NUMBER;
	
	int n;
	for(n=0; n<=ps3_game_updates_number; n++){
		add_item_MENU(ps3_game_updates[n].str, ITEM_CHECKBOX);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER]=ps3_game_updates[n].to_dl;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER]=ps3_game_updates[n].pkg_exist;
	}
	
	MENU_TABLE_END=ITEMS_NUMBER;
	MENU_COLUMN_ITEMS_NUMBER = 1+(ITEMS_NUMBER-MENU_TABLE_START)/4;
}

u8 PS3_UPDATE_MENU_CROSS()
{
	
	if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX) {
		ITEMS_VALUE_POSITION[ITEMS_POSITION] = !ITEMS_VALUE_POSITION[ITEMS_POSITION];
		ps3_game_updates[ITEMS_POSITION - MENU_TABLE_START-1].to_dl = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	}
	
	init_PS3_UPDATE_MENU();
	
	return CONTINUE;
}

u8 PS3_UPDATE_MENU_R1()
{
	return CONTINUE;	
}

u8 PS3_UPDATE_MENU_L1()
{
	Delete(ps3_game_updates[ITEMS_POSITION - MENU_TABLE_START-1].pkg_path);
	
	ps3_game_updates[ITEMS_POSITION - MENU_TABLE_START-1].pkg_exist = NO;
	
	init_PS3_UPDATE_MENU();
	
	return CONTINUE;
}

u8 PS3_UPDATE_MENU_SQUARE()
{
	int n;
	for(n=0; n<=ps3_game_updates_number; n++) {
		ps3_game_updates[n].to_dl = YES;
	}
	
	init_PS3_UPDATE_MENU();
	
	return CONTINUE;
}

u8 PS3_UPDATE_MENU_TRIANGLE()
{
	int n;
	for(n=0; n<=ps3_game_updates_number; n++) {
		ps3_game_updates[n].to_dl = NO;
	}
	
	init_PS3_UPDATE_MENU();
	
	return CONTINUE;
}

u8 PS3_UPDATE_MENU_START()
{
	loading_can_turnoff = YES;
	start_loading();
	
	int n;
	for(n=0; n<=ps3_game_updates_number; n++) {
		if( ps3_game_updates[n].to_dl && !ps3_game_updates[n].pkg_exist ) {
			print_head("Downloading update v%f", ps3_game_updates[n].pkgVers);
			if( download(ps3_game_updates[n].url, ps3_game_updates[n].pkg_path) ) {
				ps3_game_updates[n].pkg_exist = YES;
			}
		}
	}
	
	end_loading();
	loading_can_turnoff =  NO;
	
	init_PS3_UPDATE_MENU();
	
	return CONTINUE;
}

void input_PS3_UPDATE_MENU()
{
	if(MENU==NO) return;
	
	int i;
	
	get_R2speed();
	
	if(MENU_TABLE_START < ITEMS_POSITION && ITEMS_POSITION <=MENU_TABLE_END) {
		if(R2pad(BUTTON_RIGHT)) {
			if(ITEMS_POSITION + MENU_COLUMN_ITEMS_NUMBER <= MENU_TABLE_END) ITEMS_POSITION += MENU_COLUMN_ITEMS_NUMBER;
		} else
		if(R2pad(BUTTON_LEFT)) {
			if(ITEMS_POSITION - MENU_COLUMN_ITEMS_NUMBER > MENU_TABLE_START) ITEMS_POSITION -= MENU_COLUMN_ITEMS_NUMBER;
		}
		if(MENU_TABLE_END < ITEMS_NUMBER) {
			if(R2pad(BUTTON_DOWN)) {
				if( (ITEMS_POSITION-MENU_TABLE_START)%MENU_COLUMN_ITEMS_NUMBER == 0 ) ITEMS_POSITION=MENU_TABLE_END;
			}
		}
		if(0<MENU_TABLE_START) {
			if(R2pad(BUTTON_UP)) {
				if( (ITEMS_POSITION-MENU_TABLE_START)%MENU_COLUMN_ITEMS_NUMBER == 1 ) ITEMS_POSITION=MENU_TABLE_START+1;
			}
		}
	}
		
	for(i=0; i<=ITEMS_NUMBER; i++) {
		if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
		if(ITEMS_POSITION >= ITEMS_NUMBER) ITEMS_POSITION = 0;
		else ITEMS_POSITION++;
	}
	if(R2pad(BUTTON_UP)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				u8 twice=NO;
				if(TITLES[ITEMS_POSITION]==NULL) twice=YES;
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos = ITEMS_POSITION-i;
					if( i_pos < 0 ) i_pos+=ITEMS_NUMBER+1;
					if(TITLES[i_pos] != NULL) {
						if(twice==NO) {
							ITEMS_POSITION = i_pos;
							break;
						} else twice=NO;
					}
				}
			} else if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION==TITLE_MENU_FIRST_ITEM) ITEMS_POSITION=TITLE_MENU_LAST_ITEM;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} 
		else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION <= 0) ITEMS_POSITION = ITEMS_NUMBER;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		}
	} else
	if(R2pad(BUTTON_DOWN)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL==LVL_TITLE) {
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos=ITEMS_POSITION+i;
					if(ITEMS_NUMBER<i_pos) i_pos-=ITEMS_NUMBER+1;
					if(TITLES[i_pos]!=NULL) {
						ITEMS_POSITION=i_pos;
						break;
					}
				}
			} else
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION == TITLE_MENU_LAST_ITEM) ITEMS_POSITION = TITLE_MENU_FIRST_ITEM;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}				
			} else 
			if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} 
		else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION >= ITEMS_NUMBER) ITEMS_POSITION = 0;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		}
	} else
	if(NewPad(BUTTON_CROSS)) {
		if(PS3_UPDATE_MENU_CROSS() == BREAK) close_PS3_UPDATE_MENU();
	} else
	if(NewPad(BUTTON_SQUARE)) {
		if( PS3_UPDATE_MENU_SQUARE() == BREAK) close_PS3_UPDATE_MENU();
	} else
	if(NewPad(BUTTON_TRIANGLE)) {
		if( PS3_UPDATE_MENU_TRIANGLE() == BREAK) close_PS3_UPDATE_MENU();
	} else
	if(NewPad(BUTTON_R1)) {
		if( PS3_UPDATE_MENU_R1() == BREAK) close_PS3_UPDATE_MENU();
	} else
	if(NewPad(BUTTON_L1)) {
		if( PS3_UPDATE_MENU_L1() == BREAK) close_PS3_UPDATE_MENU();
	} else
	if(NewPad(BUTTON_START)) {
		if( PS3_UPDATE_MENU_START() == BREAK) close_PS3_UPDATE_MENU();
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(MENU_LVL == LVL_ITEMS) close_PS3_UPDATE_MENU();
		else {
			init_PS3_UPDATE_MENU();
			MENU_LVL = LVL_ITEMS;
		}
	}
}

void Draw_PS3_UPDATE_MENU_input()
{
	if(MENU==NO) return;
	if(txt_viewer_activ) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_DL, BUTTON_START);
	
	x=DrawButton(x, y, STR_SELECT_ALL, BUTTON_SQUARE);
	x=DrawButton(x, y, STR_UNSELECT_ALL, BUTTON_TRIANGLE);
	
	if( 0 < ITEMS_POSITION ) {
		if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_CHECKBOX) {
			if( ITEMS_VALUE_SHOW[ITEMS_POSITION]) x=DrawButton(x, y, STR_DELETE, BUTTON_L1);
		}
		if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == YES) {
			x=DrawButton(x, y, STR_UNCHECK, BUTTON_CROSS);
		} else { 
			x=DrawButton(x, y, STR_CHECK, BUTTON_CROSS);			
		}
	}
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

u8 open_PS3_UPDATE_MENU()
{
	start_loading();
	
	close_PS3_GAME_MENU();
	
	USE_TITLE_MENU=NO;
	MENU_SIDE = NO;
	new_MENU();
	
	ps3_game_updates = download_upd_xml(list_game_ID[position], &ps3_game_updates_number);
	
	get_current_version(list_game_ID[position]);
	
	mkdir("/dev_hdd0/packages", 0777);
	
	init_PS3_UPDATE_MENU();
	
	Draw_MENU_input = &Draw_PS3_UPDATE_MENU_input;
	input_MENU = &input_PS3_UPDATE_MENU;
	
	end_loading();
	
	return BREAK;
}

void peek_IDPS()
{
	if (PEEKnPOKE) {
		u8 i;
		for(i=0; i<0x10; i++) {
			IDPS[i]=lv2peek8(OFFSET_2_IDPS + i);
		}
	}
}

void poke_IDPS()
{
	if (PEEKnPOKE) {
		u8 i;
		for(i=0; i<0x10; i++) {
			lv2poke8(OFFSET_1_IDPS + i, IDPS[i]);
			lv2poke8(OFFSET_2_IDPS + i, IDPS[i]);
		}
	}
}

void LoadEID5_IDPS()
{
	int source;
	u32 read;
	u64 offset;
    u64 buffer[ 0x40 ];
    int ret = 1;
    
    ret = sys_storage_open( FLASH_NOR, &source );
    
    if( ret != 0 ) {
		offset = 0x20D; 
		sys_storage_close( source );
		sys_storage_open( FLASH_NAND, &source );
	}
	else offset = 0x181; 
   
    sys_storage_read( source, offset, 0x1, buffer, &read, 0x22 );
	sys_storage_close( source );
	
	memcpy(IDPS, &buffer[ 0x3a ], 0x10);
}

u8 CHOOSE_IDPS_position=0;

void Draw_CHOOSE_IDPS_menu()
{
	int x = 70;
	
	int x1=x;
	float h = 15+25+10+15;
	float y = 512/2 - h/2;
	
	FontSize(20);
	
	Draw_Box(0, 0, 0, 0, 848, 512, 0x00000080, NO);
	Draw_Box(0, y, 0, 0, X_MAX, h, GREY, NO);
	
	y+=15;
	
	FontColor(COLOR_3);
	SetFontZ(0);
	x = DrawString(x,y, "00000001008");

	if(CHOOSE_IDPS_position==0) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x, y, "%X", IDPS[0x5] - (IDPS[5] >> 4)*0x10 );
	if(CHOOSE_IDPS_position==0) {
		if(IDPS[0x5] - (IDPS[0x5] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0x5] - (IDPS[0x5] >> 4)*0x10 > 0x2) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	FontColor(COLOR_3);
	x = DrawString(x,y, "000");
	
	//0x7
	if(CHOOSE_IDPS_position==1) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0x7] - (IDPS[0x7] >> 4)*0x10);
	if(CHOOSE_IDPS_position==1) {
		if(IDPS[0x7]<0x0E) DrawUp((x+x1)/2, y);
		if(IDPS[0x7]>0x01) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0x8
	if(CHOOSE_IDPS_position==2) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0x8] >> 4));
	if(CHOOSE_IDPS_position==2) {
		if((IDPS[0x8] >> 4) == 0x0 || (IDPS[0x8] >> 4) == 0x1) DrawUp((x+x1)/2, y);
		if((IDPS[0x8] >> 4) == 0x1 || (IDPS[0x8] >> 4) == 0xF) DrawDown((x+x1)/2, y+25*0.85);
	}
	if(CHOOSE_IDPS_position==3) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0x8] - (IDPS[0x8] >> 4)*0x10);
	if(CHOOSE_IDPS_position==3) {
		if(IDPS[0x8] - (IDPS[0x8] >> 4)*0x10 == 0x0) DrawUp((x+x1)/2, y); else
		if(IDPS[0x8] - (IDPS[0x8] >> 4)*0x10 == 0x4) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0x9
	if(CHOOSE_IDPS_position==4) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0x9] >> 4));
	if(CHOOSE_IDPS_position==4) {
		if((IDPS[0x9] >> 4) < 0x3) DrawUp((x+x1)/2, y);
		if((IDPS[0x9] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	if(CHOOSE_IDPS_position==5) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0x9] - (IDPS[0x9] >> 4)*0x10);
	if(CHOOSE_IDPS_position==5) {
		if(IDPS[0x9] - (IDPS[0x9] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0x9] - (IDPS[0x9] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0xA
	if(CHOOSE_IDPS_position==6) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0xA] >> 4));
	if(CHOOSE_IDPS_position==6) {
		if((IDPS[0xA] >> 4) < 0xF) DrawUp((x+x1)/2, y);
		if((IDPS[0xA] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	if(CHOOSE_IDPS_position==7) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0xA] - (IDPS[0xA] >> 4)*0x10);
	if(CHOOSE_IDPS_position==7) {
		if(IDPS[0xA] - (IDPS[0xA] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0xA] - (IDPS[0xA] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0xB
	if(CHOOSE_IDPS_position==8) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0xB] >> 4));
	if(CHOOSE_IDPS_position==8) {
		if((IDPS[0xB] >> 4) < 0xF) DrawUp((x+x1)/2, y);
		if((IDPS[0xB] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	if(CHOOSE_IDPS_position==9) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0xB] - (IDPS[0xB] >> 4)*0x10);
	if(CHOOSE_IDPS_position==9) {
		if(IDPS[0xB] - (IDPS[0xB] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0xB] - (IDPS[0xB] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0xC
	if(CHOOSE_IDPS_position==10) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0xC] >> 4));
	if(CHOOSE_IDPS_position==10) {
		if((IDPS[0xC] >> 4) < 0xF) DrawUp((x+x1)/2, y);
		if((IDPS[0xC] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	if(CHOOSE_IDPS_position==11) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0xC] - (IDPS[0xC] >> 4)*0x10);
	if(CHOOSE_IDPS_position==11) {
		if(IDPS[0xC] - (IDPS[0xC] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0xC] - (IDPS[0xC] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0xD
	if(CHOOSE_IDPS_position==12) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0xD] >> 4));
	if(CHOOSE_IDPS_position==12) {
		if((IDPS[0xD] >> 4) < 0xF) DrawUp((x+x1)/2, y);
		if((IDPS[0xD] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	if(CHOOSE_IDPS_position==13) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0xD] - (IDPS[0xD] >> 4)*0x10);
	if(CHOOSE_IDPS_position==13) {
		if(IDPS[0xD] - (IDPS[0xD] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0xD] - (IDPS[0xD] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0xE
	if(CHOOSE_IDPS_position==14) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0xE] >> 4));
	if(CHOOSE_IDPS_position==14) {
		if((IDPS[0xE] >> 4) < 0xF) DrawUp((x+x1)/2, y);
		if((IDPS[0xE] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	if(CHOOSE_IDPS_position==15) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0xE] - (IDPS[0xE] >> 4)*0x10);
	if(CHOOSE_IDPS_position==15) {
		if(IDPS[0xE] - (IDPS[0xE] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0xE] - (IDPS[0xE] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	//0xF
	if(CHOOSE_IDPS_position==16) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", (IDPS[0xF] >> 4));
	if(CHOOSE_IDPS_position==16) {
		if((IDPS[0xF] >> 4) < 0xF) DrawUp((x+x1)/2, y);
		if((IDPS[0xF] >> 4) > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	if(CHOOSE_IDPS_position==17) FontColor(COLOR_2); else FontColor(COLOR_1);
	x1=x;
	x=DrawFormatString(x,y, "%X", IDPS[0xF] - (IDPS[0xF] >> 4)*0x10);
	if(CHOOSE_IDPS_position==17) {
		if(IDPS[0xF] - (IDPS[0xF] >> 4)*0x10 < 0xF) DrawUp((x+x1)/2, y);
		if(IDPS[0xF] - (IDPS[0xF] >> 4)*0x10 > 0x0) DrawDown((x+x1)/2, y+25*0.85);
	}
	
	x=70; y+=25;
	FontSize(10);
	FontColor(COLOR_3);
	x=DrawString(x,y, "Target ID : ");
	
	if((IDPS[5] >> 4) == 0) x=DrawString(x,y, "PSP "); else
	if((IDPS[5] >> 4) == 8) x=DrawString(x,y, "PS3 ");
	
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x2) DrawString(x,y, "DEX"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x3) DrawString(x,y, "JAPAN"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x4) DrawString(x,y, "USA"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x5) DrawString(x,y, "EUROPE"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x6) DrawString(x,y, "KOREA"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x7) DrawString(x,y, "UK"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x8) DrawString(x,y, "MEXICO"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0x9) DrawString(x,y, "AUSTRALIA"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0xA) DrawString(x,y, "SOUTH ASIA"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0xB) DrawString(x,y, "TAIWAN"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0xC) DrawString(x,y, "RUSSIA"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0xD) DrawString(x,y, "CHINA"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0xE) DrawString(x,y, "HONG KONG"); else
	if(IDPS[5] - (IDPS[5] >> 4)*0x10 == 0xF) DrawString(x,y, "BRAZIL");
}

u8 input_CHOOSE_IDPS()
{
	if(NewPad(BUTTON_DOWN)) {
	
		if(CHOOSE_IDPS_position==0) {
			if(IDPS[0x5] - (IDPS[0x5] >> 4)*0x10 > 0x2) IDPS[0x5]--;
		} else
		if(CHOOSE_IDPS_position==1) {
			if(IDPS[0x7]>0x01) IDPS[0x7]--;
		} else
		if(CHOOSE_IDPS_position==2) {
			if((IDPS[0x8] >> 4) == 0x1) IDPS[0x8] = IDPS[0x8] -(IDPS[0x8] >> 4)*0x10;
			else if((IDPS[0x8] >> 4) == 0xF) IDPS[0x8] = IDPS[0x8] - (IDPS[0x8] >> 4)*0x10 + 0x10;
		} else
		if(CHOOSE_IDPS_position==3) {
			if(IDPS[0x8] - (IDPS[0x8] >> 4)*0x10 == 0x4) IDPS[0x8]= (IDPS[0x8] >> 4)*0x10;
		} else
		if(CHOOSE_IDPS_position==4) {
			if((IDPS[0x9] >> 4) > 0x0) IDPS[0x9]= IDPS[0x9] - 0x10;
		} else
		if(CHOOSE_IDPS_position==5) {
			if(IDPS[0x9] - (IDPS[0x9] >> 4)*0x10 > 0x0) IDPS[0x9]--;
		} else
		if(CHOOSE_IDPS_position==6) {
			if((IDPS[0xA] >> 4) > 0x0) IDPS[0xA] = IDPS[0xA] - 0x10;
		} else
		if(CHOOSE_IDPS_position==7) {
			if(IDPS[0xA] - (IDPS[0xA] >> 4)*0x10 > 0x0) IDPS[0xA]--;
		}  else
		if(CHOOSE_IDPS_position==8) {
			if((IDPS[0xB] >> 4) > 0x0) IDPS[0xB] = IDPS[0xB] - 0x10;
		} else
		if(CHOOSE_IDPS_position==9) {
			if(IDPS[0xB] - (IDPS[0xB] >> 4)*0x10 > 0x0) IDPS[0xB]--;
		}  else
		if(CHOOSE_IDPS_position==10) {
			if((IDPS[0xC] >> 4) > 0x0) IDPS[0xC] = IDPS[0xC] - 0x10;
		} else
		if(CHOOSE_IDPS_position==11) {
			if(IDPS[0xC] - (IDPS[0xC] >> 4)*0x10 > 0x0) IDPS[0xC]--;
		} else
		if(CHOOSE_IDPS_position==12) {
			if((IDPS[0xD] >> 4) > 0x0) IDPS[0xD] = IDPS[0xD] - 0x10;
		} else
		if(CHOOSE_IDPS_position==13) {
			if(IDPS[0xD] - (IDPS[0xD] >> 4)*0x10 > 0x0) IDPS[0xD]--;
		}  else
		if(CHOOSE_IDPS_position==14) {
			if((IDPS[0xE] >> 4) > 0x0) IDPS[0xE] = IDPS[0xE] - 0x10;
		} else
		if(CHOOSE_IDPS_position==15) {
			if(IDPS[0xE] - (IDPS[0xE] >> 4)*0x10 > 0x0) IDPS[0xE]--;
		}  else
		if(CHOOSE_IDPS_position==16) {
			if((IDPS[0xF] >> 4) > 0x0) IDPS[0xF] = IDPS[0xF] - 0x10;
		} else
		if(CHOOSE_IDPS_position==17) {
			if(IDPS[0xF] - (IDPS[0xF] >> 4)*0x10 > 0x0) IDPS[0xF]--;
		}
	}
	
	if(NewPad(BUTTON_UP)) {
		if(CHOOSE_IDPS_position==0) {
			if(IDPS[0x5] - (IDPS[0x5] >> 4)*0x10 < 0xF)	IDPS[0x5]++;
		} else
		if(CHOOSE_IDPS_position==1) {
			if(IDPS[0x7]<0x0E) IDPS[0x7]++;
		} else
		if(CHOOSE_IDPS_position==2) {
			if((IDPS[0x8] >> 4) == 0x1) IDPS[0x8] = IDPS[0x8] -(IDPS[0x8] >> 4)*0x10 + 0xF0;
			else if((IDPS[0x8] >> 4) == 0x0) IDPS[0x8] = IDPS[0x8] - (IDPS[0x8] >> 4)*0x10 + 0x10;
		} else
		if(CHOOSE_IDPS_position==3) {
			if(IDPS[0x8] - (IDPS[0x8] >> 4)*0x10 == 0x0) IDPS[0x8]= (IDPS[0x8] >> 4)*0x10 + 0x4;
		} else
		if(CHOOSE_IDPS_position==4) {
			if((IDPS[0x9] >> 4) < 0x3) IDPS[0x9]= IDPS[0x9] + 0x10;
		} else
		if(CHOOSE_IDPS_position==5) {
			if(IDPS[0x9] - (IDPS[0x9] >> 4)*0x10 < 0xF) IDPS[0x9]++;
		} else
		if(CHOOSE_IDPS_position==6) {
			if((IDPS[0xA] >> 4) < 0xF) IDPS[0xA] = IDPS[0xA] + 0x10;
		} else
		if(CHOOSE_IDPS_position==7) {
			if(IDPS[0xA] - (IDPS[0xA] >> 4)*0x10 < 0xF) IDPS[0xA]++;
		}  else
		if(CHOOSE_IDPS_position==8) {
			if((IDPS[0xB] >> 4) < 0xF) IDPS[0xB] = IDPS[0xB] + 0x10;
		} else
		if(CHOOSE_IDPS_position==9) {
			if(IDPS[0xB] - (IDPS[0xB] >> 4)*0x10 < 0xF) IDPS[0xB]++;
		} else
		if(CHOOSE_IDPS_position==10) {
			if((IDPS[0xC] >> 4) < 0xF) IDPS[0xC] = IDPS[0xC] + 0x10;
		} else
		if(CHOOSE_IDPS_position==11) {
			if(IDPS[0xC] - (IDPS[0xC] >> 4)*0x10 < 0xF) IDPS[0xC]++;
		} else
		if(CHOOSE_IDPS_position==12) {
			if((IDPS[0xD] >> 4) < 0xF) IDPS[0xD] = IDPS[0xD] + 0x10;
		} else
		if(CHOOSE_IDPS_position==13) {
			if(IDPS[0xD] - (IDPS[0xD] >> 4)*0x10 < 0xF) IDPS[0xD]++;
		} else
		if(CHOOSE_IDPS_position==14) {
			if((IDPS[0xE] >> 4) < 0xF) IDPS[0xE] = IDPS[0xE] + 0x10;
		} else
		if(CHOOSE_IDPS_position==15) {
			if(IDPS[0xE] - (IDPS[0xE] >> 4)*0x10 < 0xF) IDPS[0xE]++;
		} else
		if(CHOOSE_IDPS_position==16) {
			if((IDPS[0xF] >> 4) < 0xF) IDPS[0xF] = IDPS[0xF] + 0x10;
		} else
		if(CHOOSE_IDPS_position==17) {
			if(IDPS[0xF] - (IDPS[0xF] >> 4)*0x10 < 0xF) IDPS[0xF]++;
		}
	}
	
	if(NewPad(BUTTON_RIGHT)) {
		if(0 <= CHOOSE_IDPS_position && CHOOSE_IDPS_position < 17) {
			CHOOSE_IDPS_position++;
		}
	}
	
	if(NewPad(BUTTON_LEFT)) {
		if(0 < CHOOSE_IDPS_position && CHOOSE_IDPS_position <= 17) {
			CHOOSE_IDPS_position--;
		}
	}
	
	if(NewPad(BUTTON_SQUARE)) {
		peek_IDPS();
	}
	
	if(NewPad(BUTTON_TRIANGLE)) {
		LoadEID5_IDPS();
	}
	
	if(NewPad(BUTTON_CIRCLE)) {
		return BREAK;
	}
	
	return CONTINUE;
}

void Draw_CHOOSE_IDPS_input()
{
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_CHANGE_VALUE, BUTTON_UP | BUTTON_DOWN | BUTTON_LEFT | BUTTON_RIGHT);
	x=DrawButton(x, y, STR_LOAD_IDPS_LV2, BUTTON_SQUARE);
	x=DrawButton(x, y, STR_LOAD_IDPS_EID5, BUTTON_TRIANGLE);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void Draw_CHOOSE_IDPS()
{
	u8 LoopBreak=1;
	while(LoopBreak)
	{
		cls();
		Draw_scene();
		
		Draw_CHOOSE_IDPS_menu();
		Draw_CHOOSE_IDPS_input();
		
		tiny3d_Flip();
		ScreenShot();
		ps3pad_read();
		
				
		if(input_CHOOSE_IDPS() == BREAK) {
			LoopBreak=0;
			break;
		}
	}
	old_pad = 0;
	new_pad = 0;
}

void close_PS3_GAME_MENU()
{
	write_game_setting(position);
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	MENU=NO;
	free_MENU();
}

void init_PS3_GAME_MENU()
{
	
	print_debug("init_PS3_GAME_MENU");
	
	int i, j;
	
	init_MENU();
	
	add_title_MENU(STR_GAME_SETTINGS);
	
	add_item_MENU(STR_DIRECT_BOOT, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = direct_boot;
	
	if(PEEKnPOKE) {
		add_item_MENU(STR_CLEAN_SYSCALL, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = clean_syscall;
			
		add_item_MENU(STR_CHANGE_IDPS, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = change_IDPS;
	}
	
	add_item_MENU(STR_EXT_GAME_DATA, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = ext_game_data;
	
	if(iso || HEN) {
		add_item_MENU(STR_PAYLOAD, ITEM_LOCKED);
		if(cobra) add_item_value_MENU("Cobra");
		else {
			if(mamba) add_item_value_MENU("Mamba");
			else {
				if(!PEEKnPOKE) {
					add_item_value_MENU(STR_CANT_MOUNT_PEEKPOKE);
				} else {
					if(MAMBA_SIZE != 0) {
						add_item_value_MENU("Mamba");
					} else {
						add_item_value_MENU(STR_CANT_MOUNT_UNKFW);
					}
				}
			}
		}
	} else {
		add_item_MENU(STR_PAYLOAD, ITEM_TEXTBOX);
		if(cobra) add_item_value_MENU("Cobra");
		else {
			if(mamba) add_item_value_MENU("Mamba");
			else {
				if(PEEKnPOKE && MAMBA_SIZE != 0) {
					add_item_value_MENU("Mamba");
				}				
			}
		}
		if(PEEKnPOKE) {
			if( PAYLOAD_SKY_SIZE != 0 ) add_item_value_MENU("Iris");
			if( BASE_ADDR != 0 ) add_item_value_MENU("multiMAN");
		}
		if(ITEMS_VALUE_NUMBER[ITEMS_NUMBER] == -1) {
			ITEMS_TYPE[ITEMS_NUMBER]=ITEM_LOCKED;
			ITEMS_VALUE_POSITION[ITEMS_NUMBER]=0;
			add_item_value_MENU(STR_CANT_MOUNT);
		}
	}
	
	u8 have_payload = YES;
	
	u8 temp_payload=0;
	for(temp_payload=0; temp_payload<=ITEMS_VALUE_NUMBER[ITEMS_NUMBER]; temp_payload++) {
	
		if(ITEMS_VALUE[ITEMS_NUMBER][temp_payload]==NULL) break;
		
		if(payload==SNAKE) {
			if(strcmp(ITEMS_VALUE[ITEMS_NUMBER][temp_payload], "Mamba") == 0 ) break;
			if(strcmp(ITEMS_VALUE[ITEMS_NUMBER][temp_payload], "Cobra") == 0 ) break;
		} else
		if(payload==IRIS) {
			if(strcmp(ITEMS_VALUE[ITEMS_NUMBER][temp_payload], "Iris") == 0 ) break;
		} else
		if(payload==MM) {
			if(strcmp(ITEMS_VALUE[ITEMS_NUMBER][temp_payload], "multiMAN") == 0 ) break;
		} else
		if(payload==NO_PAYLOAD) {
			have_payload = NO;
			temp_payload = 0;
		}
	}
	
	if(have_payload == NO ) {
		init_MENU();
		add_title_MENU(STR_GAME_SETTINGS);
	}
	
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = temp_payload;
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	if(ITEMS_VALUE_NUMBER[ITEMS_NUMBER] == 0) ITEMS_TYPE[ITEMS_NUMBER]=ITEM_LOCKED;
	
	if(have_payload) {
		if(iso == NO) {	
			if(cobra && usb) {
				add_item_MENU(STR_PRIM_USB, ITEM_TOGGLE);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER] = prim_USB;
			}
			
			if( HEN ) {
				add_item_MENU("BDMIRROR", ITEM_TOGGLE);
				ITEMS_VALUE_POSITION[ITEMS_NUMBER] = emu;
			} else {
				add_item_MENU(STR_BDEMU, ITEM_TEXTBOX);
				add_item_value_MENU(STR_NONE);
				add_item_value_MENU("BDMIRROR");
				add_item_value_MENU("BDEMU");
				ITEMS_VALUE_POSITION[ITEMS_NUMBER] = emu;
				ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
				
				if(emu==BDEMU) {
					add_item_MENU(STR_PATCH_LIBFS, ITEM_TEXTBOX);
					add_item_value_MENU("reactPSN");
					add_item_value_MENU("Iris");
					add_item_value_MENU("multiMAN");
					ITEMS_VALUE_POSITION[ITEMS_NUMBER] = libfs_from;
					ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
				}
			}
		}
		
		add_item_MENU(STR_MOUNT_APPHOME, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = mount_app_home;
		
		if(mount_app_home && !HEN) {
			add_item_MENU(STR_PATCH_EXP, ITEM_TOGGLE);
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = use_ex_plug;
		}
		
		add_item_MENU(STR_BT_AUDIO, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = bt_audio;	
	}
	
	add_title_MENU(STR_GAME_OPTION);
	
	if( !AutoM ) {
		if(is_favorite(list_game_path[position]) == NO) {
			add_item_MENU(STR_ADD_FAV, ITEM_TEXTBOX);
		} else {
			add_item_MENU(STR_REM_FAV, ITEM_TEXTBOX);
		}
	
		add_item_MENU(STR_RENAME, ITEM_TEXTBOX);
	
		add_item_MENU(STR_DELETE, ITEM_TEXTBOX);
	
		if(device_number != 0) {
			add_item_MENU(STR_COPY, ITEM_TEXTBOX);
			for(j=0; j<=scan_dir_number; j++) {
				for(i=0; i<=device_number; i++) {
					if(strstr(list_game_path[position], list_device[i])) continue;
					char tmp[255];
					sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
					add_item_value_MENU(tmp);
				}
			}
		}
		
		if(is_66600(list_game_path[position])==YES && is_FAT32(list_game_path[position])==NO) {
			add_item_MENU(STR_JOIN, ITEM_TEXTBOX);
		}
		
		add_item_MENU(STR_MAKE_SHTCUT_PKG, ITEM_TEXTBOX);	
	}
	
	if( !HEN ) {
		add_item_MENU(STR_PATCH_EBOOT, ITEM_TEXTBOX);
		
		if(iso==NO) {
			if(is_resigned_GAME(list_game_path[position])==NO) {
				add_item_MENU(STR_RESIGN, ITEM_TEXTBOX);
			} else {
				add_item_MENU(STR_RESTORE, ITEM_TEXTBOX);
			}
		}
	}
	
	if( !AutoM ) {
		if(iso) {
			add_item_MENU(STR_EXTRACT_ISO, ITEM_TEXTBOX);
		} else {
			add_item_MENU(STR_CONVERT_ISO, ITEM_TEXTBOX);
		}
		for(j=0; j<=scan_dir_number; j++) {
			for(i=0; i<=device_number; i++) {
				char tmp[255];
				sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
				add_item_value_MENU(tmp);
			}
		}
	}
	
	if(iso==NO) {
		add_item_MENU(STR_FIX_PERMS, ITEM_TEXTBOX);
	}
	
	add_item_MENU(STR_CHECK_IRD, ITEM_TEXTBOX);
	add_item_MENU(STR_DL_UPDATE, ITEM_TEXTBOX);
	
	add_item_MENU(STR_PROPS, ITEM_TEXTBOX);	
}

void PS3_GAME_MENU_UPDATE()
{
	if(item_is(STR_DIRECT_BOOT)) {
		direct_boot = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else 
	if(item_is(STR_CLEAN_SYSCALL)) {
		clean_syscall = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else
	if(item_is(STR_CHANGE_IDPS)) {
		change_IDPS = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else 
	if(item_is(STR_EXT_GAME_DATA)) {
		ext_game_data = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else 
	if(item_is(STR_PRIM_USB)) {
		prim_USB = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else 
	if(item_is(STR_BDEMU) || item_is("BDMIRROR")) {
		emu = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else 
	if(item_is(STR_PATCH_LIBFS)) {
		libfs_from = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else
	if(item_is(STR_MOUNT_APPHOME)) {
		mount_app_home = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else 
	if(item_is(STR_PATCH_EXP)) {
		use_ex_plug = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else
	if(item_is(STR_BT_AUDIO)) {
		bt_audio = ITEMS_VALUE_POSITION[ITEMS_POSITION];
	} else
	if(item_is(STR_PAYLOAD)) {
		if( item_value_is("Cobra") || item_value_is("Mamba")) {
			payload = SNAKE;
		} else 
		if( item_value_is("Iris")) {
			payload = IRIS;
		} else 
		if( item_value_is("multiMAN")) {
			payload = MM;
		} else {
			payload = NO_PAYLOAD;
		}
	}
	
	init_PS3_GAME_MENU();
}

u8 PS3_GAME_MENU_CROSS()
{
	if(item_is(STR_RENAME)) {
		char tmpName[128];
		strcpy(tmpName, list_game_title[position]);
		if(Get_OSK_String(STR_RENAME, tmpName, 128) == SUCCESS) {
			if(tmpName[0]!=0) {
				if(SetParamSFO("TITLE", tmpName, list_game_path[position])==SUCCESS) {
					FREE(list_game_title[position]);
					list_game_title[position] = strcpy_malloc(tmpName);
					show_msg(STR_DONE);
				}
			}
		}
	} else 
	if(item_is(STR_ADD_FAV)) {
		if(add_favorite()==SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_REM_FAV)) {
		if(remove_favorite()==SUCCESS) {
			show_msg(STR_DONE);
			if(UI_position != XMB && Only_FAV) {
				int i;
				int old_position = position;
				for(i=0; i<=game_number; i++) {
					if(position-i<0 && game_number<position+i) break;
					if(Show_it(position+i) == YES) {position+=i; break;}
					if(Show_it(position-i) == YES) {position-=i; break;}
				}
				if(old_position == position && 0 <= position) position = -1;
				return BREAK;
			} else 
			if(UI_position == XMB && XMB_H_position==XMB_COLUMN_FAVORITES) {
				return BREAK;
			}	
		} else {
			show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_MAKE_SHTCUT_PKG)) {
		
		char mk_pkg_ID[10];
		if( list_game_ID[position] != NULL ) strcpy(mk_pkg_ID, list_game_ID[position]);
		else strcpy(mk_pkg_ID, "NPEB40000");
		
		if(Get_OSK_String("Title ID", mk_pkg_ID, 10) == SUCCESS) {
			if(mk_pkg_ID[0]!=0) {
				u8 ret;
				start_loading();
				read_game_setting(position);
				ret=make_launcher_pkg(mk_pkg_ID, list_game_path[position]);
				end_loading();
				if(ret == SUCCESS) show_msg(STR_DONE);
				else show_msg(STR_FAILED);
			}
		}
	} else 
	if(item_is(STR_DELETE)) {
		char diag_msg[4096];
		sprintf(diag_msg, "%s\n%s: %s\n%s: %s\n", STR_ASK_TO_DELETE, STR_GAME_TITLE, list_game_title[position], STR_PATH, list_game_path[position]);
		if( DrawDialogYesNo(diag_msg) == YES) {
			start_loading();
			u8 ret = Delete_Game(NULL, position);
			end_loading();
			if(ret==SUCCESS) {
				show_msg(STR_DONE);
				return BREAK;
			} else show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_COPY)) {
		Copy_Game(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
	} else
	if(item_is(STR_JOIN)) {
		char dest[255];
		strcpy(dest, list_game_path[position]);
		dest[strrchr(dest, '/') - dest] = 0;
		Copy_Game(list_game_path[position], dest);
	} else 
	if(item_is(STR_PATCH_EBOOT)) {
		start_loading();
		u8 ret;
		ret = patch_EBOOT(list_game_path[position]);
		if(ret == SUCCESS) show_msg(STR_DONE); 
		else show_msg(STR_FAILED);
		end_loading();
	} else 
	if(item_is(STR_RESIGN)) {
		start_loading();
		if(re_sign_GAME(list_game_path[position]) == SUCCESS) show_msg(STR_DONE); else
		show_msg(STR_FAILED); 
		end_loading();
	} else 
	if(item_is(STR_RESTORE)) {
		start_loading();
		if(restore_GAME(list_game_path[position]) == SUCCESS) show_msg(STR_DONE); else
		show_msg(STR_FAILED); 
		end_loading();
	} else 
	if(item_is(STR_EXTRACT_ISO)) {
		start_loading();
		print_head("Converting...");
		u8 ret;

		if( support_big_files(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]) ) 
			ret = extractps3iso(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], FULL); 
		else 
			ret = extractps3iso(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], SPLIT);	
		
		if(ret==SUCCESS) {
			char ExtGame[512];
						
			sprintf(ExtGame, "%s%s", ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], strrchr(list_game_path[position], '/'));

			int l= strlen(ExtGame);
			if(!strcmp(&ExtGame[l - 2], ".0")) ExtGame[l - 6] = 0; else ExtGame[l - 4] = 0;
			
			add_GAMELIST(ExtGame);
			
			sort_GAMELIST();
			
			init_Load_GAMEPIC();
			
			read_fav();
			
			show_msg(STR_DONE);
		} 
		else 
			show_msg(STR_FAILED);
			
		end_loading();
	} else 
	if(item_is(STR_CONVERT_ISO)) {
		start_loading();
		print_head("Converting...");
		u8 ret;
		if(support_big_files(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]])) 
			ret = makeps3iso(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], FULL);
		else 
			ret = makeps3iso(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], SPLIT);
		
		if(ret==SUCCESS) {
			char IsoGame[512];
						
			if(support_big_files(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]])) {
				sprintf(IsoGame, "%s%s.iso", ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], strrchr(list_game_path[position], '/'));
			} else {
				sprintf(IsoGame, "%s%s.iso.0", ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], strrchr(list_game_path[position], '/'));
			}
			
			add_GAMELIST(IsoGame);
			
			sort_GAMELIST();
			
			init_Load_GAMEPIC();
		
			read_fav();
			
			show_msg(STR_DONE);
		} 
		else 
			show_msg(STR_FAILED);
			
		end_loading();
	} else 
	if(item_is(STR_FIX_PERMS)) {
		start_loading();
		print_head("Fixing permissions...");
		if(SetPerms(list_game_path[position]) == SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
		end_loading();
	} else 
	if(item_is(STR_CHECK_IRD)) {
		u8 ret;
		start_loading();
		ret = IRD_check(list_game_path[position]);
		print_debug("end_loading");
		end_loading();
		
		
		if( ret == SUCCESS ) {
			char temp[128];
			sprintf(temp, "%s.result_md5.txt", list_game_path[position]);
			print_debug("open_txt_viewer %s", temp);
			
			open_txt_viewer(temp);
		} else {
			print_debug("show_msg");
			show_msg(STR_FAILED);
		}
		
	} else 
	if(item_is(STR_DL_UPDATE)) {
		open_PS3_UPDATE_MENU();
	} else 
	if(item_is(STR_PROPS)) {
		start_gathering();
		Get_Game_Size(list_game_path[position]);
		end_gathering();
		
		if(gathering_cancel==NO) Draw_GameProperties();
		else gathering_cancel=NO;
	}
	
	return CONTINUE;
}

u8 PS3_GAME_MENU_SQUARE()
{
	return CONTINUE;
}

u8 PS3_GAME_MENU_TRIANGLE()
{
	return CONTINUE;
}

u8 PS3_GAME_MENU_R1()
{
	if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {	
		if(item_is(STR_CHANGE_IDPS) && change_IDPS) {
			Draw_CHOOSE_IDPS();
		}
	}

	return CONTINUE;
}

void input_PS3_GAME_MENU()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;

	int i;
	
	get_R2speed();
	
	if(R2pad(BUTTON_UP)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				u8 twice=NO;
				if(TITLES[ITEMS_POSITION]==NULL) twice=YES;
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos = ITEMS_POSITION-i;
					if( i_pos < 0 ) i_pos+=ITEMS_NUMBER+1;
					if(TITLES[i_pos] != NULL) {
						if(twice==NO) {
							ITEMS_POSITION = i_pos;
							break;
						} else twice=NO;
					}
				}
			} else if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION==TITLE_MENU_FIRST_ITEM) ITEMS_POSITION=TITLE_MENU_LAST_ITEM;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
				
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		}
	} else
	if(R2pad(BUTTON_DOWN)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL==LVL_TITLE) {
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos=ITEMS_POSITION+i;
					if(ITEMS_NUMBER<i_pos) i_pos-=ITEMS_NUMBER+1;
					if(TITLES[i_pos]!=NULL) {
						ITEMS_POSITION=i_pos;
						break;
					}
				}
			} else
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION == TITLE_MENU_LAST_ITEM) ITEMS_POSITION = TITLE_MENU_FIRST_ITEM;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}				
			} else 
			if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
				
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		}
	} else
	if(NewPad(BUTTON_CROSS)) {
		if(MENU_LVL == LVL_TITLE) {
			MENU_LVL = LVL_ITEMS;
		} else 
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) ITEMS_VALUE_POSITION[ITEMS_POSITION]=YES;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=NO;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			MENU_LVL = LVL_VALUE;
		} else {
			if(PS3_GAME_MENU_CROSS() == BREAK) {
				close_PS3_GAME_MENU();
				return;
			}
		}
	} else
	if(NewPad(BUTTON_SQUARE)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} else {
			if(PS3_GAME_MENU_SQUARE() == BREAK) {
				close_PS3_GAME_MENU();
				return;
			}
		}
	} else
	if(NewPad(BUTTON_TRIANGLE)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} else {
			if(PS3_GAME_MENU_TRIANGLE() == BREAK) {
				close_PS3_GAME_MENU();
				return;
			}
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				close_PS3_GAME_MENU(); 
				return;
			} else 
			if(MENU_LVL == LVL_ITEMS) {
				MENU_LVL = LVL_TITLE;
			} else 
			if(MENU_LVL == LVL_VALUE) {
				MENU_LVL = LVL_ITEMS;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				close_PS3_GAME_MENU(); 
				return;
			} else {
				MENU_LVL = LVL_ITEMS;
				init_PS3_GAME_MENU();
			}
		}
	} else 
	if(NewPad(BUTTON_R1)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else {
			PS3_GAME_MENU_R1();
		}
	}
	
	if(new_pad) PS3_GAME_MENU_UPDATE();
}

void Draw_PS3_GAME_MENU_input()
{
	if(MENU==NO) return;
	if(ICON0_creator == YES) return;
	if(txt_viewer_activ == YES) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	if(MENU_LVL == LVL_VALUE) {
		x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
	} else {
		x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
		x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
		if(ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				x=DrawButton(x, y, STR_CHANGE, BUTTON_SQUARE | BUTTON_TRIANGLE);
			}
		}	
	}
	if( item_is(STR_CHANGE_IDPS) && change_IDPS) {
		x=DrawButton(x, y, STR_EDIT_IDPS, BUTTON_R1);
	}
}

void open_PS3_GAME_MENU()
{
	if( DEBUG ) start_loading();
	
	read_game_setting(position);
	
	USE_TITLE_MENU=NO;
	new_MENU();
	MENU_SIDE=Use_SideMenu;
	if(MENU_SIDE) MENU_ITEMS_X=X_MAX;
	
	Draw_MENU_input = &Draw_PS3_GAME_MENU_input;
	input_MENU = &input_PS3_GAME_MENU;
	
	init_PS3_GAME_MENU();
	
	new_pad = 0;
	
	end_loading();
}

//*******************************************************
// BDVD MENU
//*******************************************************

void close_BDVD_MENU()
{
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	MENU=NO;
	free_MENU();
}

void init_BDVD_MENU()
{
	
	print_debug("init_BDVD_MENU");
	
	int i, j;
	char tmp[255];
	
	init_MENU();
	
	add_title_MENU(STR_GAME_OPTION);
	
	if(is_favorite(list_game_path[position]) == NO) {
		add_item_MENU(STR_ADD_FAV, ITEM_TEXTBOX);
	} else {
		add_item_MENU(STR_REM_FAV, ITEM_TEXTBOX);
	}
	if( HEN ) {
		add_item_MENU(STR_BUILD_ISO, ITEM_TEXTBOX);
		for(j=0; j<=scan_dir_number; j++) {
			for(i=0; i<=device_number; i++) {
				sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
				add_item_value_MENU(tmp);
			}
		}
	} else {
		add_item_MENU(STR_DUMP_DEC, ITEM_TEXTBOX);
		for(j=0; j<=scan_dir_number; j++) {
			for(i=0; i<=device_number; i++) {
				sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
				add_item_value_MENU(tmp);
			}
		}
	}
	add_item_MENU(STR_DUMP_ENC, ITEM_TEXTBOX);
	for(j=0; j<=scan_dir_number; j++) {
		for(i=0; i<=device_number; i++) {
			sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
			add_item_value_MENU(tmp);
		}
	}
	add_item_MENU(STR_REDUMP_LOG, ITEM_TEXTBOX);
	for(j=0; j<=scan_dir_number; j++) {
		for(i=0; i<=device_number; i++) {
			sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
			add_item_value_MENU(tmp);
		}
	}
	
	add_item_MENU(STR_COPY, ITEM_TEXTBOX);
	for(j=0; j<=scan_dir_number; j++) {
		for(i=0; i<=device_number; i++) {
			if(strstr(list_game_path[position], list_device[i])) continue;
			sprintf(tmp, "/%s/%s", list_device[i], scan_dir[j]);
			add_item_value_MENU(tmp);
		}
	}
	
	add_item_MENU(STR_DL_UPDATE, ITEM_TEXTBOX);
	
	add_item_MENU(STR_PROPS, ITEM_TEXTBOX);	
}

void BDVD_MENU_UPDATE()
{
		
}

u8 BDVD_MENU_CROSS()
{
	if(item_is(STR_ADD_FAV)) {
		if(add_favorite()==SUCCESS) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_REM_FAV)) {
		if(remove_favorite()==SUCCESS) {
			show_msg(STR_DONE);
			if(UI_position != XMB && Only_FAV) {
				int i;
				int old_position = position;
				for(i=0; i<=game_number; i++) {
					if(position-i<0 && game_number<position+i) break;
					if(Show_it(position+i) == YES) {position+=i; break;}
					if(Show_it(position-i) == YES) {position-=i; break;}
				}
				if(old_position == position && 0 <= position) position = -1;
				return BREAK;
			} else 
			if(UI_position == XMB && XMB_H_position==XMB_COLUMN_FAVORITES) {
				return BREAK;
			}	
		} else {
			show_msg(STR_FAILED);
		}
	} else 
	if(item_is(STR_COPY)) {
		Copy_Game(list_game_path[position], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
	} else
	if(item_is(STR_BUILD_ISO)) {
		start_copy_loading();
		char result_log[64]={0};
		sprintf(result_log, "/dev_hdd0/game/%s/USRDIR/sys/result.log", ManaGunZ_id);
		u8 ret = build_bdvd_iso(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], result_log);
		end_copy_loading();
		if( ret ) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
		open_txt_viewer(result_log);
	} else
	if(item_is(STR_DUMP_DEC)) {
		start_copy_loading();
		char result_log[64]={0};
		sprintf(result_log, "/dev_hdd0/game/%s/USRDIR/sys/result.log", ManaGunZ_id);
		u8 ret = dump_dec_bdvd(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], result_log);
		end_copy_loading();
		if( ret ) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
		open_txt_viewer(result_log);
	} else
	if(item_is(STR_DUMP_ENC)) {
		start_copy_loading();
		char result_log[64]={0};
		sprintf(result_log, "/dev_hdd0/game/%s/USRDIR/sys/result.log", ManaGunZ_id);
		u8 ret = dump_enc_bdvd(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], result_log);
		end_copy_loading();
		if( ret ) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
		open_txt_viewer(result_log);
	} else
	if(item_is(STR_REDUMP_LOG)) {
		start_copy_loading();
		u8 ret =FAILED;
		char log_path[512];
		char pic_path[512];
		char *date = get_date();
		if( date != NULL) {
			MGZ_mkdir_recursive(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
			sprintf(log_path, "%s/%s_%s.getkey.log", ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], list_game_ID[position], date);
			sprintf(pic_path, "%s/%s_%s.disc.pic", ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]], list_game_ID[position], date);
			free(date);
			ret = get_redump_log(log_path, pic_path);
		}
		end_copy_loading();
		if( ret ) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else
	if(item_is(STR_DL_UPDATE)) {
		open_PS3_UPDATE_MENU();
	} else 
	if(item_is(STR_PROPS)) {
		start_gathering();
		Get_Game_Size(list_game_path[position]);
		end_gathering();
		
		if(gathering_cancel==NO) Draw_GameProperties();
		else gathering_cancel=NO;
	}
	
	return CONTINUE;
}

u8 BDVD_MENU_SQUARE()
{
	return CONTINUE;
}

u8 BDVD_MENU_TRIANGLE()
{
	return CONTINUE;
}

u8 BDVD_MENU_R1()
{
	return CONTINUE;
}

void input_BDVD_MENU()
{
	if(MENU==NO) return;
	if(txt_viewer_activ) return;
	
	int i;
	
	get_R2speed();
	
	if(R2pad(BUTTON_UP)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				u8 twice=NO;
				if(TITLES[ITEMS_POSITION]==NULL) twice=YES;
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos = ITEMS_POSITION-i;
					if( i_pos < 0 ) i_pos+=ITEMS_NUMBER+1;
					if(TITLES[i_pos] != NULL) {
						if(twice==NO) {
							ITEMS_POSITION = i_pos;
							break;
						} else twice=NO;
					}
				}
			} else if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION==TITLE_MENU_FIRST_ITEM) ITEMS_POSITION=TITLE_MENU_LAST_ITEM;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
				
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		}
	} else
	if(R2pad(BUTTON_DOWN)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL==LVL_TITLE) {
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos=ITEMS_POSITION+i;
					if(ITEMS_NUMBER<i_pos) i_pos-=ITEMS_NUMBER+1;
					if(TITLES[i_pos]!=NULL) {
						ITEMS_POSITION=i_pos;
						break;
					}
				}
			} else
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION == TITLE_MENU_LAST_ITEM) ITEMS_POSITION = TITLE_MENU_FIRST_ITEM;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}				
			} else 
			if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
				
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		}
	} else
	if(NewPad(BUTTON_CROSS)) {
		if(MENU_LVL == LVL_TITLE) {
			MENU_LVL = LVL_ITEMS;
		} else 
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == NO) ITEMS_VALUE_POSITION[ITEMS_POSITION]=YES;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=NO;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			MENU_LVL = LVL_VALUE;
		} else {
			if(BDVD_MENU_CROSS() == BREAK) {
				close_BDVD_MENU();
				return;
			}
		}
	} else
	if(NewPad(BUTTON_SQUARE)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} else {
			if(BDVD_MENU_SQUARE() == BREAK) {
				close_BDVD_MENU();
				return;
			}
		}
	} else
	if(NewPad(BUTTON_TRIANGLE)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} else {
			if(BDVD_MENU_TRIANGLE() == BREAK) {
				close_BDVD_MENU();
				return;
			}
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				close_BDVD_MENU(); 
				return;
			} else 
			if(MENU_LVL == LVL_ITEMS) {
				MENU_LVL = LVL_TITLE;
			} else 
			if(MENU_LVL == LVL_VALUE) {
				MENU_LVL = LVL_ITEMS;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				close_BDVD_MENU(); 
				return;
			} else {
				MENU_LVL = LVL_ITEMS;
				init_BDVD_MENU();
			}
		}
	} else 
	if(NewPad(BUTTON_R1)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else {
			BDVD_MENU_R1();
		}
	}
	
	if(new_pad) BDVD_MENU_UPDATE();
}

void Draw_BDVD_MENU_input()
{
	if(MENU==NO) return;
	if(txt_viewer_activ) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void open_BDVD_MENU()
{
	if( DEBUG ) start_loading();
	
	USE_TITLE_MENU=NO;
	new_MENU();
	MENU_SIDE=Use_SideMenu;
	if(MENU_SIDE) MENU_ITEMS_X=X_MAX;
	
	Draw_MENU_input = &Draw_BDVD_MENU_input;
	input_MENU = &input_BDVD_MENU;
	
	init_BDVD_MENU();
	
	new_pad = 0;
	
	end_loading();
}

void open_GameMenu()
{
	if(list_game_platform[position] == BDVD) {
		open_BDVD_MENU();
	} else 
	if(list_game_platform[position] == JB_PS3 || list_game_platform[position] == ISO_PS3) {
		open_PS3_GAME_MENU();
	} else
	if(list_game_platform[position] == JB_PS2 || list_game_platform[position] == ISO_PS2) {
		open_PS2_GAME_MENU();
	} else
	if(list_game_platform[position] == JB_PS1 || list_game_platform[position] == ISO_PS1) {
		open_PS1_GAME_MENU();
	} else
	if(list_game_platform[position] == JB_PSP || list_game_platform[position] == ISO_PSP) {
		open_PSP_GAME_MENU();
	}

}

//*******************************************************
// SETTINGS MENU
//*******************************************************

#define PLUGINS_PATH			"/dev_hdd0/plugins"
#define PLUGINS_PATH_LENGTH		17

u8 BOOTFILE_ITEM;

void close_PLUGINS_MANAGER()
{
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	free_MENU();
	
	open_SETTINGS();
}

void GetPlugins(char *PluginsPath)
{
	char temp[512];
	
	DIR *d;
	struct dirent *dir;
	d = opendir(PluginsPath);
	if(d!=NULL) {			
		while ((dir = readdir(d))) {
			if(!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..")) continue;
			
			sprintf(temp, "%s/%s", PluginsPath, dir->d_name);
		
			if(dir->d_type & DT_DIR) GetPlugins(temp);
			
			if(strcasecmp(get_ext(dir->d_name), ".sprx")) continue;
			
			if(ITEMS_NUMBER==MENU_MAX_ITEMS-1) break;
			
			add_item_MENU(&temp[PLUGINS_PATH_LENGTH+1], ITEM_CHECKBOX);
			
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = is_it_inside(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], temp);
			
		}
		closedir(d);
	}
}

u8 cobra_bootfile_exist = NO;
u8 mamba_bootfile_exist = NO;

void init_PLUGINS_MANAGER()
{
	init_MENU();
	
	char temp[128];
		
	if(cobra || mamba) {
		add_title_MENU(STR_PLUGIN_MONITOR);
		
		unsigned int i;
		
		char plugin_name[30];
		char plugin_path[128];
		
		for(i=1; i<7; i++) {
			memset(plugin_name, 0, sizeof(plugin_name));
			memset(plugin_path, 0, sizeof(plugin_path));
			memset(temp, 0, sizeof(temp));
			
			ps3mapi_get_vsh_plugin_info(i, plugin_name, plugin_path);

			if(strlen(plugin_name)==0) {
				sprintf(temp, "[ %d ] : %s", i, STR_UNUSED);
			} else {
				sprintf(temp, "[ %d ] : %s | %s", i, plugin_name, plugin_path);
			}

			add_item_MENU(temp, ITEM_TEXTBOX);
		}
	}
	
	add_title_MENU(STR_PLUGIN_MANAGER);
	add_item_MENU(STR_BOOT_FILE, ITEM_TEXTBOX);
	
	if( cobra ) {
		if(path_info("/dev_hdd0/boot_plugins.txt") == _FILE) {
			cobra_bootfile_exist = YES;
			add_item_value_MENU("/dev_hdd0/boot_plugins.txt");
		} else {
			cobra_bootfile_exist = NO;
		}
	} else 
	if( mamba ) {
		if(path_info("/dev_hdd0/mamba_plugins.txt") == _FILE) {
			mamba_bootfile_exist = YES;
			add_item_value_MENU("/dev_hdd0/mamba_plugins.txt");
		} else {
			mamba_bootfile_exist = NO;
		}
	}
	if(path_info("/dev_hdd0/game/PRXLOADER/USRDIR/plugins.txt") == _FILE) {
		add_item_value_MENU("/dev_hdd0/game/PRXLOADER/USRDIR/plugins.txt");
	}
	if(path_info("/dev_hdd0/prx_plugins.txt") == _FILE) {
		add_item_value_MENU("/dev_hdd0/prx_plugins.txt");
	}
	
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	
	BOOTFILE_ITEM = ITEMS_NUMBER;
	if(ITEMS_VALUE_NUMBER[BOOTFILE_ITEM] == -1) return;
	
	MENU_TABLE_START=ITEMS_NUMBER;
	
	FILE* f = fopen(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], "r");
	if(f) {
		char line[255];
		int l = strlen(PLUGINS_PATH);
		while(fgets(line, 255, f) != NULL) {
			if(line[0]=='\r' || line[0]=='\n') continue;
			if(strstr(line, "\r") != NULL) strtok(line, "\r");
			if(strstr(line, "\n") != NULL) strtok(line, "\n");
			
			if(strncmp(line, PLUGINS_PATH, l) != 0) {
				if(ITEMS_NUMBER==MENU_MAX_ITEMS-1) break;
				add_item_MENU(line, ITEM_TEXTBOX);
			}
		}
		fclose(f);
	}
	
	GetPlugins(PLUGINS_PATH);
	
	MENU_TABLE_END=ITEMS_NUMBER;
	MENU_COLUMN_ITEMS_NUMBER = 1+(ITEMS_NUMBER-BOOTFILE_ITEM)/4;
}

u8 PLUGINS_MANAGER_R1()
{
	if(ITEMS_POSITION == BOOTFILE_ITEM) {
		if(ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			open_txt_viewer(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
		}
	}
	
	init_PLUGINS_MANAGER();
	
	return CONTINUE;
}

u8 PLUGINS_MANAGER_L1()
{
	if(ITEMS_POSITION == BOOTFILE_ITEM) {
		FILE* f=NULL;
		if(cobra && !cobra_bootfile_exist) {
			f=fopen("/dev_hdd0/boot_plugins.txt", "wb");
			if(f) cobra_bootfile_exist=YES;
		} else 
		if(mamba && !mamba_bootfile_exist) {
			f=fopen("/dev_hdd0/mamba_plugins.txt", "wb");
			if(f) mamba_bootfile_exist=YES;
		}
		if(f) fclose(f);
	}
	
	init_PLUGINS_MANAGER();
	
	return CONTINUE;
}

u8 PLUGINS_MANAGER_CROSS()
{
// PLUGIN MONITOR
	if(ITEMS_POSITION < BOOTFILE_ITEM) {
		if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_TEXTBOX) {
			u32 slot;
			sscanf(ITEMS[ITEMS_POSITION], "%*s %d", &slot);
			cobra_unload_vsh_plugin(slot);
		}
	} else
// BOOT FILE
	if(ITEMS_POSITION == BOOTFILE_ITEM) {
		if(ITEMS_VALUE_NUMBER[ITEMS_POSITION] == -1) {
			FILE* f=NULL;
			if(cobra) {
				f=fopen("/dev_hdd0/boot_plugins.txt", "wb"); 
				if(f) cobra_bootfile_exist=YES;
			} else
			if(mamba) {
				f=fopen("/dev_hdd0/mamba_plugins.txt", "wb");
				if(f) mamba_bootfile_exist=YES;
			}
			if(f) fclose(f);
		} else {
			open_txt_viewer(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
		}
	} else 
// PLUGIN MANAGER
	if(ITEMS_POSITION > BOOTFILE_ITEM) { 
		if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_TEXTBOX) {
			char NewPath[255] = {0};
			sprintf(NewPath, PLUGINS_PATH "/%s", &strrchr(ITEMS[ITEMS_POSITION], '/')[1]);
			if( Move(ITEMS[ITEMS_POSITION], NewPath) == SUCCESS) {
				remove_from_list(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], ITEMS[ITEMS_POSITION]);
				add_to_list(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], NewPath);
			}
		} else 
		if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_CHECKBOX) {
			char temp[255] = {0};
			sprintf(temp, PLUGINS_PATH "/%s", ITEMS[ITEMS_POSITION]);
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == YES) 
				remove_from_list(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], temp);
			else 
				add_to_list(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], temp);
		}
	}
	
	init_PLUGINS_MANAGER();
	
	return CONTINUE;
}

u8 PLUGINS_MANAGER_SQUARE()
{
	if(ITEMS_POSITION > BOOTFILE_ITEM) {
		char diag_msg[2048];
		sprintf(diag_msg, "%s\n%s: %s", STR_ASK_TO_DELETE, STR_FILE, ITEMS[ITEMS_POSITION]);
		if( DrawDialogYesNo(diag_msg) == YES) {
			char prx_path[128];
			if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX) {
				sprintf(prx_path, PLUGINS_PATH "/%s", ITEMS[ITEMS_POSITION]);
			} else 
			if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_TEXTBOX) {
				strcpy(prx_path, ITEMS[ITEMS_POSITION]);
			}
			remove_from_list(ITEMS_VALUE[BOOTFILE_ITEM][ITEMS_VALUE_POSITION[BOOTFILE_ITEM]], prx_path);
			Delete(prx_path);
			ITEMS_POSITION=0;
		}
	}
	
	init_PLUGINS_MANAGER();
	
	return CONTINUE;
}

u8 PLUGINS_MANAGER_TRIANGLE()
{
	if(ITEMS_POSITION > BOOTFILE_ITEM) {
		int i;
		for(i=0; i<6; i++) {
			if(strcmp(&strrchr(ITEMS[i], ' ')[1], STR_UNUSED)==0) {
				char prx_path[128];
				if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX) {
					sprintf(prx_path, PLUGINS_PATH "/%s", ITEMS[ITEMS_POSITION]);
				} else 
				if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_TEXTBOX) {
					strcpy(prx_path, ITEMS[ITEMS_POSITION]);
				}
				cobra_load_vsh_plugin(i+1, prx_path, NULL, 0);
				break;
			}
		}
	}
	
	init_PLUGINS_MANAGER();
	
	return CONTINUE;
}

void input_PLUGINS_MANAGER()
{
	if(MENU==NO) return;
	if(txt_viewer_activ) {
		// if the user delete the file from txt_viewer
		if(NewPad(BUTTON_SQUARE)) {
			txt_viewer_activ=NO;
			memset(txt_viewer_content, 0, sizeof(txt_viewer_content));
			FREE(txt_viewer_content);
			FREE(txt_viewer_path);
			MENU_LVL = LVL_ITEMS;
			init_PLUGINS_MANAGER();
		}
		return;
	}
	
	get_R2speed();
	
	if(MENU_TABLE_START < ITEMS_POSITION && ITEMS_POSITION <=MENU_TABLE_END) {
		if(R2pad(BUTTON_RIGHT)) {
			if(ITEMS_POSITION + MENU_COLUMN_ITEMS_NUMBER <= ITEMS_NUMBER) ITEMS_POSITION += MENU_COLUMN_ITEMS_NUMBER;
		} else
		if(R2pad(BUTTON_LEFT)) {
			if(ITEMS_POSITION - MENU_COLUMN_ITEMS_NUMBER >= 0) ITEMS_POSITION -= MENU_COLUMN_ITEMS_NUMBER;
		}
	}
	
	if(R2pad(BUTTON_UP)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
			else ITEMS_POSITION--;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
		}
	} else
	if(R2pad(BUTTON_DOWN)) {
		if(MENU_LVL == LVL_ITEMS) {
			if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
			else ITEMS_POSITION++;
		} else {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
		}
	} else
	if(NewPad(BUTTON_CROSS)) {
		if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX ) {
			PLUGINS_MANAGER_CROSS();
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION]=1;
			else ITEMS_VALUE_POSITION[ITEMS_POSITION]=0;
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1 ) {
			MENU_LVL = LVL_VALUE;
		} else {
			if(PLUGINS_MANAGER_CROSS() == BREAK) close_PLUGINS_MANAGER();
		}
	} else
	if(NewPad(BUTTON_SQUARE)) {
		if(PLUGINS_MANAGER_SQUARE() == BREAK) close_PLUGINS_MANAGER();
	} else
	if(NewPad(BUTTON_TRIANGLE)) {
		if(PLUGINS_MANAGER_TRIANGLE() == BREAK) close_PLUGINS_MANAGER();
	} else
	if(NewPad(BUTTON_R1)) {
		if( PLUGINS_MANAGER_R1() == BREAK) close_PLUGINS_MANAGER();
	} else
	if(NewPad(BUTTON_L1)) {
		if( PLUGINS_MANAGER_L1() == BREAK) close_PLUGINS_MANAGER();
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(MENU_LVL == LVL_ITEMS) close_PLUGINS_MANAGER();
		else {
			init_PLUGINS_MANAGER();
			MENU_LVL = LVL_ITEMS;
		}
	}

}

void Draw_PLUGINS_MANAGER_input()
{
	if(MENU==NO) return;
	if(txt_viewer_activ) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	if(ITEMS_POSITION < BOOTFILE_ITEM) {
		x=DrawButton(x, y, STR_UNLOAD, BUTTON_CROSS);
	} else
	if(ITEMS_POSITION == BOOTFILE_ITEM) {
		if(MENU_LVL != LVL_VALUE) {
			x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);			
		}
		if(ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			x=DrawButton(x, y, STR_VIEW, BUTTON_R1);
		}
		if( cobra && !cobra_bootfile_exist ) {
			x=DrawButton(x, y, STR_CREATE, BUTTON_L1);
		} else 
		if( mamba && !mamba_bootfile_exist) {
			x=DrawButton(x, y, STR_CREATE, BUTTON_L1);
		}
	} else
	if(ITEMS_POSITION > BOOTFILE_ITEM) {
		if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX) {
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == YES) 
				x=DrawButton(x, y, STR_UNCHECK, BUTTON_CROSS);
			else 
				x=DrawButton(x, y, STR_CHECK, BUTTON_CROSS);			
		} else {
			x=DrawButton(x, y, STR_MOVE_TO_PLUGINS, BUTTON_CROSS);
		}
		x=DrawButton(x, y, STR_DELETE, BUTTON_SQUARE);
		x=DrawButton(x, y, STR_LOAD, BUTTON_TRIANGLE);
	}
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

u8 open_PLUGINS_MANAGER()
{
	if( path_info(PLUGINS_PATH) == _NOT_EXIST) {
		if( DrawDialogYesNo(STR_ASK_PLUGINS) == YES) mkdir(PLUGINS_PATH, 0777);
		else return CONTINUE;
	}
	
	start_loading();
	
	close_SETTINGS();
	
	USE_TITLE_MENU=NO;
	MENU_SIDE = NO;
	new_MENU();
	
	if(PEEKnPOKE) {
		if(!cobra && !mamba) mamba = install_mamba();
	}
	init_PLUGINS_MANAGER();
	
	Draw_MENU_input = &Draw_PLUGINS_MANAGER_input;
	input_MENU = &input_PLUGINS_MANAGER;
	
	end_loading();
	
	return BREAK;
}

void Draw_TVTEST()
{
	if(TMP_PIC_offset != 0) {
		tiny3d_SetTexture(0, TMP_PIC_offset, TMP_PIC.width, TMP_PIC.height, TMP_PIC.pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(0, 0, 0, 0, 848, 512, WHITE, YES);
	}
}

void Draw_AdjustScreen()
{
	int Show_TVTEST=NO;
	
	char TVTEST[128];
	sprintf(TVTEST, "/dev_hdd0/game/%s/USRDIR/GUI/common/TVTEST.PNG", ManaGunZ_id);

	if(path_info(TVTEST) != _FILE) Show_TVTEST=-1;
	
	u8 LoopBreak=1;
	while(LoopBreak)
	{
			
		float x=INPUT_X;
		float y=INPUT_Y;
		SetFontZ(0);
		
		adjust_screen();
		
		cls();
		
		if(Show_TVTEST==YES)
		{
			Draw_TVTEST();
			FontColor(WHITE);
			x=DrawButton(x, y, STR_HIDETV, BUTTON_CROSS);
		} else {
			Draw_Box(0,0,10,   0,   X_MAX,Y_MAX,  0xFFFFFFFF, NO);
			Draw_Box(30,30,9 , 0,   X_MAX-30*2,Y_MAX-30*2,  0x000000FF, NO);

			int l=150, h=70;
			Draw_Box(110,150,8,   5,   15,Y_MAX-150*2,  0xFFFFFFFF, NO);

			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(110+15+5+h, Y_MAX/2, 8);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexPos(110+15+5 , Y_MAX/2 -l/2 , 8);
			tiny3d_VertexPos(110+15+5 , Y_MAX/2 +l/2 , 8);
			tiny3d_End();
			Draw_Pad(BUTTON_RIGHT,  110+15+5+5,Y_MAX/2-20,8, 40);			

			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(110-5-h, Y_MAX/2, 8);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexPos(110-5 , Y_MAX/2 -l/2 , 8);
			tiny3d_VertexPos(110-5 , Y_MAX/2 +l/2 , 8);
			tiny3d_End();
			Draw_Pad(BUTTON_LEFT,  110-5-40-5,Y_MAX/2-20,8, 40);
			
			Draw_Box(150,110,8,   5,   X_MAX-120*2,15,  0xFFFFFFFF, NO);

			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(X_MAX/2, 110+15+5+h, 8);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexPos(X_MAX/2 -l/2, 110+15+5 , 8);
			tiny3d_VertexPos(X_MAX/2 +l/2, 110+15+5 , 8);
			tiny3d_End();
			Draw_Pad(BUTTON_DOWN,  X_MAX/2-20,110+15+5+5,8, 40);
		
			tiny3d_SetPolygon(TINY3D_TRIANGLES);
			tiny3d_VertexPos(X_MAX/2, 110-5-h , 8);
			tiny3d_VertexColor(0xFFFFFFFF);
			tiny3d_VertexPos(X_MAX/2 -l/2 , 110-5 , 8);
			tiny3d_VertexPos(X_MAX/2 +l/2 , 110-5 , 8);
			tiny3d_End();
			Draw_Pad(BUTTON_UP,  X_MAX/2-20,110-5-40-5,8, 40);

			FontColor(BLACK);
			FontSize(15);
			
			//if(Show_TVTEST != -1) x=DrawButton(x, INPUT_Y, STR_SHOWTV, BUTTON_CROSS);
			if(Show_TVTEST != -1 && Load_GAMEPIC_busy==NO) x=DrawButton(x, INPUT_Y, STR_SHOWTV, BUTTON_CROSS);
		} 
		
		x=DrawButton(x, INPUT_Y, STR_RESET, BUTTON_SQUARE);
		x=DrawButton(x, INPUT_Y, STR_BACK, BUTTON_CIRCLE);
		
		tiny3d_Flip();
		ScreenShot();
		ps3pad_read();
		
		if(NewPad(BUTTON_SQUARE)) {
			videoscale_x = 0;
			videoscale_y = 0;
		}
		if(Show_TVTEST != -1 && Load_GAMEPIC_busy==NO) {
			if(NewPad(BUTTON_CROSS)) {
				if(Show_TVTEST==NO) {
					memset(TMP_PIC_path, 0, sizeof(TMP_PIC_path));
					strcpy(TMP_PIC_path, TVTEST);
					Load_FM();
					Show_TVTEST=YES;
				} else {
					Show_TVTEST=NO;
					TMP_PIC_offset=0;
					memset(TMP_PIC_path, 0, sizeof(TMP_PIC_path));
				}
			}
		}
		if(NewPad(BUTTON_DOWN)) {if(videoscale_y > -120) videoscale_y-=10;}
		if(NewPad(BUTTON_UP)) {if(videoscale_y < 120) videoscale_y+=10;}
		if(NewPad(BUTTON_RIGHT)) {if(videoscale_x > -120) videoscale_x-=10;}
		if(NewPad(BUTTON_LEFT)) {if(videoscale_x < 120) videoscale_x+=10;}
		if(NewPad(BUTTON_CIRCLE)) {
			if(Show_TVTEST==YES) {
				TMP_PIC_offset=0;
				memset(TMP_PIC_path, 0, sizeof(TMP_PIC_path));
			}
			write_setting();
			LoopBreak=0;
			return;
		}
	}
}

#define FLAG_COLOR_1		1
#define FLAG_COLOR_2		2
#define FLAG_COLOR_3		3
#define FLAG_COLOR_4		4
#define FLAG_WAVES_COLOR	5
#define FLAG_COLOR_NOTIF	6
#define FLAG_COLOR_BOXHEAD	7
#define FLAG_COLOR_BOXBODY	8
#define FLAG_COLOR_SIDEBAR	9
#define FLAG_COLOR_BGS		10
#define FLAG_COLOR_BG		11

u8 C_pos=0;
void Draw_RGBA_box(int n)
{
	u32 COLOR=0;
	if(n==FLAG_COLOR_1) COLOR = COLOR_1; else
	if(n==FLAG_COLOR_2) COLOR = COLOR_2; else
	if(n==FLAG_COLOR_3) COLOR = COLOR_3; else
	if(n==FLAG_COLOR_4) COLOR = COLOR_4; else
	if(n==FLAG_WAVES_COLOR) COLOR = WAVES_COLOR; else
	if(n==FLAG_COLOR_NOTIF) COLOR = COLOR_NOTIF; else
	if(n==FLAG_COLOR_BOXHEAD) COLOR = COLOR_BOXHEAD; else
	if(n==FLAG_COLOR_BOXBODY) COLOR = COLOR_BOXBODY; else
	if(n==FLAG_COLOR_SIDEBAR) COLOR = COLOR_SIDEBAR; else
	if(n==FLAG_COLOR_BGS) COLOR = COLOR_BGS; else
	if(n==FLAG_COLOR_BG) COLOR = COLOR_BG;
	
	float h_COLOR = 5+20*4+5;
	float w_COLOR = h_COLOR + 10+10+128+10 + 50;
	
	if(current_x + w_COLOR > X_MAX) current_x -= w_COLOR-16;
	if(current_y + h_COLOR > Y_MAX) current_y -= h_COLOR-10;
	
	// CurrentColor
	Draw_Box(current_x, current_y, 0, 0, w_COLOR, h_COLOR, 0x888888FF, NO); // Background
	Draw_Box(current_x+10, current_y+10, 0, 0, h_COLOR-20, h_COLOR-20, COLOR, NO); //CurrentColor
	
	// Bar
	Draw_Box(current_x+h_COLOR+10+10, current_y+5+9			, 0, 0, 128, 2, 0x444444FF, NO);
	Draw_Box(current_x+h_COLOR+10+10, current_y+5+20+9		, 0, 0, 128, 2, 0x444444FF, NO);
	Draw_Box(current_x+h_COLOR+10+10, current_y+5+20+20+9	, 0, 0, 128, 2, 0x444444FF, NO);
	Draw_Box(current_x+h_COLOR+10+10, current_y+5+20+20+20+9	, 0, 0, 128, 2, 0x444444FF, NO);
	
	FontSize(10);
	SetFontZ(0);
	FontColor(WHITE);
		
	u32 curs_color=WHITE;
	float e;
	
	if(C_pos == 0) {curs_color = WHITE; e=12;} else {curs_color = 0x666666FF; e=8;}
	Draw_Box(current_x+h_COLOR+5-e/2, current_y+5+10-e/2, 0, 0, e, e, RED, NO);
	Draw_Box(current_x+h_COLOR+10+10 + GetRED(COLOR)/2 - 2, current_y+5+10-4, 0, 0, 4, 8, curs_color, NO);
	FontColor(curs_color);
	DrawFormatString(current_x+w_COLOR-50, current_y+5+10-4, "%03d", (int) GetRED(COLOR));
	DrawFormatString(current_x+w_COLOR-30, current_y+5+10-4, "0x%02X", (int) GetRED(COLOR));
	
	if(C_pos == 1) {curs_color = WHITE; e=12;} else {curs_color = 0x666666FF; e=8;}
	Draw_Box(current_x+h_COLOR+5-e/2, current_y+5+20+10-e/2, 0, 0, e, e, GREEN, NO);
	Draw_Box(current_x+h_COLOR+10+10 + GetGREEN(COLOR)/2 - 2, current_y+5+20+10-4, 0, 0, 4, 8, curs_color, NO);
	FontColor(curs_color);
	DrawFormatString(current_x+w_COLOR-50, current_y+5+20+10-4, "%03d", (int) GetGREEN(COLOR));
	DrawFormatString(current_x+w_COLOR-30, current_y+5+20+10-4, "0x%02X", (int) GetGREEN(COLOR));
	
	if(C_pos == 2) {curs_color = WHITE; e=12;} else {curs_color = 0x666666FF; e=8;}
	
	Draw_Box(current_x+h_COLOR+5-e/2, current_y+5+20+20+10-e/2, 0, 0, e, e, BLUE, NO);
	Draw_Box(current_x+h_COLOR+10+10 + GetBLUE(COLOR)/2 - 2, current_y+5+20+20+10-4, 0, 0, 4, 8, curs_color, NO);
	FontColor(curs_color);
	DrawFormatString(current_x+w_COLOR-50, current_y+5+20+20+10-4, "%03d", (int) GetBLUE(COLOR));
	DrawFormatString(current_x+w_COLOR-30, current_y+5+20+20+10-4, "0x%02X", (int) GetBLUE(COLOR));
	
	if(C_pos == 3) {curs_color = WHITE; e=12;} else {curs_color = 0x666666FF; e=8;}
	Draw_Box(current_x+h_COLOR+5-e/2, current_y+5+20+20+20+10-e/2, 0, 0, e, e, BLACK-0xFF+GetALPHA(COLOR), NO);
	Draw_Box(current_x+h_COLOR+10+10 + GetALPHA(COLOR)/2 - 2, current_y+5+20+20+20+10-4, 0, 0, 4, 8, curs_color, NO);
	FontColor(curs_color);
	DrawFormatString(current_x+w_COLOR-50, current_y+5+20+20+20+10-4, "%03d", (int) GetALPHA(COLOR));
	DrawFormatString(current_x+w_COLOR-30, current_y+5+20+20+20+10-4, "0x%02X", (int) GetALPHA(COLOR));
	
	FontSize(20);
}

u8 GetSpeed(u64 delay)
{
	u64 i;
	for(i=4; 0 < i; i--) {
		if(n_s(i)<delay) return i;
	}
	return 1;
}

u8 input_COLOR(int n)
{
	u32 COLOR=0;
	if(n==FLAG_COLOR_1) COLOR = COLOR_1; else
	if(n==FLAG_COLOR_2) COLOR = COLOR_2; else
	if(n==FLAG_COLOR_3) COLOR = COLOR_3; else
	if(n==FLAG_COLOR_4) COLOR = COLOR_4; else
	if(n==FLAG_WAVES_COLOR) COLOR = WAVES_COLOR; else
	if(n==FLAG_COLOR_NOTIF) COLOR = COLOR_NOTIF; else
	if(n==FLAG_COLOR_BOXHEAD) COLOR = COLOR_BOXHEAD; else
	if(n==FLAG_COLOR_BOXBODY) COLOR = COLOR_BOXBODY; else
	if(n==FLAG_COLOR_SIDEBAR) COLOR = COLOR_SIDEBAR; else
	if(n==FLAG_COLOR_BGS) COLOR = COLOR_BGS; else
	if(n==FLAG_COLOR_BG) COLOR = COLOR_BG;
	
	get_R2speed();
	
	u8 red_inc = 0;
	u8 green_inc = 0;
	u8 blue_inc = 0;
	u8 alpha_inc = 0;
	
	u64 delay=0;
	
	if(NewPad(BUTTON_UP)) {
		if(C_pos==0) C_pos=3;
		else C_pos--;
	} else
	if(NewPad(BUTTON_DOWN)) {
		if(C_pos==3) C_pos=0;
		else C_pos++;
	} else
	if(NewPad(BUTTON_LEFT) || (delay=OldPadDelay(BUTTON_LEFT, n_ms(300))) ) {
		if(C_pos == 0) red_inc = -GetSpeed(delay);
		if(C_pos == 1) green_inc = -GetSpeed(delay);
		if(C_pos == 2) blue_inc = -GetSpeed(delay);
		if(C_pos == 3) alpha_inc = -GetSpeed(delay);
	} else
	if(NewPad(BUTTON_RIGHT) || (delay=OldPadDelay(BUTTON_RIGHT, n_ms(300))) ) {
		if(C_pos == 0) red_inc = GetSpeed(delay);
		if(C_pos == 1) green_inc = GetSpeed(delay);
		if(C_pos == 2) blue_inc = GetSpeed(delay);
		if(C_pos == 3) alpha_inc = GetSpeed(delay);
	}
	
	if(C_pos == 0 && red_inc != 0) COLOR = SetRED(GetRED(COLOR) + red_inc, COLOR); else
	if(C_pos == 1 && green_inc != 0) COLOR = SetGREEN(GetGREEN(COLOR) + green_inc, COLOR);
	if(C_pos == 2 && blue_inc != 0) COLOR = SetBLUE(GetBLUE(COLOR) + blue_inc, COLOR);
	if(C_pos == 3 && alpha_inc != 0) COLOR = SetALPHA(GetALPHA(COLOR) + alpha_inc, COLOR);
		
	if(n==1) COLOR_1 = COLOR; else
	if(n==2) COLOR_2 = COLOR; else
	if(n==3) COLOR_3 = COLOR; else
	if(n==4) COLOR_4 = COLOR; else
	if(n==5) WAVES_COLOR = COLOR;
		
		
	if(n==FLAG_COLOR_1) COLOR_1 = COLOR; else
	if(n==FLAG_COLOR_2) COLOR_2 = COLOR; else
	if(n==FLAG_COLOR_3) COLOR_3 = COLOR; else
	if(n==FLAG_COLOR_4) COLOR_4 = COLOR; else
	if(n==FLAG_WAVES_COLOR) WAVES_COLOR = COLOR; else
	if(n==FLAG_COLOR_NOTIF) COLOR_NOTIF = COLOR; else
	if(n==FLAG_COLOR_BOXHEAD) COLOR_BOXHEAD = COLOR; else
	if(n==FLAG_COLOR_BOXBODY) COLOR_BOXBODY = COLOR; else
	if(n==FLAG_COLOR_SIDEBAR) COLOR_SIDEBAR = COLOR; else
	if(n==FLAG_COLOR_BGS) COLOR_BGS = COLOR; else
	if(n==FLAG_COLOR_BG) COLOR_BG = COLOR;
		
	if(NewPad(BUTTON_CIRCLE)) {
		return BREAK;
	}
	
	return CONTINUE;
}

void Draw_COLOR_input()
{
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	x=DrawButton(x, y, STR_SET_COLOR, BUTTON_UP | BUTTON_DOWN | BUTTON_LEFT | BUTTON_RIGHT);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void Draw_ChooseColor(u8 n)
{
	u8 LoopBreak=1;
	
	u32 old_BGS_offset=PICTURE_offset[BGS];
	u8 old_FILTER_BGS= FILTER_BGS;
	
	while(LoopBreak)
	{
		cls();
		Draw_scene();
		
		Draw_RGBA_box(n);
		if( n == FLAG_COLOR_NOTIF) {
			time_not = 0;
			show_msg("0123456789");
			Draw_Notification();
		} else
		if( n == FLAG_COLOR_BOXHEAD || n == FLAG_COLOR_BOXBODY) {
			filter=YES;
			Draw_filter();
		} else
		if( n == FLAG_COLOR_SIDEBAR) {
			Draw_SIDEBAR(593);
		} else 
		if( n == FLAG_COLOR_BG) {
			PICTURE_offset[BGS]=0;
			FILTER_BGS=DISABLED;
		}
		Draw_COLOR_input();
		
		tiny3d_Flip();
		ScreenShot();
		ps3pad_read();
					
		if(input_COLOR(n) == BREAK) {
			PICTURE_offset[BGS]=old_BGS_offset;
			FILTER_BGS=old_FILTER_BGS;
			LoopBreak=0;
			time_not = 101;
			filter = NO;
			return;
		}
	}
}

u8 REC_UI_position=0;
u8 REC_Show_COVER=0;
u8 REC_Show_ICON0=0;
u8 REC_FLOW_3D=0;
void close_SETTINGS()
{
	if(REC_UI_position!=UI_position) {
		start_loading();
		print_load("Reloading Theme...");
		if(REC_UI_position == XMB ) {
			if(Show_it(position) == NO) {
				int i;
				int old_position = position;
				for(i=0; i<=game_number; i++) {
					if(position-i<0 && game_number<position+i) break;
					if(Show_it(position+i) == YES) {position+=i; break;}
					if(Show_it(position-i) == YES) {position-=i; break;}
				}
				if(old_position == position && 0 <= position) position = -1;
			}
		} else 
		if( UI_position == XMB ) {
			if( position < 0 ) {
				int i;
				position=0;
				for(i=0; i<=game_number; i++) {
					if(Show_it(i)==YES) {position=i; break;}
				}
			}
		}
		Load_Theme();
		init_Load_GAMEPIC();
		end_loading();
	} else {
		if(REC_Show_COVER!=Show_COVER 
		|| REC_Show_ICON0!=Show_ICON0
		|| REC_FLOW_3D!=FLOW_3D) {
			init_Load_GAMEPIC();
		}
	}
	
	FreeFont();
	write_setting();
	Draw_MENU_input = &EmptyFunc;
	input_MENU = &EmptyFunc;
	MENU=NO;
	free_MENU();
}

char *FM_GetContent(char *str_format, char *MountPoint, DeviceInfo_t DeviceInfo)
{
	if(str_format==NULL) return NULL;
	
	char Row[255];	
	
	u8 format = FM_GetFormat(str_format);
	u8 NTFS = is_ntfs(MountPoint);
	u8 exFAT = is_exFAT(MountPoint);
	
	switch(format)
	{
		case FM_FORMAT_EMPTY:
		{
			return NULL;
			break;
		}
		case FM_FORMAT_MEMORY:
		{
			char *Total_str = get_unit(DeviceInfo.TotalSpace);
			char *Free_str = get_unit(DeviceInfo.FreeSpace);
			sprintf(Row, "%s %s %s", Free_str, STR_FREEOF, Total_str);
			free(Total_str);
			free(Free_str);
			
			break;
		}
		case FM_FORMAT_FILESYSTEM:
		{
			int t;
			if( NTFS ) sscanf(MountPoint, "ntfs%d" , &t);
			if( exFAT ) t = exFAT_get_idx(MountPoint);
					
			if( strncmp(DeviceInfo.FileSystem, "CELL_FS_", 8) == 0) {
				if( NTFS || exFAT ) sprintf(Row, "%s (%d)", &DeviceInfo.FileSystem[8], t);
				else strcpy(Row, &DeviceInfo.FileSystem[8]);
			} else {
				if( NTFS || exFAT ) sprintf(Row, "%s (%d)", DeviceInfo.FileSystem, t);
				else strcpy(Row, DeviceInfo.FileSystem);
			}
			break;
		}
		case FM_FORMAT_LABEL:
		{
			if(DeviceInfo.Label[0] != 0) {
				strcpy(Row, DeviceInfo.Label);
			} else {
				strcpy(Row, MountPoint);
			}
			break;
		}
		case FM_FORMAT_DEVICE:
		{
			if( NTFS ) {
				sprintf(Row, "dev_usb%03d", NTFS_Test_Device(MountPoint));
			} else
			if( exFAT ) {
				sprintf(Row, "dev_usb%03d", exFAT_get_idx(MountPoint));
			} 
			else {
				strcpy(Row, MountPoint);
			}
			break;
		}
		case FM_FORMAT_DEVICE_MOUNTPOINT:
		{
			if( NTFS ) {
				sprintf(Row, "dev_usb%03d:%s", NTFS_Test_Device(MountPoint), MountPoint);
			} else
			if( exFAT ) {
				sprintf(Row, "dev_usb%03d;%s", exFAT_get_idx(MountPoint), MountPoint);
			} 
			else {
				strcpy(Row, MountPoint);
			}
			break;
		}
		case FM_FORMAT_LABEL_MOUNTPOINT:
		{
			if(DeviceInfo.Label[0] != 0) {
				sprintf(Row, "%s (%s)", DeviceInfo.Label, MountPoint);
			} else {
				strcpy(Row, MountPoint);
			}
			break;
		}
		case FM_FORMAT_LABEL_DEVICE_MOUNTPOINT:
		{
			if(DeviceInfo.Label[0] != 0) {
				if( NTFS ) {
					sprintf(Row, "%s (dev_usb%03d:%s)", DeviceInfo.Label, NTFS_Test_Device(MountPoint), MountPoint);
				} else
				if( exFAT ) {
					sprintf(Row, "%s (dev_usb%03d:%s)", DeviceInfo.Label, exFAT_get_idx(MountPoint), MountPoint);
				} 
				else {
					sprintf(Row, "%s (%s)", DeviceInfo.Label, MountPoint);
				}
			}
			else {
				if( NTFS ) {
					sprintf(Row, "dev_usb%03d:%s", NTFS_Test_Device(MountPoint), MountPoint);
				} else
				if( exFAT ) {
					sprintf(Row, "dev_usb%03d:%s", exFAT_get_idx(MountPoint), MountPoint);
				} else
				{
					strcpy(Row, MountPoint);
				}
			}
			break;
		}
		case FM_FORMAT_MOUNTPOINT:
		default:
		{
			strcpy(Row, MountPoint);
			break;
		}
	}
	
	return strcpy_malloc(Row);
}

u8 FM_GetFormat(char *str)
{
	if(str[0]==0) return FM_FORMAT_INIT;
	
	if( strcmp(str, STR_FM_EMPTY) == 0) {
		return FM_FORMAT_EMPTY;
	} else
	if( strcmp(str, STR_FM_MOUNTPOINT) == 0) {
		return FM_FORMAT_MOUNTPOINT;
	} else
	if( strcmp(str, STR_FM_FILESYSTEM) == 0) {
		return FM_FORMAT_FILESYSTEM;
	} else
	if( strcmp(str, STR_FM_MEMORY) == 0) {
		return FM_FORMAT_MEMORY;
	} else
	if( strcmp(str, STR_FM_LABEL) == 0) {
		return FM_FORMAT_LABEL;
	} else
	if( strcmp(str, STR_FM_CAPACITY) == 0) {
		return FM_FORMAT_CAPACITY;
	} else
	if( strcmp(str, STR_FM_DEVICE) == 0) {
		return FM_FORMAT_DEVICE;
	} else {
		char format[255];
		sprintf(format, "%s + %s", STR_FM_CAPACITY, STR_FM_MEMINSIDE);
		if( strcmp(str, format) == 0 ) return FM_FORMAT_CAPACITY_MEMINSIDE;
		sprintf(format, "%s + %s", STR_FM_CAPACITY, STR_FM_MEMOUTSIDE);
		if( strcmp(str, format) == 0 ) return FM_FORMAT_CAPACITY_MEMOUTSIDE;
		sprintf(format, "%s : %s", STR_FM_DEVICE, STR_FM_MOUNTPOINT);
		if( strcmp(str, format) == 0 ) return FM_FORMAT_DEVICE_MOUNTPOINT;
		sprintf(format, "%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT);
		if( strcmp(str, format) == 0 ) return FM_FORMAT_LABEL_MOUNTPOINT;
		sprintf(format, "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT);
		if( strcmp(str, format) == 0 ) return FM_FORMAT_LABEL_DEVICE_MOUNTPOINT;
	}
	
	return FM_FORMAT_MOUNTPOINT;
}


char *FM_SetFormat(u8 format_id)
{
	switch(format_id)
	{
		case FM_FORMAT_EMPTY:
		{
			return strcpy_malloc(STR_FM_EMPTY);
		}
		break;
		case FM_FORMAT_MOUNTPOINT:
		{
			return strcpy_malloc(STR_FM_MOUNTPOINT);
		}
		break;
		case FM_FORMAT_FILESYSTEM:
		{
			return strcpy_malloc(STR_FM_FILESYSTEM);
		}
		break;
		case FM_FORMAT_MEMORY:
		{
			return strcpy_malloc(STR_FM_MEMORY);
		}
		break;
		case FM_FORMAT_LABEL:
		{
			return strcpy_malloc(STR_FM_LABEL);
		}
		break;
		case FM_FORMAT_CAPACITY:
		{
			return strcpy_malloc(STR_FM_CAPACITY);
		}
		break;
		case FM_FORMAT_DEVICE:
		{
			return strcpy_malloc(STR_FM_DEVICE);
		}
		break;
		case FM_FORMAT_CAPACITY_MEMINSIDE:
		{
			return sprintf_malloc("%s + %s", STR_FM_CAPACITY, STR_FM_MEMINSIDE);
		}
		break;
		case FM_FORMAT_CAPACITY_MEMOUTSIDE:
		{
			return sprintf_malloc("%s + %s", STR_FM_CAPACITY, STR_FM_MEMOUTSIDE);
		}
		break;
		case FM_FORMAT_DEVICE_MOUNTPOINT:
		{
			return sprintf_malloc("%s : %s", STR_FM_DEVICE, STR_FM_MOUNTPOINT);
		}
		break;
		case FM_FORMAT_LABEL_MOUNTPOINT:
		{
			return sprintf_malloc("%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT);
		}
		break;
		case FM_FORMAT_LABEL_DEVICE_MOUNTPOINT:
		{
			return sprintf_malloc("%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT);
		}
		break;
		default:
		{
			return strcpy_malloc(STR_FM_MOUNTPOINT);
		}
		break;
	}
	
	return NULL;
}

u8 FM_GetFormatPosition(int row)
{
	int i;
	for(i=0; i<=ITEMS_VALUE_NUMBER[ITEMS_NUMBER]; i++) {
		if( strcmp( ITEMS_VALUE[ITEMS_NUMBER][i], fm_Format[row] ) == 0) return i;
	}
	return 0;
}

void init_SETTINGS()
{
	int i;
	
	init_MENU();
	
// GLOBAL SETTINGS
	add_title_MENU(STR_GLOB_SETTINGS);
	
	add_item_MENU(STR_ADJUST, ITEM_TEXTBOX);
	
#ifndef FILEMANAGER
	add_item_MENU(STR_DL_COVER, ITEM_TEXTBOX);
#endif

	add_item_MENU(STR_PLUGIN_MANAGER, ITEM_TEXTBOX);
	
#ifndef FILEMANAGER
	//add_item_MENU(STR_UPD_MGZ, ITEM_TEXTBOX);
	add_item_MENU(STR_GAME_PATHS, ITEM_TEXTBOX);
	for(i=0; i <= scan_dir_number; i++) {
		add_item_value_MENU(scan_dir[i]);
	}
#endif

	add_item_MENU(STR_LANG, ITEM_TEXTBOX);
	for(i=0; i < lang_N ;i++) {
		add_item_value_MENU(STR_LANGUAGE[i]);
	}
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = lang;
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	
	add_item_MENU(STR_OVERWRITE, ITEM_TEXTBOX);
	add_item_value_MENU(STR_OVERWRITE_ALWAYS);
	add_item_value_MENU(STR_OVERWRITE_NEVER);
	add_item_value_MENU(STR_OVERWRITE_ASK);
	add_item_value_MENU(STR_OVERWRITE_DUPLICATE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = OVERWRITE;
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	
	add_item_MENU(STR_XMB_PRIO, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = XMB_priority;
	
	add_item_MENU(STR_SHOWLOGS, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = SHOW_LOG;
	
	add_item_MENU(STR_HELP, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Show_Help;

// UI SETTINGS
#ifndef FILEMANAGER
	add_title_MENU(STR_UI_SETTINGS);
	
	add_item_MENU(STR_UI, ITEM_TEXTBOX);
	for(i=0; i < 4; i++) {
		add_item_value_MENU(UI[i]);
	}
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = UI_position;
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	
	add_item_MENU(STR_SIDE_MENU, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Use_SideMenu;
	
	add_item_MENU(STR_SHOW_PIC1, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Show_PIC1;
	
	if(UI_position==LIST) {
		add_item_MENU(STR_SHOW_ICON0, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Show_ICON0;
	} else
	if(UI_position==GRID) {
		add_item_MENU(STR_GRID_TYPE, ITEM_TEXTBOX);
		add_item_value_MENU(STR_GRID_SCROLL);
		add_item_value_MENU(STR_PAGE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = GRID_TYPE;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		
		add_item_MENU(STR_DIRECTION, ITEM_TEXTBOX);
		add_item_value_MENU(STR_VERTICAL);
		add_item_value_MENU(STR_HORIZONTAL);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = GRID_DIRECTION;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		
		add_item_MENU(STR_ANIMATED, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = GRID_ANIMATED;
		
		add_item_MENU(STR_KEEP_PROP, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = GRID_KEEP_PROP;
		
		add_item_MENU(STR_NB_COL, ITEM_TEXTBOX);
		for(i=0; i < 16; i++) {
			char tmp[3];
			sprintf(tmp, "%d", i);
			add_item_value_MENU(tmp);
		}
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = GRID_NB_COLUMNS;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		
		if(GRID_KEEP_PROP==NO) {
			add_item_MENU(STR_NB_LINE, ITEM_TEXTBOX);
			for(i=0; i < 16; i++) {
				char tmp[3];
				sprintf(tmp, "%d", i);
				add_item_value_MENU(tmp);
			}
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = GRID_NB_LINES;
			ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		}
	} else
	if(UI_position==FLOW) {
		add_item_MENU(STR_INVERSE, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FLOW_inverse_button;
		
		add_item_MENU(STR_3D, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FLOW_3D;
	}
	
	if((UI_position==FLOW && FLOW_3D == NO)
	||	UI_position==XMB
	||  UI_position==LIST ) 
	{
		add_item_MENU(STR_SHOW_COVER, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Show_COVER;
		
		if(Show_COVER==YES) {
			add_item_MENU(STR_SHOW_GAMECASE, ITEM_TOGGLE);
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Show_GameCase;
		}
	}
	
	if(UI_position==FLOW || UI_position==XMB) {
		add_item_MENU(STR_SHOW_WAVES, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Show_Waves;
	}
	
	if(UI_position==FLOW && FLOW_3D) {
		add_item_MENU(STR_BOX3D_ALIGN, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = BOX3D_ALIGN;
		
		add_item_MENU(STR_BOX3D_GAP, ITEM_TEXTBOX);
		add_item_value_MENU(STR_NONE);
		add_item_value_MENU(STR_SHORT);
		add_item_value_MENU(STR_MEDIUM);
		add_item_value_MENU(STR_LONG);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = BOX3D_GAP;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	}
#endif
	
// THEME SETTINGS	
	add_title_MENU(STR_THM_SETTINGS);
	
	add_item_MENU(STR_THM, ITEM_TEXTBOX);
	for(i=0; i <= Themes_number[UI_position]; i++) {
		add_item_value_MENU(Themes_Names_list[UI_position][i]);
	}
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = Themes_position[UI_position];
	
	add_item_MENU(STR_CURRENT, ITEM_LOCKED);
	add_item_value_MENU(Themes[UI_position]);
	
	FILE *f;
	char ColorSetPath[128];
	sprintf(ColorSetPath, "/dev_hdd0/game/%s/USRDIR/GUI/colorset.ini",  ManaGunZ_id);
	f = fopen(ColorSetPath, "r");
	if(f!=NULL) {
		char *ColorSetName = NextColorSetName(f);
		if(ColorSetName) {
			add_item_MENU(STR_COLORSET, ITEM_TEXTBOX);

			add_item_value_MENU(ColorSetName);
			FREE(ColorSetName);
			
			while((ColorSetName=NextColorSetName(f)) != NULL ) {
				add_item_value_MENU(ColorSetName);
				FREE(ColorSetName);
			}
			if(ITEMS_VALUE_NUMBER[ITEMS_NUMBER] < ITEMS_VALUE_POSITION[ITEMS_NUMBER]) ITEMS_VALUE_POSITION[ITEMS_NUMBER]=0;
		}
		fclose(f);
	}
	
	add_item_MENU(STR_CURRENT, ITEM_LOCKED);
	char *CurColSet = GetCurrentColorSet();
	add_item_value_MENU(CurColSet);
	FREE(CurColSet);
	
	add_item_MENU(STR_FONT, ITEM_TEXTBOX);
	for(i=0; i<=FontNumber; i++) {
		add_item_value_MENU(FontName[i]);
		if(strcmp(Font, FontPath[i]) == 0) ITEMS_VALUE_POSITION[ITEMS_NUMBER]=i;
	}
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	
	add_item_MENU(STR_COLOR_1, ITEM_COLORBOX);
	FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
	ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
	memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_1, 4);
	
	add_item_MENU(STR_COLOR_2, ITEM_COLORBOX);
	FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
	ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
	memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_2, 4);
	
	add_item_MENU(STR_COLOR_3, ITEM_COLORBOX);
	FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
	ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
	memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_3, 4);

	add_item_MENU(STR_COLOR_4, ITEM_COLORBOX);
	FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
	ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
	memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_4, 4);	
	
	if(UI_position==FLOW || UI_position==XMB) {
		if(Show_Waves) {
			add_item_MENU(STR_WAVES_COLOR, ITEM_COLORBOX);
			FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
			ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
			memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &WAVES_COLOR, 4);	
		}
	}
	
	if( FILTER_NOTIF || FILTER_BOXHEAD || FILTER_BOXBODY || FILTER_SIDEBAR || FILTER_BGS || FILTER_BG) {	
		add_item_MENU(STR_COLOR_FILTER, ITEM_LOCKED);
	}
	if(FILTER_NOTIF) {
		add_item_MENU(STR_COLOR_NOTIF, ITEM_COLORBOX);
		FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
		ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
		memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_NOTIF, 4);	
	}
	
	if(FILTER_BOXHEAD) {
		add_item_MENU(STR_COLOR_BOXHEAD, ITEM_COLORBOX);
		FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
		ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
		memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_BOXHEAD, 4);	
	}
	
	if(FILTER_BOXBODY) {
		add_item_MENU(STR_COLOR_BOXBODY, ITEM_COLORBOX);
		FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
		ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
		memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_BOXHEAD, 4);
	}
	
	if(FILTER_SIDEBAR) {
		add_item_MENU(STR_COLOR_SIDEBAR, ITEM_COLORBOX);
		FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
		ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
		memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_SIDEBAR, 4);
	}
	
	if(FILTER_BGS) {
		add_item_MENU(STR_COLOR_BGS, ITEM_COLORBOX);
		FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
		ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
		memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_BGS, 4);
	}
	
	if(FILTER_BG) {
		add_item_MENU(STR_COLOR_BG, ITEM_COLORBOX);
		FREE(ITEMS_VALUE[ITEMS_NUMBER][0]);
		ITEMS_VALUE[ITEMS_NUMBER][0] = malloc(4);
		memcpy(ITEMS_VALUE[ITEMS_NUMBER][0], &COLOR_BG, 4);
	}
	
	
// COLOR FILTERS
	add_title_MENU(STR_COLOR_FILTER);
	
	add_item_MENU(STR_COLOR_NOTIF, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FILTER_NOTIF;
#ifndef FILEMANAGER	
	add_item_MENU(STR_COLOR_BOXHEAD, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FILTER_BOXHEAD;
			
	add_item_MENU(STR_COLOR_BOXBODY, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FILTER_BOXBODY;
		
	add_item_MENU(STR_COLOR_SIDEBAR, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FILTER_SIDEBAR;
#endif
	add_item_MENU(STR_COLOR_BGS, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FILTER_BGS;

	add_item_MENU(STR_COLOR_BG, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FILTER_BG;
	
// ROOT DISPLAY

	add_title_MENU(STR_FILEMANAGER);
	
	add_item_MENU(STR_STYLE, ITEM_TEXTBOX);
	add_item_value_MENU(STR_STYLE_CUSTOM);
	add_item_value_MENU(STR_STYLE1);
	add_item_value_MENU(STR_STYLE2);
	add_item_value_MENU(STR_STYLE3);
	add_item_value_MENU(STR_STYLE4);
	add_item_value_MENU(STR_STYLE5);
	add_item_value_MENU(STR_STYLE6);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = root_display;
	ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	
	if(root_display==STYLE_CUSTOM) {
	
		add_item_MENU(STR_FM_ICON, ITEM_TEXTBOX);
		add_item_value_MENU(STR_FM_FILEFOLDER);
		add_item_value_MENU(STR_FM_CUSTOM);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = fm_CustomIcons;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		
		add_item_MENU(STR_FM_ICONSIZE, ITEM_TEXTBOX);
		add_item_value_MENU(STR_FM_SMALL);
		add_item_value_MENU(STR_FM_BIG);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = fm_LineSize;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		
		if( fm_LineSize == BIG ) {
			
		// ********** ROW NUMBER
			add_item_MENU(STR_FM_ROWNUMBER, ITEM_TEXTBOX);
			add_item_value_MENU("1");
			add_item_value_MENU("2");
			add_item_value_MENU("3");
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = fm_RowNumber;
			ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
			
			u8 capacity = NO;
			char tp[128];
			int i, j;
			for(i=0; i<=fm_RowNumber; i++) {
				
		// ********** ROW SIZE
				sprintf(tp, "#%d. %s", i+1, STR_FM_ROWSIZE); add_item_MENU(tp, ITEM_TEXTBOX);
				add_item_value_MENU("0");
				for(j=7; j<=32; j++) {
					sprintf(tp, "%d", j);
					add_item_value_MENU(tp);
				}
				if(fm_FontRowSize[i]==0) ITEMS_VALUE_POSITION[ITEMS_NUMBER]=0;
				else ITEMS_VALUE_POSITION[ITEMS_NUMBER] = fm_FontRowSize[i]-6;
				ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
				
		// ********** LEFT
				sprintf(tp, "#%d. %s", i+1, STR_FM_LEFT_CONTENT); add_item_MENU(tp, ITEM_TEXTBOX);
				
				add_item_value_MENU(STR_FM_EMPTY);	
				add_item_value_MENU(STR_FM_MOUNTPOINT);
				add_item_value_MENU(STR_FM_DEVICE);
				sprintf(tp, "%s : %s", STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
				add_item_value_MENU(STR_FM_LABEL);
				sprintf(tp, "%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
				sprintf(tp, "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
				add_item_value_MENU(STR_FM_FILESYSTEM);
				add_item_value_MENU(STR_FM_MEMORY);
				if(capacity==NO) {
					add_item_value_MENU(STR_FM_CAPACITY); 
					sprintf(tp, "%s + %s", STR_FM_CAPACITY, STR_FM_MEMINSIDE); add_item_value_MENU(tp);
					sprintf(tp, "%s + %s", STR_FM_CAPACITY, STR_FM_MEMOUTSIDE); add_item_value_MENU(tp);
				}
							
				ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FM_GetFormatPosition(i*2);
				ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
									
				if( strncmp(ITEMS_VALUE[ITEMS_NUMBER][ITEMS_VALUE_POSITION[ITEMS_NUMBER]], STR_FM_CAPACITY, strlen(STR_FM_CAPACITY)) == 0) {
					capacity = YES;
					
		// ********* CAPACITY WIDTH
					add_item_MENU(STR_FM_CB_WIDTH, ITEM_TEXTBOX);
					add_item_value_MENU(STR_FM_CB_FILL);
					for(j=0; j<=20; j++) {
						sprintf(tp, "%d", 10*j+200);
						add_item_value_MENU(tp);
					}
					
					if(fm_CapacityBarWidth != 0) ITEMS_VALUE_POSITION[ITEMS_NUMBER] = (fm_CapacityBarWidth - 200)/10 + 1;
					else ITEMS_VALUE_POSITION[ITEMS_NUMBER] = fm_CapacityBarWidth;
					ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
				}
				else {
		// ********** RIGHT	
					sprintf(tp, "#%d. %s", i+1, STR_FM_RIGHT_CONTENT); add_item_MENU(tp, ITEM_TEXTBOX);
					
					add_item_value_MENU(STR_FM_EMPTY);
					add_item_value_MENU(STR_FM_MOUNTPOINT);
					add_item_value_MENU(STR_FM_DEVICE);
					sprintf(tp, "%s : %s", STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
					add_item_value_MENU(STR_FM_LABEL);
					sprintf(tp, "%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
					sprintf(tp, "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
					add_item_value_MENU(STR_FM_FILESYSTEM);
					add_item_value_MENU(STR_FM_MEMORY);
					
					ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FM_GetFormatPosition(i*2+1);
					ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
				}	
			}
		}
		else {
			
			char tp[128];
	// ************* LEFT
			add_item_MENU(STR_FM_LEFT_CONTENT, ITEM_TEXTBOX);
			
			add_item_value_MENU(STR_FM_MOUNTPOINT);
			add_item_value_MENU(STR_FM_DEVICE);	
			sprintf(tp, "%s : %s", STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
			add_item_value_MENU(STR_FM_LABEL);
			sprintf(tp, "%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
			sprintf(tp, "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
			
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FM_GetFormatPosition(0);
			ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
			
	// ************ RIGHT
			add_item_MENU(STR_FM_RIGHT_CONTENT, ITEM_TEXTBOX);
					
			add_item_value_MENU(STR_FM_EMPTY);
			add_item_value_MENU(STR_FM_MOUNTPOINT);
			add_item_value_MENU(STR_FM_DEVICE);
			sprintf(tp, "%s : %s", STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
			add_item_value_MENU(STR_FM_LABEL);
			sprintf(tp, "%s (%s)", STR_FM_LABEL, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
			sprintf(tp, "%s (%s : %s)", STR_FM_LABEL, STR_FM_DEVICE, STR_FM_MOUNTPOINT); add_item_value_MENU(tp);
			add_item_value_MENU(STR_FM_FILESYSTEM);
			add_item_value_MENU(STR_FM_MEMORY);
			
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = FM_GetFormatPosition(1);
			ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		}
	}
	else { // NOT CUSTOM STYLE
		
		add_item_MENU(STR_FM_ICON, ITEM_LOCKED);
		if(fm_CustomIcons==NO ) add_item_value_MENU(STR_FM_FILEFOLDER);
		if(fm_CustomIcons==YES) add_item_value_MENU(STR_FM_CUSTOM);
				
		add_item_MENU(STR_FM_ICONSIZE, ITEM_LOCKED);
		if(fm_LineSize==SMALL) add_item_value_MENU(STR_FM_SMALL);
		if(fm_LineSize==BIG) add_item_value_MENU(STR_FM_BIG);
		
		
		if( fm_LineSize == BIG ) {
			char tp[128];
			
		// ********** ROW NUMBER
			add_item_MENU(STR_FM_ROWNUMBER, ITEM_LOCKED);
			
			sprintf(tp, "%d", fm_RowNumber+1); add_item_value_MENU(tp);
			
			u8 capacity = NO;
			
			int i;
			for(i=0; i<=fm_RowNumber; i++) {
				
		// ********** ROW SIZE
				sprintf(tp, "#%d. %s", i+1, STR_FM_ROWSIZE); add_item_MENU(tp, ITEM_LOCKED);
				sprintf(tp, "%d", fm_FontRowSize[i]); add_item_value_MENU(tp);
				
				
		// ********** LEFT
				sprintf(tp, "#%d. %s", i+1, STR_FM_LEFT_CONTENT); add_item_MENU(tp, ITEM_LOCKED);
				add_item_value_MENU(fm_Format[ LEFTROW(i) ]);
				
									
				if( strncmp(ITEMS_VALUE[ITEMS_NUMBER][ITEMS_VALUE_POSITION[ITEMS_NUMBER]], STR_FM_CAPACITY, strlen(STR_FM_CAPACITY)) == 0) {
					capacity = YES;
					
		// ********* CAPACITY WIDTH
					add_item_MENU(STR_FM_CB_WIDTH, ITEM_LOCKED);
					if(fm_CapacityBarWidth==0) add_item_value_MENU(STR_FM_CB_FILL);
					else {
						sprintf(tp, "%d", (int) fm_CapacityBarWidth); 
						add_item_value_MENU(tp);
					}
				}
				else {
		// ********** RIGHT	
					sprintf(tp, "#%d. %s", i+1, STR_FM_RIGHT_CONTENT); add_item_MENU(tp, ITEM_LOCKED);
					add_item_value_MENU(fm_Format[ RIGHTROW(i) ]);
				}	
			}
		}
		else {
			
	// ************* LEFT
			add_item_MENU(STR_FM_LEFT_CONTENT, ITEM_LOCKED);
			add_item_value_MENU(fm_Format[ LEFTROW(0) ]);
			
	// ************ RIGHT
			add_item_MENU(STR_FM_RIGHT_CONTENT, ITEM_LOCKED);
			add_item_value_MENU(fm_Format[ RIGHTROW(0) ]);
		}
	}
	
	add_title_MENU(STR_DUMP_OPTION);
	
	add_item_MENU(STR_IGNORE_ERR, ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = IGNORE_ERR;
	if( !HEN ) {
		add_item_MENU(STR_3K3Y_HEADER, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = with_3k3y_header;
		add_item_MENU(STR_UPLOADER, ITEM_TEXTBOX);
		if( UPLOADER[0] == 0 ) {
			add_item_value_MENU(STR_NONE);
		} else {
			add_item_value_MENU(UPLOADER);	
		}
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = 0;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
		add_item_MENU(STR_DUMPER_MAX_TRY, ITEM_TEXTBOX);
		add_item_value_MENU("0");
		add_item_value_MENU("10");
		add_item_value_MENU("20");
		add_item_value_MENU("30");
		
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = DUMPER_MAX_TRY / 10 ;
		ITEMS_VALUE_SHOW[ITEMS_NUMBER] = YES;
	}
	
	add_title_MENU(STR_SYSTEM_TOOLS);
	
	if( PEEKnPOKE ) {
		if( !HEN ) add_item_MENU(STR_DUMP_LV1, ITEM_TEXTBOX);
		add_item_MENU(STR_DUMP_LV2, ITEM_TEXTBOX);
	}
	
	add_item_MENU(STR_DUMP_FLASH, ITEM_TEXTBOX);
	
	add_item_MENU(STR_FIX_PERMS, ITEM_TEXTBOX);
	
	if( PEEKnPOKE ) {
		if( ERK_DUMPER_SIZE != 0 ) {
			add_item_MENU(STR_DUMP_ERK, ITEM_TEXTBOX);
			add_item_MENU(STR_DUMP_3DUMP, ITEM_TEXTBOX);
		}
		add_item_MENU(STR_DYNAREC, ITEM_TOGGLE);
		ITEMS_VALUE_POSITION[ITEMS_NUMBER] = HaveDynarec();
		
		if( UFS_SB_ADDR ) {
			add_item_MENU(STR_HDD_UNLOCK_SPACE, ITEM_TOGGLE);
			ITEMS_VALUE_POSITION[ITEMS_NUMBER] = hdd0_is_unlocked();
		}
	}
	
	add_item_MENU("MGZ log", ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = LOG;
	
	add_item_MENU("MGZ debug", ITEM_TOGGLE);
	ITEMS_VALUE_POSITION[ITEMS_NUMBER] = DEBUG;
}

void update_SETTINGS()
{
	if( item_title_is(STR_GLOB_SETTINGS)){
		if(item_is(STR_LANG)) {
			lang = ITEMS_VALUE_POSITION[ITEMS_POSITION];
			lang_code = LANGCODE[lang];
			if(lang_code != lang_code_loaded) {
				start_loading();
				print_load("Loading language : %s", STR_LANGUAGE[lang]);
				update_lang();
				update_RootDisplay();
				init_SETTINGS();
				end_loading();
			}
		} else
		if(item_is(STR_HELP)) {
			Show_Help = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_XMB_PRIO)) {
			XMB_priority = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_OVERWRITE)) {
			OVERWRITE = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_SHOWLOGS)) {
			SHOW_LOG = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		}
	} else 
	if( item_title_is(STR_UI_SETTINGS)){
		if(item_is(STR_UI)) {
			if( UI_position != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				UI_position = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				init_SETTINGS();
			}
		} else
		if(item_is(STR_SIDE_MENU)) {
			Use_SideMenu = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_SHOW_PIC1)) {
			Show_PIC1 = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_SHOW_COVER)) {
			if( Show_COVER != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				Show_COVER = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				init_SETTINGS();
			}
		} else 
		if(item_is(STR_SHOW_GAMECASE)) {
			Show_GameCase = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_SHOW_WAVES)) {
			if( Show_Waves != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				Show_Waves = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				init_SETTINGS();
			}
		} else 
		if(item_is(STR_SHOW_ICON0)) {
			Show_ICON0 = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_GRID_TYPE)) {
			GRID_TYPE = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_DIRECTION)) {
			GRID_DIRECTION = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_ANIMATED)) {
			GRID_ANIMATED = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_KEEP_PROP)) {
			if( GRID_KEEP_PROP != ITEMS_VALUE_POSITION[ITEMS_POSITION] ) {
				GRID_KEEP_PROP = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				init_SETTINGS();
			}
		} else
		if(item_is(STR_NB_COL)) {
			GRID_NB_COLUMNS = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(item_is(STR_NB_LINE)) {
			GRID_NB_LINES = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_INVERSE)) {
			FLOW_inverse_button = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_3D)) {
			if( FLOW_3D != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FLOW_3D = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				init_SETTINGS();
			}
		} else
		if(item_is(STR_BOX3D_ALIGN)) {
			BOX3D_ALIGN = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_BOX3D_GAP)) {
			BOX3D_GAP = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} 
	} else 
	if( item_title_is(STR_THM_SETTINGS)){
		if(item_is(STR_THM)) {
			Themes_position[UI_position] = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_FONT)) {
			if(strcmp(Font, FontPath[ITEMS_VALUE_POSITION[ITEMS_POSITION]]) != 0) {
				if(Load_GAMEPIC_busy) show_msg("Try Later");
				else {
					//start_loading();
					strcpy(Font, FontPath[ITEMS_VALUE_POSITION[ITEMS_POSITION]]);				
					LoadFont();
					//end_loading();
				}
			}
		}
		
	} else
	if( item_title_is(STR_COLOR_FILTER)){
		if(item_is(STR_COLOR_NOTIF) && ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {
			if(FILTER_NOTIF != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FILTER_NOTIF = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				ReloadTheme(NOTIF);
				// J'ajoute ou je retire une option pour changer la couleur avant (theme) donc la position actuelle change aussi.
				if(FILTER_NOTIF) ITEMS_POSITION++;
				else ITEMS_POSITION--;
				init_SETTINGS();
			}
		} else
		if(item_is(STR_COLOR_BOXHEAD) && ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {
			if(FILTER_BOXHEAD != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FILTER_BOXHEAD = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				ReloadTheme(BOXHEAD);
				// J'ajoute ou je retire une option pour changer la couleur avant (theme) donc la position actuelle change aussi.
				if(FILTER_BOXHEAD) ITEMS_POSITION++;
				else ITEMS_POSITION--;
				init_SETTINGS();
			}
		} else 
		if(item_is(STR_COLOR_BOXBODY) && ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {
			if(FILTER_BOXBODY != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FILTER_BOXBODY = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				ReloadTheme(BOXBODY);
				// J'ajoute ou je retire une option pour changer la couleur avant (theme) donc la position actuelle change aussi.
				if(FILTER_BOXBODY) ITEMS_POSITION++;
				else ITEMS_POSITION--;
				init_SETTINGS();
			}	
		} else 
		if(item_is(STR_COLOR_SIDEBAR) && ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {
			if(FILTER_SIDEBAR != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FILTER_SIDEBAR = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				ReloadTheme(SIDEBAR);
				// J'ajoute ou je retire une option pour changer la couleur avant (theme) donc la position actuelle change aussi.
				if(FILTER_SIDEBAR) ITEMS_POSITION++;
				else ITEMS_POSITION--;
				init_SETTINGS();
			}
		} else 
		if(item_is(STR_COLOR_BGS) && ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {
			if(FILTER_BGS != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FILTER_BGS = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				ReloadTheme(BGS);
				// J'ajoute ou je retire une option pour changer la couleur avant (theme) donc la position actuelle change aussi.
				if(FILTER_BGS) ITEMS_POSITION++;
				else ITEMS_POSITION--;
				init_SETTINGS();
			}
		} else 
		if(item_is(STR_COLOR_BG) && ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {
			if(FILTER_BG != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				FILTER_BG = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				ReloadTheme(_BG_);
				// J'ajoute ou je retire une option pour changer la couleur avant (theme) donc la position actuelle change aussi.
				if(FILTER_BG) ITEMS_POSITION++;
				else ITEMS_POSITION--;
				init_SETTINGS();
			}	
		}
	} else 
	if( item_title_is(STR_FILEMANAGER)){
		if(item_is(STR_STYLE)) {
			if( root_display != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
				root_display = ITEMS_VALUE_POSITION[ITEMS_POSITION];
				update_RootDisplay();
				Window(".");
				init_SETTINGS();
			}
		} else
		if(root_display == STYLE_CUSTOM) {
			if(item_is(STR_FM_ICONSIZE)) {
				if( fm_LineSize != ITEMS_VALUE_POSITION[ITEMS_POSITION]) {
					fm_LineSize = ITEMS_VALUE_POSITION[ITEMS_POSITION];
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else
			if(item_is(STR_FM_ROWNUMBER)) {
				if( fm_RowNumber != ITEMS_VALUE_POSITION[ITEMS_POSITION] ) {
					fm_RowNumber = ITEMS_VALUE_POSITION[ITEMS_POSITION];
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else
			if(item_is(STR_FM_ICON)) {
				if( fm_CustomIcons != ITEMS_VALUE_POSITION[ITEMS_POSITION] ) {
					fm_CustomIcons = ITEMS_VALUE_POSITION[ITEMS_POSITION];
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else
			if(item_is(STR_FM_CB_WIDTH)) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] != 0) {
					if( fm_CapacityBarWidth != 200 + (ITEMS_VALUE_POSITION[ITEMS_POSITION]-1)*10 ) {
						fm_CapacityBarWidth = 200 + (ITEMS_VALUE_POSITION[ITEMS_POSITION]-1)*10;
						write_RootSetting();
						init_SETTINGS();
						Window(".");
					}
				} else {
					if( fm_CapacityBarWidth != 0 ) {
						fm_CapacityBarWidth = 0;
						write_RootSetting();
						init_SETTINGS();
						Window(".");
					}
				}
			} else
			if( strcmp(STR_FM_ROWSIZE, &ITEMS[ITEMS_POSITION][4]) == 0) {
				int row=0;
				sscanf(ITEMS[ITEMS_POSITION], "#%d", &row); row--;
				
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) {
					if( fm_FontRowSize[row] != 0 ) {
						fm_FontRowSize[row]=0;
						write_RootSetting();
						init_SETTINGS();
						Window(".");
					}
				} else 
				if( fm_FontRowSize[row] != ITEMS_VALUE_POSITION[ITEMS_POSITION] + 6) {
					fm_FontRowSize[row] = ITEMS_VALUE_POSITION[ITEMS_POSITION] + 6;
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else 
			if( strcmp(STR_FM_LEFT_CONTENT, &ITEMS[ITEMS_POSITION][4]) == 0) {
				int row=0;
				sscanf(ITEMS[ITEMS_POSITION], "#%d", &row); row--;
				if( strcmp(fm_Format[row*2], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]) != 0) {
					memset(fm_Format[row*2], 0, sizeof(fm_Format[row*2]));
					strcpy(fm_Format[row*2], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else
			if(item_is(STR_FM_LEFT_CONTENT)) {
				if( strcmp(fm_Format[0], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]) != 0) {
					memset(fm_Format[0], 0, sizeof(fm_Format[0]));
					strcpy(fm_Format[0], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else 
			if( strcmp(STR_FM_RIGHT_CONTENT, &ITEMS[ITEMS_POSITION][4]) == 0) {
				int row=0;
				sscanf(ITEMS[ITEMS_POSITION], "#%d", &row); row--;
				if( strcmp(fm_Format[row*2+1], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]) != 0) {
					memset(fm_Format[row*2+1], 0, sizeof(fm_Format[row*2+1]));
					strcpy(fm_Format[row*2+1], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			} else
			if(item_is(STR_FM_RIGHT_CONTENT)) {
				if( strcmp(fm_Format[1], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]) != 0) {
					memset(fm_Format[1], 0, sizeof(fm_Format[1]));
					strcpy(fm_Format[1], ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
					write_RootSetting();
					init_SETTINGS();
					Window(".");
				}
			}
		}
	} else
	if( item_title_is(STR_DUMP_OPTION)){
		if(item_is(STR_3K3Y_HEADER)) {
			with_3k3y_header = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_IGNORE_ERR)) {
			IGNORE_ERR = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is(STR_DUMPER_MAX_TRY)) {
			DUMPER_MAX_TRY = ITEMS_VALUE_POSITION[ITEMS_POSITION] * 10;
		}
	} else
	if( item_title_is(STR_SYSTEM_TOOLS)){
		if(item_is(STR_DYNAREC)) {
			if( ITEMS_VALUE_POSITION[ITEMS_POSITION] != HaveDynarec() ) {
				if( ITEMS_VALUE_POSITION[ITEMS_POSITION] == YES ) {
					InstallDynarec();
				} else {
					RemoveDynarec();
				}
			}
		} else
		if(item_is(STR_HDD_UNLOCK_SPACE)) {
			if( ITEMS_VALUE_POSITION[ITEMS_POSITION] != hdd0_is_unlocked() ) {
				hdd0_unlock(ITEMS_VALUE_POSITION[ITEMS_POSITION]);
			}
		} else
		if(item_is("MGZ log")) {
			LOG = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else
		if(item_is("MGZ debug")) {
			DEBUG = ITEMS_VALUE_POSITION[ITEMS_POSITION];
		}
	}
}

u8 SETTING_R1()
{
	if( item_title_is(STR_COLOR_FILTER)){
		if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_TOGGLE) {	
			if(item_is(STR_SHOW_WAVES) && Show_Waves) {
				Draw_ChooseColor(FLAG_WAVES_COLOR);
			} else
			if(item_is(STR_COLOR_NOTIF) && FILTER_NOTIF) {
				Draw_ChooseColor(FLAG_COLOR_NOTIF);
			} else
			if(item_is(STR_COLOR_BOXHEAD) && FILTER_BOXHEAD) {
				Draw_ChooseColor(FLAG_COLOR_BOXHEAD);
			} else
			if(item_is(STR_COLOR_BOXBODY) && FILTER_BOXBODY) {
				Draw_ChooseColor(FLAG_COLOR_BOXBODY);
			} else
			if(item_is(STR_COLOR_SIDEBAR) && FILTER_SIDEBAR) {
				Draw_ChooseColor(FLAG_COLOR_SIDEBAR);
			} else
			if(item_is(STR_COLOR_BGS) && FILTER_BGS) {
				Draw_ChooseColor(FLAG_COLOR_BGS);
			} else
			if(item_is(STR_COLOR_BG) && FILTER_BG) {
				Draw_ChooseColor(FLAG_COLOR_BG);
			}
		}
	}
	
	return SUCCESS;
}

u8 SETTINGS_CROSS()
{
	if(item_is(STR_FIX_PERMS)) {
		start_loading();
		print_head("Fixing file permissions to /dev_hdd0");
		SetPerms("/dev_hdd0");
		end_loading();
	} else
	if(item_is(STR_DUMP_LV1)) {
		start_loading();
		dump_lv1("/dev_hdd0");
		end_loading();
	} else 
	if(item_is(STR_DUMP_LV2)) {
		start_loading();
		dump_lv2("/dev_hdd0");
		end_loading();
	} else 
	if(item_is(STR_DUMP_FLASH)) {
		start_loading();
		dump_flash("/dev_hdd0");
		end_loading();
	} else 
	if(item_is(STR_DUMP_ERK)) {
		start_loading();
		mkdir("/dev_hdd0/tmp", 0777);
		u8 ret = dump_eid_root_key(Path_ERK);
		end_loading();
		if( ret == SUCCESS ) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_DUMP_3DUMP)) {
		start_loading();
		u8 ret = dump_3Dump();
		end_loading();
		if( ret == SUCCESS ) show_msg(STR_DONE);
		else show_msg(STR_FAILED);
	} else 
	if(item_is(STR_ADJUST)) {
		Draw_AdjustScreen();
	} else 
	if(item_is(STR_DL_COVER)) {
		start_loading();
		if( 0 < Download_covers() ) init_Load_GAMEPIC();
		end_loading();
	} else 
	if(item_is(STR_GAME_PATHS)) {
		char tmpName[128];
		memset(tmpName, 0, sizeof(tmpName));
		if(Get_OSK_String(STR_NEWFOLDER, tmpName, 128) == SUCCESS) {
			if(tmpName[0]!=0) {
				start_loading();
				scan_dir_number++;
				strcpy(scan_dir[scan_dir_number], tmpName);
				write_scan_dir();
				add_SCANDIR(scan_dir[scan_dir_number]);
				init_Load_GAMEPIC();
				end_loading();
			}
		}
	} else 
	if(item_is(STR_UPLOADER)) {
		char tmpName[0x40];
		memset(tmpName, 0, 0x40);
		if(Get_OSK_String(STR_UPLOADER, tmpName, 0x40) == SUCCESS) {
			if(tmpName[0]!=0) {
				strcpy(UPLOADER, tmpName);
			}
		}
	} else
	if(item_is(STR_PLUGIN_MANAGER)) {
		return open_PLUGINS_MANAGER();
	} else 
	if(item_is(STR_UPD_MGZ)) {
		show_msg("To Fix");
		//update_MGZ();
	} else 
	if(item_is(STR_THM)) {
		if(Load_GAMEPIC_busy) show_msg("Try Later");
		else {
			start_loading();
			print_load("Loading theme...");
			u8 ret = InstallTheme();
			if(ret==SUCCESS) {
				Load_Theme();
				LoadThemeColorSet();
				LoadThemeFont();
				write_setting();
			}
			end_loading();
		}
	} else 
	if(item_is(STR_COLORSET)) {
		start_loading();
		LoadColorSet(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
		end_loading();
	} else
	if(ITEMS_TYPE[ITEMS_POSITION]==ITEM_COLORBOX) {
		if(item_is(STR_COLOR_1)) {
			Draw_ChooseColor(FLAG_COLOR_1);
		} else 
		if(item_is(STR_COLOR_2)) {
			Draw_ChooseColor(FLAG_COLOR_2);
		} else 
		if(item_is(STR_COLOR_3)) {
			Draw_ChooseColor(FLAG_COLOR_3);
		} else 
		if(item_is(STR_COLOR_4)) {
			Draw_ChooseColor(FLAG_COLOR_4);
		} else
		if(item_is(STR_WAVES_COLOR) && Show_Waves) {
			Draw_ChooseColor(FLAG_WAVES_COLOR);
		} else
		if(item_is(STR_COLOR_NOTIF) && FILTER_NOTIF) {
			Draw_ChooseColor(FLAG_COLOR_NOTIF);
		} else
		if(item_is(STR_COLOR_BOXHEAD) && FILTER_BOXHEAD) {
			Draw_ChooseColor(FLAG_COLOR_BOXHEAD);
		} else
		if(item_is(STR_COLOR_BOXBODY) && FILTER_BOXBODY) {
			Draw_ChooseColor(FLAG_COLOR_BOXBODY);
		} else
		if(item_is(STR_COLOR_SIDEBAR) && FILTER_SIDEBAR) {
			Draw_ChooseColor(FLAG_COLOR_SIDEBAR);
		} else
		if(item_is(STR_COLOR_BGS) && FILTER_BGS) {
			Draw_ChooseColor(FLAG_COLOR_BGS);
		} else
		if(item_is(STR_COLOR_BG) && FILTER_BG) {
			Draw_ChooseColor(FLAG_COLOR_BG);
		}
	} else 
		return CONTINUE;
	
	update_SETTINGS();
	init_SETTINGS();
	
	return CONTINUE;
}

u8 SETTINGS_SQUARE()
{
	if(item_is(STR_COLOR_1)) {
		COLOR_1 = WHITE;
	} else 
	if(item_is(STR_COLOR_2)) {
		COLOR_2 = GREEN;
	} else 
	if(item_is(STR_COLOR_3)) {
		COLOR_3 = ORANGE;
	} else 
	if(item_is(STR_COLOR_4)) {
		COLOR_4 = RED;
	} else 
	if(item_is(STR_WAVES_COLOR)) {
		WAVES_COLOR = WHITE-0xFF+0x20;
	} else
	if(item_is(STR_UPLOADER)) {
		memset(UPLOADER, 0, 0x40);
	} else
	if(item_is(STR_DUMPER_MAX_TRY)) {
		DUMPER_MAX_TRY = 30;
	} else 
	if(item_is(STR_THM)) {
		u8 ThemeType = GetThemeType(Themes_Paths_list[UI_position][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
		if(ThemeType == MGZ) {
			char tmpName[128];
			strcpy(tmpName, Themes_Names_list[UI_position][Themes_position[UI_position]]);
			if(Get_OSK_String(STR_RENAME, tmpName, 128) == SUCCESS) {
				char old[128], new[128];
				sprintf(old, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], Themes_Names_list[UI_position][Themes_position[UI_position]]);
				sprintf(new, "/dev_hdd0/game/%s/USRDIR/GUI/%s/%s", ManaGunZ_id, UI[UI_position], tmpName);
				if( rename(old, new) == 0 ) {
					strcpy(Themes_Names_list[UI_position][Themes_position[UI_position]], tmpName);
					show_msg(STR_DONE);
				} else show_msg(STR_FAILED);	
			}	
		}
	} else 
	if(strcmp(ITEMS[ITEMS_POSITION], STR_GAME_PATHS) == 0) {
		char temp[512];
		strcpy(temp, scan_dir[ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
		
		if(Get_OSK_String(STR_RENAME, temp, 128) == SUCCESS) {
			if(temp[0] != 0) {
			
				if(strcmp(scan_dir[ITEMS_VALUE_POSITION[ITEMS_POSITION]], temp) != 0) {
					start_loading();
					remove_SCANDIR(scan_dir[ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
					strcpy(scan_dir[ITEMS_VALUE_POSITION[ITEMS_POSITION]], temp);
					write_scan_dir();
					add_SCANDIR(scan_dir[ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
					init_Load_GAMEPIC();
					end_loading();
				}
			}
		}
	} else
	if(item_is(STR_COLORSET)) {
		char NewColorSet[128];
		memset(NewColorSet, 0, 128);
		if(Get_OSK_String(STR_COLORSET, NewColorSet, 128) == SUCCESS) {
			AddColorSet(NewColorSet);
		}
	} else
		return CONTINUE;
	
	update_SETTINGS();
	init_SETTINGS();
	
	return CONTINUE;
}

u8 SETTINGS_TRIANGLE()
{
	if(strcmp(ITEMS[ITEMS_POSITION], STR_THM) == 0) {
		start_loading();
				
		Delete(Themes_Paths_list[UI_position][Themes_position[UI_position]]);
			
		if(path_info(Themes_Paths_list[UI_position][Themes_position[UI_position]]) == _NOT_EXIST) {			
			GetThemes();
			if(Themes_position[UI_position] > Themes_number[UI_position]) Themes_position[UI_position]=Themes_number[UI_position];
			ITEMS_VALUE_NUMBER[ITEMS_POSITION] = Themes_number[UI_position];
			ITEMS_VALUE_POSITION[ITEMS_POSITION] = Themes_position[UI_position];
			show_msg(STR_DONE);
		} else show_msg(STR_FAILED);
		
		end_loading();
	} else 
	if(item_is(STR_GAME_PATHS)) {
		if(scan_dir_number>0) {
			remove_SCANDIR(scan_dir[ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
			
			int i;
			for(i=ITEMS_VALUE_POSITION[ITEMS_POSITION]; i < scan_dir_number; i++) {
				strcpy(scan_dir[i], scan_dir[i+1]);
			}
			memset(scan_dir[scan_dir_number], 0, sizeof(scan_dir[scan_dir_number]));
			if(scan_dir_number==ITEMS_VALUE_POSITION[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			scan_dir_number--;
			write_scan_dir();
			
			init_Load_GAMEPIC();
		}
	} else
	if(item_is(STR_COLORSET)) {
		if( ITEMS_VALUE_NUMBER[ITEMS_POSITION] > 0) {
			RemoveColorSet(ITEMS_VALUE[ITEMS_POSITION][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
			ITEMS_VALUE_NUMBER[ITEMS_POSITION]--;
			if(ITEMS_VALUE_POSITION[ITEMS_POSITION]>ITEMS_VALUE_NUMBER[ITEMS_POSITION]) 
				ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
		}
	} else
		return CONTINUE;
	
	update_SETTINGS();
	init_SETTINGS();

	return CONTINUE;
} 

void input_SETTINGS()
{
	int i;
		
	get_R2speed();
	
	if(R2pad(BUTTON_UP)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				u8 twice=NO;
				if(TITLES[ITEMS_POSITION]==NULL) twice=YES;
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos = ITEMS_POSITION-i;
					if( i_pos < 0 ) i_pos+=ITEMS_NUMBER+1;
					if(TITLES[i_pos] != NULL) {
						if(twice==NO) {
							ITEMS_POSITION = i_pos;
							break;
						} else twice=NO;
					}
				}
			} else if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION==TITLE_MENU_FIRST_ITEM) ITEMS_POSITION=TITLE_MENU_LAST_ITEM;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION == 0) ITEMS_POSITION = ITEMS_NUMBER;
					else ITEMS_POSITION--;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		}
	} else
	if(R2pad(BUTTON_DOWN)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL==LVL_TITLE) {
				for(i=1; i<=ITEMS_NUMBER; i++) {
					int i_pos=ITEMS_POSITION+i;
					if(ITEMS_NUMBER<i_pos) i_pos-=ITEMS_NUMBER+1;
					if(TITLES[i_pos]!=NULL) {
						ITEMS_POSITION=i_pos;
						break;
					}
				}
			} else
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=TITLE_MENU_LAST_ITEM-TITLE_MENU_FIRST_ITEM; i++) {
					if(ITEMS_POSITION == TITLE_MENU_LAST_ITEM) ITEMS_POSITION = TITLE_MENU_FIRST_ITEM;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}				
			} else 
			if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {
				for(i=0; i<=ITEMS_NUMBER; i++) {
					if(ITEMS_POSITION == ITEMS_NUMBER) ITEMS_POSITION = 0;
					else ITEMS_POSITION++;
					if(ITEMS_TYPE[ITEMS_POSITION]!=ITEM_LOCKED) break;
				}
				
			} else if(MENU_LVL == LVL_VALUE) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		}
	} else
	if(NewPad(BUTTON_CROSS)) {
		if(MENU_LVL == LVL_TITLE) {
			MENU_LVL = LVL_ITEMS;
		} else 
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE || ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX ) {
			ITEMS_VALUE_POSITION[ITEMS_POSITION] = !ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			MENU_LVL = LVL_VALUE;
		} else {
			if(SETTINGS_CROSS() == BREAK) return;
		}
	} else
	if(NewPad(BUTTON_SQUARE)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE || ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX ) {
			ITEMS_VALUE_POSITION[ITEMS_POSITION] = !ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == 0) ITEMS_VALUE_POSITION[ITEMS_POSITION] = ITEMS_VALUE_NUMBER[ITEMS_POSITION];
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]--;
			}
		} else {
			if(SETTINGS_SQUARE() == BREAK) return;
		}
	} else
	if(NewPad(BUTTON_TRIANGLE)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else
		if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE && ITEMS_TYPE[ITEMS_POSITION] == ITEM_CHECKBOX ) {
			ITEMS_VALUE_POSITION[ITEMS_POSITION] = !ITEMS_VALUE_POSITION[ITEMS_POSITION];
		} else 
		if(MENU_LVL == LVL_ITEMS && ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				if(ITEMS_VALUE_POSITION[ITEMS_POSITION] == ITEMS_VALUE_NUMBER[ITEMS_POSITION]) ITEMS_VALUE_POSITION[ITEMS_POSITION] = 0 ;
				else ITEMS_VALUE_POSITION[ITEMS_POSITION]++;
			}
		} else {
			if(SETTINGS_TRIANGLE() == BREAK) return;
		}
	} else
	if(NewPad(BUTTON_CIRCLE)) {
		if(USE_TITLE_MENU) {
			if(MENU_LVL == LVL_TITLE) {
				close_SETTINGS(); 
				return;
			} else 
			if(MENU_LVL == LVL_ITEMS) {
				MENU_LVL = LVL_TITLE;
				//init_SETTINGS();
			} else 
			if(MENU_LVL == LVL_VALUE) {
				MENU_LVL = LVL_ITEMS;
				//init_SETTINGS();
			}
		} else {
			if(MENU_LVL == LVL_ITEMS) {close_SETTINGS(); return;}
			else {
				MENU_LVL = LVL_ITEMS;
				init_SETTINGS();
			}
		}
	} else 
	if(NewPad(BUTTON_R1)) {
		if(MENU_LVL == LVL_TITLE) {
			//nothing
		} else {
			SETTING_R1();
		}
	}
	
	if(new_pad != 0) update_SETTINGS();
}

void Draw_SETTINGS_input()
{
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	if(MENU_LVL == LVL_VALUE) {
		if(strcmp(ITEMS[ITEMS_POSITION], STR_GAME_PATHS) == 0) {
			x=DrawButton(x, y, STR_ADD, BUTTON_CROSS);
			if(scan_dir_number>0) {
				x=DrawButton(x, y, STR_DELETE, BUTTON_TRIANGLE);
				x=DrawButton(x, y, STR_RENAME, BUTTON_SQUARE);
			}
		} else
		if(strcmp(ITEMS[ITEMS_POSITION], STR_THM) == 0) {
			x=DrawButton(x, y, STR_LOAD, BUTTON_CROSS);
			x=DrawButton(x, y, STR_DELETE, BUTTON_TRIANGLE);
			u8 ThemeType = GetThemeType(Themes_Paths_list[UI_position][ITEMS_VALUE_POSITION[ITEMS_POSITION]]);
			if(ThemeType == MGZ) {
				x=DrawButton(x, y, STR_RENAME, BUTTON_SQUARE);
			}
		} else
		if(item_is(STR_COLORSET)) {
			x=DrawButton(x, y, STR_LOAD, BUTTON_CROSS);
			x=DrawButton(x, y, STR_ADD, BUTTON_SQUARE);
			if(ITEMS_VALUE_NUMBER[ITEMS_POSITION]>0) {
				x=DrawButton(x, y, STR_DELETE, BUTTON_TRIANGLE);
			}
		} else
		if(item_is(STR_UPLOADER)){
			x=DrawButton(x, y, STR_RENAME, BUTTON_CROSS);
			x=DrawButton(x, y, STR_RESET, BUTTON_SQUARE);
		}
		x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
	} else if(MENU_LVL == LVL_ITEMS) {
		x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
		x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
		if(ITEMS_VALUE_NUMBER[ITEMS_POSITION] != -1) {
			if(ITEMS_VALUE_SHOW[ITEMS_POSITION] == YES) {
				x=DrawButton(x, y, STR_CHANGE, BUTTON_SQUARE | BUTTON_TRIANGLE);
			}
		} else
		if(ITEMS_TYPE[ITEMS_POSITION] == ITEM_COLORBOX) {
			x=DrawButton(x, y, STR_RESET, BUTTON_SQUARE);
		}
	} else if(MENU_LVL == LVL_TITLE) {
		x=DrawButton(x, y, STR_ENTER, BUTTON_CROSS);
		x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
	}
	
	if( ITEMS_TYPE[ITEMS_POSITION] == ITEM_TOGGLE ) {
		if( ( item_is(STR_COLOR_NOTIF) && FILTER_NOTIF==ENABLED )
		||  ( item_is(STR_COLOR_BOXHEAD) && FILTER_BOXHEAD==ENABLED )
		||  ( item_is(STR_COLOR_BOXBODY) && FILTER_BOXBODY==ENABLED )
		||  ( item_is(STR_COLOR_SIDEBAR) && FILTER_SIDEBAR==ENABLED )
		||  ( item_is(STR_COLOR_BGS) && FILTER_BGS==ENABLED )
		||  ( item_is(STR_COLOR_BG) && FILTER_BG==ENABLED )
		||  ( item_is(STR_SHOW_WAVES) && Show_Waves==YES)
		){
			x=DrawButton(x, y, STR_SET_COLOR, BUTTON_R1);
		}
	}
}

void open_SETTINGS()
{
	start_loading();
	MENU_SIDE=NO;
	USE_TITLE_MENU=YES;
	new_MENU();
#ifndef FILEMANAGER
	read_scan_dir();
#endif
	update_RootDisplay();
	read_setting();
	
	if( !UFS_SB_ADDR ) UFS_SB_ADDR = get_ufs_sb_addr();
	
	REC_UI_position=UI_position;
	REC_Show_COVER=Show_COVER;
	REC_Show_ICON0=Show_ICON0;
	REC_FLOW_3D=FLOW_3D;
	
	GetFont();
	init_SETTINGS();
	Draw_MENU_input = &Draw_SETTINGS_input;
	input_MENU = &input_SETTINGS;
	end_loading();
}

//*******************************************************
// MODE AutoMount
//*******************************************************

u8 is_AutoMount()
{
	FILE* fp;
	fp = fopen("/dev_hdd0/vsh/pushlist/game.dat", "rb");
	if(fp==NULL) return FAILED;
	fread(ManaGunZ_id, 9, 1, fp);
	fclose(fp);
	ManaGunZ_id[9]=0;
	
	//_sys_process_get_paramsfo(ManaGunZ_id);
	
	char M_path[128];
	sprintf(M_path, "/dev_hdd0/game/%s/USRDIR/AutoMount", ManaGunZ_id);
	
	if(path_info(M_path) == _NOT_EXIST) return NO;
	
	return YES;
}

void AutoMountCheckPad()
{
	if( AutoM && !gui_called ) {
		ps3pad_read();
		if((NewPad(BUTTON_TRIANGLE) || OldPad(BUTTON_TRIANGLE))) {
			gui_called=YES;
		}
	}
}

void AutoMount()
{
	print_load("Read AutoMount settings");

	if(read_AutoMount_setting()==FAILED) {	
		end_loading();
		u8 LoopBreak=1;
		while(LoopBreak)
		{
			cls();
			
			float x=50, y=40;
			
			FontSize(20);
			FontColor(RED);
			
			DrawString(x, y, STR_NOGAME);
			y+=20;
			DrawFormatString(x, y, "%s = %s", STR_PATH, GamPath);
			
			DrawFormatString(10, 10, "%d", gui_called);
			x=INPUT_X;
			y=INPUT_Y;
			FontColor(COLOR_1);
			SetFontZ(0);			
			
			DrawButton(x, y, STR_EXIT, BUTTON_CIRCLE);
		
			tiny3d_Flip();
			ScreenShot();
			ps3pad_read();
			
			if(NewPad(BUTTON_CIRCLE)) exit(0);
		}
	}
	
	AutoMountCheckPad();
	
	if(gui_called) {
		end_loading();
		
		open_GameMenu();
		
		while(MENU){
			cls();
			
			Draw_MENU();
			Draw_MENU_input();
		
			tiny3d_Flip();
			ScreenShot();
		
			ps3pad_read();
			
			input_MENU();
		}
		
		write_AutoMount_setting(list_game_path[0], NO);
	}
	
	MountGame(list_game_path[0]);
	
	end_loading();
	
	exit(0);
}

//*******************************************************
// Filter
//*******************************************************

void open_filter()
{
	filter = YES;
	read_setting();
}

void close_filter()
{
	filter=NO;
	write_setting();
}

void input_filter()
{
	if(filter==NO) return;
	
	if(NewPad(BUTTON_CROSS)) {
		
		if(filter_position==0) {
			if(Only_FAV==YES) Only_FAV=NO;
			else Only_FAV=YES;
		} else
		if(filter_position==1) {
			if(Show_PS3==YES) Show_PS3=NO;
			else Show_PS3=YES;
		} else
		if(filter_position==2) {
			if(Show_PS2==YES) Show_PS2=NO;
			else Show_PS2=YES;
		} else
		if(filter_position==3) {
			if(Show_PS1==YES) Show_PS1=NO;
			else Show_PS1=YES;
		} else
		if(filter_position==4) {
			if(Show_PSP==YES) Show_PSP=NO;
			else Show_PSP=YES;
		}
		
		if( UI_position == XMB) {
			if(XMB_H_position==XMB_COLUMN_PSP && !Show_PSP) { XMB_H_position--; }
			if(XMB_H_position==XMB_COLUMN_PS1 && !Show_PS1) { XMB_H_position--; }
			if(XMB_H_position==XMB_COLUMN_PS2 && !Show_PS2) { XMB_H_position--; }
			if(XMB_H_position==XMB_COLUMN_PS3 && !Show_PS3) { XMB_H_position--; }
			if(XMB_H_position==XMB_COLUMN_FAVORITES && !Only_FAV) { XMB_H_position--; }
		} else
		if(Show_it(position) == NO) {
			int i;
			int old_position = position;
			for(i=0; i<=game_number; i++) {
				if(position-i<0 && game_number<position+i) break;
				if(Show_it(position+i) == YES) {position+=i; break;}
				if(Show_it(position-i) == YES) {position-=i; break;}
			}
			if(old_position == position && 0 <= position) position = -1;
		}
	}
	
	filter_x += R2JoyStick_X(BUTTON_L);
	filter_y += R2JoyStick_Y(BUTTON_L);
	
	if(NewPad(BUTTON_SQUARE)) {
		filter_x = FILTER_X_DEFAULT;
		filter_y = FILTER_Y_DEFAULT;
	}
	
	if(NewPad(BUTTON_UP)) {
		if(filter_position==0) filter_position=4;
		else filter_position--;
	}
	
	if(NewPad(BUTTON_DOWN)) {
		if(filter_position==4) filter_position=0;
		else filter_position++;
	}
	
	if(NewPad(BUTTON_CIRCLE)) {
		close_filter();
	}
}

void Draw_filter_input()
{
	if(filter==NO) return;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);
	
	u8 is_checked=NO;
	
	if(filter_position==0) {
		if(Only_FAV==YES) is_checked=YES;
	} else
	if(filter_position==1) {
		if(Show_PS3==YES) is_checked=YES;
	} else
	if(filter_position==2) {
		if(Show_PS2==YES) is_checked=YES;
	} else
	if(filter_position==3) {
		if(Show_PS1==YES) is_checked=YES;
	} else
	if(filter_position==4) {
		if(Show_PSP==YES) is_checked=YES;
	}
	
	if(filter_position==0 && UI_position != XMB) {
		x=DrawButton(x, y, STR_CHANGE, BUTTON_CROSS);
	}
	else {
		if(is_checked) x=DrawButton(x, y, STR_UNCHECK, BUTTON_CROSS);
		else x=DrawButton(x, y, STR_CHECK, BUTTON_CROSS);
	}
	
	x=DrawButton(x, y, STR_MOVE, BUTTON_L);
	x=DrawButton(x, y, STR_RESET, BUTTON_SQUARE);
	x=DrawButton(x, y, STR_BACK, BUTTON_CIRCLE);
}

void Draw_filter()
{
	if(filter==NO) return;
	
	SetFontZ(0);
	float x=filter_x;
	float y=filter_y;
	float w=120;
	float h=115;
	u32 color = COLOR_BOXBODY_DEFAULT;
	
	if(UI_position!=XMB) h=160;
	
	if(PICTURE_offset[BOXBODY]) {
		if(FILTER_BOXBODY == ENABLED) color = COLOR_BOXBODY;
		else color = WHITE;
		
		tiny3d_SetTexture(0, PICTURE_offset[BOXBODY], PICTURE[BOXBODY].width, PICTURE[BOXBODY].height, PICTURE[BOXBODY].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		
		Draw_Box(x, y, 0, 0, w, h, color, YES);
	} else {
		if(FILTER_BOXBODY == ENABLED) {
			Draw_Box(x, y, 0, 0, w, h, COLOR_BOXBODY, NO);
		} else {
			Draw_Box(x, y, 0, 0, w, h, COLOR_BOXBODY_DEFAULT, NO);
		}
	}
	
	if(PICTURE_offset[BOXHEAD]) {
		if(FILTER_BOXHEAD == ENABLED) color = COLOR_BOXHEAD;
		else color = WHITE;
		
		tiny3d_SetTexture(0, PICTURE_offset[BOXHEAD], PICTURE[BOXHEAD].width, PICTURE[BOXHEAD].height, PICTURE[BOXHEAD].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, 0, 0, w, 25, color, YES);
		
		if(UI_position != XMB) {
			tiny3d_SetTexture(0, PICTURE_offset[BOXHEAD], PICTURE[BOXHEAD].width, PICTURE[BOXHEAD].height, PICTURE[BOXHEAD].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(x, y+25+30, 0, 0, w, 25, color, YES);		
		}
	} else {
		if(FILTER_BOXHEAD == ENABLED) {
			Draw_Box(x, y, 0, 0, w, 25, COLOR_BOXHEAD, NO);
			if(UI_position != XMB) {
				Draw_Box(x, y+25+30, 0, 0, w, 25, COLOR_BOXHEAD, NO);
			}
		} else {
			Draw_BoxGradiant(VERTICAL, x, y, 0, w, 25,  COLOR_BOXHEAD_DEFAULT, 0x101010FF, NO);
			if(UI_position != XMB) {
				Draw_BoxGradiant(VERTICAL, x, y+25+30, 0, w, 25,  COLOR_BOXHEAD_DEFAULT, 0x101010FF, NO);
			}
		}
	}
	
	
	FontSize(18);
	FontColor(COLOR_3);
	if( UI_position == XMB) {
		DrawStringFromCenterX(x+w/2, y+5, STR_FILTER);
	} else {
		DrawStringFromCenterX(x+w/2, y+5, STR_DISPLAY);
	}
	
	x+=8;
	y+=30;
	if( UI_position != XMB) {
		if(filter_position==0) FontColor(COLOR_2);
		else FontColor(COLOR_1);
		
		if( Only_FAV ) DrawString(x+5, y, STR_ONLY_FAV);
		else DrawString(x+5, y, STR_ALL_GAMES);
		
		y+=25;
		x-=8;
		
		FontSize(18);
		FontColor(COLOR_3);
		DrawStringFromCenterX(x+w/2, y+5, STR_FILTER);
		
		FontSize(15);
		x+=8;
		y+=15;
	} else {
		FontSize(15);
		
		Draw_checkbox(x+5, y, 0, STR_FAVORITE, Only_FAV, filter_position==0);
	}
	
	y+=15;
	Draw_checkbox(x+5, y, 0, "PS3", Show_PS3, filter_position==1);
	y+=15;
	Draw_checkbox(x+5, y, 0, "PS2", Show_PS2, filter_position==2);
	y+=15;
	Draw_checkbox(x+5, y, 0, "PS1", Show_PS1, filter_position==3);
	y+=15;
	Draw_checkbox(x+5, y, 0, "PSP", Show_PSP, filter_position==4);
	
	FontColor(COLOR_1);
}

//*******************************************************
// USER INTERFACE
//*******************************************************

void TranslateTo(float *value, float target)
{
	if( *value == target) return;
	
	float local;
	float TranslateSpeed = 1; 
	memcpy(&local, value, sizeof(float));
	
	if(local > target) {
		while(local-TranslateSpeed*10 > target ) 
			TranslateSpeed=TranslateSpeed*2;
	} else
	if(local < target) {
		while(local+TranslateSpeed*10 < target ) 
			TranslateSpeed=TranslateSpeed*2;
	}
	
	if(MOVE_animated==NO) {
		*value = target;
	} else
	if(target < local) {
		if(local - TranslateSpeed < target) *value = target;
		else {
			local -= TranslateSpeed;
			*value = local;
		}
	} else
	if(local < target) {
		if( target < local + TranslateSpeed) *value = target;
		else {
			local += TranslateSpeed;
			*value = local;
		}
	}
}

void RotateTo(float *value, float target)
{
	float local;
	float RotateSpeed = DEG(1);
	memcpy(&local, value, sizeof(float));
	
	if(local > target) {
		while(local-RotateSpeed*10 > target ) 
			RotateSpeed=RotateSpeed*2;
	} else
	if(local < target) {
		while(local+RotateSpeed*10 < target ) 
			RotateSpeed=RotateSpeed*2;
	}
	
	if((local - RotateSpeed < target && target < local + RotateSpeed) || MOVE_animated==NO) {
		*value = target;
	} else
	if(local > target) {
		local -= RotateSpeed;
		*value = local;
	} else
	if(local < target) {
		local += RotateSpeed;
		*value = local;
	}
}

float FLOW_FakeZoom(float z)
{
    return 2-(z-10)/90;
}

//*******************************************************
// LIST
//*******************************************************

void Draw_LIST()
{
	if(position == -1) return;
	
	if(Show_ICON0) {
		Draw_GAMEPIC(position, GAMEPIC_ICON0, 630, 30, 100, 141.3, 0, NO, WHITE);
	}
	if(Show_COVER) {
		int slot;
		if(Get_GAMEPIC_TYPE(position, &slot) == GAMEPIC_COVER2D) {
			Draw_GAMEPIC(position, GAMEPIC_COVER2D,  630, 150, 100, 141.3, 0, NO, WHITE);
		} else {
			Draw_COVER(position, 630, 150, 100, 141.3, 0, COVER_offset, COVER, NO, WHITE);
		}
	}
	
	float x=50, y=40;
	
	FontColor(COLOR_1);
	FontSize(LIST_SizeFont);
	
	nb_line = (460 - y - LIST_SizeFont) / LIST_SizeFont;
	
	int j=0, i=0;
		
	if(position<=first_line) {
		first_line=position;
		j=0;
		for(i=first_line; j<=nb_line; i++) {
			if(game_number < first_line + i) break;
			if(Show_it(i) == NO) continue;
			j++;
		}
		last_line=i-1;
	}
	if(last_line<=position) {
		last_line=position;
		j=0;
		for(i=last_line;  j<=nb_line; i--) {
			if(game_number < last_line - i) break;
			if(Show_it(i) == NO) continue;
			j++;
		}
		first_line=i+1;
	}
	
	SetFontZ(105);
	
	j=0;
	for(i=first_line;  j <= nb_line; i++) {
		if(i>game_number) break;
		if(Show_it(i) == NO) continue;
		
		j++;
		
		DrawTXTinLineBox(x, y, 0, X_MAX-x, list_game_title[i], 0, i==position ? COLOR_2 : COLOR_1);
		
		y+=LIST_SizeFont;
	}
	SetFontZ(10);
	last_line=i-1;
	
	if(j < nb_line) {
		j=0;
		for(i=last_line;  j<=nb_line; i--) {
			if(game_number < last_line - i) break;
			if(Show_it(i) == NO) continue;
			j++;
		}
		first_line=i+1;
	}
}

//*******************************************************
// FLOW 3D
//*******************************************************

// ** TINY3D_QUAD_STRIP **
//
// ** FULL COVER OUVERT **
//
//	 BACK CORN COTE CORN FRONT
//	1----3----5----7----9----11
//  |  / |  / |  / |  / |  / |  
//	| /  | /  | /  | /  | /  |  
//  2----4----6----8----10---12
//
//
// ** Inferieur **
//					|
//	 CORN BACK      
//	5----3----1
//  | \  | \  |
//	|  \ |  \ |
//  6----4----2
//

void Draw_ONFRONT3D(float w, float h, float e, float x1)
{
	float x=0,y=0,z=0; // 0,0,0 au centre du volume
	z=-e/2;
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	
	tiny3d_VertexPos(x-w/2+x1, y+h/2, z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(0.0f, 0.0f);
	
	tiny3d_VertexPos(x-w/2+x1, y-h/2 , z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(0.0f, 1.0f);
	
	tiny3d_VertexPos(x+w/2, y+h/2, z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(1.0f, 0.0f);
	 
	tiny3d_VertexPos(x+w/2, y-h/2, z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(1.0f, 1.0f);
	
	tiny3d_End();
	
}

void Draw_ONFRONT3D_ICON0(float w, float e, float r)
{
	float h_icon0 = w * 176.0 / 320.0;
	
	Draw_ONFRONT3D(w, h_icon0, e, r);
}

void Draw_COVER3D(u8 type, float w, float h, float e, float r, float x1, float y1) 
{
	if(type == GAMEPIC_ICON0)  {
		Draw_ONFRONT3D_ICON0(w, e, r);
		return;
	}
	if(type == GAMEPIC_COVER2D) {
		Draw_ONFRONT3D(w, h, e, r);
		return;
	}
	
	float t;
	
	// la boite est de face
	float x=0,y=0,z=0; // 0,0,0 au centre du volume 
	
	y+=y1;
	x+=x1;
	
	float l_tot = w-r + PI*r/4;
	
	float SW=0; // longueur de la texture
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	
	if(type==GAMEPIC_COVER3D) {
	
		l_tot = w*2-2*r + e-2*r + PI*r;
	
		tiny3d_VertexPos(x+w/2, y+h/2 , z+e/2);  // inferieur / haut / droite  [1]
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexTexture(0.0f, 0.0f);
		
		tiny3d_VertexPos(x+w/2, y-h/2 , z+e/2); // inferieur / bas / droite  [2]
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexTexture(0.0f, 1.0f);
				
		// COIN INFERIEUR
		for(t=90; t>=0 ; t-=10) {
			if(t==90) SW += w-r;
			else SW += (PI*r) * 10/180;
			
			tiny3d_VertexPos(x-w/2+r - r*cos(t*PI/180), y+h/2 , z+e/2-r + r*sin(t*PI/180));  //  t=90 [3] , t=0 [5]
			tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
			tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
			
			tiny3d_VertexPos(x-w/2+r - r*cos(t*PI/180), y-h/2 , z+e/2-r + r*sin(t*PI/180));  //  t=90 [4] , t=0 [6]
			tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
			tiny3d_VertexTexture((float) SW / l_tot, 1.0f);			
		}
			
		// COIN SUPERIEUR (1)
		for(t=0; t>-45 ; t-=7.5) {
			if(t==0) SW += e-2*r;
			else SW += (PI*r) * 7.5/180;
			
			tiny3d_VertexPos(x-w/2+r - r*cos(t*PI/180), y+h/2 , z-e/2+r + r*sin(t*PI/180));	// [7] t=0 
			tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
			tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
			tiny3d_VertexPos(x-w/2+r - r*cos(t*PI/180), y-h/2 , z-e/2+r + r*sin(t*PI/180));	// [8] t=0
			tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
			tiny3d_VertexTexture((float) SW / l_tot, 1.0f);
		}
	}
	
	
	// COIN SUPERIEUR (2)
	for(t=-45; t>=-90 ; t-=7.5) {
		if(t==-45) {
			if(GAMEPIC_COVER3D) SW += (PI*r) * 7.5/180;
		} else {
			SW += (PI*r) * 7.5/180;
		}
		
		tiny3d_VertexPos(x-w/2+r - r*cos(t*PI/180), y+h/2 , z-e/2+r + r*sin(t*PI/180));	// [9] t=-90
		tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
		tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
		tiny3d_VertexPos(x-w/2+r - r*cos(t*PI/180), y-h/2 , z-e/2+r + r*sin(t*PI/180));	// [10] t=-90
		tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
		tiny3d_VertexTexture((float) SW / l_tot, 1.0f);	
	}
	
	SW += w-r;
	tiny3d_VertexPos(x+w/2, y+h/2, z-e/2); // superieur / haut / droite 		// [11] 
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
	
	tiny3d_VertexPos(x+w/2, y-h/2, z-e/2); // superieur / bas / droite 		// [12]
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture((float) SW / l_tot, 1.0f);


	tiny3d_End();
}

//***********
// PS3 BOX
//***********
#define BOX3D_PS3_e  14.0f
#define BOX3D_PS3_hb 172.0f
#define BOX3D_PS3_wb 135.0f
#define BOX3D_PS3_wc 129.0f
#define BOX3D_PS3_hc 149.0f
#define BOX3D_PS3_l2 7.0f
#define BOX3D_PS3_X0 ((float) (-BOX3D_PS3_wc / 2.0f))
#define BOX3D_PS3_Y0 ((float) (-BOX3D_PS3_hc / 2.0f - BOX3D_PS3_l2))

void Draw_PS3PIC_3D(u8 type)
{
	float w=BOX3D_PS3_wc; // largeur de la jaquette de face
	float h=BOX3D_PS3_hc; // hauteur de la jaquettte de face
	float e=BOX3D_PS3_e+0.05; // epaisseur de la boite + 0.1 pixel de chaque coté pour garder la jaquette autour de la boite.
	float r=3; // rayon des arrondies
	
	Draw_COVER3D(type, w,h,e,r,-0.01,0);
}

void Draw_PS3GAMECASE_3D()
{
	//float l;
	int t,i;
	
	float x=0,y=0,z=0; // 0,0,0 au centre du volume de la jaquette
	
	float w=BOX3D_PS3_wc; // largeur de la jaquette de face
	float h=BOX3D_PS3_hc; // hauteur de la jaquettte de face
	float e=BOX3D_PS3_e; // epaisseur de la boite 
	float r=3; // rayon des arrondies
	
	float wb = BOX3D_PS3_wb; // largeur de la boite
	float hb = BOX3D_PS3_hb; // hauteur de la boite
	//float l1 = 15; // hauteur de l'en-tete de la boite 
	float r1 = 7.5f; // rayon du haut
	float l2 = BOX3D_PS3_l2; // distance entre le bas de la boite et la jaquette
	float r2 = 5.0f; // rayon du bas
	
	float l3 = 36; // distance entre le bas et l'ouverture lateral
	
	x = -w/2;
	y = -h/2-l2;
	z = -e/2;
	
// surface superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*sin(t*PI/180)   , y+hb-r1 + (r1-r)*cos(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*sin(t*PI/180),y+hb-r1  + (r1-r)*cos((t)*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	tiny3d_End();
	
	
// arrondie superieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie gauche superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut gauche TORE
	for(t=180; t<=260; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// surface du bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb-r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_End();
	
// coin bas droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surfaces de droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+r2, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+r2, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+r );
		tiny3d_Normal(sin(t*PI/180), cos(t*PI/180), 0);
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(sin(t*PI/180), cos(t*PI/180), 0);
	}
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-5, y+l3+5, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+l3+5, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3-5, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3-5, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*cos(t*PI/180), y+hb-l3-5 + 5*sin(t*PI/180) , z+r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
		tiny3d_VertexPos(x+wb - 5*cos(t*PI/180), y+hb-l3-5 + 5*sin(t*PI/180) , z+e-r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
	}
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();


	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+r );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+hb-l3-5 + 5*cos(t*PI/180) , z+r );
		tiny3d_Normal(0, 0, 1);
	}
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+hb-l3-5 + 5*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(0, 0, -1);
	}
	tiny3d_End();
	
// coin haut droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+e-r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface du haut
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_End();
	
// coin haut gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface de gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x, y+hb-r1, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+hb-r1, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_End();
	
	
// coin bas gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();

// 	arrondie inferieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin inferieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie gauche inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=180; t<=270; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// surface inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*cos(t*PI/180)   , y+hb-r1 + (r1-r)*sin(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*cos(t*PI/180), y+hb-r1 + (r1-r)*sin((t)*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	tiny3d_End();
	
	// BR logo
	if(PICTURE_offset[BR_LOGO]) {
		tiny3d_SetPolygon(TINY3D_QUADS);
		tiny3d_VertexPos(x+wb-r1-20, y+hb-r   , z);
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexTexture(0.0f, 0.0f);
		tiny3d_VertexPos(x+wb-r1   , y+hb-r   , z);
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexTexture(1.0f, 0.0f);
		tiny3d_VertexPos(x+wb-r1   , y+hb-r-10, z);
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexTexture(1.0f, 1.0f);
		tiny3d_VertexPos(x+wb-r1-20, y+hb-r-10, z);
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexTexture(0.0f, 1.0f);
		tiny3d_End();
	}

/*
// ligne d'ouverture
	wb+=0.1f;
	hb+=0.1f;
	tiny3d_SetPolygon(TINY3D_LINE_LOOP);
	tiny3d_VertexColor(0x000000FF);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - r1*cos(t*PI/180)   , y+hb-r1 + r1*sin(t*PI/180), z+e/2 );
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+wb-r1 + r1*sin(t*PI/180)   , y+hb-r1 + r1*cos(t*PI/180), z+e/2 );
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+hb-l3-5 + 5*cos(t*PI/180) , z+e/2 );
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*cos(t*PI/180), y+l3+5 - 5*sin(t*PI/180) , z+e/2 );
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+wb-r2 - r2*cos(t*PI/180)   , y+r2 - r2*sin(t*PI/180), z+e/2 );
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r2 - r2*sin(t*PI/180)   , y+r2 - r2*cos(t*PI/180), z+e/2 );
	}
	tiny3d_End();
*/

/*	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	
// surface gauche
	tiny3d_VertexPos(x, y+hb , z);  // superieur / haut / gauche  
	tiny3d_VertexPos(x, y+hb , z+e);  // inferieur / haut / gauche 
	tiny3d_VertexPos(x, y , z);  // superieur / bas / gauche
	tiny3d_VertexPos(x, y , z+e);  // superieur / bas / gauche

// surface du bas
	tiny3d_VertexPos(x+wb, y, z+e);  // inferieur / bas / droite  
	tiny3d_VertexPos(x, y , z);  // superieur / bas / gauche 
	tiny3d_VertexPos(x+wb, y , z);  // superieur / bas / droite
	
// surface superieur
	tiny3d_VertexPos(x, y+hb , z);  // superieur / haut / gauche  
	tiny3d_VertexPos(x+wb, y+hb, z);  // superieur / haut / droite 

// surface du haut
	tiny3d_VertexPos(x, y+hb , z+e);  // inferieur / haut / gauche  
	tiny3d_VertexPos(x+wb, y+hb, z+e);  // inferieur / haut / droite
	
// surface inferieur
	tiny3d_VertexPos(x, y , z+e);  // inferieur / bas / gauche  
	tiny3d_VertexPos(x+wb, y, z+e);  // inferieur / bas / droite
	
// surface droite
	tiny3d_VertexPos(x+wb, y , z);  // superieur / bas / droite  
	tiny3d_VertexPos(x+wb, y+hb, z+e);  // inferieur / haut / droite
	tiny3d_VertexPos(x+wb, y+hb, z);  // superieur / haut / droite
	
	tiny3d_End();
*/

}

//***********
// PS2 BOX
//***********
#define BOX3D_PS2_e	 14.0f
#define BOX3D_PS2_hb 190.0f
#define BOX3D_PS2_wb 135.0f
#define BOX3D_PS2_hc 180.0f
#define BOX3D_PS2_wc 130.0f
#define BOX3D_PS2_l2 5.0f
#define BOX3D_PS2_X0 ((float) (-BOX3D_PS2_wc / 2.0f))
#define BOX3D_PS2_Y0 ((float) (-BOX3D_PS2_hc / 2.0f - BOX3D_PS2_l2))

void Draw_PS2PIC_3D(u8 type)
{
	float w=BOX3D_PS2_wc; // largeur de la jaquette de face
	float h=BOX3D_PS2_hc; // hauteur de la jaquettte de face
	float e=BOX3D_PS2_e+0.05; // epaisseur de la boite + 0.1 pixel de chaque coté pour garder la jaquette autour de la boite.
	float r=3; // rayon des arrondies
	
	Draw_COVER3D(type, w, h, e, r, -0.01, 0);
}

void Draw_PS2GAMECASE_3D()
{
	//float l;
	int t,i;
	
	float x=0,y=0,z=0; // 0,0,0 au centre du volume de la jaquette
	
	float w=BOX3D_PS2_wc; // largeur de la jaquette de face
	float h=BOX3D_PS2_hc; // hauteur de la jaquettte de face
	float e=BOX3D_PS2_e; // epaisseur de la boite 
	float r=3; // rayon des arrondies
	
	float wb = BOX3D_PS2_wb; // largeur de la boite
	float hb = BOX3D_PS2_hb; // hauteur de la boite
	//float l1 = 15; // hauteur de l'en-tete de la boite 
	float r1 = 5; // rayon du haut
	float l2 = BOX3D_PS2_l2; // distance entre le coté de la boite et la jaquette = distance entre le bas de la boite et la jaquette
	float r2 = 5; // rayon du bas
	
	float l3 = 50; // distance entre le bas et l'ouverture lateral
	
	x = -w/2;
	y = -h/2-l2;
	z = -e/2;
	
// surface superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*sin(t*PI/180)   , y+hb-r1 + (r1-r)*cos(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*sin(t*PI/180),y+hb-r1  + (r1-r)*cos((t)*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	tiny3d_End();
	
	
// arrondie superieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie gauche superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut gauche TORE
	for(t=180; t<=260; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// surface du bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb-r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_End();
	
// coin bas droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surfaces de droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+r2, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+r2, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+l3, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-5, y+l3, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-5, y+l3, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-5, y+l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();

	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+l3, z+r );
	tiny3d_Normal(0, 0, 1);
	tiny3d_VertexPos(x+wb-5, y+l3 , z+r );
	tiny3d_Normal(0, 0, 1);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+r );
	tiny3d_Normal(0, 0, 1);
	tiny3d_VertexPos(x+wb-5, y+hb-l3, z+r );
	tiny3d_Normal(0, 0, 1);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+l3, z+e-r );
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexPos(x+wb-5, y+l3 , z+e-r );
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+e-r );
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexPos(x+wb-5, y+hb-l3, z+e-r );
	tiny3d_Normal(0, 0, -1);
	tiny3d_End();
	
// coin haut droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+e-r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface du haut
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_End();
	
// coin haut gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface de gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x, y+hb-r1, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+hb-r1, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_End();
	
	
// coin bas gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();

// 	arrondie inferieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin inferieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie gauche inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=180; t<=270; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// surface inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*cos(t*PI/180)   , y+hb-r1 + (r1-r)*sin(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*cos(t*PI/180), y+hb-r1 + (r1-r)*sin((t)*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	tiny3d_End();

	
}

//***********
// PSP BOX
//***********
#define BOX3D_PSP_e  14.0f
#define BOX3D_PSP_hb 168.0f
#define BOX3D_PSP_wb 99.0f
#define BOX3D_PSP_hc 158.0f
#define BOX3D_PSP_wc 92.0f
#define BOX3D_PSP_l2 5.0f
#define BOX3D_PSP_X0 ((float) (-BOX3D_PSP_wc / 2.0f))
#define BOX3D_PSP_Y0 ((float) (-BOX3D_PSP_hc / 2.0f - BOX3D_PSP_l2))

void Draw_PSPPIC_3D(u8 type)
{
	float w=BOX3D_PSP_wc; // largeur de la jaquette de face
	float h=BOX3D_PSP_hc; // hauteur de la jaquettte de face
	float e=BOX3D_PSP_e+0.05; // épaisseur de la boite + 0.1 pixel de chaque coté pour garder la jaquette autour de la boite.
	float r=3; // rayon des arrondies

	Draw_COVER3D(type,w,h,e,r,-0.01,0);
}

void Draw_PSPGAMECASE_3D()
{

	//float l;
	int t,i;
	
	float x=0,y=0,z=0; // 0,0,0 au centre du volume de la jaquette
	
	float w=BOX3D_PSP_wc; // largeur de la jaquette de face
	float h=BOX3D_PSP_hc; // hauteur de la jaquettte de face
	float e=BOX3D_PSP_e; // epaisseur de la boite 
	float r=3; // rayon des arrondies
	
	float wb = BOX3D_PSP_wb; // largeur de la boite
	float hb = BOX3D_PSP_hb; // hauteur de la boite
	//float l1 = 15; // hauteur de l'en-tete de la boite 
	float r1 = 5; // rayon du haut
	float l2 = BOX3D_PSP_l2; // distance entre le coté de la boite et la jaquette
	float r2 = 5; // rayon du bas
	
	float l3 = 36; // distance entre le bas et l'ouverture lateral
	
	x = -w/2;
	y = -h/2-l2;
	z = -e/2;
	
// surface superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*sin(t*PI/180)   , y+hb-r1 + (r1-r)*cos(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*sin(t*PI/180),y+hb-r1  + (r1-r)*cos((t)*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	tiny3d_End();
	
	
// arrondie superieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie gauche superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut gauche TORE
	for(t=180; t<=260; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// surface du bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb-r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_End();
	
// coin bas droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surfaces de droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+r2, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+r2, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+r );
		tiny3d_Normal(sin(t*PI/180), cos(t*PI/180), 0);
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(sin(t*PI/180), cos(t*PI/180), 0);
	}
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-5, y+l3+5, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+l3+5, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3-5, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb-5, y+hb-l3-5, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*cos(t*PI/180), y+hb-l3-5 + 5*sin(t*PI/180) , z+r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
		tiny3d_VertexPos(x+wb - 5*cos(t*PI/180), y+hb-l3-5 + 5*sin(t*PI/180) , z+e-r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
	}
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-l3, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();


	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+r );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+hb-l3-5 + 5*cos(t*PI/180) , z+r );
		tiny3d_Normal(0, 0, 1);
	}
	tiny3d_End();
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+l3+5 - 5*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos(x+wb - 5*sin(t*PI/180), y+hb-l3-5 + 5*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(0, 0, -1);
	}
	tiny3d_End();
	
// coin haut droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+e-r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface du haut
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_End();
	
// coin haut gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface de gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x, y+hb-r1, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+hb-r1, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_End();
	
	
// coin bas gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();

// 	arrondie inferieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin inferieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie gauche inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=180; t<=270; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// surface inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*cos(t*PI/180)   , y+hb-r1 + (r1-r)*sin(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*cos(t*PI/180), y+hb-r1 + (r1-r)*sin((t)*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	tiny3d_End();

}

//***********
// PS1 BOX
//***********

#define BOX3D_PS1_e  15.0f
#define BOX3D_PS1_hb 130.0f
#define BOX3D_PS1_wb 140.0f
#define BOX3D_PS1_hc BOX3D_PS1_hb
#define BOX3D_PS1_wc 126.0f
#define BOX3D_PS1_X0 ((float) (-BOX3D_PS1_wb / 2.0f))
#define BOX3D_PS1_Y0 ((float) (-BOX3D_PS1_hb / 2.0f))

void Draw_PS1ICON0()
{	
	float wb = BOX3D_PS1_wb; // largeur de la boite
	float e=BOX3D_PS1_e+0.01; // épaisseur de la boite + 0.1 pixel de chaque coté pour garder la jaquette autour de la boite.
	float w=BOX3D_PS1_wc; // largeur de la jaquette de face
	float l=wb-w; // largeur de la marge noire à gauche
	
	Draw_ONFRONT3D_ICON0(w, e, l);
}

void Draw_PS1COVER_FRONT()
{
	float x=0,y=0,z=0; // 0,0,0 au centre du volume 
		
	float wb = BOX3D_PS1_wb; // largeur de la boite
	float hb = BOX3D_PS1_hb; // hauteur de la boite
	
	float w=BOX3D_PS1_wc; // largeur de la jaquette de face
	float e=BOX3D_PS1_e+0.2; // épaisseur de la boite + 0.1 pixel de chaque coté pour garder la jaquette autour de la boite.
	float r=2; // rayon des arrondies

	float l=wb-r-w; // largeur de la marge noire à gauche

// x,y,z : supérieur bas gauche
	x = -wb/2;
	y = -hb/2;
	z = -e/2; 
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	
	tiny3d_VertexPos(x+l, y+hb-r , z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(0.0f, 0.0f);
	
	tiny3d_VertexPos(x+l, y+r , z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(0.0f, 1.0f);
	
	tiny3d_VertexPos(x+wb-r, y+hb-r	, z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(1.0f, 0.0f);
	 
	tiny3d_VertexPos(x+wb-r, y+r	, z);
	tiny3d_Normal(0, 0, -1);
	tiny3d_VertexTexture(1.0f, 1.0f);
	
	tiny3d_End();
}

void Draw_PS1COVER_BACK()
{
	float x=0,y=0,z=0; // 0,0,0 au centre du volume 
		
	float wb = 140+0.2; // largeur de la boite
	float hb = 130; // hauteur de la boite
	
	float e=BOX3D_PS1_e+0.2; // epaisseur de la boite + 0.1 pixel de chaque coté pour garder la jaquette autour de la boite.
	float r=2; // rayon des arrondies

// x,y,z : superieur bas gauche
	x = -wb/2;
	y = -hb/2;
	z = -e/2;
	
	float gap = 2;
	
	float l_tot = wb-2*r + 2*(e-r) + PI*r - gap*2;
	
	float SW=0; // longueur de la texture
	
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		
	tiny3d_VertexPos(x+wb, y+hb-r , z+r+gap);  
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexTexture(0.0f, 0.0f);

	tiny3d_VertexPos(x+wb, y+r , z+r+gap); 
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexTexture(0.0f, 1.0f);
	
	tiny3d_VertexPos(x+wb, y+hb-r , z+e-r); 
	tiny3d_Normal(1, 0, 0);
	SW+=e-r-gap;
	tiny3d_VertexTexture((float) SW / l_tot, 0.0f);

	tiny3d_VertexPos(x+wb, y+r , z+e-r); 
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexTexture((float) SW / l_tot, 1.0f);

	int t;
	for(t=10; t<=90; t+=10) {
		SW += (PI*r) * 10/180;
		
		tiny3d_VertexPos(x+wb-r + r*cos(t*PI/180), y+hb-r  , z+e-r + r*sin(t*PI/180) );
		tiny3d_Normal(cos(t*PI/180), 0, sin(t*PI/180));
		tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
		
		tiny3d_VertexPos(x+wb-r + r*cos(t*PI/180), y+r    , z+e-r + r*sin(t*PI/180) );
		tiny3d_Normal(cos(t*PI/180), 0, sin(t*PI/180));
		tiny3d_VertexTexture((float) SW / l_tot, 1.0f);
	}
	
	SW += wb-2*r;
	tiny3d_VertexPos(x+r, y+hb-r, z+e);
	tiny3d_Normal(0, 0, 1);
	tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
	
	tiny3d_VertexPos(x+r, y+r, z+e);
	tiny3d_Normal(0, 0, 1);
	tiny3d_VertexTexture((float) SW / l_tot, 1.0f); 
	
	for(t=10; t<=90; t+=10) {
		SW += (PI*r) * 10/180;
		
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
		
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r    , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexTexture((float) SW / l_tot, 1.0f);
	}
	
	SW += e-r-gap;
	tiny3d_VertexPos(x, y+hb-r, z+r+gap);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
	
	tiny3d_VertexPos(x, y+r, z+r+gap);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexTexture((float) SW / l_tot, 1.0f); 
	
	tiny3d_End();
	
}

void Draw_PS1GAMECASE_3D()
{
	//float l;
	int t,i;
	
	float x=0,y=0,z=0; // 0,0,0 au centre du volume
	
	float e=BOX3D_PS1_e; // epaisseur de la boite 
	float wb=BOX3D_PS1_wb; // largeur de la boite
	float hb=BOX3D_PS1_hb; // hauteur de la boite
	
	float r=2; // rayon des bordures
	float r1=r, r2=r;
	
	float w=126; // largeur de la jaquette de face 

	float l=wb-r-w; // largeur de la marge noire à gauche

	x = -wb/2;
	y = -hb/2;
	z = -e/2;
	
// surface superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*sin(t*PI/180)   , y+hb-r1 + (r1-r)*cos(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*sin(t*PI/180),y+hb-r1  + (r1-r)*cos((t)*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*cos(t*PI/180), y+r2 - (r2-r)*sin(t*PI/180), z );
		tiny3d_Normal(0, 0, -1);
	}
	tiny3d_End();
	
// arrondie superieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+r - r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), -cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin superieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie gauche superieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+r - r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, -cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin superieur haut gauche TORE
	for(t=180; t<=260; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=270; i<=360; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// surface du bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb-r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+wb-r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_VertexPos(x+r2, y, z+e-r);
	tiny3d_Normal(0, -1, 0);
	tiny3d_End();
	
// coin bas droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r2 + r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surfaces de droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+wb, y+r2, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+r2, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_VertexPos(x+wb, y+hb-r1, z+e-r);
	tiny3d_Normal(1, 0, 0);
	tiny3d_End();
	
// coin haut droite
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
		tiny3d_VertexPos(x+wb-r1 + r1*cos(t*PI/180), y+hb-r1 + r1*sin(t*PI/180) , z+e-r );
		tiny3d_Normal(cos(t*PI/180), sin(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface du haut
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x+r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_VertexPos(x+wb-r1, y+hb, z+e-r);
	tiny3d_Normal(0, 1, 0);
	tiny3d_End();
	
// coin haut gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r1 - r1*sin(t*PI/180), y+hb-r1 + r1*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), cos(t*PI/180), 0);
	}
	tiny3d_End();
	
// surface de gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	tiny3d_VertexPos(x, y+hb-r1, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+hb-r1, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_VertexPos(x, y+r2, z+e-r);
	tiny3d_Normal(-1, 0, 0);
	tiny3d_End();
	
	
// coin bas gauche
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
		tiny3d_VertexPos(x+r2 - r2*sin(t*PI/180), y+r2 - r2*cos(t*PI/180) , z+e-r );
		tiny3d_Normal(-sin(t*PI/180), -cos(t*PI/180), 0);
	}
	tiny3d_End();

// 	arrondie inferieur bas
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2   , y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r2, y+r - r*sin(t*PI/180) , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, -sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();

// arrondie coin inferieur bas droit TORE
	for(t=270; t<=350; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// arrondie droit inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+r2     , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+wb-r + r*sin(t*PI/180), y+hb-r1  , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut droite TORE
	for(t=0; t<=80; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+wb-r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie haut inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+wb-r1 , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
		tiny3d_VertexPos(x+r1    , y+hb-r + r*sin(t*PI/180), z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(0, sin(t*PI/180), cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=90; t<=170; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r1 + ((r1-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+hb-r1 + ((r1-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}

// arrondie gauche inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+hb-r1 , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
		tiny3d_VertexPos(x+r - r*sin(t*PI/180), y+r2    , z+e-r + r*cos(t*PI/180) );
		tiny3d_Normal(-sin(t*PI/180), 0, cos(t*PI/180));
	}
	tiny3d_End();
	
// arrondie coin inferieur haut gauche TORE
	for(t=180; t<=270; t+=10) {
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		for(i=0; i<=90; i+=10) {
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos(t*PI/180)      , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin(t*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos(t*PI/180), cos(i*PI/180)*sin(t*PI/180), sin(i*PI/180));
			tiny3d_VertexPos(x+r2 + ((r2-r)+r*cos(i*PI/180))*cos((t+10)*PI/180) , y+r2 + ((r2-r)+r*cos(i*PI/180))*sin((t+10)*PI/180) , z+e-r +  r*sin(i*PI/180) );
			tiny3d_Normal(cos(i*PI/180)*cos((t+10)*PI/180), cos(i*PI/180)*sin((t+10)*PI/180), sin(i*PI/180));
		}
		tiny3d_End();
	}
	
// surface inferieur
	tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos(x+r2    - (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos(x+wb-r2 + (r2-r)*sin(t*PI/180), y+r2 - (r2-r)*cos(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	for(t=0; t<=90; t+=10) {
		tiny3d_VertexPos( x+r1 - (r1-r)*cos(t*PI/180)   , y+hb-r1 + (r1-r)*sin(t*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
		tiny3d_VertexPos( x+wb-r1 + (r1-r)*cos(t*PI/180), y+hb-r1 + (r1-r)*sin((t)*PI/180), z+e );
		tiny3d_Normal(0, 0, 1);
	}
	tiny3d_End();
	
	
	if(PICTURE_offset[PS_LOGO]) {
	
		float l_tot = l-1-r + PI*r/2 ;
	
		float SW=0; // longueur de la texture
		
		tiny3d_SetPolygon(TINY3D_QUAD_STRIP);
		
		tiny3d_VertexPos(x, y+hb-r, z+r);
		tiny3d_Normal(-1, 0, 0);
		tiny3d_VertexTexture(0, 0.0f);
		tiny3d_VertexPos(x, y+r, z+r);
		tiny3d_Normal(-1, 0, 0);
		tiny3d_VertexTexture(0, 1.0f); 
		
		// COIN SUPERIEUR
		for(t=-10; t>=-90 ; t-=10) {
			SW += (PI*r) * 10/180;
			
			tiny3d_VertexPos(x+r - r*cos(t*PI/180), y+hb-r , z+r + r*sin(t*PI/180));
			tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
			tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
			tiny3d_VertexPos(x+r - r*cos(t*PI/180), y+r , z+r + r*sin(t*PI/180));
			tiny3d_Normal(-cos(t*PI/180), 0, sin(t*PI/180));
			tiny3d_VertexTexture((float) SW / l_tot, 1.0f);
		}
		
		
		SW += l-1-r;
		tiny3d_VertexPos(x+l-1, y+hb-r, z);
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexTexture((float) SW / l_tot, 0.0f);
		
		tiny3d_VertexPos(x+l-1, y+r, z);
		tiny3d_Normal(0, 0, -1);
		tiny3d_VertexTexture((float) SW / l_tot, 1.0f);
		
		tiny3d_End();
	}
}

#define BOX3D_Y 	0.0f
#define BOX3D_Z		700.0f
float GetBox3D_Y(u32 pos)
{
	if( BOX3D_ALIGN == NO) return BOX3D_Y;
	
	float hb = 0.0f;
	
	if( list_game_platform[pos]== ISO_PS3 || list_game_platform[pos]== JB_PS3 || list_game_platform[pos]== BDVD) hb = BOX3D_PS3_Y0; else
	if( list_game_platform[pos]== ISO_PS2 || list_game_platform[pos]== JB_PS2) hb = BOX3D_PS2_Y0; else
	if(	list_game_platform[pos]== ISO_PS1 || list_game_platform[pos]== JB_PS1) hb = BOX3D_PS1_Y0; else
	if(	list_game_platform[pos]== ISO_PSP || list_game_platform[pos]== JB_PSP) hb = BOX3D_PSP_Y0;
	
	return (float) (BOX3D_PS3_Y0 - hb + BOX3D_Y);
}

float GetBox3D_Z(u32 pos)
{
	if( BOX3D_ALIGN == NO) return BOX3D_Z;
	
	float wb = 0.0f;
	
	if( list_game_platform[pos]== ISO_PS3 || list_game_platform[pos]== JB_PS3 || list_game_platform[pos]== BDVD) wb = BOX3D_PS3_X0; else
	if( list_game_platform[pos]== ISO_PS2 || list_game_platform[pos]== JB_PS2) wb = BOX3D_PS2_X0; else
	if(	list_game_platform[pos]== ISO_PS1 || list_game_platform[pos]== JB_PS1) wb = BOX3D_PS1_X0; else
	if(	list_game_platform[pos]== ISO_PSP || list_game_platform[pos]== JB_PSP) wb = BOX3D_PSP_X0;
	
	return (float) (BOX3D_PS3_X0 - wb + BOX3D_Z);
}

float GetBox3D_E(u32 pos)
{
	float e = 0.0f;
	
	if( list_game_platform[pos]== ISO_PS3 || list_game_platform[pos]== JB_PS3 || list_game_platform[pos]== BDVD) e = BOX3D_PS3_e; else
	if( list_game_platform[pos]== ISO_PS2 || list_game_platform[pos]== JB_PS2) e = BOX3D_PS2_e; else
	if(	list_game_platform[pos]== ISO_PS1 || list_game_platform[pos]== JB_PS1) e = BOX3D_PS1_e; else
	if(	list_game_platform[pos]== ISO_PSP || list_game_platform[pos]== JB_PSP) e = BOX3D_PSP_e;
	
	return (float) e/2.0f;
}

float GetBox3D_Zoom(u32 pos)
{
	if( FLOW_Zoom == NO ) return (float) 500.0f;
	
	return 350.0f;
}

void update_3DFLOW()
{

	if( position == -1) return;
	
	float e=0;
	int i;
	
	if(ITEM_moveZ[position]==0) MOVE_animated=NO;
	
	int previous=-1;
	int next=-1;
	
	e=170;
	for(i=position+1; i<=game_number; i++) {
		if(Show_it(i) == NO) continue;
		e += GetBox3D_E(i);
		TranslateTo(&ITEM_moveX[i], e);
		TranslateTo(&ITEM_moveY[i], GetBox3D_Y(i));
		TranslateTo(&ITEM_moveZ[i], GetBox3D_Z(i));
		RotateTo(&ITEM_angleX[i], 0.0);
		RotateTo(&ITEM_angleY[i], -PI/2);
		RotateTo(&ITEM_angleZ[i], 0.0);
		e += (float)BOX3D_GAP*15.0f + GetBox3D_E(i);
		
		if(next==-1) next=i;
	}
	
	e=-170;
	for(i=position-1; i>=0; i--) {
		if(Show_it(i) == NO) continue;
		e -= GetBox3D_E(i);
		TranslateTo(&ITEM_moveX[i], e);
		TranslateTo(&ITEM_moveY[i], GetBox3D_Y(i));
		TranslateTo(&ITEM_moveZ[i], GetBox3D_Z(i));
		RotateTo(&ITEM_angleX[i], 0.0);
		RotateTo(&ITEM_angleY[i], -PI/2);
		RotateTo(&ITEM_angleZ[i], 0.0);
		e -= (float)BOX3D_GAP*15.0f + GetBox3D_E(i);
		
		if(previous==-1) previous=i;
	}
	
	TranslateTo(&ITEM_moveX[position], 0.0);
	TranslateTo(&ITEM_moveY[position], 0.0);
	TranslateTo(&ITEM_moveZ[position], GetBox3D_Zoom(position));
	
	RotateTo(&ITEM_angleX[position], 0.0);
	// don't rotate if the boxes are too close
	if( ( previous!=-1 && ITEM_moveX[position] - ITEM_moveX[previous] < 50)
	 || ( next!=-1     && ITEM_moveX[next] - ITEM_moveX[position] < 50))
	{
		RotateTo(&ITEM_angleY[position], -PI/2);
	} else {
		if(FLOW_ShowBack==YES) 
			RotateTo(&ITEM_angleY[position], PI);
		else 
			RotateTo(&ITEM_angleY[position], 0.0);
	}
	RotateTo(&ITEM_angleZ[position], 0.0);
	
	MOVE_animated=YES;
}

void Draw_FLOW_SCROLL(float x, float y, float z, float w)
{	
	if(position == -1) return;
	
	if( OldPad(BUTTON_LEFT) == NO && OldPad(BUTTON_RIGHT) == NO) {
		return;
	} else
	if( R2speed == 6 ) {
		if(OldPadDelay(BUTTON_LEFT, n_s(2)) == NO && OldPadDelay(BUTTON_RIGHT, n_s(2)) == NO ) return;
	} else
	if( 3 < R2speed ) return;
	
	FontSize(15);
	SetFontZ(z);
	
	float xc1 = 0;
	float xc2 = 0;
	float xc = 0;
	float xp = 0;
	int cc = upit(list_game_title[position][0]);
	int c = 0;
	int cp = 0;
	float x_gpos = 0;
	int i;
	
	int displayed_game_number = -1;
	for(i=0; i<=game_number; i++) {
		if(Show_it(i)) displayed_game_number++;
	}
	
	if(displayed_game_number == -1) return;
	
	float wg = w / (displayed_game_number + 1);
	
	Draw_Box(x, y-1, z, 0, w, 2, COLOR_1, NO);
	
	for(i=0; i<=game_number; i++) {
		if(Show_it(i) == NO) continue;
		
		x_gpos = i*wg;
				
		if(c < upit(list_game_title[i][0]) || i == game_number) {
		
			cp = c;
			c = upit(list_game_title[i][0]);
			
			xp = xc;
			xc = x + x_gpos;
			
			if( xp == 0 || cp == 0) continue; // first
			
here:
			if(cp == cc) {
				Draw_Box(xp, y-2, z, 0, xc-xp, 2, COLOR_2, NO);
				FontColor(COLOR_2);
			} else {
				FontColor(COLOR_1);
			}
			
			char str[2]={0};
			str[0]=cp;
			
			float xt = xp + (xc-xp)/2 - WidthFromStr(str)/2;
					
			if( xc1 < xt ) {
				xc1 = DrawFormatString(xt, y-4-15, "%c", cp);
			} else
			if( xc2 < xt ) {
				xc2 = DrawFormatString(xt, y+8, "%c", cp);
			} else
			if(xc1 < xc2) {
				xc1 = DrawFormatString(xc1, y-4-15, "%c", cp);
			} else {
				xc2 = DrawFormatString(xc2, y+8, "%c", cp);
			}
			
			if(i==game_number) {
				cp=c;
				xp=xc;
				xc=x+w;
				i++;
				goto here;
			}
		}
	}
	
	x_gpos = position*wg;
	
	Draw_Box(x+x_gpos, y, z, 0, wg, 2, COLOR_3, NO);
	
	Draw_TriangleGradiant(x+x_gpos + wg/2    , y+2,
						  x+x_gpos + wg/2 - 6, y+2+12,
						  x+x_gpos + wg/2 + 6, y+2+12,
						  0,  
						  COLOR_4, 
						  SetALPHA(GetALPHA(COLOR_4)/16, COLOR_4),
						  SetALPHA(GetALPHA(COLOR_4)/16, COLOR_4));
						  
}


void materials_cover()
{
	tiny3d_EmissiveMaterial(0.1f, 0.1f, 0.1f, 0.00f);
	tiny3d_AmbientMaterial( 0.3f, 0.3f, 0.3f, 1.0f);
	tiny3d_DiffuseMaterial( 0.6f, 0.6f, 0.6f, 1.0f);
	tiny3d_SpecularMaterial(0.9f, 0.9f, 0.9f, 1.0f);
}

void Draw_FLOW_3D()
{
	if(position == -1) return;

	MATRIX tmp;
	
    // fix Perspective Projection Matrix 
	// Video_aspect = 1 -> 4:3 
	// Video_aspect = 2 -> 16:9
    tmp = MatrixProjPerspective( 90, (float) (Video_aspect == 1) ? 9.0f / 16.0f :  1.0f, 0.00125F, 300.0F);
    tiny3d_SetProjectionMatrix(&tmp);
    // calculating modelview
    tmp    = MatrixTranslation(0, 0, 80);
    matrix = MatrixRotationY(0);
    matrix = MatrixMultiply(matrix, tmp);
    // fix ModelView Matrix
	tiny3d_SetMatrixModelView(&matrix);
	
// *** LIGHT ***
    tiny3d_SetLightsOff();
    tiny3d_SetAmbientLight(0.8f, 0.8f, 0.8f);
	tiny3d_SetLight(0,  0.0f , 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,  LIGHT_DIFFUSE);
	tiny3d_SetLight(1,  0.0f , 0.0f, -500.0f, 1.0f, 1.0f, 1.0f,  LIGHT_DIFFUSE);
	tiny3d_SetLight(2,  0.0f , 0.0f, -1000.0f, 1.0f, 1.0f, 1.0f,  LIGHT_DIFFUSE);
	tiny3d_SetLight(3,  -500.0f , 500.0f, 0.0f, 0.5f, 0.5f, 0.5f,  LIGHT_SPECULAR);

	int i=position;
	int k=0;
	int j=-1;
	
	int always_true=1;
	while(always_true)
	{
		i=position+k*j;	
		k++;
		
		if(i<0) {j=1; k=0; continue;}
		if(game_number<i) break;
		
		if(Show_it(i)==NO) continue;
		
		if(ITEM_moveX[i] < -410) {j=1; k=0; continue;}
		if(410 < ITEM_moveX[i] ) break;
		
		// *** MOVEMENT ***
		MATRIX m_axis;
		m_axis = MatrixRotationX(ITEM_angleX[i]);
		tmp = MatrixRotationY(ITEM_angleY[i]);
		m_axis = MatrixMultiply(m_axis, tmp);
		tmp = MatrixRotationZ(ITEM_angleZ[i]);
		m_axis = MatrixMultiply(m_axis, tmp);
		tmp    = MatrixTranslation(ITEM_moveX[i], ITEM_moveY[i], ITEM_moveZ[i]);
		matrix = MatrixMultiply(m_axis, tmp);
		
		tiny3d_SetMatrixModelView(&matrix);
	
		int TextSlot = VRAM_GetSlot(i);
		
		u8 PICType = GAMEPIC_COVER_UNK;
		
		if(0<=TextSlot) PICType = Get_PICType(GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height);
		
		if( list_game_platform[i] == ISO_PS3 || list_game_platform[i] == JB_PS3 || list_game_platform[i] == BDVD) {
			// texture
			if(PICTURE_offset[BR_LOGO]) tiny3d_SetTexture(0, PICTURE_offset[BR_LOGO], PICTURE[BR_LOGO].width, PICTURE[BR_LOGO].height, PICTURE[BR_LOGO].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);

			// material
			tiny3d_EmissiveMaterial(0.0f, 0.0f, 0.0f, 0.0f); // r,g,b,unused
			tiny3d_AmbientMaterial( 0.2f, 0.2f, 0.2f, 1.0f); // r,g,b,a
			tiny3d_DiffuseMaterial( 0.2f, 0.2f, 0.2f, 1.0f); // r,g,b,enable
			tiny3d_SpecularMaterial(0.2f, 0.2f, 0.2f, 2.0f); // r,g,b,shininess
			
			// Object
			Draw_PS3GAMECASE_3D();
			
			if(0<=TextSlot) {
				if(GAMEPIC_offset[TextSlot]) {
					// texture
					tiny3d_SetTexture(0, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height, GAMEPIC[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
					
					// material
					materials_cover();
					
					// Object
					Draw_PS3PIC_3D(PICType);
				}
			}		
		
		} else
		if( list_game_platform[i] == ISO_PS2 || list_game_platform[i] == JB_PS2 ) {
			// material
			tiny3d_EmissiveMaterial(0.0f, 0.0f, 0.0f, 0.0f); // r,g,b,unused
			tiny3d_AmbientMaterial( 0.1f, 0.1f, 0.1f, 1.0f); // r,g,b,a
			tiny3d_DiffuseMaterial( 0.1f, 0.1f, 0.1f, 1.0f); // r,g,b,enable
			tiny3d_SpecularMaterial(0.2f, 0.2f, 0.2f, 5.0f); // r,g,b,shininess
			
			// Object
			Draw_PS2GAMECASE_3D();
			
			if(0<=TextSlot) {
				if(GAMEPIC_offset[TextSlot]) {
					// texture
					tiny3d_SetTexture(0, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height, GAMEPIC[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
					
					// material
					materials_cover();
					
					// Object
					Draw_PS2PIC_3D(PICType);
				}
			}
		} else
		if( list_game_platform[i] == ISO_PS1 || list_game_platform[i] == JB_PS1 ) {
			
			// texture
			if(PICTURE_offset[PS_LOGO]) tiny3d_SetTexture(0, PICTURE_offset[PS_LOGO], PICTURE[PS_LOGO].width, PICTURE[PS_LOGO].height, PICTURE[PS_LOGO].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);

			// material
			tiny3d_EmissiveMaterial(0.0f, 0.0f, 0.0f, 0.0f); // r,g,b,unused
			tiny3d_AmbientMaterial( 0.1f, 0.1f, 0.1f, 1.0f); // r,g,b,a
			tiny3d_DiffuseMaterial( 0.2f, 0.2f, 0.2f, 1.0f); // r,g,b,enable
			tiny3d_SpecularMaterial(0.3f, 0.3f, 0.3f, 1.0f); // r,g,b,shininess
			
			// Object
			Draw_PS1GAMECASE_3D();
			
			if(0<=TextSlot) {
				if(GAMEPIC_offset[TextSlot]) {
					// texture
					tiny3d_SetTexture(0, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height, GAMEPIC[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
				
					// material
					materials_cover();
					
					// Object
					if(PICType == GAMEPIC_ICON0)
						Draw_PS1ICON0();
					else
						Draw_PS1COVER_FRONT(); 
				}
				
				if(PS1BACK_offset[TextSlot]) {
					// texture
					tiny3d_SetTexture(0, PS1BACK_offset[TextSlot], PS1BACK[TextSlot].width, PS1BACK[TextSlot].height, PS1BACK[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
				
					// material
					materials_cover();
					
					// Object
					Draw_PS1COVER_BACK();
				}
			}
		} else
		if( list_game_platform[i] == ISO_PSP || list_game_platform[i] == JB_PSP ) {
			// material
			tiny3d_EmissiveMaterial(0.0f, 0.0f, 0.0f, 0.0f); // r,g,b,unused
			tiny3d_AmbientMaterial( 0.2f, 0.2f, 0.2f, 1.0f); // r,g,b,a
			tiny3d_DiffuseMaterial( 0.2f, 0.2f, 0.2f, 1.0f); // r,g,b,enable
			tiny3d_SpecularMaterial(0.2f, 0.2f, 0.2f, 2.0f); // r,g,b,shininess
			
			// Object
			Draw_PSPGAMECASE_3D();
			
			if(0<=TextSlot) {
				if(GAMEPIC_offset[TextSlot]) {
					// texture
					tiny3d_SetTexture(0, GAMEPIC_offset[TextSlot], GAMEPIC[TextSlot].width, GAMEPIC[TextSlot].height, GAMEPIC[TextSlot].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
					
					// material
					materials_cover();
					
					// Object
					Draw_PSPPIC_3D(PICType);
				}
			}
		}
	}
}

void update_FLOW()
{
	if( position == -1) return;
	
	int i;
	float x=848/2;
	float y=512/2;
	float e;
	
	// Init
	if(ITEM_moveX[position]==0 && ITEM_moveY[position]==0) MOVE_animated=NO;
	
	TranslateTo(&ITEM_moveX[position], x);
	TranslateTo(&ITEM_moveY[position], y);
	TranslateTo(&ITEM_moveZ[position], 10.0);
	
	e=x+160;
	for(i=position+1; i<=game_number; i++) {	
		if(Show_it(i)==NO) continue;
		TranslateTo(&ITEM_moveX[i], e);
		TranslateTo(&ITEM_moveY[i], y);
		TranslateTo(&ITEM_moveZ[i], 100.0);
		e+=FLOW_W * FLOW_FakeZoom(ITEM_moveZ[i]) + 10;
	}
	
	e=x-160;
	for(i=position-1; i>=0; i--) {
		if(Show_it(i)==NO) continue;
		TranslateTo(&ITEM_moveX[i], e);
		TranslateTo(&ITEM_moveY[i], y);
		TranslateTo(&ITEM_moveZ[i], 100.0);
		e-=FLOW_W * FLOW_FakeZoom(ITEM_moveZ[i]) + 10;
	}
	
	MOVE_animated=YES;
}

void Draw_FLOW()
{
	if(position == -1) return;
	
	int i;
	for(i=0; i<=game_number; i++) {
		if(Show_it(i)==NO) continue;
		
		float w_3D = FLOW_W * FLOW_FakeZoom(ITEM_moveZ[i]);
		//float h_3D = FLOW_H * FLOW_FakeZoom(ITEM_moveZ[i]);
		
		if(ITEM_moveX[i] < -w_3D) continue;
		if(X_MAX + w_3D < ITEM_moveX[i]) break;
		
		Draw_GAMEPIC(i, GAMEPIC_COVER2D | GAMEPIC_ICON0 | GAMEPIC_ICON0_DEFAULT, ITEM_moveX[i], ITEM_moveY[i], ITEM_moveZ[i], w_3D, 0, YES, WHITE);
		
	}
}

//*******************************************************
// XMB
//*******************************************************

#define XMB_X_COLUMN 250.0
#define XMB_Y_COLUMN 165.0

#define XMB_X_LINE XMB_X_COLUMN
#define XMB_Y_LINE 240.0

void init_XMB()
{
	XMB_nb_line=-1;
	memset(XMB_value_line, 0, sizeof(XMB_value_line));
	
	
	if(XMB_H_position==XMB_COLUMN_PS3 && !Show_PS3) {
		if(Show_PS2) XMB_H_position=XMB_COLUMN_PS2; else
		if(Show_PS1) XMB_H_position=XMB_COLUMN_PS1; else
		if(Show_PSP) XMB_H_position=XMB_COLUMN_PSP; else
		if(Only_FAV) XMB_H_position=XMB_COLUMN_FAVORITES; else
		XMB_H_position=XMB_COLUMN_SETTINGS;
	}
	
	int i;
	for(i = 0 ; i <= game_number ; i++) {
		if(XMB_H_position==XMB_COLUMN_SETTINGS) continue;
		
		if(XMB_H_position==XMB_COLUMN_PS3 && (list_game_platform[i] != ISO_PS3 && list_game_platform[i] != JB_PS3 && list_game_platform[i] != BDVD)) continue;
		if(XMB_H_position==XMB_COLUMN_PS2 && (list_game_platform[i] != ISO_PS2 && list_game_platform[i] != JB_PS2)) continue;
		if(XMB_H_position==XMB_COLUMN_PS1 && (list_game_platform[i] != ISO_PS1 && list_game_platform[i] != JB_PS1)) continue;
		if(XMB_H_position==XMB_COLUMN_PSP && (list_game_platform[i] != ISO_PSP && list_game_platform[i] != JB_PSP)) continue;
		if(XMB_H_position==XMB_COLUMN_FAVORITES && is_favorite(list_game_path[i]) == NO) continue;
		
		XMB_nb_line++;
		XMB_value_line[XMB_nb_line]=i;
		
		if(XMB_V_position[XMB_H_position]==XMB_nb_line) position=i;
	}
	
	if(XMB_V_position[XMB_H_position]>XMB_nb_line) XMB_V_position[XMB_H_position] = XMB_nb_line;
	if(XMB_nb_line==-1) Game_stuff=NO;
}

float XMB_FakeZoom(float z)
{
	if(10<=z && z<=100) return 2 - (z-10)/90; else
	if(0<=z && z<10) return 3 - (z/10); else
	return 1;
}

void Draw_XMB_COLUMNS()
{
	int i;
	
	for(i=0; i<XMB_COLUMN_NUMBER; i++) {
		if(i==XMB_COLUMN_FAVORITES && !Only_FAV) continue;
		if(i==XMB_COLUMN_PS3 && !Show_PS3) continue;
		if(i==XMB_COLUMN_PS2 && !Show_PS2) continue;
		if(i==XMB_COLUMN_PS1 && !Show_PS1) continue;
		if(i==XMB_COLUMN_PSP && !Show_PSP) continue;
		
		float l = 85 - XMB_columnZ[i];
		
		SetFontZ(XMB_columnZ[i]);
		
		u32 color = WHITE;
		if(MENU && i!=XMB_H_position) color = WHITE - 0xA0;
		
		if(XMB_Col_offset[i] != 0) {
			tiny3d_SetTexture(0, XMB_Col_offset[i], XMB_Col[i].width, XMB_Col[i].height, XMB_Col[i].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
			Draw_Box(XMB_columnX[i]-l/2, XMB_columnY[i]-l, XMB_columnZ[i], 0, l, l, color, YES);
		} else
		if(XMB_MMTHM_XMB_offset != 0 && XMB_MMTHM_XMB2_offset != 0) { 
			u8 ico=6;
			if(i==0) ico=2 ;else
			if(i==1) ico=12;else
			if(i==2) ico=6 ;else
			if(i==3) ico=29;else
			if(i==4) ico=28;else
			if(i==5) ico=30;
			Draw_MMTHM_XMB(XMB_columnX[i]-l/2, XMB_columnY[i]-l, XMB_columnZ[i], l, l, ico);
		} 
		else {
			FontSize(l-30);
			DrawStringFromCenterX(XMB_columnX[i], XMB_columnY[i]-XMB_columnZ[i], XMB_COLUMN_NAME[i]);
		}
	}
	
	
	if(!MENU) {
		FontSize(12);
		SetFontZ(100);
		if(XMB_H_position==XMB_COLUMN_SETTINGS) {
			DrawStringFromCenterX(XMB_X_COLUMN, XMB_Y_COLUMN, STR_SETTINGS);
		} else 
		if(XMB_H_position==XMB_COLUMN_FAVORITES) {
			DrawStringFromCenterX(XMB_X_COLUMN, XMB_Y_COLUMN, STR_FAVORITE);
		} else {
			DrawStringFromCenterX(XMB_X_COLUMN, XMB_Y_COLUMN, XMB_COLUMN_NAME[XMB_H_position]);
		}
		FontSize(20);
		SetFontZ(10);	
	}
}

void Draw_XMB_LINES()
{	
	int i;
	float w, h;
	
	SetFontZ(10);
	FontSize(20);
	
	u32 color = WHITE;
	if(MENU) color = WHITE - 0xA0;
	//if(MENU) Draw_Box(0, 0, 110, 0, 848, 512, 0x00000040, NO); // Dark
	
	if(XMB_H_position != XMB_COLUMN_SETTINGS && Game_stuff) {
		
		for(i=XMB_V_position[XMB_H_position]-6; i<=XMB_V_position[XMB_H_position]+6; i++) {
			if(i < 0) continue;
			if(i==XMB_V_position[XMB_H_position]) continue;
			if(i > XMB_nb_line) break;
			
			w = XMB_W * XMB_FakeZoom(ITEM_moveZ[i]);
			h = XMB_H * XMB_FakeZoom(ITEM_moveZ[i]);
			Draw_GAMEPIC(XMB_value_line[i], GAMEPIC_ICON0 | GAMEPIC_ICON0_DEFAULT, ITEM_moveX[i], ITEM_moveY[i], ITEM_moveZ[i], w, h, YES, color);			
		}
		
		if(Show_COVER) {
			int slot;
			if(Get_GAMEPIC_TYPE(position, &slot) == GAMEPIC_COVER2D) {
				Draw_GAMEPIC(position, GAMEPIC_COVER2D, 30, 200, 10, 130, 0, NO, WHITE);
			} else {
				Draw_COVER(position, 30, 200, 10, 130, 0, COVER_offset, COVER, NO, WHITE);
			}
		}
		
		w = XMB_W * XMB_FakeZoom(ITEM_moveZ[XMB_V_position[XMB_H_position]]);
		h = XMB_H * XMB_FakeZoom(ITEM_moveZ[XMB_V_position[XMB_H_position]]);
		Draw_GAMEPIC(XMB_value_line[XMB_V_position[XMB_H_position]], GAMEPIC_ICON0 | GAMEPIC_ICON0_DEFAULT,
					ITEM_moveX[XMB_V_position[XMB_H_position]], 
					ITEM_moveY[XMB_V_position[XMB_H_position]], 
					ITEM_moveZ[XMB_V_position[XMB_H_position]],
					w, h, YES, WHITE);
		
		if(w<XMB_W*2) w = XMB_W*2;
		DrawTXTInBox(XMB_X_LINE+w/2+20, XMB_Y_LINE - 20, 10, X_MAX-XMB_X_LINE+w/2+20, Y_MAX-XMB_Y_LINE - 20, list_game_title[position], 0, color);
		//DrawString(XMB_X_LINE+w/2+20, XMB_Y_LINE - 20, list_game_title[position]);
	}

}

void update_XMB_COLUMNS()
{	
	int i;
	float x=XMB_X_COLUMN;
	float y=XMB_Y_COLUMN;
	float e;
	float e2=95.0;
	if(MENU) e2=85.0;
	
	// Init
	if(XMB_columnY[XMB_H_position] != y) MOVE_animated=NO; 
	
	//if(XMB_columnX[XMB_H_position] == x) return;
	
	TranslateTo(&XMB_columnX[XMB_H_position], x);
	TranslateTo(&XMB_columnY[XMB_H_position], y);
	TranslateTo(&XMB_columnZ[XMB_H_position], 20.0);
	
	e=x+e2;
	for(i=XMB_H_position+1; i<XMB_COLUMN_NUMBER; i++) {
		if(i==XMB_COLUMN_FAVORITES && !Only_FAV) continue;
		if(i==XMB_COLUMN_PS3 && !Show_PS3) continue;
		if(i==XMB_COLUMN_PS2 && !Show_PS2) continue;
		if(i==XMB_COLUMN_PS1 && !Show_PS1) continue;
		if(i==XMB_COLUMN_PSP && !Show_PSP) continue;
		
		TranslateTo(&XMB_columnX[i], e);
		TranslateTo(&XMB_columnY[i], y);
		TranslateTo(&XMB_columnZ[i], 35.0);
		e2-=5;
		e+=e2;
	}
	
	e2=95.0;
	if(MENU) e2=85.0;
	e=x-e2;
	for(i=XMB_H_position-1; i>=0; i--) {
		if(i==XMB_COLUMN_FAVORITES && !Only_FAV) continue;
		if(i==XMB_COLUMN_PS3 && !Show_PS3) continue;
		if(i==XMB_COLUMN_PS2 && !Show_PS2) continue;
		if(i==XMB_COLUMN_PS1 && !Show_PS1) continue;
		if(i==XMB_COLUMN_PSP && !Show_PSP) continue;
		
		TranslateTo(&XMB_columnX[i], e);
		TranslateTo(&XMB_columnY[i], y);
		TranslateTo(&XMB_columnZ[i], 35.0);
		e2-=5;
		e-=e2;
	}

}

void update_XMB_LINES()
{
	int i;
	float x=XMB_X_LINE;
	float y=XMB_Y_LINE;
	float e;
	
	if(Game_stuff==NO) return;
	
	// Init
	if(ITEM_moveX[XMB_V_position[XMB_H_position]] != x) MOVE_animated=NO;
	
	TranslateTo(&ITEM_moveX[XMB_V_position[XMB_H_position]], x);
	TranslateTo(&ITEM_moveY[XMB_V_position[XMB_H_position]], y);
	
	if(MENU) 
		TranslateTo(&ITEM_moveZ[XMB_V_position[XMB_H_position]], 0.0);
	else 
		TranslateTo(&ITEM_moveZ[XMB_V_position[XMB_H_position]], 10.0);
	
	e=y+120.0;
	for(i=XMB_V_position[XMB_H_position]+1; i<=XMB_nb_line; i++) {
		TranslateTo(&ITEM_moveX[i], x);
		TranslateTo(&ITEM_moveY[i], e);
		TranslateTo(&ITEM_moveZ[i], 100.0);
		e+=XMB_H+2;
	}
	
	e=y-175.0;
	for(i=XMB_V_position[XMB_H_position]-1; i>=0; i--) {
		TranslateTo(&ITEM_moveX[i], x);
		TranslateTo(&ITEM_moveY[i], e);
		TranslateTo(&ITEM_moveZ[i], 100.0);
		e-=XMB_H+2;
	}
	
	MOVE_animated=YES;
}

//*******************************************************
// GRID
//*******************************************************

void init_GRID()
{	
	int i, j=0;
	
	if(GRID_KEEP_PROP==YES) GRID_NB_LINES = (GRID_H+GRID_e) / (GRID_e+GRID_H_ICON0);
	
	if(position < GRID_FIRST_ICON) {
		j=-1;
		for(i=GRID_FIRST_ICON; i>=0; i--){
			if(Show_it(i)==NO) continue;
			j++;
			GRID_FIRST_ICON=i;
			if(GRID_TYPE == PAGE && j==GRID_NB_ICON0) break;
			if(GRID_TYPE == SCROLL && GRID_DIRECTION==HORIZONTAL && j==GRID_NB_LINES) break;
			if(GRID_TYPE == SCROLL && GRID_DIRECTION==VERTICAL && j==GRID_NB_COLUMNS) break;
		}
	} else
	if(position > GRID_LAST_ICON) {
		j=-1;
		for(i=GRID_FIRST_ICON; i<=game_number; i++){
			if(Show_it(i)==NO) continue;
			j++;
			GRID_FIRST_ICON=i;
			if(GRID_TYPE == PAGE && j==GRID_NB_ICON0) break;
			if(GRID_TYPE == SCROLL && GRID_DIRECTION==HORIZONTAL && j==GRID_NB_LINES) break;
			if(GRID_TYPE == SCROLL && GRID_DIRECTION==VERTICAL && j==GRID_NB_COLUMNS) break;
		}
	}
	
	j=0;
	for(i=GRID_FIRST_ICON; i<=game_number; i++) {
		if(Show_it(i)==NO) continue;
		j++;
		GRID_LAST_ICON=i;
		if(j==GRID_NB_ICON0) break;
	}
	MOVE_animated = NO;
}

void Draw_GRID()
{
	if(position == -1) return;
	
	int i;
	for(i = GRID_FIRST_ICON-GRID_NB_ICON0 ; i<=GRID_LAST_ICON+GRID_NB_ICON0 ; i++) {
		if(i<0) continue;
		if(i>game_number) break;
		if(Show_it(i)==NO) continue;
		
		Draw_GAMEPIC(i, GAMEPIC_ICON0 | GAMEPIC_COVER2D | GAMEPIC_ICON0_DEFAULT, ITEM_moveX[i], ITEM_moveY[i], ITEM_moveZ[i], GRID_W_ICON0, GRID_H_ICON0, NO, WHITE);
		if(i==position) {
			Draw_LineBoxOutside(ITEM_moveX[i], ITEM_moveY[i], ITEM_moveZ[i], 5, GRID_W_ICON0, GRID_H_ICON0, WHITE);
		} else {
			Draw_Box(ITEM_moveX[i], ITEM_moveY[i], ITEM_moveZ[i]-1, 0, GRID_W_ICON0, GRID_H_ICON0, 0xFFFFFF80, NO); 
		}
	}
}

void update_GRID()
{
	if(position==-1) return;
	
	// Init
	if(ITEM_moveZ[position]!=100.0 || GRID_ANIMATED == NO) MOVE_animated=NO;
	
	float x, y, x1, y1;
	int i, k=0;
	x = GRID_X;
	y = GRID_Y;
	x1=x;
	y1=y;
	for(i = GRID_FIRST_ICON ; i<=GRID_LAST_ICON ; i++) {
		if(Show_it(i)==NO) continue;
		k++;
		
		TranslateTo(&ITEM_moveX[i], x);
		TranslateTo(&ITEM_moveY[i], y);
		TranslateTo(&ITEM_moveZ[i], 100.0);
			
		if(GRID_DIRECTION == HORIZONTAL)  {
			y+= GRID_H_ICON0 + GRID_e;
			if(k==GRID_NB_LINES) {k=0; y = GRID_Y; x += GRID_W_ICON0 + GRID_e;}
		} else
		if(GRID_DIRECTION == VERTICAL)  {
			x+= GRID_W_ICON0 + GRID_e;
			if(k==GRID_NB_COLUMNS) {k=0; x = GRID_X; y += GRID_H_ICON0 + GRID_e;}
		}
	}
	
	x = GRID_X;
	y = GRID_Y;
	if(GRID_DIRECTION == HORIZONTAL) {
		y+= (GRID_NB_LINES-1) * (GRID_H_ICON0 + GRID_e);
		x-= GRID_W_ICON0 + GRID_e;
	} else
	if(GRID_DIRECTION == VERTICAL) {
		x+= (GRID_NB_COLUMNS-1) * (GRID_W_ICON0 + GRID_e);
		y-= GRID_H_ICON0 + GRID_e;
	}
	x1=x;
	y1=y;
	k=0;
	for(i = GRID_FIRST_ICON-1 ; i>=0 ; i--) {
		if(Show_it(i)==NO) continue;
		k++;
		
		TranslateTo(&ITEM_moveX[i], x);
		TranslateTo(&ITEM_moveY[i], y);
		TranslateTo(&ITEM_moveZ[i], 100.0);
			
		if(GRID_DIRECTION == HORIZONTAL)  {
			y-= GRID_H_ICON0 + GRID_e;
			if(k==GRID_NB_LINES) {k=0; y = y1; x -= GRID_W_ICON0 + GRID_e;}
		} else
		if(GRID_DIRECTION == VERTICAL)  {
			x-= GRID_W_ICON0 + GRID_e;
			if(k==GRID_NB_COLUMNS) {k=0; x = x1; y -= GRID_H_ICON0 + GRID_e;}
		}
	}
	
	x = GRID_X;
	y = GRID_Y;
	if(GRID_DIRECTION == HORIZONTAL) {
		x+= GRID_NB_COLUMNS * (GRID_W_ICON0 + GRID_e);
	} else
	if(GRID_DIRECTION == VERTICAL) {
		y+= GRID_NB_LINES * (GRID_H_ICON0 + GRID_e);
	}
	x1=x;
	y1=y;
	k=0;
	for(i = GRID_LAST_ICON+1 ; i<=game_number ; i++) {
		if(Show_it(i)==NO) continue;
		k++;
		
		TranslateTo(&ITEM_moveX[i], x);
		TranslateTo(&ITEM_moveY[i], y);
		TranslateTo(&ITEM_moveZ[i], 100.0);
			
		if(GRID_DIRECTION == HORIZONTAL)  {
			y+= GRID_H_ICON0 + GRID_e;
			if(k==GRID_NB_LINES) {k=0; y = GRID_Y; x += GRID_W_ICON0 + GRID_e;}
		} else
		if(GRID_DIRECTION == VERTICAL)  {
			x+= GRID_W_ICON0 + GRID_e;
			if(k==GRID_NB_COLUMNS) {k=0; x = GRID_X; y += GRID_H_ICON0 + GRID_e;}
		}
	}
	
	MOVE_animated=YES;
}

//*******************************************************
//Main
//*******************************************************

void input_MAIN()
{
	if(filter==YES) return;
	if(MENU==YES) return;
	if(txt_viewer_activ == YES) return;
	
	int i,j,k;
		
	R2_SyncLeftJoystick();
		
	if(HoldCircleDelay()) {
		MGZ_exit();
		exit(0);
	}
	
	if(ComboNewPad(BUTTON_L3, BUTTON_R3)) {
		sysProcessExitSpawn2("/dev_hdd0/game/MANAGUNZ0/USRDIR/ManaGunZ.self", NULL, NULL, NULL, 0, 1001, SYS_PROCESS_SPAWN_STACK_SIZE_1M);
	}
	
	if(OldPad(BUTTON_R1)) Display_PIC1=YES;
	else Display_PIC1=NO;
	
	if(OldPad(BUTTON_L1)) {
		if(NewPad(BUTTON_LEFT)) {
			start_MemMonitor();
		} else 
		if(NewPad(BUTTON_RIGHT)) {
			end_MemMonitor();
		} else
		if(NewPad(BUTTON_DOWN)) {
			do_Refresh=YES;
		}
	}
	
	if(NewPad(BUTTON_CROSS) && Game_stuff == YES) {
		
		if(can_be_mounted(list_game_platform[position]) ){
			start_loading();	
			
			read_game_setting(position);
			
			u8 mounted = MountGame(list_game_path[position]);
			
			end_loading();
			
#ifdef RPCS3
			if(mounted) show_msg("EXIT !");
			else show_msg("FAILED : EXIT !");
#else
			if(mounted) {
				MGZ_exit();
				exit(0);
			}
#endif
		} else {
			show_msg(STR_CANT_MOUNT);
		}
	} else
	if(NewPad(BUTTON_TRIANGLE) && Game_stuff) {
		open_GameMenu();
	} else
	if(NewPad(BUTTON_SELECT)) {
		Draw_FileExplorer();
	} else
	if(NewPad(BUTTON_SQUARE)) {
		open_filter();
	} else
	if(NewPad(BUTTON_START)) {
		open_SETTINGS();
	}
	
	if(UI_position==XMB) {
		if(R2pad(BUTTON_LEFT) ) {
			if(XMB_H_position > 0) {
				XMB_H_position--;
				if(XMB_H_position==XMB_COLUMN_PSP && !Show_PSP) XMB_H_position--;
				if(XMB_H_position==XMB_COLUMN_PS1 && !Show_PS1) XMB_H_position--;
				if(XMB_H_position==XMB_COLUMN_PS2 && !Show_PS2) XMB_H_position--;
				if(XMB_H_position==XMB_COLUMN_PS3 && !Show_PS3) XMB_H_position--;
				if(XMB_H_position==XMB_COLUMN_FAVORITES && !Only_FAV) XMB_H_position--;
				
				MOVE_animated=NO; 
				init_XMB(); 
				update_XMB_LINES();
				position_CURPIC = -1;
				MOVE_animated=YES; 
			}
		} else
		if(R2pad(BUTTON_RIGHT)) {
			if(XMB_H_position < 5) {	
				u8 old_XMB_H_position = XMB_H_position;
				XMB_H_position++;
				if(XMB_H_position==XMB_COLUMN_FAVORITES && !Only_FAV) XMB_H_position++;
				if(XMB_H_position==XMB_COLUMN_PS3 && !Show_PS3) XMB_H_position++;
				if(XMB_H_position==XMB_COLUMN_PS2 && !Show_PS2) XMB_H_position++;
				if(XMB_H_position==XMB_COLUMN_PS1 && !Show_PS1) XMB_H_position++;
				if(XMB_H_position==XMB_COLUMN_PSP && !Show_PSP) XMB_H_position=old_XMB_H_position;
				
				if( old_XMB_H_position != XMB_H_position ) {
					MOVE_animated=NO;
					init_XMB();
					update_XMB_LINES();
					position_CURPIC = -1;
					MOVE_animated=YES;
				}
			}
		} else
		if(R2pad(BUTTON_UP)) {
			if(XMB_V_position[XMB_H_position] == 0 && XMB_nb_line != 0) {
				XMB_V_position[XMB_H_position] = XMB_nb_line;
				MOVE_animated=NO;
				COVER_offset=0;
				TMP_PIC_offset=0;
				position_CURPIC = -1;
			} 
			else if(XMB_V_position[XMB_H_position] > 0) {
				XMB_V_position[XMB_H_position]--;
				COVER_offset=0;
				TMP_PIC_offset=0;
				position_CURPIC = -1;
			}
		} else
		if(R2pad(BUTTON_DOWN)) {
			if(XMB_V_position[XMB_H_position] == XMB_nb_line && XMB_nb_line != 0) {
				XMB_V_position[XMB_H_position] = 0;
				MOVE_animated=NO;
				COVER_offset=0;
				TMP_PIC_offset=0;
				position_CURPIC = -1;
			} else
			if(XMB_V_position[XMB_H_position] < XMB_nb_line) {
				XMB_V_position[XMB_H_position]++;
				COVER_offset=0;
				TMP_PIC_offset=0;
				position_CURPIC = -1;
			}
		}
	}
	
	if(position < 0) return;
	
	if(UI_position==LIST) {
		if(R2pad(BUTTON_UP)) {
			for(i=0; i<=game_number;i++) {
				position--;
				if(position<0) position=game_number;
				if(Show_it(position) == YES) break;
			}
			COVER_offset=0;
		} else
		if(R2pad(BUTTON_DOWN)) {
			for(i=0; i<=game_number;i++) {
				position++;
				if(position>game_number) position=0;
				if(Show_it(position) == YES) break;
			}
			COVER_offset=0;
		}
	} else
	if(UI_position==GRID) {
		if( (R2pad(BUTTON_UP) && GRID_DIRECTION==HORIZONTAL)  ||
			(R2pad(BUTTON_LEFT) && GRID_DIRECTION==VERTICAL  )  )
		{
			j=-1;
			for(i=position; i>=0;i--){
				if(Show_it(i)==NO) continue;
				j++;
				position=i;
				if(j==1) break;
			}
		}
		if( (R2pad(BUTTON_DOWN) && GRID_DIRECTION==HORIZONTAL)  ||
			(R2pad(BUTTON_RIGHT) && GRID_DIRECTION==VERTICAL  )  )
		{
			j=-1;
			for(i=position; i<=game_number;i++){
				if(Show_it(i)==NO) continue;
				j++;
				position=i;
				if(j==1) break;
			}
		}
		if( (R2pad(BUTTON_LEFT) && GRID_DIRECTION==HORIZONTAL)  ||
			(R2pad(BUTTON_UP) && GRID_DIRECTION==VERTICAL  )  )
		{
			j=-1;
			for(i=position; i>=0;i--){
				if(Show_it(i)==NO) continue;
				j++;
				position=i;
				if(GRID_DIRECTION==VERTICAL   && j==GRID_NB_COLUMNS) break;
				if(GRID_DIRECTION==HORIZONTAL && j==GRID_NB_LINES) break;
			}
		}
		if( (R2pad(BUTTON_RIGHT) && GRID_DIRECTION==HORIZONTAL)  ||
			(R2pad(BUTTON_DOWN) && GRID_DIRECTION==VERTICAL  )  )
		{
			j=-1;
			for(i=position; i<=game_number;i++){
				if(Show_it(i)==NO) continue;
				j++;
				position=i;
				if(GRID_DIRECTION==VERTICAL   && j==GRID_NB_COLUMNS) break;
				if(GRID_DIRECTION==HORIZONTAL && j==GRID_NB_LINES) break;
			}
		}
	} else
	if(UI_position==FLOW) {
		if( (FLOW_inverse_button==NO  && R2pad(BUTTON_RIGHT)) ||
			(FLOW_inverse_button==YES && R2pad(BUTTON_LEFT))   ) 
		{
			for(i=0; i<game_number;i++) {
				position--;
				FLOW_ShowBack=NO;
				if(position < 0) {
					for(k=game_number; k>=0; k--) {
						if(Show_it(k) == NO) continue;
						position=k;
						MOVE_animated=NO;
						break;
					}
				}
				if(Show_it(position) == YES) break;
			}
		}
		if( (FLOW_inverse_button==NO  && R2pad(BUTTON_LEFT) ) ||
			(FLOW_inverse_button==YES && R2pad(BUTTON_RIGHT))   ) 
		{
			for(i=0; i<game_number;i++) {
				position++;
				FLOW_ShowBack=NO;
				if(position > game_number) {
					for(k=0; k<=game_number; k++) {
						if(Show_it(k) == NO) continue;
						position=k;
						MOVE_animated=NO;
						break;
					}
				}
				if(Show_it(position) == YES) break;
			}
		}
		if( NewPad(BUTTON_R3) && FLOW_3D) {
			if(FLOW_ShowBack==YES) FLOW_ShowBack=NO;
			else FLOW_ShowBack=YES;
		}
		if( NewPad(BUTTON_L3) && FLOW_3D) {
			FLOW_Zoom = !FLOW_Zoom;
		}
		
	}

}

float DrawTAG(float x, float y, float z, float min_width, float font_height, char *str)
{	

	float w = min_width;
	
	float w_str = WidthFromStr(str) + 8.0;
	
	while( w_str > w ) w += 4.0;
	
	float e = (w - (w_str-8.0))/2.0;
	
	if(PICTURE_offset[TAG] != 0) {
		tiny3d_SetTexture(0, PICTURE_offset[TAG], PICTURE[TAG].width, PICTURE[TAG].height, PICTURE[TAG].pitch, TINY3D_TEX_FORMAT_A8R8G8B8, TEXTURE_LINEAR);
		Draw_Box(x, y, z+1, 0, w, font_height, WHITE, YES);
	} else	
		Draw_Box(x, y, z+1, 0, w, font_height, 0xA0A0A0A0, NO);
	
	DrawFormatString(x + e + 1, y+1, str);
	
	return x+w+1;
}

void Draw_MAIN_input()
{
	if(MENU==YES) return;
	if(filter==YES) return;
	
	float tagbox_min_width = 50;
	
	float x=INPUT_X;
	float y=INPUT_Y;
	FontColor(COLOR_1);
	SetFontZ(0);

	x=DrawButton(x, y, STR_SETTINGS, BUTTON_START);
	x=DrawButton(x, y, STR_FILTER, BUTTON_SQUARE);
	
	if(Game_stuff) {
		x=DrawButton(x, y, STR_GAMEMENU, BUTTON_TRIANGLE);
		if(can_be_mounted(list_game_platform[position])) {
			x=DrawButton(x, y, STR_MOUNTGAME, BUTTON_CROSS);
		}
	}
	x=DrawButton(x, y, STR_FILEMANAGER, BUTTON_SELECT);
	
	x=DrawSpam(x, y);
	x=DrawButton(x, y, STR_EXIT, BUTTON_CIRCLE);

	x=X_MAX-10-4*tagbox_min_width;
	y=INPUT_Y;
	if(Game_stuff) {
		char tag_str[20];
		int t;
		
		FontColor(COLOR_1);
		
		if(list_game_platform[position] == ISO_PS3 || list_game_platform[position] == JB_PS3 || list_game_platform[position]==BDVD) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "PS3");
		} else
		if(list_game_platform[position] == ISO_PS2 || list_game_platform[position] == JB_PS2) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "PS2");
		} else
		if(list_game_platform[position] == ISO_PS1 || list_game_platform[position] == JB_PS1) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "PS1");
		} else
		if(list_game_platform[position] == ISO_PSP || list_game_platform[position] == JB_PSP) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "PSP");
		} else {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "UNK");
		}
		
		float x1 = x;
		
		char *Ext = GetExtension(list_game_path[position]);
	
		if( !strncasecmp(Ext, ".iso", 4) )	{
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "ISO");
		} else	
		if( !strncasecmp(Ext, ".bin", 4) )	{
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "BIN");
		} else
		if( !strncasecmp(Ext, ".mdf", 4) )	{
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "MDF");
		} else
		if( !strncasecmp(Ext, ".img", 4) )	{
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "IMG");
		} else
		if( !strncasecmp(Ext, ".cso", 4) )  {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "CSO");
		} else
		if( list_game_platform[position]==BDVD) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "BLU-RAY");
		} else {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "JB");			
		}
		
		if(is_66600(list_game_path[position])) {
			FontColor(COLOR_4);
			FontSize(INPUT_SIZE/2);
			DrawTAG(x1, y-INPUT_SIZE/2, 0, 0, INPUT_SIZE/2, "666");
			FontColor(COLOR_1);
			FontSize(INPUT_SIZE);
		}	
				
		if(usb) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "FAT32");
			sscanf(list_game_path[position], "/dev_usb%d%*s" , &t);
			sprintf(tag_str, "USB%d", t);
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, tag_str);
		} else
		if(is_ntfs(list_game_path[position]) == YES) {
			
			sscanf(list_game_path[position], "/ntfs%d%*s" , &t);
			sprintf(tag_str, "NTFS%d", t);
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, tag_str);
			
			char dev[10];
			sprintf(dev, "ntfs%d", t);
			sprintf(tag_str, "USB%d", NTFS_Test_Device(dev));
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, tag_str);
		} else 
		if(is_exFAT(list_game_path[position]) ) {
			
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "exFAT");
			
			sprintf(tag_str, "USB%d", exFAT_get_idx(list_game_path[position]));
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, tag_str);
		} else
		if( strstr(list_game_path[position], "/dev_sd") != NULL) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "FAT32");
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "SD");
		} else
		if( strstr(list_game_path[position], "/dev_cf") != NULL) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "FAT32");
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "CF");
		} else
		if( strstr(list_game_path[position], "/dev_ms") != NULL) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "FAT32");
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "MS");
		} else
		if( strstr(list_game_path[position], "/dev_hdd0") != NULL) {
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "UFS2");
			x = DrawTAG(x, y, 0, tagbox_min_width, INPUT_SIZE, "HDD0");
		}
	}
	
}

void Draw_MAIN()
{
	if(MENU==YES && MENU_SIDE == NO) return;
	
	SetFontZ(10);
	
	if( game_number < 0 ) {
		Game_stuff = NO;
		DrawFormatString(50, 40, "%s", STR_NOGAME);
		return;
	}
	if(position < 0) {
		Game_stuff = NO;
		DrawFormatString(50, 40, "%s", STR_FILTER_NOGAME);
		return;
	}
	
	iso = is_iso(list_game_path[position]);
	usb = is_usb(list_game_path[position]);
	
	Game_stuff = YES;	
	
	if(UI_position==XMB) {
		
		if(XMB_H_position == XMB_COLUMN_SETTINGS) Game_stuff = NO; 
		else Game_stuff = YES;
		
		init_XMB();
		
		Draw_XMB_COLUMNS();
		update_XMB_COLUMNS();
		
		Draw_XMB_LINES();
		update_XMB_LINES();
		
	} else
	if(UI_position==LIST) {
		Draw_LIST();
	} else
	if(UI_position==GRID) {
		init_GRID();
		update_GRID();
		Draw_GRID();
	} else
	if(UI_position==FLOW) {
		if(FLOW_3D) {
			FontSize(20);
			
			DrawTXTInBoxFromCenter(0, FLOW_Zoom ? 10 : 50, 10, X_MAX, 60, list_game_title[position], 0, WHITE);
			
			update_3DFLOW();
		
			tiny3d_Project3D();
			
			Draw_FLOW_3D();

			tiny3d_Project2D(); 
			
			tiny3d_SetMatrixModelView(NULL);
		
		}
		else {
			FontSize(20);
			DrawTXTInBoxFromCenter(0, 75, 10, X_MAX, 60, list_game_title[position], 0, WHITE);
			
			update_FLOW();
			
			Draw_FLOW();
		}
		
		Draw_FLOW_SCROLL(30, 400, 0, X_MAX-30*2);
	}
}

u8 Show_it(int pos)
{
	if(pos<0 || game_number<pos) return NO;
	
	if( Show_PS3==NO && (list_game_platform[pos]== ISO_PS3 || list_game_platform[pos]== JB_PS3 || list_game_platform[pos]== BDVD)) return NO;
	if( Show_PS2==NO && (list_game_platform[pos]== ISO_PS2 || list_game_platform[pos]== JB_PS2)) return NO;
	if(	Show_PS1==NO && (list_game_platform[pos]== ISO_PS1 || list_game_platform[pos]== JB_PS1)) return NO;
	if(	Show_PSP==NO && (list_game_platform[pos]== ISO_PSP || list_game_platform[pos]== JB_PSP)) return NO;
	
	if( UI_position != XMB) {
		if( Only_FAV && is_favorite(list_game_path[pos])==NO) return NO;
	}
	
	return YES;
}

void MGZ_exit()
{
	if( DEBUG ) start_loading();
	print_debug("end_PlugAndPlay");
	end_PlugAndPlay();
	print_debug("end_MemMonitor");
	end_MemMonitor();
	print_debug("end_Load_GAMEPIC");
	end_Load_GAMEPIC();
	print_debug("end_load_CURPIC");
	end_load_CURPIC();
	print_debug("end_gathering");
	end_gathering();
	print_debug("end_copy_loading");
	end_copy_loading();
	print_debug("exFAT_deinit");
	exFAT_deinit();
	print_debug("sysModuleUnload(SYSMODULE_PNGDEC)");
	sysModuleUnload(SYSMODULE_PNGDEC);
	print_debug("sysModuleUnload(SYSMODULE_JPGDEC)");
	sysModuleUnload(SYSMODULE_JPGDEC);
	print_debug("ioPadEnd()");
	ioPadEnd();
	print_debug("FCLOSE(mgz_log) && end_loading()");
	FCLOSE(mgz_log);
	end_loading();
}

int main(void)
{
	u8 LoopBreak=1;
	
	AutoM = is_AutoMount(); // ManaGunZ_id
	
	exFAT_init();
	
	sysModuleLoad(SYSMODULE_PNGDEC);
	sysModuleLoad(SYSMODULE_JPGDEC);
	
	Init_Graph();
	ioPadInit(7);
	ioPadSetPressMode(0,1);
	SetCurrentFont(-1);

	AutoMountCheckPad();
	
#ifdef RPCS3
#ifdef FILEMANAGER
	strcpy(ManaGunZ_id, "FILEMANAG");
#else
	strcpy(ManaGunZ_id, "MANAGUNZ0");
#endif //  FILEMANAGER
	cobra = NO;
	mamba = NO;
	HEN = YES;
	device_number++;
	strcpy(list_device[device_number], "dev_hdd0");
	//device_number++;
	//strcpy(list_device[device_number], "dev_usb000");
#endif // RPCS3

	read_setting(); //it needs ManaGunZ_id

	LoadFont();
	
	AutoMountCheckPad();

	init_lang();
	load_lang();

	start_loading(); // it needs font and lang
	
	u64 test_peek = lv2peek(0x8000000000003000ULL);
	if( test_peek == 0xFFFFFFFF80010003ULL || test_peek == 0 || test_peek == 0x80010003ULL) // rpcs3 return 80010003
		PEEKnPOKE = NO;
	else
		PEEKnPOKE = YES;

	print_load("Initialization");
	
	if(PEEKnPOKE) {
		if(init_fw() == FAILED) {
			if( HEN ) {
				PEEKnPOKE=NO;
			} else
			if( init_fw_unk() == FAILED ) {
				PEEKnPOKE = NO;
			}
		}
	}
	
	//init_MAP_PATHS_LIST();
	
#ifdef FILEMANAGER

#ifndef RPCS3
	getDevices();
	cobra = is_cobra();
	mamba = is_mamba();
#endif // RPCS3

	print_load(STR_ADJUST);
	adjust_screen();

	print_load("Load Theme");
	Load_Theme();
	
	Draw_FileExplorer();
	
	MGZ_exit();
	
	return 0;
#endif // FILEMANAGER
	
#ifndef RPCS3
	if(init_ManaGunZ() == FAILED) {
		end_loading();
		LoopBreak=1;
		while(LoopBreak) {
			cls();		
			
			FontSize(20);
			FontColor(RED);
			DrawString(50, 100, "Error : Cannot init ManaGunZ");
			
			float x=INPUT_X;
			float y=INPUT_Y;
			FontColor(COLOR_1);
			SetFontZ(0);

			DrawButton(x, y, STR_EXIT, BUTTON_CIRCLE);
			
			tiny3d_Flip();
			ScreenShot();
			ps3pad_read();
			
			if(NewPad(BUTTON_CIRCLE)) {
				MGZ_exit();
				LoopBreak=0;
				return 0;
			}
		}
	}
#endif	
	
	if(AutoM) AutoMount();	

	print_load(STR_ADJUST);
	adjust_screen();

	print_load("Load Theme");
	Load_Theme();
	
	print_load("Get directories names from scan_dir.txt");
	if(read_scan_dir()==FAILED){
		end_loading();
		LoopBreak=1;
		while(LoopBreak) 
		{
			cls();		
			
			Draw_BGS();
			Draw_MemMonitor();
			
			FontSize(20);
			FontColor(RED);
			DrawString(50, 40, "Error : Can't read scan_dir.txt");
			
			float x=INPUT_X;
			float y=INPUT_Y;
			FontColor(COLOR_1);
			SetFontZ(0);
			
			DrawButton(x, y, STR_EXIT, BUTTON_CIRCLE);
			
			tiny3d_Flip();
			ScreenShot();
			ps3pad_read();
			
			if(NewPad(BUTTON_CIRCLE)) {
				MGZ_exit();
				LoopBreak=0;
				return 0;
			}
		}
	}
	
	Load_GAMELIST();
	
	print_load("Get Favorite game list");
	read_fav();

	position=-1;
	int i;
	for(i=0; i<=game_number; i++) {
		if(Show_it(i)==YES) {position=i; break;}
	}
	
	end_loading();
	
	start_Load_GAMEPIC();
	
	LoopBreak=1;
	while(LoopBreak) {

		scene = SCENE_MAIN;
		
		cls();
		
		Draw_BG();
		Draw_MemMonitor();
		
		Draw_CURPIC();
		Draw_MAIN();
		Draw_MAIN_input();
		Draw_Load_GAMEPIC();
		
		Draw_filter();
		Draw_filter_input();
		
		Draw_MENU();
		Draw_MENU_input();
		
		Draw_txt_viewer();
		Draw_txt_viewer_input();
		
		Draw_ICON0_creator();
		Draw_ICON0_creator_input();
		
		Draw_Notification();
		
		AutoRefresh_GAMELIST();
		
		tiny3d_Flip();
		ScreenShot();
		ps3pad_read();
		
		input_MAIN();
		input_filter();
		input_MENU();
		txt_viewer_input();
		input_ICON0_creator();
	}
	
	return 0;
}

void Draw_scene()
{
	if(scene == SCENE_FILEMANAGER) 
	{
		Draw_BGS();
		Draw_MemMonitor();
		Draw_window();
		Draw_option();
		Draw_properties();
		Draw_picture_viewer();
		Draw_txt_viewer();
		Draw_SFO_viewer();
		Draw_Notification();
		Draw_cursor();
	} else
	if(scene == SCENE_MAIN) 
	{
		Draw_BG();
		Draw_MemMonitor();
		Draw_MAIN();
		Draw_filter();
		Draw_MENU();	
	}
}
